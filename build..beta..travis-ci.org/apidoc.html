<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kaizhu256/node-utility2"

    >utility2 (2019.10.8)</a>
</h1>
<h4>this zero-dependency package will provide high-level functions to to build, test, and deploy webapps</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2">module utility2</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Blob">
            function <span class="apidocSignatureSpan">utility2.</span>Blob
            <span class="apidocSignatureSpan">(list, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData">
            function <span class="apidocSignatureSpan">utility2.</span>FormData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module">
            function <span class="apidocSignatureSpan">utility2.</span>Module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildApidoc_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApidoc_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildApp_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApp_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildLib_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildLib_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildReadme_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildReadme_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildTest_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildTest_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_webpage_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_webpage_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.ajax">
            function <span class="apidocSignatureSpan">utility2.</span>ajax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.ajaxProgressUpdate">
            function <span class="apidocSignatureSpan">utility2.</span>ajaxProgressUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidocCreate">
            function <span class="apidocSignatureSpan">utility2.</span>apidocCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assert">
            function <span class="apidocSignatureSpan">utility2.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertJsonEqual">
            function <span class="apidocSignatureSpan">utility2.</span>assertJsonEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertJsonNotEqual">
            function <span class="apidocSignatureSpan">utility2.</span>assertJsonNotEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64FromBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>base64FromBuffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64ToBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>base64ToBuffer
            <span class="apidocSignatureSpan">(b64, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64ToUtf8">
            function <span class="apidocSignatureSpan">utility2.</span>base64ToUtf8
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.blobRead">
            function <span class="apidocSignatureSpan">utility2.</span>blobRead
            <span class="apidocSignatureSpan">(blob, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.browserTest">
            function <span class="apidocSignatureSpan">utility2.</span>browserTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferConcat">
            function <span class="apidocSignatureSpan">utility2.</span>bufferConcat
            <span class="apidocSignatureSpan">(bufList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferIndexOfSubBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>bufferIndexOfSubBuffer
            <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferRandomBytes">
            function <span class="apidocSignatureSpan">utility2.</span>bufferRandomBytes
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferToUtf8">
            function <span class="apidocSignatureSpan">utility2.</span>bufferToUtf8
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferValidateAndCoerce">
            function <span class="apidocSignatureSpan">utility2.</span>bufferValidateAndCoerce
            <span class="apidocSignatureSpan">(buf, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildApp">
            function <span class="apidocSignatureSpan">utility2.</span>buildApp
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildLib">
            function <span class="apidocSignatureSpan">utility2.</span>buildLib
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildReadme">
            function <span class="apidocSignatureSpan">utility2.</span>buildReadme
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildTest">
            function <span class="apidocSignatureSpan">utility2.</span>buildTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.childProcessSpawnWithTimeout">
            function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithTimeout
            <span class="apidocSignatureSpan">(command, args, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.childProcessSpawnWithUtility2">
            function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithUtility2
            <span class="apidocSignatureSpan">(script, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliRun">
            function <span class="apidocSignatureSpan">utility2.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.coalesce">
            function <span class="apidocSignatureSpan">utility2.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.corsBackendHostInject">
            function <span class="apidocSignatureSpan">utility2.</span>corsBackendHostInject
            <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.corsForwardProxyHostIfNeeded">
            function <span class="apidocSignatureSpan">utility2.</span>corsForwardProxyHostIfNeeded
            <span class="apidocSignatureSpan">(xhr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt">
            function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawDecrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt">
            function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawEncrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateGetWeekOfMonth">
            function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfMonth
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateGetWeekOfYear">
            function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfYear
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateUtcFromLocal">
            function <span class="apidocSignatureSpan">utility2.</span>dateUtcFromLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateUtcToLocal">
            function <span class="apidocSignatureSpan">utility2.</span>dateUtcToLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domFragmentRender">
            function <span class="apidocSignatureSpan">utility2.</span>domFragmentRender
            <span class="apidocSignatureSpan">(template, dict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domQuerySelectorAllTagName">
            function <span class="apidocSignatureSpan">utility2.</span>domQuerySelectorAllTagName
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domSelectOptionValue">
            function <span class="apidocSignatureSpan">utility2.</span>domSelectOptionValue
            <span class="apidocSignatureSpan">(elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domStyleValidate">
            function <span class="apidocSignatureSpan">utility2.</span>domStyleValidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.emit">
            function <span class="apidocSignatureSpan">utility2.</span>emit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.errorMessagePrepend">
            function <span class="apidocSignatureSpan">utility2.</span>errorMessagePrepend
            <span class="apidocSignatureSpan">(err, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.eventEmitterCreate">
            function <span class="apidocSignatureSpan">utility2.</span>eventEmitterCreate
            <span class="apidocSignatureSpan">(that = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.events">
            function <span class="apidocSignatureSpan">utility2.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsReadFileOrEmptyStringSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsReadFileOrEmptyStringSync
            <span class="apidocSignatureSpan">(file, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.gotoNext">
            function <span class="apidocSignatureSpan">utility2.</span>gotoNext
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.identity">
            function <span class="apidocSignatureSpan">utility2.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.isNullOrUndefined">
            function <span class="apidocSignatureSpan">utility2.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.HtmlReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.TextReport">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.TextReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulCoverageMerge">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageMerge
            <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulCoverageReportCreate">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulInstrumentInPackage">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulInstrumentSync">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslintAndPrint">
            function <span class="apidocSignatureSpan">utility2.</span>jslintAndPrint
            <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslintAutofixLocalFunction">
            function <span class="apidocSignatureSpan">utility2.</span>jslintAutofixLocalFunction
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jsonCopy">
            function <span class="apidocSignatureSpan">utility2.</span>jsonCopy
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jsonStringifyOrdered">
            function <span class="apidocSignatureSpan">utility2.</span>jsonStringifyOrdered
            <span class="apidocSignatureSpan">(obj, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtAes256GcmDecrypt">
            function <span class="apidocSignatureSpan">utility2.</span>jwtAes256GcmDecrypt
            <span class="apidocSignatureSpan">(token, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtAes256GcmEncrypt">
            function <span class="apidocSignatureSpan">utility2.</span>jwtAes256GcmEncrypt
            <span class="apidocSignatureSpan">(data, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtAes256KeyCreate">
            function <span class="apidocSignatureSpan">utility2.</span>jwtAes256KeyCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtAes256KeyInit">
            function <span class="apidocSignatureSpan">utility2.</span>jwtAes256KeyInit
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtHs256Decode">
            function <span class="apidocSignatureSpan">utility2.</span>jwtHs256Decode
            <span class="apidocSignatureSpan">(token, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jwtHs256Encode">
            function <span class="apidocSignatureSpan">utility2.</span>jwtHs256Encode
            <span class="apidocSignatureSpan">(data, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listGetElementRandom">
            function <span class="apidocSignatureSpan">utility2.</span>listGetElementRandom
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listShuffle">
            function <span class="apidocSignatureSpan">utility2.</span>listShuffle
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerEmit">
            function <span class="apidocSignatureSpan">utility2.</span>listenerEmit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerOn">
            function <span class="apidocSignatureSpan">utility2.</span>listenerOn
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerOnce">
            function <span class="apidocSignatureSpan">utility2.</span>listenerOnce
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerRemove">
            function <span class="apidocSignatureSpan">utility2.</span>listenerRemove
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.localStorageSetItemOrClear">
            function <span class="apidocSignatureSpan">utility2.</span>localStorageSetItemOrClear
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked">
            function <span class="apidocSignatureSpan">utility2.</span>marked
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareAssetsCached">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareAssetsCached
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareBodyRead">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareBodyRead
            <span class="apidocSignatureSpan">(req, ignore, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareError">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareError
            <span class="apidocSignatureSpan">(err, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareFileServer">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareFileServer
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareForwardProxy">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareForwardProxy
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareInit">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareJsonpStateInit">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareJsonpStateInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.moduleDirname">
            function <span class="apidocSignatureSpan">utility2.</span>moduleDirname
            <span class="apidocSignatureSpan">(module, pathList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.nop">
            function <span class="apidocSignatureSpan">utility2.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.normalizeJwt">
            function <span class="apidocSignatureSpan">utility2.</span>normalizeJwt
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.normalizeJwtBase64Url">
            function <span class="apidocSignatureSpan">utility2.</span>normalizeJwtBase64Url
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.numberToRomanNumerals">
            function <span class="apidocSignatureSpan">utility2.</span>numberToRomanNumerals
            <span class="apidocSignatureSpan">(num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.objectSetDefault">
            function <span class="apidocSignatureSpan">utility2.</span>objectSetDefault
            <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.objectSetOverride">
            function <span class="apidocSignatureSpan">utility2.</span>objectSetOverride
            <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.on">
            function <span class="apidocSignatureSpan">utility2.</span>on
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorDefault">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorDefault
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorThrow">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorThrow
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onFileModifiedRestart">
            function <span class="apidocSignatureSpan">utility2.</span>onFileModifiedRestart
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onParallel">
            function <span class="apidocSignatureSpan">utility2.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onParallelList">
            function <span class="apidocSignatureSpan">utility2.</span>onParallelList
            <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onTimeout">
            function <span class="apidocSignatureSpan">utility2.</span>onTimeout
            <span class="apidocSignatureSpan">(onError, timeout, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.once">
            function <span class="apidocSignatureSpan">utility2.</span>once
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.profile">
            function <span class="apidocSignatureSpan">utility2.</span>profile
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.profileSync">
            function <span class="apidocSignatureSpan">utility2.</span>profileSync
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteerLaunch">
            function <span class="apidocSignatureSpan">utility2.</span>puppeteerLaunch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.querySelector">
            function <span class="apidocSignatureSpan">utility2.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.removeEventListener">
            function <span class="apidocSignatureSpan">utility2.</span>removeEventListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.removeListener">
            function <span class="apidocSignatureSpan">utility2.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.replStart">
            function <span class="apidocSignatureSpan">utility2.</span>replStart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.requireReadme">
            function <span class="apidocSignatureSpan">utility2.</span>requireReadme
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.semverCompare">
            function <span class="apidocSignatureSpan">utility2.</span>semverCompare
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverLocalReqHandler">
            function <span class="apidocSignatureSpan">utility2.</span>serverLocalReqHandler
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverLocalUrlTest">
            function <span class="apidocSignatureSpan">utility2.</span>serverLocalUrlTest
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondCors">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondCors
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondDefault">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondDefault
            <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondEcho">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondEcho
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondHeadSet">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondHeadSet
            <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondTimeoutDefault">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondTimeoutDefault
            <span class="apidocSignatureSpan">(req, res, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.setTimeoutOnError">
            function <span class="apidocSignatureSpan">utility2.</span>setTimeoutOnError
            <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng">
            function <span class="apidocSignatureSpan">utility2.</span>sjcl.prng
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHashScryptCreate">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHashScryptCreate
            <span class="apidocSignatureSpan">(password, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHashScryptValidate">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHashScryptValidate
            <span class="apidocSignatureSpan">(password, hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHashSha1Create">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHashSha1Create
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHashSha256Create">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHashSha256Create
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHmacSha1Create">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHmacSha1Create
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjclHmacSha256Create">
            function <span class="apidocSignatureSpan">utility2.</span>sjclHmacSha256Create
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stateInit">
            function <span class="apidocSignatureSpan">utility2.</span>stateInit
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stream">
            function <span class="apidocSignatureSpan">utility2.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.streamCleanup">
            function <span class="apidocSignatureSpan">utility2.</span>streamCleanup
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringHtmlSafe">
            function <span class="apidocSignatureSpan">utility2.</span>stringHtmlSafe
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringMerge">
            function <span class="apidocSignatureSpan">utility2.</span>stringMerge
            <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringQuotedToAscii">
            function <span class="apidocSignatureSpan">utility2.</span>stringQuotedToAscii
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringRegexpEscape">
            function <span class="apidocSignatureSpan">utility2.</span>stringRegexpEscape
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringTruncate">
            function <span class="apidocSignatureSpan">utility2.</span>stringTruncate
            <span class="apidocSignatureSpan">(text, maxLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringUniqueKey">
            function <span class="apidocSignatureSpan">utility2.</span>stringUniqueKey
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.templateRender">
            function <span class="apidocSignatureSpan">utility2.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.templateRenderMyApp">
            function <span class="apidocSignatureSpan">utility2.</span>templateRenderMyApp
            <span class="apidocSignatureSpan">(template, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testMock">
            function <span class="apidocSignatureSpan">utility2.</span>testMock
            <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testReportCreate">
            function <span class="apidocSignatureSpan">utility2.</span>testReportCreate
            <span class="apidocSignatureSpan">(testReport)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testReportMerge">
            function <span class="apidocSignatureSpan">utility2.</span>testReportMerge
            <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunBrowser">
            function <span class="apidocSignatureSpan">utility2.</span>testRunBrowser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunDefault">
            function <span class="apidocSignatureSpan">utility2.</span>testRunDefault
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunServer">
            function <span class="apidocSignatureSpan">utility2.</span>testRunServer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.throwError">
            function <span class="apidocSignatureSpan">utility2.</span>throwError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.timeElapsedPoll">
            function <span class="apidocSignatureSpan">utility2.</span>timeElapsedPoll
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.timeElapsedStart">
            function <span class="apidocSignatureSpan">utility2.</span>timeElapsedStart
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.tryCatchOnError">
            function <span class="apidocSignatureSpan">utility2.</span>tryCatchOnError
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideAccordian">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideAccordian
            <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideDown">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideDown
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideUp">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideUp
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.urlJoin">
            function <span class="apidocSignatureSpan">utility2.</span>urlJoin
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.urlParse">
            function <span class="apidocSignatureSpan">utility2.</span>urlParse
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uuid4Create">
            function <span class="apidocSignatureSpan">utility2.</span>uuid4Create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.</span>timeExit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.</span>timeoutDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>utility2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>FormData.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>Module._extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>Module.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>_debugTryCatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>_http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>assetsDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cacheDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>contentTypeDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>errDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.HtmlReport.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.TextReport.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul._istanbul_fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.collector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.coverageUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.escodegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima.Position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.estraverse.Controller.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.handlebars</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.writer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.CSSLint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.CSSLint._Reporter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Renderer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>middlewareList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer.puppeteerApi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpMatchUrl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidateEmail</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidatePhone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidateUuid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.beware</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.bitArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.cipher.aes.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.exception</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.hash.sha1.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.hash.sha256.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.misc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.misc.hmac.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>sjcl.prng.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>swgg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>swgg.uiEventListenerDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>taskOnTaskDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>modeTestCase</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>serverLocalHost</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetAscii</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringHelloEmoji</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.FormData">module utility2.FormData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.FormData">
            function <span class="apidocSignatureSpan">utility2.</span>FormData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.FormData.prototype">module utility2.FormData.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.prototype.append">
            function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>append
            <span class="apidocSignatureSpan">(name, value, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.prototype.read">
            function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>read
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module">module utility2.Module</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.Module">
            function <span class="apidocSignatureSpan">utility2.</span>Module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._debug">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_debug
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._findPath">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_findPath
            <span class="apidocSignatureSpan">(request, paths, isMain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._initPaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_initPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._load">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_load
            <span class="apidocSignatureSpan">(request, parent, isMain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._nodeModulePaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_nodeModulePaths
            <span class="apidocSignatureSpan">(from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._preloadModules">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_preloadModules
            <span class="apidocSignatureSpan">(requests)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._resolveFilename">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveFilename
            <span class="apidocSignatureSpan">(request, parent, isMain, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._resolveLookupPaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveLookupPaths
            <span class="apidocSignatureSpan">(request, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.createRequire">
            function <span class="apidocSignatureSpan">utility2.Module.</span>createRequire
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.createRequireFromPath">
            function <span class="apidocSignatureSpan">utility2.Module.</span>createRequireFromPath
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.runMain">
            function <span class="apidocSignatureSpan">utility2.Module.</span>runMain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_pathCache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>builtinModules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>globalPaths</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module._extensions">module utility2.Module._extensions</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module.prototype">module utility2.Module.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype._compile">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>_compile
            <span class="apidocSignatureSpan">(content, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype.load">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>load
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype.require">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>require
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2._http">module utility2._http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._http.createServer">
            function <span class="apidocSignatureSpan">utility2._http.</span>createServer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._http.request">
            function <span class="apidocSignatureSpan">utility2._http.</span>request
            <span class="apidocSignatureSpan">(xhr, onResponse)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2._http.</span>STATUS_CODES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.apidoc">module utility2.apidoc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.apidoc.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.apidoc.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.apidocCreate">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.apidocModuleDictAdd">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocModuleDictAdd
            <span class="apidocSignatureSpan">(opt, moduleDict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.assert">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.cliRun">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.coalesce">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.events">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.identity">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.moduleDirname">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>moduleDirname
            <span class="apidocSignatureSpan">(module, pathList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.nop">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.objectSetDefault">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectSetDefault
            <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.querySelector">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.stream">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.stringHtmlSafe">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>stringHtmlSafe
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.templateRender">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.tryCatchOnError">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>tryCatchOnError
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>_debugTryCatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.apidoc.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.apidoc.</span>templateApidocHtml</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.apidoc.cliDict">module utility2.apidoc.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.cliDict._default">
            function <span class="apidocSignatureSpan">utility2.apidoc.cliDict.</span>_default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.cliDict">module utility2.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.browserTest">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.browserTest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentDelete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentGet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentPut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentTouch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoDelete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.start">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.swaggerValidateFile">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.swaggerValidateFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.testReportCreate">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.testReportCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.github_crud">module utility2.github_crud</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.github_crud.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.github_crud.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.ajax">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>ajax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.assert">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliRun">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.coalesce">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.events">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudAjax">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudAjax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentDelete">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentDelete
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentGet">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentGet
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentPut">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPut
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentPutFile">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPutFile
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentTouch">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouch
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentTouchList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouchList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreate">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreate
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreateList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreateList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoDelete">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDelete
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDeleteList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.gotoNext">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>gotoNext
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.identity">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.nop">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onErrorDefault">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorDefault
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onParallel">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onParallelList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallelList
            <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.querySelector">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.stream">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.github_crud.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.github_crud.cliDict">module utility2.github_crud.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.delete">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>delete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.get">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.put">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>put
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.repo_create">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.repo_delete">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_delete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.touch">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul">module utility2.istanbul</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>HtmlReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.TextReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>TextReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul._istanbul_module">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>_istanbul_module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.assert">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliRun">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coalesce">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageMerge">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageMerge
            <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageReportCreate">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.events">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.identity">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.instrumentInPackage">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.instrumentSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.nop">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.querySelector">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.stream">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>_istanbul_fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>_istanbul_path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>collector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>escodegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>esprima</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>esutils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>handlebars</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>writer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>foot.txt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>head.txt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>templateCoverageBadgeSvg</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.HtmlReport">module utility2.istanbul.HtmlReport</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.HtmlReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>HtmlReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.</span>TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.HtmlReport.prototype">module utility2.istanbul.HtmlReport.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.fillTemplate">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>fillTemplate
            <span class="apidocSignatureSpan">(node, templateData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.getPathHtml">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>getPathHtml
            <span class="apidocSignatureSpan">(node, linkMapper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.standardLinkMapper">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>standardLinkMapper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeDetailPage">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeDetailPage
            <span class="apidocSignatureSpan">(writer, node, fileCoverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeFiles">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeFiles
            <span class="apidocSignatureSpan">(writer, node, dir, collector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeIndexPage">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeIndexPage
            <span class="apidocSignatureSpan">(writer, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeReport
            <span class="apidocSignatureSpan">(collector, sync)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.Instrumenter">module utility2.istanbul.Instrumenter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.Instrumenter.prototype">module utility2.istanbul.Instrumenter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>arrowBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchIncrementExprAst
            <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchLocationFor
            <span class="apidocSignatureSpan">(name, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchName
            <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>conditionalBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>convertToBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverExport
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverFunction
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverMetaProperty
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverStatement
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>endIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>extractCurrentHint
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>filterHints
            <span class="apidocSignatureSpan">(comments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>findLeaves
            <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>fixColumnPositions
            <span class="apidocSignatureSpan">(coverState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>functionName
            <span class="apidocSignatureSpan">(node, line, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>getPreamble
            <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrument
            <span class="apidocSignatureSpan">(code, filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentASTSync
            <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>isUseStrictExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastFileCoverage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastSourceMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>locationsForNodes
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>logicalExpressionBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>loopBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddSkip
            <span class="apidocSignatureSpan">(branchLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeSkipNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>paranoidHandlerCheck
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipInit
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipLeft
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>splice
            <span class="apidocSignatureSpan">(statements, node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>startIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>statementName
            <span class="apidocSignatureSpan">(location, initValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchCaseInjector
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>withBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.TextReport">module utility2.istanbul.TextReport</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.TextReport.TextReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>TextReport
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.TextReport.</span>TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.TextReport.prototype">module utility2.istanbul.TextReport.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.TextReport.prototype.writeReport">
            function <span class="apidocSignatureSpan">utility2.istanbul.TextReport.prototype.</span>writeReport
            <span class="apidocSignatureSpan">(collector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul._istanbul_fs">module utility2.istanbul._istanbul_fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul._istanbul_fs.readFileSync">
            function <span class="apidocSignatureSpan">utility2.istanbul._istanbul_fs.</span>readFileSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul._istanbul_fs.readdirSync">
            function <span class="apidocSignatureSpan">utility2.istanbul._istanbul_fs.</span>readdirSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.cliDict">module utility2.istanbul.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.cover">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>cover
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.instrument">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>instrument
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.report">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>report
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.test">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.collector">module utility2.istanbul.collector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.collector.fileCoverageFor">
            function <span class="apidocSignatureSpan">utility2.istanbul.collector.</span>fileCoverageFor
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.collector.files">
            function <span class="apidocSignatureSpan">utility2.istanbul.collector.</span>files
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.coverageUtils">module utility2.istanbul.coverageUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfo">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>addDerivedInfo
            <span class="apidocSignatureSpan">(coverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfoForFile">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>addDerivedInfoForFile
            <span class="apidocSignatureSpan">(fileCoverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.blankSummary">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>blankSummary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.mergeFileCoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>mergeFileCoverage
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.mergeSummaryObjects">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>mergeSummaryObjects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.removeDerivedInfo">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>removeDerivedInfo
            <span class="apidocSignatureSpan">(coverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.summarizeCoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>summarizeCoverage
            <span class="apidocSignatureSpan">(coverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.summarizeFileCoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>summarizeFileCoverage
            <span class="apidocSignatureSpan">(fileCoverage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageUtils.toYUICoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>toYUICoverage
            <span class="apidocSignatureSpan">(coverage)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.escodegen">module utility2.istanbul.escodegen</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>browser</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.escodegen.attachComments">
            function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.escodegen.generate">
            function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>generate
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>FORMAT_DEFAULTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>FORMAT_MINIFY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>Precedence</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima">module utility2.istanbul.esprima</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Node">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Node
            <span class="apidocSignatureSpan">(parser, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Position">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.SourceLocation">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>SourceLocation
            <span class="apidocSignatureSpan">(p, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.TokContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokContext
            <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Token">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Token
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.TokenType">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokenType
            <span class="apidocSignatureSpan">(label, conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.getLineInfo">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>getLineInfo
            <span class="apidocSignatureSpan">(input, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierChar
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierStart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isNewLine">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isNewLine
            <span class="apidocSignatureSpan">(code, ecma2019String)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.parse">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.parseExpressionAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.tokenizer">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>keywordTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>lineBreak</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>lineBreakG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>nonASCIIwhitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokContexts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima.Parser.prototype">module utility2.istanbul.esprima.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>adaptDirectivePrologue
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>afterTrailingComma
            <span class="apidocSignatureSpan">(tokType, notNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>braceIsBlock
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>buildBinary
            <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>canInsertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExport
            <span class="apidocSignatureSpan">(exports, name, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExpressionErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLVal
            <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLocalExport
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkParams
            <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternExport
            <span class="apidocSignatureSpan">(exports, pat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPropClash
            <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkUnreserved
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkVariableExport
            <span class="apidocSignatureSpan">(exports, decls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentThisScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentVarScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>declareName
            <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eat
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eatContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>enterScope
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>exitScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expectContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNodeAt
            <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishOp
            <span class="apidocSignatureSpan">(type, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishToken
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>fullCharCodeAtPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getTokenFromCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inGeneratorContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inNonArrowFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initialContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>insertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>invalidStringToken
            <span class="apidocSignatureSpan">(position, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncProp
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isDirectiveCandidate
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isLet
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleAssignTarget
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleParamList
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseArrowExpression
            <span class="apidocSignatureSpan">(node, params, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseAwait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingList
            <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingListItem
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBreakContinueStatement
            <span class="apidocSignatureSpan">(node, keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClass
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassElement
            <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassId
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassMethod
            <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassSuper
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDebuggerStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDoStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDynamicImport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseEmptyStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExport
            <span class="apidocSignatureSpan">(node, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExportSpecifiers
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprAtom
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprList
            <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOp
            <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOps
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprSubscripts
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpressionStatement
            <span class="apidocSignatureSpan">(node, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFor
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForIn
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionBody
            <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionParams
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionStatement
            <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIdent
            <span class="apidocSignatureSpan">(liberal, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIfStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImportSpecifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLabeledStatement
            <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeAssign
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeConditional
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeDefault
            <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeUnary
            <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMethod
            <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseNew
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseObj
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
            <span class="apidocSignatureSpan">(canBeArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenArrowList
            <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenItem
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseProperty
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyName
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseRestBinding
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseReturnStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSpread
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseStatement
            <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscript
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscripts
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSwitchStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplate
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplateElement
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseThrowStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTryStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVar
            <span class="apidocSignatureSpan">(node, isFor, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarId
            <span class="apidocSignatureSpan">(decl, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarStatement
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWhileStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWithStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseYield
            <span class="apidocSignatureSpan">(noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raise
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raiseRecoverable
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readEscapedChar
            <span class="apidocSignatureSpan">(inTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readHexChar
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInt
            <span class="apidocSignatureSpan">(radix, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInvalidTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(startsWithDot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRadixNumber
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRegexp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readString
            <span class="apidocSignatureSpan">(quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readTmplToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_caret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_eq_excl
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_lt_gt
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_pipe_amp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_plus_min
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_slash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_alternative
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_classRanges
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_disjunction
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAssertion
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBackReference
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClass
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
            <span class="apidocSignatureSpan">(state, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatKGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatOctalDigit
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatTerm
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatZero
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_groupSpecifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_pattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
            <span class="apidocSignatureSpan">(state, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state, nameOrValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>shouldParseExportStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipBlockComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipLineComment
            <span class="apidocSignatureSpan">(startSkip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNodeAt
            <span class="apidocSignatureSpan">(pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>strictDirective
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignable
            <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignableList
            <span class="apidocSignatureSpan">(exprList, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>tryReadTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>unexpected
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpFlags
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpPattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima.Position.prototype">module utility2.istanbul.esprima.Position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Position.prototype.</span>offset
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.estraverse">module utility2.istanbul.estraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.attachComments">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>cloneEnvironment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.replace">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.traverse">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>VisitorKeys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>VisitorOption</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.estraverse.Controller.prototype">module utility2.istanbul.estraverse.Controller.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__execute
            <span class="apidocSignatureSpan">(callback, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__initialize
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>current
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>notify
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>parents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>path
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>skip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.handlebars">module utility2.istanbul.handlebars</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.compile">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>compile
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.registerHelper">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>registerHelper
            <span class="apidocSignatureSpan">(key, helper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.replace">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>replace
            <span class="apidocSignatureSpan">(template, dict, withPrefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.show_code">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_code
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.show_ignores">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_ignores
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.show_line_execution_counts">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_line_execution_counts
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.show_lines">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_lines
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.handlebars.show_picture">
            function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_picture
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.process">module utility2.istanbul.process</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_exiting</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._debugEnd">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._debugProcess">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._fatalException">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_fatalException
            <span class="apidocSignatureSpan">(er, fromPromise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._getActiveHandles">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveHandles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._getActiveRequests">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveRequests
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._kill">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_kill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._linkedBinding">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_linkedBinding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._rawDebug">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_rawDebug
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_startProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_stopProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._tickCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_tickCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.abort">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.assert">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.binding">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>binding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.chdir">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>chdir
            <span class="apidocSignatureSpan">(directory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.cpuUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cpuUsage
            <span class="apidocSignatureSpan">(prevValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.cwd">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.dlopen">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>dlopen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.emitWarning">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>emitWarning
            <span class="apidocSignatureSpan">(warning, type, code, ctor, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.exit">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getegid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getegid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.geteuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>geteuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getgid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgroups
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hasUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.hrtime">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hrtime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.initgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>initgroups
            <span class="apidocSignatureSpan">(user, extraGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.kill">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>kill
            <span class="apidocSignatureSpan">(pid, sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.memoryUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>memoryUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.nextTick">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.openStdin">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>openStdin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.reallyExit">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>reallyExit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.resourceUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>resourceUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setegid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setegid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.seteuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>seteuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setgid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgroups
            <span class="apidocSignatureSpan">(groups)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.umask">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>umask
            <span class="apidocSignatureSpan">(mask)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.uptime">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>uptime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>debugPort</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>pid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>ppid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_preload_modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>allowedNodeEnvironmentFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>argv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>execArgv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>features</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>mainModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>moduleLoadList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>release</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stderr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stdin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stdout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>versions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>arch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>argv0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>execPath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>platform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>title</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.require">module utility2.istanbul.require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require.require">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require.resolve">
            function <span class="apidocSignatureSpan">utility2.istanbul.require.</span>resolve
            <span class="apidocSignatureSpan">(request, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>main</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.util">module utility2.istanbul.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.util.inherits">
            function <span class="apidocSignatureSpan">utility2.istanbul.util.</span>inherits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.writer">module utility2.istanbul.writer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.writer.write">
            function <span class="apidocSignatureSpan">utility2.istanbul.writer.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.writer.writeFile">
            function <span class="apidocSignatureSpan">utility2.istanbul.writer.</span>writeFile
            <span class="apidocSignatureSpan">(file, onError)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint">module utility2.jslint</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.jslint.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.jslint.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.assert">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliRun">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.coalesce">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.events">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.identity">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAndPrint">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrint
            <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAndPrintDir">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrintDir
            <span class="apidocSignatureSpan">(dir, opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAutofix">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAutofix
            <span class="apidocSignatureSpan">(code, file, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintGetColumnLine">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintGetColumnLine
            <span class="apidocSignatureSpan">(code, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintUtility2">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintUtility2
            <span class="apidocSignatureSpan">(code, ignore, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslint_extra">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslint_extra
            <span class="apidocSignatureSpan">(source, opt, global_array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.nop">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.onParallel">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.querySelector">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.stream">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>CSSLint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>jslintResult</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.jslint.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.CSSLint">module utility2.jslint.CSSLint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_Reporter
            <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.addFormatter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addFormatter
            <span class="apidocSignatureSpan">(formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.addRule">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.clearRules">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>clearRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.format">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>format
            <span class="apidocSignatureSpan">(results, filename, formatId, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getFormatter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getFormatter
            <span class="apidocSignatureSpan">(formatId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getRules">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getRuleset">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRuleset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.hasFormat">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>hasFormat
            <span class="apidocSignatureSpan">(formatId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.verify">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>verify
            <span class="apidocSignatureSpan">(text, ruleset)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>Util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_listeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.CSSLint._Reporter.prototype">module utility2.jslint.CSSLint._Reporter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>constructor
            <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>error
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>info
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>report
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupError
            <span class="apidocSignatureSpan">(message, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupWarn
            <span class="apidocSignatureSpan">(message, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>stat
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>warn
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.cliDict">module utility2.jslint.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliDict._default">
            function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>_default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliDict.dir">
            function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>dir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked">module utility2.marked</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.marked">
            function <span class="apidocSignatureSpan">utility2.</span>marked
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.inlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>inlineLexer
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>lexer
            <span class="apidocSignatureSpan">(e, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.options">
            function <span class="apidocSignatureSpan">utility2.marked.</span>options
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.parse">
            function <span class="apidocSignatureSpan">utility2.marked.</span>parse
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>parser
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.setOptions">
            function <span class="apidocSignatureSpan">utility2.marked.</span>setOptions
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.InlineLexer">module utility2.marked.InlineLexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.output">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>output
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>rules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.InlineLexer.prototype">module utility2.marked.InlineLexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.mangle">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>mangle
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.output">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>output
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>outputLink
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>smartypants
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Lexer">module utility2.marked.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.Lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.lex">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>lex
            <span class="apidocSignatureSpan">(e, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>rules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Lexer.prototype">module utility2.marked.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.prototype.lex">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>lex
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.prototype.token">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>token
            <span class="apidocSignatureSpan">(t, n, r)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Parser">module utility2.marked.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.Parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.parse">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.</span>parse
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Parser.prototype">module utility2.marked.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.next">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.parseText">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parseText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.peek">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>peek
            <span class="apidocSignatureSpan">( )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.tok">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>tok
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Renderer">module utility2.marked.Renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.Renderer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Renderer.prototype">module utility2.marked.Renderer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.blockquote">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>blockquote
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.br">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>br
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.code">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>code
            <span class="apidocSignatureSpan">( e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.codespan">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>codespan
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.del">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>del
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.em">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>em
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.heading">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>heading
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.hr">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>hr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.html">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>html
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.image">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>image
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.link">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>link
            <span class="apidocSignatureSpan">( e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.list">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>list
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.listitem">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>listitem
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.paragraph">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>paragraph
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.strong">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>strong
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.table">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>table
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.tablecell">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablecell
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.tablerow">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablerow
            <span class="apidocSignatureSpan">( e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.text">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>text
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.puppeteer">module utility2.puppeteer</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.puppeteer.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.puppeteer.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.assert">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.cliRun">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.coalesce">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.events">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.identity">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.nop">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerLaunch">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerLaunch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.querySelector">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.stream">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>_puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerApi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.puppeteer.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.puppeteer.puppeteerApi">module utility2.puppeteer.puppeteerApi</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Accessibility
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Browser">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Browser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserContext
            <span class="apidocSignatureSpan">(connection, browser, contextId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>CDPSession
            <span class="apidocSignatureSpan">(connection, targetType, sessionId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ConsoleMessage
            <span class="apidocSignatureSpan">(type, text, args, location = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Coverage
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Dialog
            <span class="apidocSignatureSpan">(string|undefined)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ElementHandle
            <span class="apidocSignatureSpan">(context, client, remoteObject, page, frameManager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ExecutionContext
            <span class="apidocSignatureSpan">(client, contextPayload, world)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>FileChooser
            <span class="apidocSignatureSpan">(client, event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Frame">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Frame
            <span class="apidocSignatureSpan">(frameManager, client, parentFrame, frameId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>JSHandle
            <span class="apidocSignatureSpan">(context, client, remoteObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Keyboard
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Mouse
            <span class="apidocSignatureSpan">(client, keyboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Page">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Page
            <span class="apidocSignatureSpan">(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Puppeteer
            <span class="apidocSignatureSpan">(projectRoot, preferredRevision, isPuppeteerCore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Request">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Request
            <span class="apidocSignatureSpan">(client, frame, interceptionId, allowInterception, event, redirectChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Response">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Response
            <span class="apidocSignatureSpan">(client, request, responsePayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>SecurityDetails
            <span class="apidocSignatureSpan">(securityPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Target">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Target
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>TimeoutError
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Touchscreen
            <span class="apidocSignatureSpan">(client, keyboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Tracing
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Worker">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Worker
            <span class="apidocSignatureSpan">(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserFetcher</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl">module utility2.sjcl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.decrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.</span>decrypt
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.encrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.</span>encrypt
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng">
            function <span class="apidocSignatureSpan">utility2.sjcl.</span>prng
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>beware</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>bitArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>codec</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>exception</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>keyexchange</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>misc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>mode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.sjcl.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.beware">module utility2.sjcl.beware</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.bitArray">module utility2.sjcl.bitArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.bitLength">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>bitLength
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.bitSlice">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>bitSlice
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.byteswapM">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>byteswapM
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.clamp">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>clamp
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.concat">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>concat
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.equal">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>equal
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.extract">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>extract
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.getPartial">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>getPartial
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.i">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>i
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.bitArray.partial">
            function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>partial
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.cipher">module utility2.sjcl.cipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.cipher.aes">
            function <span class="apidocSignatureSpan">utility2.sjcl.cipher.</span>aes
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.cipher.aes.prototype">module utility2.sjcl.cipher.aes.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.O">
            function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>O
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.decrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.encrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>s</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.exception">module utility2.sjcl.exception</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.exception.bug">
            function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>bug
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.exception.corrupt">
            function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>corrupt
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.exception.invalid">
            function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>invalid
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.exception.notReady">
            function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>notReady
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.hash">module utility2.sjcl.hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.</span>sha1
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha256">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.</span>sha256
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.hash.sha1.prototype">module utility2.sjcl.hash.sha1.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._S">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_S
            <span class="apidocSignatureSpan">(n, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._block">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_block
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._f">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_f
            <span class="apidocSignatureSpan">(t, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.finalize">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.reset">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.update">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>update
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_init</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_key</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.hash.sha256.prototype">module utility2.sjcl.hash.sha256.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.O">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>O
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.finalize">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.reset">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.update">
            function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>update
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>blockSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>Y</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>b</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.json">module utility2.sjcl.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.decode">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>decode
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.decrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>decrypt
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.encode">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>encode
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.encrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>encrypt
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.g">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>g
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.ia">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ia
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.ja">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ja
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.ra">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ra
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.json.sa">
            function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>sa
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.json.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.misc">module utility2.sjcl.misc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.cachedPbkdf2">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>cachedPbkdf2
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>hmac
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.pbkdf2">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>pbkdf2
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.scrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>scrypt
            <span class="apidocSignatureSpan">(password, salt, N, r, p, length, Prff)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>pa</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.misc.hmac.prototype">module utility2.sjcl.misc.hmac.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.digest">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>digest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.encrypt">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.mac">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>mac
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.reset">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.update">
            function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>update
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.prng">module utility2.sjcl.prng</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prng">
            function <span class="apidocSignatureSpan">utility2.sjcl.</span>prng
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.sjcl.prng.prototype">module utility2.sjcl.prng.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.addEntropy">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>addEntropy
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.addEventListener">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>addEventListener
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.ea">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>ea
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.getProgress">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>getProgress
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.isReady">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>isReady
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.la">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>la
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.ma">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>ma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.oa">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>oa
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.qa">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>qa
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.randomWords">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>randomWords
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.removeEventListener">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>removeEventListener
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.setDefaultParanoia">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>setDefaultParanoia
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.startCollectors">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>startCollectors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.sjcl.prng.prototype.stopCollectors">
            function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>stopCollectors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.swgg">module utility2.swgg</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.swgg.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.swgg.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.Blob">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>Blob
            <span class="apidocSignatureSpan">(list, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.FormData">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>FormData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.Module">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>Module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_buildApidoc_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildApidoc_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_buildApp_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildApp_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_buildLib_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildLib_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_buildReadme_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildReadme_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_buildTest_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildTest_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg._testCase_webpage_default">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_webpage_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.ajax">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>ajax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.ajaxProgressUpdate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>ajaxProgressUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.apiAjax">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>apiAjax
            <span class="apidocSignatureSpan">(that, opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.apiUpdate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>apiUpdate
            <span class="apidocSignatureSpan">(swaggerJson)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.apidocCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>apidocCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.assert">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.assertJsonEqual">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>assertJsonEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.assertJsonNotEqual">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>assertJsonNotEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.base64FromBuffer">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>base64FromBuffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.base64ToBuffer">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>base64ToBuffer
            <span class="apidocSignatureSpan">(b64, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.base64ToUtf8">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>base64ToUtf8
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.blobRead">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>blobRead
            <span class="apidocSignatureSpan">(blob, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.browserTest">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>browserTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.bufferConcat">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferConcat
            <span class="apidocSignatureSpan">(bufList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.bufferIndexOfSubBuffer">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferIndexOfSubBuffer
            <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.bufferRandomBytes">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferRandomBytes
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.bufferToUtf8">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferToUtf8
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.bufferValidateAndCoerce">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferValidateAndCoerce
            <span class="apidocSignatureSpan">(buf, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.buildApp">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>buildApp
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.buildLib">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>buildLib
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.buildReadme">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>buildReadme
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.buildTest">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>buildTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.childProcessSpawnWithTimeout">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>childProcessSpawnWithTimeout
            <span class="apidocSignatureSpan">(command, args, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.childProcessSpawnWithUtility2">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>childProcessSpawnWithUtility2
            <span class="apidocSignatureSpan">(script, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.cliRun">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.coalesce">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.corsBackendHostInject">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>corsBackendHostInject
            <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.corsForwardProxyHostIfNeeded">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>corsForwardProxyHostIfNeeded
            <span class="apidocSignatureSpan">(xhr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawDecrypt">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>cryptoAesXxxCbcRawDecrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawEncrypt">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>cryptoAesXxxCbcRawEncrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dateGetWeekOfMonth">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dateGetWeekOfMonth
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dateGetWeekOfYear">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dateGetWeekOfYear
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dateUtcFromLocal">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dateUtcFromLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dateUtcToLocal">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dateUtcToLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dbFieldRandomCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dbFieldRandomCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dbRowListRandomCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dbRowListRandomCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.dbRowRandomCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>dbRowRandomCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.domFragmentRender">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>domFragmentRender
            <span class="apidocSignatureSpan">(template, dict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.domQuerySelectorAllTagName">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>domQuerySelectorAllTagName
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.domSelectOptionValue">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>domSelectOptionValue
            <span class="apidocSignatureSpan">(elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.domStyleValidate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>domStyleValidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.emit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>emit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.errorMessagePrepend">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>errorMessagePrepend
            <span class="apidocSignatureSpan">(err, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.eventEmitterCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>eventEmitterCreate
            <span class="apidocSignatureSpan">(that = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.events">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>events
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.fsReadFileOrEmptyStringSync">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>fsReadFileOrEmptyStringSync
            <span class="apidocSignatureSpan">(file, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(file, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.functionOrNop">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>functionOrNop
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.gotoNext">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>gotoNext
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.idDomElementCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>idDomElementCreate
            <span class="apidocSignatureSpan">(seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.idNameInit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>idNameInit
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.identity">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.isNullOrUndefined">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.istanbulCoverageMerge">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulCoverageMerge
            <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.istanbulCoverageReportCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulCoverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.istanbulInstrumentInPackage">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulInstrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.istanbulInstrumentSync">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulInstrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jslintAndPrint">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jslintAndPrint
            <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jslintAutofixLocalFunction">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jslintAutofixLocalFunction
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jsonCopy">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jsonCopy
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jsonStringifyOrdered">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jsonStringifyOrdered
            <span class="apidocSignatureSpan">(obj, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtAes256GcmDecrypt">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256GcmDecrypt
            <span class="apidocSignatureSpan">(token, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtAes256GcmEncrypt">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256GcmEncrypt
            <span class="apidocSignatureSpan">(data, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtAes256KeyCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256KeyCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtAes256KeyInit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256KeyInit
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtHs256Decode">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtHs256Decode
            <span class="apidocSignatureSpan">(token, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.jwtHs256Encode">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtHs256Encode
            <span class="apidocSignatureSpan">(data, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listGetElementRandom">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listGetElementRandom
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listShuffle">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listShuffle
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listenerEmit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerEmit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listenerOn">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerOn
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listenerOnce">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerOnce
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.listenerRemove">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerRemove
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.localStorageSetItemOrClear">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>localStorageSetItemOrClear
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.marked">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>marked
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareAssetsCached">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareAssetsCached
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareBodyParse">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareBodyParse
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareBodyRead">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareBodyRead
            <span class="apidocSignatureSpan">(req, ignore, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareCrudBuiltin">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareCrudBuiltin
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareCrudEnd">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareCrudEnd
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareError">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareError
            <span class="apidocSignatureSpan">(err, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareFileServer">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareFileServer
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareForwardProxy">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareForwardProxy
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareInit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareJsonpStateInit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareJsonpStateInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareRouter">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareRouter
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareUserLogin">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareUserLogin
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.middlewareValidate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareValidate
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.moduleDirname">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>moduleDirname
            <span class="apidocSignatureSpan">(module, pathList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.nop">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.normalizeJwt">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeJwt
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.normalizeJwtBase64Url">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeJwtBase64Url
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.normalizeSwaggerJson">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeSwaggerJson
            <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.normalizeSwaggerParamDict">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeSwaggerParamDict
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.numberToRomanNumerals">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>numberToRomanNumerals
            <span class="apidocSignatureSpan">(num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.objectSetDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>objectSetDefault
            <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.objectSetOverride">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>objectSetOverride
            <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.on">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>on
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onErrorDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorDefault
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onErrorJsonapi">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorJsonapi
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onErrorThrow">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorThrow
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onFileModifiedRestart">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onFileModifiedRestart
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onParallel">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onParallelList">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onParallelList
            <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.onTimeout">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>onTimeout
            <span class="apidocSignatureSpan">(onError, timeout, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.once">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>once
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.operationIdFromAjax">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>operationIdFromAjax
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.profile">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>profile
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.profileSync">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>profileSync
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.puppeteerLaunch">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>puppeteerLaunch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.querySelector">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>querySelector
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.querySelectorAll">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>querySelectorAll
            <span class="apidocSignatureSpan">(selectors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.removeEventListener">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>removeEventListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.removeListener">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.replStart">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>replStart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.requireReadme">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>requireReadme
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.schemaPItems">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPItems
            <span class="apidocSignatureSpan">(schemaP)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.schemaPItemsType">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPItemsType
            <span class="apidocSignatureSpan">(schemaP)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.schemaPType">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPType
            <span class="apidocSignatureSpan">(schemaP)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.semverCompare">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>semverCompare
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondCors">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondCors
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondDefault
            <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondEcho">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondEcho
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondHeadSet">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondHeadSet
            <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondJsonapi">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondJsonapi
            <span class="apidocSignatureSpan">(req, res, err, data, meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.serverRespondTimeoutDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondTimeoutDefault
            <span class="apidocSignatureSpan">(req, res, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.setTimeoutOnError">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>setTimeoutOnError
            <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHashScryptCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashScryptCreate
            <span class="apidocSignatureSpan">(password, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHashScryptValidate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashScryptValidate
            <span class="apidocSignatureSpan">(password, hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHashSha1Create">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashSha1Create
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHashSha256Create">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashSha256Create
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHmacSha1Create">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHmacSha1Create
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.sjclHmacSha256Create">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHmacSha256Create
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stateInit">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stateInit
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stream">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.streamCleanup">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>streamCleanup
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringHtmlSafe">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringHtmlSafe
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringMerge">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringMerge
            <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringQuotedToAscii">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringQuotedToAscii
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringRegexpEscape">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringRegexpEscape
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringTruncate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringTruncate
            <span class="apidocSignatureSpan">(text, maxLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.stringUniqueKey">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>stringUniqueKey
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerJsonFromAjax">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromAjax
            <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerJsonFromCurl">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromCurl
            <span class="apidocSignatureSpan">(swaggerJson, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerJsonFromPostBody">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromPostBody
            <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerValidate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidate
            <span class="apidocSignatureSpan">(swaggerJson)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerValidateDataParameters">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateDataParameters
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerValidateDataSchema">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateDataSchema
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.swaggerValidateFile">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateFile
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.templateRender">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.templateRenderMyApp">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>templateRenderMyApp
            <span class="apidocSignatureSpan">(template, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testMock">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testMock
            <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testReportCreate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testReportCreate
            <span class="apidocSignatureSpan">(testReport)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testReportMerge">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testReportMerge
            <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testRunBrowser">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunBrowser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testRunDefault">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunDefault
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.testRunServer">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunServer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.throwError">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>throwError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.throwSwaggerError">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>throwSwaggerError
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.timeElapsedPoll">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>timeElapsedPoll
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.timeElapsedStart">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>timeElapsedStart
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.tryCatchOnError">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>tryCatchOnError
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiAnimateSlideAccordian">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideAccordian
            <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiAnimateSlideDown">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideDown
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiAnimateSlideUp">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideUp
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventDelegate">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uiEventDelegate
            <span class="apidocSignatureSpan">(evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiRenderSchemaP">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uiRenderSchemaP
            <span class="apidocSignatureSpan">(schemaP)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.urlJoin">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>urlJoin
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.urlParse">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>urlParse
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.urlParseWithBraket">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>urlParseWithBraket
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.userLoginByPassword">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>userLoginByPassword
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.userLogout">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>userLogout
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uuid4Create">
            function <span class="apidocSignatureSpan">utility2.swgg.</span>uuid4Create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.swgg.</span>timeExit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.swgg.</span>timeoutDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>swgg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>_debugTryCatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>_http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>apiDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>apidoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>assetsDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>cacheDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>contentTypeDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>errDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>github_crud</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>jslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpMatchUrl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpValidateEmail</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpValidatePhone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>regexpValidateUuid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>sjcl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerErrorTypeDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerSchemaJson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>taskOnTaskDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>templateApiDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>uiEventListenerDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>utility2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.swgg.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>serverLocalHost</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>stringCharsetAscii</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>stringCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>stringCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>stringHelloEmoji</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonBasePath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateSwaggerUiLogoMediumBase64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateSwaggerUiLogoSmallBase64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiMain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiOperation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiParameter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiReqJs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiResource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.swgg.</span>templateUiTitle</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.swgg.uiEventListenerDict">module utility2.swgg.uiEventListenerDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputTextareaChange">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventInputTextareaChange
            <span class="apidocSignatureSpan">(evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputValidateAndAjax">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventInputValidateAndAjax
            <span class="apidocSignatureSpan">( opt, onError )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationAjax">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventOperationAjax
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationDisplayShow">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventOperationDisplayShow
            <span class="apidocSignatureSpan">( evt, onError )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventResourceDisplayAction">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventResourceDisplayAction
            <span class="apidocSignatureSpan">(evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventUiReload">
            function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventUiReload
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2" id="apidoc.module.utility2">module utility2</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.Blob" id="apidoc.elem.utility2.Blob">
        function <span class="apidocSignatureSpan">utility2.</span>Blob
        <span class="apidocSignatureSpan">(list, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Blob = function (list, opt) {
<span class="apidocCodeCommentSpan">    /*
     * this function will emulate in node, browser&apos;s Blob class
     * https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob
     */
</span>    this.buf = local.bufferConcat(list.map(function (elem) {
        if (
            typeof elem === &quot;string&quot;
            || Object.prototype.toString.call(elem) === &quot;[object Uint8Array]&quot;
        ) {
            return elem;
        }
        // emulate in node, browser-behavior - auto-stringify arbitrary data
        return String(elem);
    }));
    this.type = (opt &amp;&amp; opt.type) || &quot;&quot;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// run shared js-env code - function
(function () {
local.testCase_FormData_default = function (opt, onError) {
/*
* this function will test FormData&apos;s default handling-behavior
*/
   opt = {};
   opt.blob1 = new local.<span class="apidocCodeKeywordSpan">Blob</span>([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ]);
   opt.blob2 = new local.Blob([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ], {
       type: &quot;text/plain; charset=utf-8&quot;
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.FormData" id="apidoc.elem.utility2.FormData">
        function <span class="apidocSignatureSpan">utility2.</span>FormData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FormData = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a serverLocal-compatible FormData instance
 * The FormData(form) constructor must run these steps:
 * 1. Let fd be a new FormData object.
 * 2. If form is given, set fd&apos;s entries to the result
 *    of constructing the form data set for form. (not implemented)
 * 3. Return fd.
 * https://xhr.spec.whatwg.org/#dom-formdata
 */
</span>    this.entryList = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
})[0];
// init default
local.objectSetDefault(opt, {
    inForm: (
        that._consumes0 === &quot;multipart/form-data&quot;
        ? new local.<span class="apidocCodeKeywordSpan">FormData</span>()
        : &quot;&quot;
    ),
    inHeader: {},
    inPath: that._path.replace((
        /#.*?$/
    ), &quot;&quot;),
    inQuery: &quot;&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module" id="apidoc.elem.utility2.Module">
        function <span class="apidocSignatureSpan">utility2.</span>Module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init example.js
tmp = process.cwd() + &quot;/example.js&quot;;
// jslint code
local.jslintAndPrint(code, tmp);
// cover code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.<span class="apidocCodeKeywordSpan">Module</span>(tmp);
require.cache[tmp] = module;
// load code into module
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildApidoc_default" id="apidoc.elem.utility2._testCase_buildApidoc_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApidoc_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApidoc_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApidoc&apos;s default handling-behavior
 */
</span>    let require2;
    require2 = function (file) {
    /*
     * this function will require &lt;file&gt; in sandbox-env
     */
        let exports;
        let mockDict;
        let mockList;
        mockList = [
            [
                globalThis, {
                    setImmediate: local.nop,
                    setInterval: local.nop,
                    setTimeout: local.nop
                }
            ]
        ];
        [
            [
                local, &quot;child_process&quot;
            ], [
                local, &quot;cluster&quot;
            ], [
                local, &quot;http&quot;
            ], [
                local, &quot;https&quot;
            ], [
                local, &quot;net&quot;
            ], [
                local, &quot;repl&quot;
            ], [
                local.events, &quot;prototype&quot;
            ], [
                globalThis, &quot;process&quot;
            ], [
                local.stream, &quot;prototype&quot;
            ], [
                process, &quot;stdin&quot;
            ]
        ].forEach(function (elem, tmp) {
            tmp = elem[0][elem[1]];
            mockDict = {};
            Object.keys(tmp).forEach(function (key) {
                if (typeof tmp[key] === &quot;function&quot; &amp;&amp; !(
                    /^(?:fs\.Read|fs\.read|process\.binding|process\.dlopen)/
                ).test(elem[1] + &quot;.&quot; + key)) {
                    mockDict[key] = function () {
                        return;
                    };
                }
            });
            mockList.push([
                tmp, mockDict
            ]);
        });
        local.testMock(mockList, function (onError) {
            local.tryCatchOnError(function () {
                exports = require(file);
            }, local.onErrorDefault);
            onError();
        }, local.onErrorThrow);
        return exports;
    };
    if (
        local.isBrowser
        || local.env.npm_config_mode_coverage
        || local.env.npm_config_mode_test_case
        !== &quot;testCase_buildApidoc_default&quot;
    ) {
        onError(undefined, opt);
        return;
    }
    // save apidoc.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/apidoc.html&quot;,
        local.apidocCreate(local.objectAssignDefault(opt, {
            blacklistDict: local,
            require: require2
        }))
    );
    console.error(
        &quot;created apidoc file &quot; + process.cwd() + &quot;/tmp/build/apidoc.html\n&quot;
    );
    onError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_buildApidoc_default = function (opt, onError) {
/*
* this function will test buildApidoc&apos;s default handling-behavior
*/
   local.<span class="apidocCodeKeywordSpan">_testCase_buildApidoc_default</span>({
       blacklistDict: {}
   }, onError, opt);
};

local.testCase_buildApp_default = function (opt, onError) {
/*
* this function will test buildApp&apos;s default handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildApp_default" id="apidoc.elem.utility2._testCase_buildApp_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApp_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApp_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApp&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
    local.buildApp(opt, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            testCase_buildReadme_default: local.nop,
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default(null, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildApp_default</span>(null, local.nop);
    local._testCase_buildLib_default(null, local.nop);
    local._testCase_buildReadme_default(null, local.nop);
    local._testCase_buildTest_default(null, local.nop);
    local._testCase_webpage_default(null, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default(null, local.nop);
    onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildLib_default" id="apidoc.elem.utility2._testCase_buildLib_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildLib_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildLib_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildLib&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildLib({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default(null, local.nop);
    local._testCase_buildApp_default(null, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildLib_default</span>(null, local.nop);
    local._testCase_buildReadme_default(null, local.nop);
    local._testCase_buildTest_default(null, local.nop);
    local._testCase_webpage_default(null, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default(null, local.nop);
    onError(undefined, opt);
}, onError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildReadme_default" id="apidoc.elem.utility2._testCase_buildReadme_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildReadme_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildReadme_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildReadme&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildReadme({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                testCase_buildTest_default: local.nop
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildReadme_default</span>(null, local.nop);
        local._testCase_buildTest_default(null, local.nop);
        local._testCase_webpage_default(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildTest_default" id="apidoc.elem.utility2._testCase_buildTest_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildTest_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildTest_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildTest&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildTest({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local._testCase_buildReadme_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildTest_default</span>(null, local.nop);
        local._testCase_webpage_default(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_webpage_default" id="apidoc.elem.utility2._testCase_webpage_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_webpage_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_webpage_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test webpage&apos;s default handling-behavior
 */
</span>    local.domStyleValidate();
    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    local.browserTest({
        fileScreenshot: (
            local.env.npm_config_dir_build
            + &quot;/screenshot.&quot; + local.env.MODE_BUILD + &quot;.browser.%2F.png&quot;
        ),
        url: (
            local.assetsDict[&quot;/&quot;].indexOf(
                &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;
            ) &gt;= 0
            ? local.serverLocalHost
            + &quot;?modeTest=1&amp;timeoutDefault=&quot; + local.timeoutDefault
            : local.serverLocalHost
            + &quot;/assets.utility2.base.html?modeTest=1&amp;timeoutDefault=1&quot;
        ) + &quot;&amp;modeTestCase=&quot; + local.modeTestCase.replace((
            /_?testCase_webpage_default/
        ), &quot;&quot;)
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local._testCase_buildReadme_default(null, local.nop);
        local._testCase_buildTest_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_webpage_default</span>(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};

local.testCase_childProcessSpawnWithTimeout_default = function (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.ajax" id="apidoc.elem.utility2.ajax">
        function <span class="apidocSignatureSpan">utility2.</span>ajax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send an ajax-req
 * with given &lt;opt&gt;.url and callback &lt;onError&gt;
 * with err and timeout handling
 * example usage:
    local.ajax({
        data: &quot;hello world&quot;,
        header: {&quot;x-header-hello&quot;: &quot;world&quot;},
        method: &quot;POST&quot;,
        url: &quot;/index.html&quot;
    }, function (err, xhr) {
        console.log(xhr.statusCode);
        console.log(xhr.responseText);
    });
 */
</span>    let ajaxProgressUpdate;
    let bufferValidateAndCoerce;
    let isDone;
    let local2;
    let onError2;
    let onEvent;
    let stack;
    let streamCleanup;
    let timeout;
    let tmp;
    let xhr;
    let xhrInit;
    // init local2
    local2 = opt.local2 || local.utility2 || {};
    // init function
    ajaxProgressUpdate = local2.ajaxProgressUpdate || function () {
        return;
    };
    bufferValidateAndCoerce = local2.bufferValidateAndCoerce || function (
        buf,
        mode
    ) {
    /*
     * this function will validate and coerce/convert
     * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
     */
        // coerce ArrayBuffer to Buffer
        if (Object.prototype.toString.call(buf) === &quot;[object ArrayBuffer]&quot;) {
            buf = new Uint8Array(buf);
        }
        // convert Buffer to utf8
        if (mode === &quot;string&quot; &amp;&amp; typeof buf !== &quot;string&quot;) {
            buf = String(buf);
        }
        return buf;
    };
    onEvent = function (evt) {
    /*
     * this function will handle events
     */
        if (Object.prototype.toString.call(evt) === &quot;[object Error]&quot;) {
            xhr.err = xhr.err || evt;
            xhr.onEvent({
                type: &quot;error&quot;
            });
            return;
        }
        // init statusCode
        xhr.statusCode = (xhr.statusCode || xhr.status) | 0;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
        case &quot;load&quot;:
            if (isDone) {
                return;
            }
            isDone = true;
            // decrement counter
            ajaxProgressUpdate.counter = Math.max(
                ajaxProgressUpdate.counter - 1,
                0
            );
            ajaxProgressUpdate();
            // handle abort or err event
            switch (!xhr.err &amp;&amp; evt.type) {
            case &quot;abort&quot;:
            case &quot;error&quot;:
                xhr.err = new Error(&quot;ajax - event &quot; + evt.type);
                break;
            case &quot;load&quot;:
                if (xhr.statusCode &gt;= 400) {
                    xhr.err = new Error(
                        &quot;ajax - statusCode &quot; + xhr.statusCode
                    );
                }
                break;
            }
            // debug statusCode / method / url
            if (xhr.err) {
                xhr.statusCode = xhr.statusCode || 500;
                xhr.err.statusCode = xhr.statusCode;
                tmp = (
                    (
                        local.isBrowser
                        ? &quot;browser&quot;
                        : &quot;node&quot;
                    )
                    + &quot; - &quot; + xhr.statusCode + &quot; &quot; + xhr.method + &quot; &quot; + xhr.url
                    + &quot;\n&quot;
                );
                xhr.err.message = tmp + xhr.err.message;
                xhr.err.stack = tmp + xhr.err.stack;
            }
            // update resHeaders
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
            if (xhr.getAllResponseHeaders) {
                xhr.getAllResponseHeaders().replace((
                    /(.*?):\u0020*(.*?)\r\n/g
                ), function (ignore, key, val) {
                    xhr.resHeaders[key.toLowerCase()] = val;
                });
            }
            // debug ajaxResponse
            xhr.resContentLength =...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/* validateLineSortedReset */
local.ajax = function (opt, onError) {
/*
* this function will send an ajax-req
* with given &lt;opt&gt;.url and callback &lt;onError&gt;
* with err and timeout handling
* example usage:
   local.<span class="apidocCodeKeywordSpan">ajax</span>({
       data: &quot;hello world&quot;,
       header: {&quot;x-header-hello&quot;: &quot;world&quot;},
       method: &quot;POST&quot;,
       url: &quot;/index.html&quot;
   }, function (err, xhr) {
       console.log(xhr.statusCode);
       console.log(xhr.responseText);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.ajaxProgressUpdate" id="apidoc.elem.utility2.ajaxProgressUpdate">
        function <span class="apidocSignatureSpan">utility2.</span>ajaxProgressUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajaxProgressUpdate = function () {
    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ) {
        return;
    }
    // test-run
    globalThis.utility2_modeTest += 1;
}
// visual notification - testRun
local.<span class="apidocCodeKeywordSpan">ajaxProgressUpdate</span>();
// mock console.error
consoleError = console.error;
isCoverage = (
    typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
    &amp;&amp; Object.keys(globalThis.__coverage__).length
);
console.error = function (...argList) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidocCreate" id="apidoc.elem.utility2.apidocCreate">
        function <span class="apidocSignatureSpan">utility2.</span>apidocCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create the apidoc from &lt;opt&gt;.dir
 */
</span>    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given &lt;module&gt;
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(&quot;.&quot;);
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(&quot;.&quot;);
        elem.id = encodeURIComponent(&quot;apidoc.elem.&quot; + prefix + &quot;.&quot; + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + &quot; &lt;span class=\&quot;apidocSignatureSpan\&quot;&gt;&quot;
            + elem.moduleName + &quot;.&lt;/span&gt;&quot; + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
        if (elem.typeof !== &quot;function&quot;) {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || &quot;n/a&quot;
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), &quot;&quot;).replace((
                /,/g
            ), &quot;, &quot;).replace((
                /\s+/g
            ), &quot; &quot;);
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), &quot;&lt;span class=\&quot;apidocCodeCommentSpan\&quot;&gt;$1&lt;/span&gt;&quot;).replace((
            /^function\u0020\(/
        ), key + &quot; = function (&quot;);
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp(&quot;((?:\n.*?){8}\\.)(&quot; + key + &quot;)(\\((?:.*?\n){8})&quot;),
                function (ignore, match1, match2, match3) {
                    elem.example = &quot;...&quot; + trimStart(
                        local.stringHtmlSafe(match1)
                        + &quot;&lt;span class=\&quot;apidocCodeKeywordSpan\&quot;&gt;&quot;
                        + local.stringHtmlSafe(match2)
                        + &quot;&lt;/span&gt;&quot;
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + &quot;\n...&quot;;
                    return &quot;&quot;;
                }
            );
            return elem.example;
        });
        elem.example = elem.example || &quot;n/a&quot;;
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = local.path.resolve(opt.dir, file);
            console.error(&quot;apidocCreate - readExample &quot; + file);
            result = &quot;&quot;;
            result = local.identity(
                &quot;\n\n\n\n\n\n\n\n&quot;
                // bug-workaround - truncate example to manageable size
                + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
                + &quot;\n\n\n\n\n\n\n\n&quot;
            ).replace((
                /\r\n*/g
            ), &quot;\n&quot;);
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = &quot;&quot;;
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (text) {
    /...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.write(local.<span class="apidocCodeKeywordSpan">apidocCreate</span>({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assert" id="apidoc.elem.utility2.assert">
        function <span class="apidocSignatureSpan">utility2.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertJsonEqual" id="apidoc.elem.utility2.assertJsonEqual">
        function <span class="apidocSignatureSpan">utility2.</span>assertJsonEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) === JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa === bb, message || [
        aa, bb
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // test http GET handling-behavior
    local.ajax({
        url: &quot;assets.hello.txt&quot;
    }, opt.gotoNext);
    break;
case 2:
    // validate responseText
    local.<span class="apidocCodeKeywordSpan">assertJsonEqual</span>(data.responseText, local.stringHelloEmoji);
    // test http GET 304 cache handling-behavior
    local.ajax({
        headers: {
            &quot;If-Modified-Since&quot;: (
                new Date(Date.now() + 0xffff).toUTCString()
            )
        },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertJsonNotEqual" id="apidoc.elem.utility2.assertJsonNotEqual">
        function <span class="apidocSignatureSpan">utility2.</span>assertJsonNotEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonNotEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) !== JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa !== bb, [
        aa
    ], message || aa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &quot;&quot;, 0, false, null, undefined
        ].forEach(function (bb, jj) {
            if (ii === jj) {
                // test assertJsonEqual&apos;s handling-behavior
                local.assertJsonEqual(aa, bb);
            } else {
                // test assertJsonNotEqual&apos;s handling-behavior
                local.<span class="apidocCodeKeywordSpan">assertJsonNotEqual</span>(aa, bb);
            }
        });
    });
    onError(undefined, opt);
};

local.testCase_base64Xxx_default = function (opt, onError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertOrThrow" id="apidoc.elem.utility2.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64FromBuffer" id="apidoc.elem.utility2.base64FromBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>base64FromBuffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64FromBuffer = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to base64
 * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/StringView#The_code
 */
</span>    let ii;
    let mod3;
    let text;
    let uint24;
    let uint6ToB64;
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    }
    buf = buf || [];
    text = &quot;&quot;;
    uint24 = 0;
    uint6ToB64 = function (uint6) {
        return (
            uint6 &lt; 26
            ? uint6 + 65
            : uint6 &lt; 52
            ? uint6 + 71
            : uint6 &lt; 62
            ? uint6 - 4
            : uint6 === 62
            ? 43
            : 47
        );
    };
    ii = 0;
    while (ii &lt; buf.length) {
        mod3 = ii % 3;
        uint24 |= buf[ii] &lt;&lt; (16 &gt;&gt;&gt; mod3 &amp; 24);
        if (mod3 === 2 || buf.length - ii === 1) {
            text += String.fromCharCode(
                uint6ToB64(uint24 &gt;&gt;&gt; 18 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 12 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 6 &amp; 63),
                uint6ToB64(uint24 &amp; 63)
            );
            uint24 = 0;
        }
        ii += 1;
    }
    return text.replace((
        /A(?=A$|$)/gm
    ), &quot;=&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? &quot;abcd1234&quot;
    : Number(
        (1 + Math.random()) * 0x10000000000000
    ).toString(36).slice(1)
);
switch (schemaP.format) {
case &quot;byte&quot;:
    value = local.<span class="apidocCodeKeywordSpan">base64FromBuffer</span>(value);
    break;
case &quot;date&quot;:
case &quot;date-time&quot;:
    value = new Date().toISOString();
    break;
case &quot;email&quot;:
    value = value + &quot;@example.com&quot;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64ToBuffer" id="apidoc.elem.utility2.base64ToBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>base64ToBuffer
        <span class="apidocSignatureSpan">(b64, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToBuffer = function (b64, mode) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert &lt;b64&gt; to Uint8Array
 * https://gist.github.com/wang-bin/7332335
 */
</span>    let buf;
    let byte;
    let chr;
    let ii;
    let jj;
    let map64;
    let mod4;
    b64 = b64 || &quot;&quot;;
    buf = new Uint8Array(b64.length); // 3/4
    byte = 0;
    jj = 0;
    map64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
    mod4 = 0;
    ii = 0;
    while (ii &lt; b64.length) {
        chr = map64.indexOf(b64[ii]);
        if (chr &gt;= 0) {
            mod4 %= 4;
            if (mod4 === 0) {
                byte = chr;
            } else {
                byte = byte * 64 + chr;
                buf[jj] = 255 &amp; (byte &gt;&gt; ((-2 * (mod4 + 1)) &amp; 6));
                jj += 1;
            }
            mod4 += 1;
        }
        ii += 1;
    }
    // optimization - create resized-view of buf
    buf = buf.subarray(0, jj);
    return local.bufferValidateAndCoerce(buf, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!data) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    local.serverRespondHeadSet(req, res, null, {
        &quot;Content-Type&quot;: data.fileContentType
    });
    res.end(local.<span class="apidocCodeKeywordSpan">base64ToBuffer</span>(data.fileBlob));
    break;
case &quot;userLogout&quot;:
    opt.gotoNext();
    break;
default:
    opt.gotoNext(null, data, meta);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64ToUtf8" id="apidoc.elem.utility2.base64ToUtf8">
        function <span class="apidocSignatureSpan">utility2.</span>base64ToUtf8
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToUtf8 = function (b64) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert &lt;b64&gt; to utf8
 */
</span>    return local.base64ToBuffer(b64, &quot;string&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // validate signature
        local.assertOrThrow(local.sjcl.codec.base64url.fromBits(
            new Hmac(local.sjcl.codec.base64url.toBits(
                local.jwtAes256KeyInit(key)
            )).encrypt(token[0] + &quot;.&quot; + token[1])
        ) === token[2]);
        // return decoded data
        token = JSON.parse(local.<span class="apidocCodeKeywordSpan">base64ToUtf8</span>(token[1]));
        // https://tools.ietf.org/html/rfc7519#section-4.1
        // validate jwt-registered-headers
        local.assertOrThrow(!token.exp || token.exp &gt;= timeNow);
        local.assertOrThrow(!token.nbf || token.nbf &lt;= timeNow);
        return token;
    }, local.nop) || {};
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.blobRead" id="apidoc.elem.utility2.blobRead">
        function <span class="apidocSignatureSpan">utility2.</span>blobRead
        <span class="apidocSignatureSpan">(blob, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobRead = function (blob, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will read from &lt;blob&gt;
 */
</span>    let isDone;
    let reader;
    if (blob &amp;&amp; blob.constructor &amp;&amp; blob.constructor === local.FormData) {
        blob.read(onError);
        return;
    }
    if (!local.isBrowser) {
        onError(undefined, local.bufferValidateAndCoerce(blob.buf));
        return;
    }
    reader = new FileReader();
    reader.onabort = function (evt) {
        if (isDone) {
            return;
        }
        isDone = true;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
            onError(new Error(&quot;blobRead - &quot; + evt.type));
            break;
        case &quot;load&quot;:
            onError(
                undefined,
                Object.prototype.toString.call(reader.result)
                === &quot;[object ArrayBuffer]&quot;
                // convert ArrayBuffer to Uint8Array
                ? new Uint8Array(reader.result)
                : reader.result
            );
            break;
        }
    };
    reader.onerror = reader.onabort;
    reader.onload = reader.onabort;
    reader.readAsArrayBuffer(blob);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
switch ((xhr.data &amp;&amp; xhr.data.constructor) || true) {
// Blob
// https://developer.mozilla.org/en-US/docs/Web/API/Blob
case local2.Blob:
// FormData
// https://developer.mozilla.org/en-US/docs/Web/API/FormData
case local2.FormData:
    local2.<span class="apidocCodeKeywordSpan">blobRead</span>(xhr.data, function (err, data) {
        if (err) {
            xhr.onEvent(err);
            return;
        }
        // send data
        xhr.send(data);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.browserTest" id="apidoc.elem.utility2.browserTest">
        function <span class="apidocSignatureSpan">utility2.</span>browserTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">browserTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will spawn google-puppeteer-process to test &lt;opt&gt;.url
 */
</span>    let browser;
    let fileScreenshot;
    let isDone;
    let onParallel;
    let page;
    let testId;
    let testName;
    let timerTimeout;
    // init utility2_testReport
    globalThis.utility2_testReport = globalThis.utility2_testReport || {
        coverage: globalThis.__coverage__,
        testPlatformList: [
            {
                name: (
                    local.isBrowser
                    ? (
                        &quot;browser - &quot;
                        + location.pathname + &quot; - &quot; + navigator.userAgent
                    )
                    : &quot;node - &quot; + process.platform + &quot; &quot; + process.version
                ) + &quot; - &quot; + new Date().toISOString(),
                testCaseList: []
            }
        ]
    };
    if (opt.modeTestReportCreate) {
        return;
    }
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        // node - init
        case 1:
            onParallel = local.onParallel(opt.gotoNext);
            onParallel.counter += 1;
            isDone = 0;
            testId = Math.random().toString(16);
            testName = new local.url.URL(opt.url).pathname;
            testName = (
                local.env.MODE_BUILD + &quot;.browser.&quot;
                + encodeURIComponent(testName.replace(
                    &quot;/build..&quot;
                    + local.env.CI_BRANCH
                    + &quot;..&quot; + local.env.CI_HOST,
                    &quot;/build&quot;
                ))
            );
            fileScreenshot = (
                local.env.npm_config_dir_build + &quot;/screenshot.&quot;
                + testName
                + &quot;.png&quot;
            );
            opt.url = opt.url.replace(
                &quot;{{timeExit}}&quot;,
                Date.now() + local.timeoutDefault
            );
            // init timerTimeout
            timerTimeout = local.onTimeout(
                opt.gotoNext,
                local.timeoutDefault,
                testName
            );
            // create puppeteer browser
            local.puppeteerLaunch({
                args: [
                    &quot;--headless&quot;,
                    &quot;--incognito&quot;,
                    &quot;--no-sandbox&quot;,
                    &quot;--remote-debugging-port=0&quot;
                ],
                dumpio: !opt.modeSilent,
                executablePath: local.env.CHROME_BIN,
                ignoreDefaultArgs: true
            }).then(opt.gotoNextData);
            break;
        case 2:
            browser = data;
            browser.newPage().then(opt.gotoNextData);
            break;
        case 3:
            page = data;
            page.goto(opt.url).then(opt.gotoNextData);
            break;
        case 4:
            onParallel.counter += 1;
            setTimeout(function () {
                page.screenshot({
                    path: fileScreenshot
                }).then(function () {
                    console.error(
                        &quot;\nbrowserTest - created screenshot file &quot;
                        + fileScreenshot
                        + &quot;\n&quot;
                    );
                    onParallel();
                });
            }, 100);
            page.evaluate(function (testId) {
                window.utility2_testId = testId;
            }, testId);
            page.on(&quot;metrics&quot;, function (metric) {
                if (isDone &gt;= 1 || metric.title !== testId) {
                    return;
                }
                isDone = 1;
                opt.gotoNext();
            });
            break;
        case 5:
            page.evaluate(function () {
                return JSON.stringify(window.utility2_testReport);
            }).then(opt.gotoNextData);
            break;
        case 6:
            data = JSON.parse(data);...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict = {};

local.cliDict[&quot;utility2.browserTest&quot;] = function () {
/*
* &lt;urlList&gt; &lt;mode&gt;
* will browser-test in parallel, comma-separated &lt;urlList&gt; with given &lt;mode&gt;
*/
   local.<span class="apidocCodeKeywordSpan">browserTest</span>({
       url: process.argv[3]
   }, local.onErrorDefault);
};

local.cliDict[&quot;utility2.githubCrudContentDelete&quot;] = function () {
/*
* &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferConcat" id="apidoc.elem.utility2.bufferConcat">
        function <span class="apidocSignatureSpan">utility2.</span>bufferConcat
        <span class="apidocSignatureSpan">(bufList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferConcat = function (bufList) {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s Buffer.concat
 */
</span>    let byteLength;
    let ii;
    let isString;
    let jj;
    let result;
    isString = true;
    result = [
        &quot;&quot;
    ];
    byteLength = 0;
    bufList.forEach(function (buf) {
        if (buf !== 0 &amp;&amp; !(buf &amp;&amp; buf.length)) {
            return;
        }
        // optimization - concat string
        if (isString &amp;&amp; typeof buf === &quot;string&quot;) {
            result[0] += buf;
            return;
        }
        isString = null;
        buf = local.bufferValidateAndCoerce(buf);
        byteLength += buf.byteLength;
        result.push(buf);
    });
    // optimization - return string
    if (isString) {
        return result[0];
    }
    result[0] = local.bufferValidateAndCoerce(result[0]);
    byteLength += result[0].byteLength;
    bufList = result;
    result = local.bufferValidateAndCoerce(new Uint8Array(byteLength));
    ii = 0;
    bufList.forEach(function (buf) {
        jj = 0;
        while (jj &lt; buf.byteLength) {
            result[ii] = buf[jj];
            ii += 1;
            jj += 1;
        }
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
// init boundary
ii = 0;
jj = local.bufferIndexOfSubBuffer(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.<span class="apidocCodeKeywordSpan">bufferConcat</span>([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
while (true) {
    jj = local.bufferIndexOfSubBuffer(
        req.bodyRaw,
        boundary,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferIndexOfSubBuffer" id="apidoc.elem.utility2.bufferIndexOfSubBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>bufferIndexOfSubBuffer
        <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferIndexOfSubBuffer = function (buf, subBff, fromIndex) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;buf&gt; from &lt;fromIndex&gt; for position of &lt;subBff&gt;
 */
</span>    let ii;
    let jj;
    let kk;
    if (!subBff.length) {
        return 0;
    }
    ii = fromIndex || 0;
    while (ii &lt; buf.length) {
        kk = ii;
        jj = 0;
        while (jj &lt; subBff.length) {
            if (subBff[jj] !== buf[kk]) {
                break;
            }
            kk += 1;
            jj += 1;
        }
        if (jj === subBff.length) {
            return kk - jj;
        }
        ii += 1;
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
req.swgg.bodyParsed = {};
req.swgg.bodyMeta = {};
crlf = new Uint8Array([
    0x0d, 0x0a
]);
// init boundary
ii = 0;
jj = local.<span class="apidocCodeKeywordSpan">bufferIndexOfSubBuffer</span>(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.bufferConcat([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferRandomBytes" id="apidoc.elem.utility2.bufferRandomBytes">
        function <span class="apidocSignatureSpan">utility2.</span>bufferRandomBytes
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferRandomBytes = function (length) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a Buffer with given &lt;length&gt;,
 * filled with cryptographically-strong random-values
 */
</span>    return (
        (
            typeof window === &quot;object&quot;
            &amp;&amp; window.crypto
            &amp;&amp; typeof window.crypto.getRandomValues === &quot;function&quot;
        )
        ? window.crypto.getRandomValues(new Uint8Array(length))
        : require(&quot;crypto&quot;).randomBytes(length)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.jwtAes256KeyCreate = function () {
/*
* this function will create a random, aes-256-base64url-jwt-key
*/
   return local.normalizeJwtBase64Url(
       local.base64FromBuffer(local.<span class="apidocCodeKeywordSpan">bufferRandomBytes</span>(32))
   );
};

local.jwtAes256KeyInit = function (key) {
/*
* this function will init aes-256-base64url-jwt-&lt;key&gt;
* https://jwt.io/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferToUtf8" id="apidoc.elem.utility2.bufferToUtf8">
        function <span class="apidocSignatureSpan">utility2.</span>bufferToUtf8
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferToUtf8 = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to utf8
 */
</span>    return local.bufferValidateAndCoerce(buf, &quot;string&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let name;
// if req is already parsed, then goto next
if (!req.swgg.operation || !local.isNullOrUndefined(req.swgg.bodyParsed)) {
    next();
    return;
}
headerParse = function () {
    local.<span class="apidocCodeKeywordSpan">bufferToUtf8</span>(req.bodyRaw.slice(ii, ii + 1024)).replace((
        /^content-disposition:\u0020?form-data;(.+?)\r\n(?:content-type:\u0020?(.*?)$)?/im
    ), function (ignore, match1, match2) {
        data = {
            contentType: match2,
            name: &quot;&quot;
        };
        match1.replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferValidateAndCoerce" id="apidoc.elem.utility2.bufferValidateAndCoerce">
        function <span class="apidocSignatureSpan">utility2.</span>bufferValidateAndCoerce
        <span class="apidocSignatureSpan">(buf, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferValidateAndCoerce = function (buf, mode) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate and coerce/convert
 * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
 */
</span>    // validate not 0
    if (buf !== 0) {
        buf = buf || &quot;&quot;;
    }
    if (typeof buf === &quot;string&quot; &amp;&amp; mode === &quot;string&quot;) {
        return buf;
    }
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    // validate instanceof Uint8Array
    } else if (Object.prototype.toString.call(buf) !== &quot;[object Uint8Array]&quot;) {
        throw new Error(
            &quot;bufferValidateAndCoerce - value is not instanceof &quot;
            + &quot;ArrayBuffer, String, or Uint8Array&quot;
        );
    }
    // convert Uint8Array to utf8
    if (mode === &quot;string&quot;) {
        return new TextDecoder().decode(buf);
    }
    // coerce Uint8Array to Buffer
    if (globalThis.Buffer &amp;&amp; Buffer.isBuffer &amp;&amp; !Buffer.isBuffer(buf)) {
        Object.setPrototypeOf(buf, Buffer.prototype);
    }
    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           }
           mod4 += 1;
       }
       ii += 1;
   }
   // optimization - create resized-view of buf
   buf = buf.subarray(0, jj);
   return local.<span class="apidocCodeKeywordSpan">bufferValidateAndCoerce</span>(buf, mode);
};

local.base64ToUtf8 = function (b64) {
/*
* this function will convert &lt;b64&gt; to utf8
*/
   return local.base64ToBuffer(b64, &quot;string&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildApp" id="apidoc.elem.utility2.buildApp">
        function <span class="apidocSignatureSpan">utility2.</span>buildApp
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildApp = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build app with given &lt;opt&gt;
 */
</span>    opt = local.objectSetDefault(opt, {
        assetsList: []
    });
    // build assets
    local.fsRmrfSync(&quot;tmp/build/app&quot;);
    local.onParallelList({
        list: [
            {
                file: &quot;/LICENSE&quot;,
                url: &quot;/LICENSE&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
                url: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;
            }, {
                file: &quot;/assets.app.js&quot;,
                url: &quot;/assets.app.js&quot;
            }, {
                file: &quot;/assets.example.html&quot;,
                url: &quot;/assets.example.html&quot;
            }, {
                file: &quot;/assets.example.js&quot;,
                url: &quot;/assets.example.js&quot;
            }, {
                file: &quot;/assets.swgg.html&quot;,
                url: &quot;/assets.swgg.html&quot;
            }, {
                file: &quot;/assets.swgg.swagger.json&quot;,
                url: &quot;/assets.swgg.swagger.json&quot;
            }, {
                file: &quot;/assets.swgg.swagger.petstore.json&quot;,
                url: &quot;/assets.swgg.swagger.petstore.json&quot;
            }, {
                file: &quot;/assets.swgg.swagger.server.json&quot;,
                url: &quot;/assets.swgg.swagger.server.json&quot;
            }, {
                file: &quot;/assets.test.js&quot;,
                url: &quot;/assets.test.js&quot;
            }, {
                file: &quot;/assets.utility2.html&quot;,
                url: &quot;/assets.utility2.html&quot;
            }, {
                file: &quot;/assets.utility2.base.html&quot;,
                url: &quot;/assets.utility2.base.html&quot;
            }, {
                file: &quot;/assets.utility2.rollup.js&quot;,
                url: &quot;/assets.utility2.rollup.js&quot;
            }, {
                file: &quot;/index.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/index.rollup.html&quot;,
                url: &quot;/index.rollup.html&quot;
            }, {
                file: &quot;/jsonp.utility2.stateInit&quot;,
                url: (
                    &quot;/jsonp.utility2.stateInit&quot;
                    + &quot;?callback=window.utility2.stateInit&quot;
                )
            }
        ].concat(opt.assetsList)
    }, function (option2, onParallel) {
        option2 = option2.elem;
        onParallel.counter += 1;
        local.ajax(option2, function (err, xhr) {
            // handle err
            local.assertOrThrow(!err, err);
            // jslint file
            local.jslintAndPrint(xhr.responseText, option2.file, {
                conditional: true,
                coverage: local.env.npm_config_mode_coverage
            });
            // handle err
            local.assertOrThrow(
                !local.jslint.jslintResult.errMsg,
                local.jslint.jslintResult.errMsg
            );
            local.fsWriteFileWithMkdirpSync(
                &quot;tmp/build/app&quot; + option2.file,
                xhr.response
            );
            onParallel();
        });
    }, function (err) {
        // handle err
        local.assertOrThrow(!err, err);
        // test standalone assets.app.js
        local.fsWriteFileWithMkdirpSync(
            &quot;tmp/buildApp/assets.app.js&quot;,
            local.assetsDict[&quot;/assets.app.js&quot;]
        );
        local.childProcessSpawnWithTimeout(&quot;node&quot;, [
            &quot;assets.app.js&quot;
        ], {
            cwd: &quot;tmp/buildApp&quot;,
            env: {
                PATH: local.env.PATH,
                PORT: (Math.random()...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
   local.<span class="apidocCodeKeywordSpan">buildApp</span>(opt, onError);
};

local._testCase_buildLib_default = function (opt, onError) {
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildLib" id="apidoc.elem.utility2.buildLib">
        function <span class="apidocSignatureSpan">utility2.</span>buildLib
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildLib = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build lib with given &lt;opt&gt;
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        dataFrom: local.fsReadFileOrEmptyStringSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            &quot;utf8&quot;
        ),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.my_app.template.js&quot;],
            opt
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize top-level comment-description
        (
            /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
        ),
        // customize body after /* validateLineSortedReset */
        (
            /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize local for assets.utility2.rollup.js
    if (
        local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
        &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
    ) {
        opt.dataTo = opt.dataTo.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // save lib
    result = opt.dataTo;
    if (!local.env.npm_config_mode_coverage) {
        local.fs.writeFileSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            result
        );
    }
    opt.customize(opt);
    onError();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildLib</span>({}, onError);
};

local._testCase_buildReadme_default = function (opt, onError) {
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildReadme" id="apidoc.elem.utility2.buildReadme">
        function <span class="apidocSignatureSpan">utility2.</span>buildReadme
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildReadme = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build readme with given &lt;opt&gt; my-app-lite template
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        // reset toc
        dataFrom: local.fsReadFileOrEmptyStringSync(
            &quot;README.md&quot;,
            &quot;utf8&quot;
        ).replace((
            /\n#\u0020table\u0020of\u0020contents$[\S\s]*?\n\n\n\n/m
        ), &quot;\n# table of contents\n\n\n\n&quot;),
        packageJsonRgx: (
            /\n#\u0020package.json\n```json\n([\S\s]*?)\n```\n/
        )
    });
    // render dataTo
    opt.dataTo = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.readme.template.md&quot;],
        opt
    );
    // init package.json
    opt.dataFrom.replace(opt.packageJsonRgx, function (match0, match1) {
        // remove null from package.json
        opt.packageJson = JSON.parse(match1.replace((
            /\u0020{4}&quot;.*?&quot;:\u0020null,?$/gm
        ), &quot;&quot;));
        opt.packageJson.description = opt.dataFrom.split(&quot;\n&quot;)[1];
        local.tryCatchOnError(function () {
            local.objectSetDefault(opt.packageJson, {
                nameLib: local.fsReadFileOrEmptyStringSync(
                    &quot;./package.json&quot;,
                    &quot;json&quot;
                ).nameLib
            });
        }, local.nop);
        opt.packageJson = local.objectSetDefault(opt.packageJson, {
            nameLib: opt.packageJson.name.replace((
                /\W/g
            ), &quot;_&quot;),
            nameOriginal: opt.packageJson.name
        });
        opt.packageJson = local.objectSetDefault(
            opt.packageJson,
            JSON.parse(local.templateRenderMyApp(opt.packageJsonRgx.exec(
                local.assetsDict[&quot;/assets.readme.template.md&quot;]
            )[1], opt)),
            2
        );
        // avoid npm-installing that
        delete opt.packageJson.devDependencies[opt.packageJson.name];
        // reset scripts
        opt.packageJson.scripts = {
            &quot;build-ci&quot;: &quot;./npm_scripts.sh&quot;,
            env: &quot;env&quot;,
            eval: &quot;./npm_scripts.sh&quot;,
            &quot;heroku-postbuild&quot;: &quot;./npm_scripts.sh&quot;,
            postinstall: &quot;./npm_scripts.sh&quot;,
            start: &quot;./npm_scripts.sh&quot;,
            test: &quot;./npm_scripts.sh&quot;,
            utility2: &quot;./npm_scripts.sh&quot;
        };
        // save package.json
        local.fs.writeFileSync(
            &quot;package.json&quot;,
            local.jsonStringifyOrdered(opt.packageJson, undefined, 4) + &quot;\n&quot;
        );
        // re-render dataTo
        opt.dataTo = local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.readme.template.md&quot;],
            opt
        );
        opt.dataTo = opt.dataTo.replace(
            opt.packageJsonRgx,
            match0.replace(
                match1,
                local.jsonStringifyOrdered(opt.packageJson, undefined, 4)
            )
        );
    });
    // search-and-replace - customize dataTo
    [
        // customize name and description
        (
            /.*?\n.*?\n/
        ),
        // customize cdn-download
        (
            /\n#\u0020cdn\u0020download\n[\S\s]*?\n\n\n\n/
        ),
        // customize live-web-demo
        (
            /\n#\u0020live\u0020web\u0020demo\n[\S\s]*?\n\n\n\n/
        ),
        // customize to-do
        (
            /\n####\u0020todo\n[\S\s]*?\n\n\n\n/
        ),
        // customize example.js - shared js-env code - init-before
        (
            /\nglobalThis\.local\u0020=\u0020local;\n[^`]*?\n\/\/\u0020run\u0020browser\u0020js\-env\u0020code\u0020-\u0020init-
test\n/
        ),
        // customize example.js - html-body
        (
            /\n&lt;!--\u0020custom-html-start\u0020--&gt;\\n\\\n[^`]*?\n&lt;!--\u0020custom-html-end\u0020--&gt;\\n\\\n/
        ),
        // customize build_ci - shBuildCiAfter...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildReadme</span>({}, onError);
};

local._testCase_buildTest_default = function (opt, onError) {
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildTest" id="apidoc.elem.utility2.buildTest">
        function <span class="apidocSignatureSpan">utility2.</span>buildTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build test with given &lt;opt&gt;
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        dataFrom: local.fsReadFileOrEmptyStringSync(&quot;test.js&quot;, &quot;utf8&quot;),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.test.template.js&quot;],
            opt
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize shared js\-env code - function
        (
            /\n\}\(\)\);\n\n\n\n\/\/\u0020run\u0020shared\u0020js\-env\u0020code\u0020-\u0020function\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize require(&quot;utility2&quot;)
    [
        &quot;./assets.utility2.rollup.js&quot;,
        &quot;./lib.utility2.js&quot;
    ].forEach(function (file) {
        if (local.fs.existsSync(file)) {
            opt.dataTo = opt.dataTo.replace(
                &quot;require(\&quot;utility2\&quot;)&quot;,
                &quot;require(\&quot;&quot; + file + &quot;\&quot;)&quot;
            );
        }
    });
    opt.customize(opt);
    // save test.js
    result = opt.dataTo;
    local.fs.writeFileSync(&quot;test.js&quot;, result);
    onError();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildTest</span>({}, onError);
};

local._testCase_webpage_default = function (opt, onError) {
/*
* this function will test webpage&apos;s default handling-behavior
*/
   local.domStyleValidate();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.childProcessSpawnWithTimeout" id="apidoc.elem.utility2.childProcessSpawnWithTimeout">
        function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithTimeout
        <span class="apidocSignatureSpan">(command, args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithTimeout = function (command, args, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run like child_process.spawn,
 * but with auto-timeout after timeout milliseconds
 * example usage:
    let child = local.childProcessSpawnWithTimeout(
        &quot;/bin/sh&quot;,
        [&quot;-c&quot;, &quot;echo hello world&quot;],
        {stdio: [&quot;ignore&quot;, 1, 2], timeout: 5000}
    );
    child.on(&quot;error&quot;, console.error);
    child.on(&quot;exit&quot;, function (exitCode) {
        console.error(&quot;exitCode &quot; + exitCode);
    });
 */
</span>    let child;
    let child_process;
    let timerTimeout;
    child_process = require(&quot;child_process&quot;);
    // spawn child
    child = child_process.spawn(command, args, opt).on(&quot;exit&quot;, function () {
        // cleanup timerTimeout
        try {
            process.kill(timerTimeout.pid);
        } catch (ignore) {}
    });
    // init timerTimeout
    timerTimeout = child_process.spawn(
        // convert timeout to integer seconds with 2 second delay
        &quot;sleep &quot;
        + Math.floor(
            0.001 * (Number(opt &amp;&amp; opt.timeout) || local.timeoutDefault)
            + 2
        )
        + &quot;; kill -9 &quot; + child.pid + &quot; 2&gt;/dev/null&quot;,
        {
            shell: true,
            stdio: &quot;ignore&quot;
        }
    );
    return child;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handle err
local.assertOrThrow(!err, err);
// test standalone assets.app.js
local.fsWriteFileWithMkdirpSync(
    &quot;tmp/buildApp/assets.app.js&quot;,
    local.assetsDict[&quot;/assets.app.js&quot;]
);
local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithTimeout</span>(&quot;node&quot;, [
    &quot;assets.app.js&quot;
], {
    cwd: &quot;tmp/buildApp&quot;,
    env: {
        PATH: local.env.PATH,
        PORT: (Math.random() * 0x10000) | 0x8000,
        npm_config_timeout_exit: 5000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.childProcessSpawnWithUtility2" id="apidoc.elem.utility2.childProcessSpawnWithUtility2">
        function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithUtility2
        <span class="apidocSignatureSpan">(script, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithUtility2 = function (script, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run child_process.spawn, with lib.utility2.sh sourced
 */
</span>    require(&quot;child_process&quot;).spawn(
        &quot;. &quot; + (process.env.npm_config_dir_utility2 || __dirname)
        + &quot;/lib.utility2.sh; &quot; + script,
        {
            shell: true,
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        }
    ).on(&quot;exit&quot;, function (exitCode) {
        onError(exitCode &amp;&amp; Object.assign(new Error(), {
            exitCode
        }));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // test __dirname handling-behavior
        [
            process.env, {
                npm_config_dir_utility2: &quot;&quot;
            }
        ]
    ], function (onError) {
        local.local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithUtility2</span>(&quot;undefined&quot;, function (err
) {
            // handle err
            local.assertOrThrow(err, err);
        });
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliRun" id="apidoc.elem.utility2.cliRun">
        function <span class="apidocSignatureSpan">utility2.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.coalesce" id="apidoc.elem.utility2.coalesce">
        function <span class="apidocSignatureSpan">utility2.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.corsBackendHostInject" id="apidoc.elem.utility2.corsBackendHostInject">
        function <span class="apidocSignatureSpan">utility2.</span>corsBackendHostInject
        <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsBackendHostInject = function (url, backendHost, rgx, location) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;location&gt;.host is a github site,
 * inject &lt;backendHost&gt; into &lt;url&gt; with given &lt;rgx&gt;
 */
</span>    location = (
        location
        || (typeof window === &quot;object&quot; &amp;&amp; window &amp;&amp; window.location)
    );
    if (!(backendHost &amp;&amp; location &amp;&amp; (
        /\bgithub.io$/
    ).test(location.host))) {
        return url;
    }
    // init github-branch
    location.pathname.replace((
        /\/build\.\.(alpha|beta|master)\.\.travis-ci\.org\//
    ), function (ignore, match1) {
        backendHost = backendHost.replace(&quot;-alpha.&quot;, &quot;-&quot; + match1 + &quot;.&quot;);
    });
    return url.replace(rgx || (
        /.*?($)/m
    ), backendHost + &quot;$1&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_corsBackendHostInject_default = function (opt, onError) {
/*
* this function will corsBackendHostInject&apos;s default handling-behavior
*/
   // test null-case handling-behavior
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">corsBackendHostInject</span>(), undefined);
   // test override-all handling-behavior
   local.assertJsonEqual(local.corsBackendHostInject(
       &quot;cc.com&quot;,
       &quot;aa-alpha.bb.com&quot;,
       null,
       {
           host: &quot;github.io&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.corsForwardProxyHostIfNeeded" id="apidoc.elem.utility2.corsForwardProxyHostIfNeeded">
        function <span class="apidocSignatureSpan">utility2.</span>corsForwardProxyHostIfNeeded
        <span class="apidocSignatureSpan">(xhr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsForwardProxyHostIfNeeded = function (xhr) {
<span class="apidocCodeCommentSpan">/*
 * this function will return xhr.corsForwardProxyHost, if needed
 */
</span>    return (
        local.isBrowser
        &amp;&amp; local.env.npm_package_nameLib
        &amp;&amp; (
            /^https?:\/\//
        ).test(xhr.url)
        &amp;&amp; xhr.url.indexOf(xhr.location.protocol + &quot;//&quot; + xhr.location.host)
        !== 0
        &amp;&amp; (
            /\.github\.io$/
        ).test(xhr.location.host)
        &amp;&amp; xhr.corsForwardProxyHost !== &quot;disabled&quot;
        &amp;&amp; (xhr.corsForwardProxyHost || &quot;https://h1-proxy1.herokuapp.com&quot;)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.functionOrNop(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.<span class="apidocCodeKeywordSpan">corsForwardProxyHostIfNeeded</span>(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt" id="apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt">
        function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawDecrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
 * example usage:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // base64
    if (opt.mode === &quot;base64&quot;) {
        data = local.base64ToBuffer(data);
    }
    // normalize data
    if (Object.prototype.toString.call(data) !== &quot;[object Uint8Array]&quot;) {
        data = new Uint8Array(data);
    }
    // init iv
    iv = data.subarray(0, 16);
    // optimization - create resized-view of data
    data = data.subarray(16);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            cipher = crypto.createDecipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv
            );
            onError(undefined, Buffer.concat([
                cipher.update(data), cipher.final()
            ]));
        });
        return;
    }
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;decrypt&quot;
    ]).then(function (key) {
        crypto.subtle.decrypt({
            iv,
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            onError(undefined, new Uint8Array(data));
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawDecrypt</span>({
           data,
           key,
           mode
       }, console.log);
   });
*/
   let cipher;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt" id="apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt">
        function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawEncrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawEncrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc encrypt with given &lt;opt&gt;
 * example usage:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // init iv
    iv = new Uint8Array((((data.byteLength) &gt;&gt; 4) &lt;&lt; 4) + 32);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            // init iv
            iv.set(crypto.randomBytes(16));
            cipher = crypto.createCipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv.subarray(0, 16)
            );
            data = cipher.update(data);
            iv.set(data, 16);
            iv.set(cipher.final(), 16 + data.byteLength);
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        });
        return;
    }
    // init iv
    iv.set(crypto.getRandomValues(new Uint8Array(16)));
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;encrypt&quot;
    ]).then(function (key) {
        crypto.subtle.encrypt({
            iv: iv.subarray(0, 16),
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            iv.set(new Uint8Array(data), 16);
            // base64
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
/*
* this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
* example usage:
   data = new Uint8Array([1,2,3]);
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawEncrypt</span>({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateGetWeekOfMonth" id="apidoc.elem.utility2.dateGetWeekOfMonth">
        function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfMonth
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfMonth = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return sunday-based week-of-month from &lt;date&gt;
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    return Math.ceil((date.getUTCDate() + new Date(
        date.getUTCFullYear(),
        date.getUTCMonth(),
        1
    ).getUTCDay()) / 7) - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateGetWeekOfYear" id="apidoc.elem.utility2.dateGetWeekOfYear">
        function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfYear
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfYear = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return ISO week-of-year from &lt;date&gt;
 *
 * Based on information at:
 *
 *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR
 *
 * Algorithm is to find nearest thursday, it&apos;s year
 * is the year of the week number. Then get weeks
 * between that date and the first day of that year.
 *
 * Note that dates in one year can be weeks of previous
 * or next year, overlap is up to 3 days.
 *
 * e.g. 2014/12/29 is Monday in week  1 of 2015
 *      2012/1/1   is Sunday in week 52 of 2011
 *
 * https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    // Set to nearest Thursday: current date + 4 - current day number
    // Make Sunday&apos;s day number 7
    date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
    // Calculate full weeks to nearest Thursday
    return Math.ceil((((
        date
        // Get first day of year
        - new Date(Date.UTC(date.getUTCFullYear(), 0, 1))
    ) / 86400000) + 1) / 7);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateUtcFromLocal" id="apidoc.elem.utility2.dateUtcFromLocal">
        function <span class="apidocSignatureSpan">utility2.</span>dateUtcFromLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcFromLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert local-&lt;date&gt; to utc-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?$/
    ).test(date), &quot;invalid local-date &quot; + date);
    if (!timezoneOffset) {
        return new Date(date).toISOString();
    }
    return new Date(
        new Date(date + &quot;Z&quot;).getTime() + timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateUtcToLocal" id="apidoc.elem.utility2.dateUtcToLocal">
        function <span class="apidocSignatureSpan">utility2.</span>dateUtcToLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcToLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert utc-&lt;date&gt; to local-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?Z$/
    ).test(date), &quot;invalid utc-date &quot; + date);
    timezoneOffset = timezoneOffset || new Date(date).getTimezoneOffset();
    return new Date(
        new Date(date).getTime() - timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domFragmentRender" id="apidoc.elem.utility2.domFragmentRender">
        function <span class="apidocSignatureSpan">utility2.</span>domFragmentRender
        <span class="apidocSignatureSpan">(template, dict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domFragmentRender = function (template, dict) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem rendered from &lt;template&gt;
 */
</span>    let tmp;
    tmp = document.createElement(&quot;template&quot;);
    tmp.innerHTML = local.templateRender(template, dict);
    return tmp.content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
// init uiFragment
swaggerJson.uiFragment = document.createDocumentFragment();
// init resourceDict
Object.keys(swaggerJson.resourceDict).sort().forEach(function (key) {
    // templateRender resource
    swaggerJson.uiFragment.appendChild(
        local.<span class="apidocCodeKeywordSpan">domFragmentRender</span>(
            local.templateUiResource,
            swaggerJson.resourceDict[key]
        )
    );
});
Object.keys(swaggerJson.operationDict).sort(function (aa, bb) {
    aa = swaggerJson.operationDict[aa];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domQuerySelectorAllTagName" id="apidoc.elem.utility2.domQuerySelectorAllTagName">
        function <span class="apidocSignatureSpan">utility2.</span>domQuerySelectorAllTagName
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domQuerySelectorAllTagName = function (selector) {
<span class="apidocCodeCommentSpan">/*
 * this function will return all tagName that match &lt;selector&gt;
 */
</span>    let set;
    set = new Set();
    local.querySelectorAll(selector).forEach(function (elem) {
        set.add(elem.tagName);
    });
    return Array.from(set).sort();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domSelectOptionValue" id="apidoc.elem.utility2.domSelectOptionValue">
        function <span class="apidocSignatureSpan">utility2.</span>domSelectOptionValue
        <span class="apidocSignatureSpan">(elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domSelectOptionValue = function (elem) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;elem&gt;.options[&lt;elem&gt;.selectedIndex].value
 */
</span>    elem = elem &amp;&amp; elem.options[elem.selectedIndex];
    return (elem &amp;&amp; elem.value) || &quot;&quot;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domStyleValidate" id="apidoc.elem.utility2.domStyleValidate">
        function <span class="apidocSignatureSpan">utility2.</span>domStyleValidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domStyleValidate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will validate &lt;style&gt; tags
 */
</span>    let rgx;
    let tmp;
    rgx = (
        /^0\u0020(?:(body\u0020&gt;\u0020)?(?:\.testReportDiv\u0020.+|\.x-istanbul\u0020.+|\.button|\.colorError|\.readonly|\.textarea
|\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\u0020\{))|^[1-9]\d*?\u0020#/m
    );
    tmp = [];
    local.querySelectorAll(&quot;style&quot;).map(function (elem, ii) {
        elem.innerHTML.replace((
            /\/\*[\S\s]*?\*\/|;|\}/g
        ), &quot;\n&quot;).replace((
            /^([^\n\u0020@].*?)[,{:].*?$/gm
        ), function (match0, match1) {
            try {
                ii = local.querySelectorAll(match1).length;
            } catch (errCaught) {
                console.error(errCaught);
            }
            if (!(ii &gt; 1)) {
                tmp.push(ii + &quot; &quot; + match0);
            }
        });
    });
    tmp.filter(function (elem) {
        return !rgx.test(elem);
    }).sort().reverse().forEach(function (elem, ii, list) {
        console.error(
            &quot;domStyleValidateUnmatched &quot; + (list.length - ii) + &quot;. &quot; + elem
        );
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return local.buildTest({}, onError);
};

local._testCase_webpage_default = function (opt, onError) {
/*
* this function will test webpage&apos;s default handling-behavior
*/
   local.<span class="apidocCodeKeywordSpan">domStyleValidate</span>();
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   local.browserTest({
       fileScreenshot: (
           local.env.npm_config_dir_build
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.emit" id="apidoc.elem.utility2.emit">
        function <span class="apidocSignatureSpan">utility2.</span>emit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  data = concat(fragments, messageLength);
} else if (this._binaryType === &apos;arraybuffer&apos;) {
  data = toArrayBuffer(concat(fragments, messageLength));
} else {
  data = fragments;
}

this.<span class="apidocCodeKeywordSpan">emit</span>(&apos;message&apos;, data);
      } else {
const buf = concat(fragments, messageLength);

if (!isValidUTF8(buf)) {
  this._loop = false;
  return error(Error, &apos;invalid UTF-8 sequence&apos;, true, 1007);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.errorMessagePrepend" id="apidoc.elem.utility2.errorMessagePrepend">
        function <span class="apidocSignatureSpan">utility2.</span>errorMessagePrepend
        <span class="apidocSignatureSpan">(err, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorMessagePrepend = function (err, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will prepend message to &lt;err&gt;.message and &lt;err&gt;.stack
 */
</span>    if (err === local.errDefault) {
        return;
    }
    err.message = message + err.message;
    err.stack = message + err.stack;
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
local.onErrorJsonapi(function (err, data) {
    local.serverRespondHeadSet(req, res, err &amp;&amp; err.statusCode, {
        &quot;Content-Type&quot;: &quot;application/json&quot;
    });
    if (err) {
        // debug statusCode / method / url
        local.<span class="apidocCodeKeywordSpan">errorMessagePrepend</span>(
            err,
            res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url + &quot;\n&quot;
        );
        // print err.stack to stderr
        local.onErrorDefault(err);
    }
    data = err || data;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.eventEmitterCreate" id="apidoc.elem.utility2.eventEmitterCreate">
        function <span class="apidocSignatureSpan">utility2.</span>eventEmitterCreate
        <span class="apidocSignatureSpan">(that = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventEmitterCreate = function (that = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a simple, node-like event-emitter with &lt;that&gt;,
 * with methods emit, on, once, removeListener
 */
</span>    let dict;
    let emit;
    let on;
    let once;
    let remove;
    emit = function (type, msg) {
    /*
     * this function will emit evt &lt;type&gt; with &lt;msg&gt;
     */
        Array.from(dict[type] || []).forEach(function (listener) {
            listener(msg);
        });
    };
    on = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
     */
        let isDone;
        if (typeof listener === &quot;function&quot;) {
            dict[type] = dict[type] || [];
            dict[type].push(
                opt.once
                ? function listener2(msg) {
                    remove(type, listener2);
                    if (!isDone) {
                        isDone = true;
                        listener(msg);
                    }
                }
                : listener
            );
        }
        return that;
    };
    once = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
     */
        opt.once = true;
        return on(type, listener, opt);
    };
    remove = function (type, listener) {
    /*
     * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
     */
        let ii;
        let list;
        list = dict[type] || [];
        ii = list.length;
        while (ii &gt; 0) {
            ii -= 1;
            if (list[ii] === listener) {
                list.splice(ii, 1);
            }
        }
        return that;
    };
    dict = {};
    that.emit = that.emit || emit;
    that.listenerEmit = that.listenerEmit || emit;
    that.on = that.on || on;
    that.once = that.once || once;
    that.removeListener = that.removeListener || remove;
    that.removeEventListener = that.removeEventListener || remove;
    that.listenerOn = that.listenerOn || on;
    that.listenerOnce = that.listenerOnce || once;
    that.listenerRemove = that.listenerRemove || remove;
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   that.removeEventListener = that.removeEventListener || remove;
   that.listenerOn = that.listenerOn || on;
   that.listenerOnce = that.listenerOnce || once;
   that.listenerRemove = that.listenerRemove || remove;
   return that;
};

local.<span class="apidocCodeKeywordSpan">eventEmitterCreate</span>(local);

local.fsReadFileOrEmptyStringSync = function (file, opt) {
/*
* this function will try to read file or return empty-string, or
* if &lt;opt&gt; === &quot;json&quot;, then try to JSON.parse file or return {}
*/
   try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.events" id="apidoc.elem.utility2.events">
        function <span class="apidocSignatureSpan">utility2.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsReadFileOrEmptyStringSync" id="apidoc.elem.utility2.fsReadFileOrEmptyStringSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsReadFileOrEmptyStringSync
        <span class="apidocSignatureSpan">(file, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrEmptyStringSync = function (file, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to read file or return empty-string, or
 * if &lt;opt&gt; === &quot;json&quot;, then try to JSON.parse file or return {}
 */
</span>    try {
        return (
            opt === &quot;json&quot;
            ? JSON.parse(local.fs.readFileSync(file, &quot;utf8&quot;))
            : local.fs.readFileSync(file, opt)
        );
    } catch (ignore) {
        return (
            opt === &quot;json&quot;
            ? {}
            : &quot;&quot;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    local.templateSwaggerUiLogoMediumBase64,
    &quot;base64&quot;
);
local.assetsDict[&quot;/assets.swagger-ui.logo.small.png&quot;] = Buffer.from(
    local.templateSwaggerUiLogoSmallBase64,
    &quot;base64&quot;
);
local.swgg.apiUpdate(local.<span class="apidocCodeKeywordSpan">fsReadFileOrEmptyStringSync</span>(
    local.__dirname + &quot;/assets.swgg.swagger.json&quot;,
    &quot;json&quot;
));
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsRmrfSync" id="apidoc.elem.utility2.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.functionOrNop" id="apidoc.elem.utility2.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.gotoNext" id="apidoc.elem.utility2.gotoNext">
        function <span class="apidocSignatureSpan">utility2.</span>gotoNext
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoNext = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
 * and append current-stack to any err
 */
</span>    opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
        try {
            opt.gotoState += (
                (err &amp;&amp; !opt.modeErrorIgnore)
                ? 1000
                : 1
            );
            if (opt.modeDebug) {
                console.error(&quot;gotoNext - &quot; + JSON.stringify({
                    gotoState: opt.gotoState,
                    errorMessage: err &amp;&amp; err.message
                }));
                if (err &amp;&amp; err.stack) {
                    console.error(err.stack);
                }
            }
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.gotoNext(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.<span class="apidocCodeKeywordSpan">gotoNext</span>(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
};

local.onErrorDefault = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.identity" id="apidoc.elem.utility2.identity">
        function <span class="apidocSignatureSpan">utility2.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.isNullOrUndefined" id="apidoc.elem.utility2.isNullOrUndefined">
        function <span class="apidocSignatureSpan">utility2.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will test if val is null or undefined
 */
</span>    return val === null || val === undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ? &quot;arraybuffer&quot;
        : &quot;&quot;
    )
});
// init paramDict
that.parameters.forEach(function (schemaP) {
    tmp = opt.paramDict[schemaP.name];
    if (local.<span class="apidocCodeKeywordSpan">isNullOrUndefined</span>(tmp)) {
        return;
    }
    // serialize array
    if (Array.isArray(tmp) &amp;&amp; schemaP.in !== &quot;body&quot;) {
        switch (
            schemaP.collectionFormat || schemaP[&quot;x-swgg-collectionFormat&quot;]
        ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport" id="apidoc.elem.utility2.istanbul.HtmlReport">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.HtmlReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlReport(opts) {
    Report.call(this);
    this.opts = opts || {};
    this.opts.dir = this.opts.dir || path.resolve(process.cwd(), &apos;html-report&apos;);
    this.opts.sourceStore = this.opts.sourceStore || Store.create(&apos;fslookup&apos;);
    this.opts.linkMapper = this.opts.linkMapper || this.standardLinkMapper();
    this.opts.writer = this.opts.writer || null;
    // hack-coverage - new Date() bugfix
    this.opts.templateData = { datetime: new Date().toGMTString() };
    this.opts.watermarks = this.opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.TextReport" id="apidoc.elem.utility2.istanbul.TextReport">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.TextReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextReport(opts) {
    Report.call(this);
    opts = opts || {};
    this.dir = opts.dir || process.cwd();
    this.file = opts.file;
    this.summary = opts.summary;
    this.maxCols = opts.maxCols || 0;
    this.watermarks = opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require" id="apidoc.elem.utility2.istanbul.require">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulCoverageMerge" id="apidoc.elem.utility2.istanbulCoverageMerge">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageMerge
        <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageMerge = function (coverage1, coverage2) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge coverage2 into coverage1
 */
</span>    let dict1;
    let dict2;
    coverage1 = coverage1 || {};
    coverage2 = coverage2 || {};
    Object.keys(coverage2).forEach(function (file) {
        if (!coverage2[file]) {
            return;
        }
        // if file is undefined in coverage1, then add it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge file from coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (count, ii) {
                        dict1[key][ii] += count;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        case 6:
data = JSON.parse(data);
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.<span class="apidocCodeKeywordSpan">istanbulCoverageMerge</span>(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.testReportMerge(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.counter += 1;
local.fs.writeFile(
    local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
    JSON.stringify(globalThis.utility2_testReport),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulCoverageReportCreate" id="apidoc.elem.utility2.istanbulCoverageReportCreate">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. print coverage in text-format to stdout
 * 2. write coverage in html-format to filesystem
 * 3. return coverage in html-format as single document
 */
</span>    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    opt = {};
    opt.dir = process.cwd() + &quot;/tmp/build/coverage.html&quot;;
    // merge previous coverage
    if (!local.isBrowser &amp;&amp; process.env.npm_config_mode_coverage_merge) {
        console.log(&quot;merging file &quot; + opt.dir + &quot;/coverage.json to coverage&quot;);
        try {
            local.coverageMerge(opt.coverage, JSON.parse(
                local.fs.readFileSync(opt.dir + &quot;/coverage.json&quot;, &quot;utf8&quot;)
            ));
        } catch (ignore) {}
        try {
            Object.keys(JSON.parse(local.fs.readFileSync(
                opt.dir + &quot;/coverage.code-dict.json&quot;,
                &quot;utf8&quot;
            ))).forEach(function (key) {
                globalThis.__coverageCodeDict__[key] = (
                    globalThis.__coverageCodeDict__[key]
                    || true
                );
            });
        } catch (ignore) {}
    }
    // init writer
    local.coverageReportHtml = &quot;&quot;;
    local.coverageReportHtml += (
        &quot;&lt;div class=\&quot;coverageReportDiv\&quot;&gt;\n&quot;
        + &quot;&lt;h1&gt;coverage-report&lt;/h1&gt;\n&quot;
        + &quot;&lt;div style=\&quot;&quot;
        + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
        + &quot;\&quot;&gt;\n&quot;
    );
    local.writerData = &quot;&quot;;
    opt.sourceStore = {};
    opt.writer = local.writer;
    // 1. print coverage in text-format to stdout
    new local.TextReport(opt).writeReport(local.collector);
    // 2. write coverage in html-format to filesystem
    new local.HtmlReport(opt).writeReport(local.collector);
    local.writer.writeFile(&quot;&quot;, local.nop);
    if (!local.isBrowser) {
        // write coverage.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.json&quot;,
            JSON.stringify(opt.coverage)
        );
        // write coverage.code-dict.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.code-dict.json&quot;,
            JSON.stringify(globalThis.__coverageCodeDict__)
        );
        // write coverage.badge.svg
        opt.pct = local.coverageReportSummary.root.metrics.lines.pct;
        local.fsWriteFileWithMkdirpSync(
            local._istanbul_path.dirname(opt.dir) + &quot;/coverage.badge.svg&quot;,
            // edit coverage badge percent
            // edit coverage badge color
            local.templateCoverageBadgeSvg.replace((
                /100.0/g
            ), opt.pct).replace((
                /0d0/g
            ), (
                Math.round((100 - opt.pct) * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + Math.round(opt.pct * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + &quot;00&quot;
            ))
        );
    }
    console.log(&quot;created coverage file &quot; + opt.dir + &quot;/index.html&quot;);
    // 3. return coverage in html-format as a single document
    local.coverageReportHtml += &quot;&lt;/div&gt;\n&lt;/div&gt;\n&quot;;
    // write coverage.rollup.html
    if (!local.isBrowser) {
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.rollup.html&quot;,
            local.coverageReportHtml
        );
    }
    return local.coverageReportHtml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulInstrumentInPackage" id="apidoc.elem.utility2.istanbulInstrumentInPackage">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument the code
 * only if the macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in the code
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &quot;globalThis.utility2_moduleExports&quot;
);
// init example.js
tmp = process.cwd() + &quot;/example.js&quot;;
// jslint code
local.jslintAndPrint(code, tmp);
// cover code
code = local.<span class="apidocCodeKeywordSpan">istanbulInstrumentInPackage</span>(code, tmp);
// init module.exports
module = new local.Module(tmp);
require.cache[tmp] = module;
// load code into module
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulInstrumentSync" id="apidoc.elem.utility2.istanbulInstrumentSync">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. normalize the file
 * 2. save code to __coverageCodeDict__[file] for future html-report
 * 3. return instrumented code
 */
</span>    // 1. normalize the file
    file = local._istanbul_path.resolve(&quot;/&quot;, file);
    // 2. save code to __coverageCodeDict__[file] for future html-report
    globalThis.__coverageCodeDict__[file] = true;
    // 3. return instrumented code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslintAndPrint" id="apidoc.elem.utility2.jslintAndPrint">
        function <span class="apidocSignatureSpan">utility2.</span>jslintAndPrint
        <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrint = function (code = &quot;&quot;, file = &quot;undefined&quot;, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint / csslint &lt;code&gt; and print any errors to stderr
 */
</span>    let ii;
    let tmp;
    if (!(opt &amp;&amp; opt.gotoState)) {
        local.jslintResult = {
            gotoState: 0
        };
    }
    opt = Object.assign(local.jslintResult, opt);
    opt.gotoState += 1;
    switch (opt.gotoState) {
    // jslint - init
    case 1:
        // cleanup
        opt.errList = [];
        opt.errMsg = &quot;&quot;;
        // preserve lineno
        if (opt.iiStart) {
            opt.lineOffset |= 0;
            ii = 0;
            while (true) {
                ii = code.indexOf(&quot;\n&quot;, ii);
                if (ii === 0 || ii &gt; opt.iiStart) {
                    break;
                }
                ii += 1;
                opt.lineOffset += 1;
            }
            code = code.slice(opt.iiStart, opt.iiEnd || code.length);
        }
        switch (opt.fileType0) {
        // deembed-js - &apos;\\n\\\n...\\n\\\n&apos;
        case &quot;.\\n\\&quot;:
            // rgx - remove \\n\\
            code = code.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || &quot;&quot;;
            });
            break;
        // deembed-js - &apos;\n...\n&apos;
        case &quot;.sh&quot;:
            // rgx - convert &apos;&quot;&apos;&quot;&apos; to &apos;
            code = code.replace((
                /&apos;&quot;&apos;&quot;&apos;/g
            ), &quot;&apos;&quot;);
            break;
        }
        // init
        opt = Object.assign(opt, {
            &quot;.css&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.html&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.js&quot;: (
                /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.md&quot;: (
                /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.sh&quot;: (
                /(^#\u0020jslint\u0020utility2:true$)/m
            ),
            code0: code,
            fileType: (
                /\.\w+?$|$/m
            ).exec(file)[0]
        });
        // jslint - .json
        if (
            code &amp;&amp; (opt.fileType === &quot;.js&quot; || opt.fileType === &quot;.json&quot;)
            &amp;&amp; !opt.fileType0
        ) {
            try {
                tmp = JSON.parse(code);
                opt.fileType = &quot;.json&quot;;
                if (opt.autofix) {
                    code = JSON.stringify(tmp, null, 4) + &quot;\n&quot;;
                    opt.code0 = code;
                }
                opt.gotoState = Infinity;
                break;
            } catch (errCaught) {
                if (opt.fileType === &quot;.json&quot;) {
                    opt.errList.push({
                        column: 0,
                        evidence: code.slice(0, 100),
                        line: 0,
                        message: errCaught.message
                    });
                    opt.gotoState = Infinity;
                    break;
                }
            }
        }
        try {
            opt.conditionalPassed = opt[opt.fileType].exec(code);
        } catch (ignore) {}
        opt.utility2 = (
            opt.conditionalPassed
            &amp;&amp; opt.conditionalPassed[1]
        ) || opt.autofix;
        if (
            opt.conditional
            &amp;&amp; (!opt.conditionalPassed || opt.coverage)
        ) {
            break;
        }
        opt.gotoState = 10;
        break;
    // jslint - autofix
    case 11:
        code = local.jslintAutofix(code, file, opt);
        local.jslintResult = opt;
        break;
    // jslint - csslint and jslint
    case 12:
        // restore lineOffset
        code = &quot;\n&quot;.rep...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    // read file
    local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
    break;
case 2:
    // jslint
    local.jslint.<span class="apidocCodeKeywordSpan">jslintAndPrint</span>(data, opt.file);
    local.assertOrThrow(
        !local.jslint.jslintResult.errMsg,
        local.jslint.jslintResult.errMsg.replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;)
    );
    // validate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslintAutofixLocalFunction" id="apidoc.elem.utility2.jslintAutofixLocalFunction">
        function <span class="apidocSignatureSpan">utility2.</span>jslintAutofixLocalFunction
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAutofixLocalFunction = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint-autofix local-function
 */
</span>    let code2;
    let dictFnc;
    let dictProp;
    let tmp;
    if (local.isBrowser) {
        return code;
    }
    file = file.replace(process.cwd() + &quot;/&quot;, &quot;&quot;);
    switch (file) {
    case &quot;README.md&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.sh&quot;:
    case &quot;lib.apidoc.js&quot;:
    case &quot;lib.github_crud.js&quot;:
    case &quot;lib.istanbul.js&quot;:
    case &quot;lib.jslint.js&quot;:
    case &quot;lib.marked.js&quot;:
    case &quot;lib.puppeteer.js&quot;:
    case &quot;lib.sjcl.js&quot;:
    case &quot;lib.swgg.js&quot;:
    case &quot;npm_scripts.sh&quot;:
    case &quot;test.js&quot;:
        break;
    default:
        return code;
    }
    // autofix - assets.utility2.header.js
    code = code.replace((
        /\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020start\n[\S\s]*?\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020end\n/
    ), &quot;\n&quot; + local.assetsDict[&quot;/assets.utility2.header.js&quot;]);
    // autofix - assets.my_app.template.js
    code = local.stringMerge(
        code,
        local.assetsDict[&quot;/assets.my_app.template.js&quot;].replace((
            /my_app/g
        ), file.split(&quot;.&quot;)[1]),
        file !== &quot;README.md&quot; &amp;&amp; local.identity(
            /\n\/\*\u0020istanbul\u0020instrument\u0020in\u0020package\u0020[\S\s]*?\n\/\*\u0020validateLineSortedReset\u0020\*\/\n/
        )
    );
    // customize local for assets.utility2.rollup.js
    if (
        file === &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;
        &amp;&amp; local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
        &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
    ) {
        code = code.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // init functionAllDict and functionBaseDict
    [
        [
            &quot;utility2&quot;, &quot;swgg&quot;
        ], [
            &quot;utility2&quot;, &quot;apidoc&quot;, &quot;github_crud&quot;, &quot;swgg&quot;
        ]
    ].forEach(function (dictList, ii) {
        tmp = (
            ii
            ? &quot;functionAllDict&quot;
            : &quot;functionBaseDict&quot;
        );
        if (local[tmp]) {
            return;
        }
        local[tmp] = {};
        dictList.forEach(function (dict) {
            dict = local[dict];
            Object.keys(dict).forEach(function (key) {
                if (
                    !(
                        /^[A-Z_]|^testCase_/m
                    ).test(key)
                    &amp;&amp; typeof dict[key] === &quot;function&quot;
                ) {
                    local[tmp][key] = local[tmp][key] || String(dict[key]);
                }
            });
        });
        Object.keys(local[tmp]).forEach(function (key) {
            if (process.binding(&quot;natives&quot;)[key]) {
                local[tmp][key] = undefined;
            }
        });
    });
    // autofix - local-function
    dictFnc = {};
    dictProp = {};
    code = code.replace((
        /^local\.(.*?)\u0020=\u0020(function\u0020\([\S\s]*?\n\});\n+/gm
    ), function (match0, key, match2, match3) {
        // local-function - duplicate
        if (dictFnc[key]) {
            return &quot;&quot;;
        }
        // local-function - normalize
        dictFnc[key] = true;
        match3 = local.functionAllDict[key] || &quot;&quot;;
        // make shell-safe
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c
        if...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jsonCopy" id="apidoc.elem.utility2.jsonCopy">
        function <span class="apidocSignatureSpan">utility2.</span>jsonCopy
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonCopy = function (obj) {
<span class="apidocCodeCommentSpan">/*
 * this function will deep-copy obj
 */
</span>    return (
        obj === undefined
        ? undefined
        : JSON.parse(JSON.stringify(obj))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// try to validate paramDict
opt.err = local.swaggerValidateDataParameters({
    // normalize paramDict
    data: local.normalizeSwaggerParamDict({
        modeNoDefault: opt.modeNoDefault,
        operation: that,
        paramDict: local.<span class="apidocCodeKeywordSpan">jsonCopy</span>(opt.paramDict)
    }).paramDict,
    dataReadonlyRemove: opt.paramDict,
    prefix: [
        &quot;operation&quot;, that._methodPath
    ],
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jsonStringifyOrdered" id="apidoc.elem.utility2.jsonStringifyOrdered">
        function <span class="apidocSignatureSpan">utility2.</span>jsonStringifyOrdered
        <span class="apidocSignatureSpan">(obj, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonStringifyOrdered = function (obj, replacer, space) {
<span class="apidocCodeCommentSpan">/*
 * this function will JSON.stringify &lt;obj&gt;,
 * with object-keys sorted and circular-references removed
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Syntax
 */
</span>    let circularSet;
    let stringify;
    let tmp;
    stringify = function (obj) {
    /*
     * this function will recursively JSON.stringify obj,
     * with object-keys sorted and circular-references removed
     */
        // if obj is not an object or function, then JSON.stringify as normal
        if (!(
            obj
            &amp;&amp; typeof obj === &quot;object&quot;
            &amp;&amp; typeof obj.toJSON !== &quot;function&quot;
        )) {
            return JSON.stringify(obj);
        }
        // ignore circular-reference
        if (circularSet.has(obj)) {
            return;
        }
        circularSet.add(obj);
        // if obj is an array, then recurse items
        if (Array.isArray(obj)) {
            tmp = &quot;[&quot; + obj.map(function (obj) {
                // recurse
                tmp = stringify(obj);
                return (
                    typeof tmp === &quot;string&quot;
                    ? tmp
                    : &quot;null&quot;
                );
            }).join(&quot;,&quot;) + &quot;]&quot;;
            circularSet.delete(obj);
            return tmp;
        }
        // if obj is not an array,
        // then recurse its items with object-keys sorted
        tmp = &quot;{&quot; + Object.keys(obj).sort().map(function (key) {
            // recurse
            tmp = stringify(obj[key]);
            if (typeof tmp === &quot;string&quot;) {
                return JSON.stringify(key) + &quot;:&quot; + tmp;
            }
        }).filter(function (obj) {
            return typeof obj === &quot;string&quot;;
        }).join(&quot;,&quot;) + &quot;}&quot;;
        circularSet.delete(obj);
        return tmp;
    };
    circularSet = new Set();
    return JSON.stringify((
        (typeof obj === &quot;object&quot; &amp;&amp; obj)
        // recurse
        ? JSON.parse(stringify(obj))
        : obj
    ), replacer, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;!-- swgg-script-extra-end --&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.<span class="apidocCodeKeywordSpan">jsonStringifyOrdered</span>(
local.objectSetOverride(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtAes256GcmDecrypt" id="apidoc.elem.utility2.jwtAes256GcmDecrypt">
        function <span class="apidocSignatureSpan">utility2.</span>jwtAes256GcmDecrypt
        <span class="apidocSignatureSpan">(token, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256GcmDecrypt = function (token, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will use json-web-encryption to
 * aes-256-gcm-decrypt &lt;token&gt; with given base64url-encoded &lt;key&gt;
 * https://tools.ietf.org/html/rfc7516
 */
</span>    return local.tryCatchOnError(function () {
        token = token.replace((
            /-/g
        ), &quot;+&quot;).replace((
            /_/g
        ), &quot;/&quot;).split(&quot;.&quot;);
        token = local.sjcl.decrypt(
            local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
            JSON.stringify({
                adata: token[4],
                ct: token[3],
                iv: token[2],
                ks: 256,
                mode: &quot;gcm&quot;
            })
        );
        return local.jwtHs256Decode(token, key);
    }, local.nop) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
crud = req.swgg.crud;
user = {};
req.swgg.user = user;
user.jwtEncrypted = (
    req.headers.authorization
    &amp;&amp; req.headers.authorization.replace(&quot;Bearer &quot;, &quot;&quot;)
);
user.jwtDecrypted = local.<span class="apidocCodeKeywordSpan">jwtAes256GcmDecrypt</span>(user.jwtEncrypted);
switch (crud.crudType[0]) {
// hack-coverage - test err handling-behavior
case &quot;crudErrorLogin&quot;:
    opt.gotoNext(local.errDefault);
    return;
case &quot;userLoginByPassword&quot;:
    user.password = req.urlParsed.query.password;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtAes256GcmEncrypt" id="apidoc.elem.utility2.jwtAes256GcmEncrypt">
        function <span class="apidocSignatureSpan">utility2.</span>jwtAes256GcmEncrypt
        <span class="apidocSignatureSpan">(data, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256GcmEncrypt = function (data, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will use json-web-encryption to
 * aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
 * https://tools.ietf.org/html/rfc7516
 */
</span>    let adata;
    adata = local.jwtAes256KeyCreate();
    data = local.jwtHs256Encode(data, key);
    data = JSON.parse(local.sjcl.encrypt(
        local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
        data,
        {
            adata: local.sjcl.codec.base64url.toBits(adata),
            ks: 256,
            mode: &quot;gcm&quot;
        }
    ));
    return local.normalizeJwtBase64Url(
        &quot;eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4R0NNIn0..&quot;
        + data.iv + &quot;.&quot; + data.ct + &quot;.&quot; + adata
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init isAuthenticated
user.isAuthenticated = true;
// create JSON Web Token (JWT)
// https://tools.ietf.org/html/rfc7519
user.jwtDecrypted = {};
user.jwtDecrypted.sub = user.data.username;
// update jwtEncrypted in client
user.jwtEncrypted = local.<span class="apidocCodeKeywordSpan">jwtAes256GcmEncrypt</span>(
    user.jwtDecrypted
);
local.serverRespondHeadSet(req, res, null, {
    &quot;swgg-jwt-encrypted&quot;: user.jwtEncrypted
});
// update jwtEncrypted in dbTableUser
local.dbTableUser.crudUpdateOneById({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtAes256KeyCreate" id="apidoc.elem.utility2.jwtAes256KeyCreate">
        function <span class="apidocSignatureSpan">utility2.</span>jwtAes256KeyCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256KeyCreate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random, aes-256-base64url-jwt-key
 */
</span>    return local.normalizeJwtBase64Url(
        local.base64FromBuffer(local.bufferRandomBytes(32))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.jwtAes256GcmEncrypt = function (data, key) {
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
* https://tools.ietf.org/html/rfc7516
*/
   let adata;
   adata = local.<span class="apidocCodeKeywordSpan">jwtAes256KeyCreate</span>();
   data = local.jwtHs256Encode(data, key);
   data = JSON.parse(local.sjcl.encrypt(
       local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
       data,
       {
           adata: local.sjcl.codec.base64url.toBits(adata),
           ks: 256,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtAes256KeyInit" id="apidoc.elem.utility2.jwtAes256KeyInit">
        function <span class="apidocSignatureSpan">utility2.</span>jwtAes256KeyInit
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256KeyInit = function (key) {
<span class="apidocCodeCommentSpan">/*
 * this function will init aes-256-base64url-jwt-&lt;key&gt;
 * https://jwt.io/
 */
</span>    // init npm_config_jwtAes256Key
    local.env.npm_config_jwtAes256Key = (
        local.env.npm_config_jwtAes256Key
        || &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
    );
    return key || local.env.npm_config_jwtAes256Key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return local.tryCatchOnError(function () {
token = token.replace((
    /-/g
), &quot;+&quot;).replace((
    /_/g
), &quot;/&quot;).split(&quot;.&quot;);
token = local.sjcl.decrypt(
    local.sjcl.codec.base64url.toBits(local.<span class="apidocCodeKeywordSpan">jwtAes256KeyInit</span>(key)),
    JSON.stringify({
        adata: token[4],
        ct: token[3],
        iv: token[2],
        ks: 256,
        mode: &quot;gcm&quot;
    })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtHs256Decode" id="apidoc.elem.utility2.jwtHs256Decode">
        function <span class="apidocSignatureSpan">utility2.</span>jwtHs256Decode
        <span class="apidocSignatureSpan">(token, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtHs256Decode = function (token, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will decode json-web-token with given base64-encoded &lt;key&gt;
 * https://jwt.io/
 */
</span>    let Hmac;
    let timeNow;
    Hmac = local.sjcl.misc.hmac;
    timeNow = Date.now() / 1000;
    // try to decode token
    return local.tryCatchOnError(function () {
        token = token.split(&quot;.&quot;);
        // validate header
        local.assertOrThrow(
            token[0] === &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;,
            token
        );
        // validate signature
        local.assertOrThrow(local.sjcl.codec.base64url.fromBits(
            new Hmac(local.sjcl.codec.base64url.toBits(
                local.jwtAes256KeyInit(key)
            )).encrypt(token[0] + &quot;.&quot; + token[1])
        ) === token[2]);
        // return decoded data
        token = JSON.parse(local.base64ToUtf8(token[1]));
        // https://tools.ietf.org/html/rfc7519#section-4.1
        // validate jwt-registered-headers
        local.assertOrThrow(!token.exp || token.exp &gt;= timeNow);
        local.assertOrThrow(!token.nbf || token.nbf &lt;= timeNow);
        return token;
    }, local.nop) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               adata: token[4],
               ct: token[3],
               iv: token[2],
               ks: 256,
               mode: &quot;gcm&quot;
           })
       );
       return local.<span class="apidocCodeKeywordSpan">jwtHs256Decode</span>(token, key);
   }, local.nop) || {};
};

local.jwtAes256GcmEncrypt = function (data, key) {
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jwtHs256Encode" id="apidoc.elem.utility2.jwtHs256Encode">
        function <span class="apidocSignatureSpan">utility2.</span>jwtHs256Encode
        <span class="apidocSignatureSpan">(data, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtHs256Encode = function (data, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will encode &lt;data&gt; into a json-web-token
 * with given base64-encoded &lt;key&gt;
 * https://jwt.io/
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    data = (
        &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.&quot;
        + local.normalizeJwtBase64Url(
            local.base64FromBuffer(JSON.stringify(data))
        )
    );
    return data + &quot;.&quot; + local.sjcl.codec.base64url.fromBits(
        new Hmac(local.sjcl.codec.base64url.toBits(
            local.jwtAes256KeyInit(key)
        )).encrypt(data)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
* https://tools.ietf.org/html/rfc7516
*/
   let adata;
   adata = local.jwtAes256KeyCreate();
   data = local.<span class="apidocCodeKeywordSpan">jwtHs256Encode</span>(data, key);
   data = JSON.parse(local.sjcl.encrypt(
       local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
       data,
       {
           adata: local.sjcl.codec.base64url.toBits(adata),
           ks: 256,
           mode: &quot;gcm&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listGetElementRandom" id="apidoc.elem.utility2.listGetElementRandom">
        function <span class="apidocSignatureSpan">utility2.</span>listGetElementRandom
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listGetElementRandom = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will return random elem from &lt;list&gt;
 */
</span>    return list[Math.floor(Math.random() * list.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return local.jsonCopy(schemaP.default);
}
// init enum-value
if (schemaP.enum) {
    value = (
        opt.modeNotRandom
        ? schemaP.enum[0]
        : local.<span class="apidocCodeKeywordSpan">listGetElementRandom</span>(schemaP.enum)
    );
    return (
        local.schemaPType(schemaP) === &quot;array&quot;
        ? [
            value
        ]
        : value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listShuffle" id="apidoc.elem.utility2.listShuffle">
        function <span class="apidocSignatureSpan">utility2.</span>listShuffle
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listShuffle = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace shuffle &lt;list&gt; using fisher-yates algorithm
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
</span>    let ii;
    let random;
    let swap;
    ii = list.length;
    while (ii &gt; 1) {
        ii -= 1;
        random = Math.floor(Math.random() * (ii + 1));
        swap = list[ii];
        list[ii] = list[random];
        list[random] = swap;
    }
    return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
opt = {};
// init list
opt.list = &quot;[0,1]&quot;;
// shuffle list 100 times
opt.ii = 0;
while (opt.ii &lt; 100) {
    opt.listShuffled = JSON.stringify(
        local.<span class="apidocCodeKeywordSpan">listShuffle</span>(JSON.parse(opt.list))
    );
    // validate shuffled list
    local.assertJsonEqual(opt.listShuffled.length, opt.list.length);
    opt.changed = opt.changed || opt.listShuffled !== opt.list;
    opt.ii += 1;
}
// validate list changed at least once during the shuffle
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerEmit" id="apidoc.elem.utility2.listenerEmit">
        function <span class="apidocSignatureSpan">utility2.</span>listenerEmit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerEmit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerOn" id="apidoc.elem.utility2.listenerOn">
        function <span class="apidocSignatureSpan">utility2.</span>listenerOn
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOn = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerOnce" id="apidoc.elem.utility2.listenerOnce">
        function <span class="apidocSignatureSpan">utility2.</span>listenerOnce
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOnce = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerRemove" id="apidoc.elem.utility2.listenerRemove">
        function <span class="apidocSignatureSpan">utility2.</span>listenerRemove
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerRemove = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.localStorageSetItemOrClear" id="apidoc.elem.utility2.localStorageSetItemOrClear">
        function <span class="apidocSignatureSpan">utility2.</span>localStorageSetItemOrClear
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localStorageSetItemOrClear = function (key, value) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to set &lt;key&gt;/&lt;value&gt; pair to localStorage,
 * or else call localStorage.clear()
 */
</span>    try {
        localStorage.setItem(key, value);
    } catch (ignore) {
        localStorage.clear();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    local.apiKeyValue = localStorage.getItem(local.apiKeyKey) || &quot;&quot;;
// save apiKeyValue
} else {
    local.apiKeyValue = document.querySelector(
        &quot;#swggApiKeyInput1&quot;
    ).value;
    local.<span class="apidocCodeKeywordSpan">localStorageSetItemOrClear</span>(
        local.apiKeyKey,
        local.apiKeyValue
    );
}
// if keyup-evt is not return-key, then return
if (
    (opt.type === &quot;keyup&quot; &amp;&amp; opt.code !== &quot;Enter&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked" id="apidoc.elem.utility2.marked">
        function <span class="apidocSignatureSpan">utility2.</span>marked
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer" id="apidoc.elem.utility2.marked.Lexer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser" id="apidoc.elem.utility2.marked.Parser">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer" id="apidoc.elem.utility2.marked.Renderer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareAssetsCached" id="apidoc.elem.utility2.middlewareAssetsCached">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareAssetsCached
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareAssetsCached = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve cached-assets
 */
</span>    if (!local.assetsDict.hasOwnProperty(req.urlParsed.pathname)) {
        next();
        return;
    }
    // do not cache if headers already sent or url has &apos;?&apos; search indicator
    if (!(res.headersSent || req.url.indexOf(&quot;?&quot;) &gt;= 0)) {
        // init serverResponseHeaderLastModified
        local.serverResponseHeaderLastModified = (
            local.serverResponseHeaderLastModified
            // resolve to 1000 ms
            || new Date(new Date().toUTCString())
        );
        // respond with 304 If-Modified-Since serverResponseHeaderLastModified
        if (
            new Date(req.headers[&quot;if-modified-since&quot;])
            &gt;= local.serverResponseHeaderLastModified
        ) {
            res.statusCode = 304;
            res.end();
            return;
        }
        res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        res.setHeader(
            &quot;Last-Modified&quot;,
            local.serverResponseHeaderLastModified.toUTCString()
        );
    }
    res.end(local.assetsDict[req.urlParsed.pathname]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareBodyRead" id="apidoc.elem.utility2.middlewareBodyRead">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareBodyRead
        <span class="apidocSignatureSpan">(req, ignore, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareBodyRead = function (req, ignore, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * read and save &lt;req&gt; body to &lt;req&gt;.bodyRaw
 */
</span>    // if req is already read, then goto next
    if (!req.readable) {
        next();
        return;
    }
    let bufList;
    bufList = [];
    req.on(&quot;data&quot;, function (buf) {
        bufList.push(buf);
    }).on(&quot;end&quot;, function () {
        req.bodyRaw = (
            local.isBrowser
            ? bufList[0]
            : Buffer.concat(bufList)
        );
        next();
    // on event-error, pass error to onError
    }).on(&quot;error&quot;, next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will run the test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
   case &quot;/test.body&quot;:
       // test req-body-read handling-behavior
       local.<span class="apidocCodeKeywordSpan">middlewareBodyRead</span>(req, res, function () {
           // test multiple req-body-read handling-behavior
           local.middlewareBodyRead(req, res, function () {
               res.write(req.bodyRaw);
               res.end();
           });
       });
       break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareError" id="apidoc.elem.utility2.middlewareError">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareError
        <span class="apidocSignatureSpan">(err, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareError = function (err, req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to handle errors
 */
</span>    // default - 404 Not Found
    if (!err) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    // http://jsonapi.org/format/#errors
    if (local.swgg &amp;&amp; typeof local.swgg.serverRespondJsonapi === &quot;function&quot;) {
        local.swgg.serverRespondJsonapi(req, res, err);
    }
    // statusCode [400, 600)
    local.serverRespondDefault(req, res, (
        (err.statusCode &gt;= 400 &amp;&amp; err.statusCode &lt; 600)
        ? err.statusCode
        : 500
    ), err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
globalThis.utility2_onReadyBefore.counter += 1;
local.serverLocalReqHandler = function (req, res) {
    let that;
    that = {};
    local.gotoNext(that, function (err) {
        if (err || that.gotoState &gt;= local.middlewareList.length) {
            local.<span class="apidocCodeKeywordSpan">middlewareError</span>(err, req, res);
            return;
        }
        // recurse with next middleware in middlewareList
        local.middlewareList[that.gotoState](req, res, that.gotoNext);
    });
    that.gotoState = -1;
    that.gotoNext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareFileServer" id="apidoc.elem.utility2.middlewareFileServer">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareFileServer
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareFileServer = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve files
 */
</span>    let file;
    if (req.method !== &quot;GET&quot; || local.isBrowser) {
        next();
        return;
    }
    // security - disable parent directory lookup
    file = local.path.resolve(&quot;/&quot;, req.urlParsed.pathname).slice(1);
    // replace trailing &apos;/&apos; with &apos;/index.html&apos;
    file = file.replace((
        /\/$/
    ), &quot;/index.html&quot;);
    local.fs.readFile(file, function (err, data) {
        // default to next
        if (err) {
            next();
            return;
        }
        // respond with data
        local.serverRespondHeadSet(req, res, undefined, {
            &quot;Content-Type&quot;: local.contentTypeDict[(
                /\.[^.]*?$|$/m
            ).exec(file)[0]]
        });
        res.end(data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &quot;/test.timeout&quot;:
        setTimeout(function () {
            res.end();
        }, 2000);
        break;
    // serve file
    default:
        local.<span class="apidocCodeKeywordSpan">middlewareFileServer</span>(req, res, next);
    }
});
}());



// run node js-env code - init-after
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareForwardProxy" id="apidoc.elem.utility2.middlewareForwardProxy">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareForwardProxy
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareForwardProxy = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to forward-proxy &lt;req&gt;
 * to its destination-host
 */
</span>    let isDone;
    let onError;
    let opt;
    let timerTimeout;
    // handle preflight-cors
    if (req.method === &quot;OPTIONS&quot; &amp;&amp; (
        /forward-proxy-url/
    ).test(req.headers[&quot;access-control-request-headers&quot;])) {
        local.serverRespondCors(req, res);
        res.end();
        return;
    }
    if (!req.headers[&quot;forward-proxy-url&quot;]) {
        next();
        return;
    }
    local.serverRespondCors(req, res);
    // init onError
    onError = function (err) {
        if (isDone) {
            return;
        }
        isDone = true;
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // debug middlewareForwardProxy
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(opt.timeStart).toISOString(),
            type: &quot;middlewareForwardProxyResponse&quot;,
            method: opt.method,
            url: opt.url,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - opt.timeStart,
            // extra
            headers: opt.headers
        }));
        if (!err) {
            return;
        }
        // cleanup clientReq and clientRes
        local.streamCleanup(opt.clientReq);
        local.streamCleanup(opt.clientReq);
        next(err);
    };
    // init opt
    opt = local.urlParse(req.headers[&quot;forward-proxy-url&quot;]);
    opt.method = req.method;
    opt.url = req.headers[&quot;forward-proxy-url&quot;];
    // init timerTimeout
    timerTimeout = local.onTimeout(
        onError,
        local.timeoutDefault,
        &quot;forward-proxy &quot; + opt.method + &quot; &quot; + opt.url
    );
    // parse headers
    opt.headers = {};
    local.tryCatchOnError(function () {
        opt.headers = JSON.parse(req.headers[&quot;forward-proxy-headers&quot;]);
    }, local.nop);
    // debug opt
    local._debugForwardProxy = opt;
    opt.clientReq = (
        opt.protocol === &quot;https:&quot;
        ? local.https
        : local.http
    ).request(opt, function (clientReq) {
        opt.clientReq = clientReq.on(&quot;error&quot;, onError);
        res.statusCode = opt.clientReq.statusCode;
        // pipe clientReq to res
        opt.clientReq.pipe(res);
    }).on(&quot;error&quot;, onError);
    opt.timeStart = Date.now();
    // handle evt
    req.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError).on(&quot;error&quot;, onError);
    // pipe req to clientReq
    req.pipe(opt.clientReq);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareInit" id="apidoc.elem.utility2.middlewareInit">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to init &lt;req&gt; and &lt;res&gt;
 */
</span>    // debug req and res
    local._debugServerReqRes4 = local._debugServerReqRes3;
    local._debugServerReqRes3 = local._debugServerReqRes2;
    local._debugServerReqRes2 = local._debugServerReqRes1;
    local._debugServerReqRes1 = {
        req,
        res
    };
    // init timerTimeout
    local.serverRespondTimeoutDefault(req, res, local.timeoutDefault);
    // init req.urlParsed
    req.urlParsed = local.urlParse(req.url);
    // init res-header content-type
    local.serverRespondHeadSet(req, res, undefined, {
        &quot;Content-Type&quot;: local.contentTypeDict[(
            /\.[^.]*?$|$/m
        ).exec(req.urlParsed.pathname)[0]]
    });
    // set main-page content-type to text/html
    if (req.urlParsed.pathname === &quot;/&quot;) {
        local.serverRespondHeadSet(req, res, undefined, {
            &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
        });
    }
    // default to next
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareJsonpStateInit" id="apidoc.elem.utility2.middlewareJsonpStateInit">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareJsonpStateInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareJsonpStateInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * serve browser-state wrapped in given jsonp-callback
 */
</span>    let state;
    if (!(req.stateInit || (
        req.urlParsed
        &amp;&amp; req.urlParsed.pathname === &quot;/jsonp.utility2.stateInit&quot;
    ))) {
        next();
        return;
    }
    state = {
        utility2: {
            assetsDict: {
                &quot;/assets.example.html&quot;:
                local.assetsDict[&quot;/assets.example.html&quot;],
                &quot;/assets.example.js&quot;: local.assetsDict[&quot;/assets.example.js&quot;],
                &quot;/assets.swgg.swagger.json&quot;:
                local.assetsDict[&quot;/assets.swgg.swagger.json&quot;],
                &quot;/assets.test.js&quot;: local.assetsDict[&quot;/assets.test.js&quot;],
                &quot;/assets.utility2.base.html&quot;:
                local.assetsDict[&quot;/assets.utility2.base.rollup.html&quot;],
                &quot;/index.rollup.html&quot;: local.assetsDict[&quot;/index.rollup.html&quot;]
            },
            env: {
                NODE_ENV: local.env.NODE_ENV,
                npm_config_mode_backend: local.env.npm_config_mode_backend,
                npm_package_description: local.env.npm_package_description,
                npm_package_homepage: local.env.npm_package_homepage,
                npm_package_name: local.env.npm_package_name,
                npm_package_nameLib: local.env.npm_package_nameLib,
                npm_package_version: local.env.npm_package_version
            }
        }
    };
    if (req.stateInit) {
        return state;
    }
    res.end(
        req.urlParsed.query.callback + &quot;(&quot; + JSON.stringify(state) + &quot;);&quot;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    code += local.assetsDict[tmp];
    break;
case &quot;local.stateInit&quot;:
    // handle large string-replace
    code = local.assetsDict[&quot;/assets.utility2.rollup.content.js&quot;].split(
        &quot;/* utility2.rollup.js content */&quot;
    );
    tmp = local.<span class="apidocCodeKeywordSpan">middlewareJsonpStateInit</span>({
        stateInit: true
    });
    // add extra physical files to assetsDict
    local.fs.readdirSync(&quot;.&quot;).forEach(function (file) {
        file = &quot;/&quot; + file;
        if (
            local.assetsDict[file]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.moduleDirname" id="apidoc.elem.utility2.moduleDirname">
        function <span class="apidocSignatureSpan">utility2.</span>moduleDirname
        <span class="apidocSignatureSpan">(module, pathList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moduleDirname = function (module, pathList) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
 */
</span>    let result;
    // search process.cwd()
    if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
        return require(&quot;path&quot;).resolve(process.cwd(), module || &quot;&quot;);
    }
    // search pathList
    Array.from([
        pathList,
        require(&quot;module&quot;).globalPaths,
        [
            process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
        ]
    ]).flat().some(function (path) {
        try {
            result = require(&quot;path&quot;).resolve(
                process.cwd(),
                path + &quot;/&quot; + module
            );
            result = require(&quot;fs&quot;).statSync(result).isDirectory() &amp;&amp; result;
            return result;
        } catch (ignore) {
            result = &quot;&quot;;
        }
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return match0.replace((
            /(.{128}(?:\b|\w+))/g
        ), &quot;$1\n&quot;).trimEnd();
    });
    return text;
};
// init opt
opt.dir = local.<span class="apidocCodeKeywordSpan">moduleDirname</span>(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.nop" id="apidoc.elem.utility2.nop">
        function <span class="apidocSignatureSpan">utility2.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.normalizeJwt" id="apidoc.elem.utility2.normalizeJwt">
        function <span class="apidocSignatureSpan">utility2.</span>normalizeJwt
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwt = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will normalize the jwt-data with registered-headers
 * https://tools.ietf.org/html/rfc7519#section-4.1
 */
</span>    let timeNow;
    timeNow = Date.now() / 1000;
    return local.objectSetDefault(data, {
        exp: timeNow + 5 * 60,
        iat: timeNow,
        jti: Math.random().toString(16).slice(2),
        nbf: timeNow
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.testCase_jwtAes256GcmXxx_default = function (opt, onError) {
/*
* this function will test jwtAes256GcmXxx&apos;s default handling-behavior
*/
   opt = {};
   opt.key = local.jwtAes256KeyCreate();
   // use canonical example at https://jwt.io/
   opt.data = JSON.parse(local.jsonStringifyOrdered(local.<span class="apidocCodeKeywordSpan">normalizeJwt</span>({
       sub: &quot;1234567890&quot;,
       name: &quot;John Doe&quot;,
       admin: true
   })));
   // encrypt token
   opt.token = local.jwtAes256GcmEncrypt(opt.data, opt.key);
   // validate encrypted-token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.normalizeJwtBase64Url" id="apidoc.elem.utility2.normalizeJwtBase64Url">
        function <span class="apidocSignatureSpan">utility2.</span>normalizeJwtBase64Url
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwtBase64Url = function (b64) {
<span class="apidocCodeCommentSpan">/*
 * this function will normlize &lt;b64&gt; to base64url format
 */
</span>    return b64.replace((
        /\=/g
    ), &quot;&quot;).replace((
        /\+/g
    ), &quot;-&quot;).replace((
        /\//g
    ), &quot;_&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        data,
        {
            adata: local.sjcl.codec.base64url.toBits(adata),
            ks: 256,
            mode: &quot;gcm&quot;
        }
    ));
    return local.<span class="apidocCodeKeywordSpan">normalizeJwtBase64Url</span>(
        &quot;eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4R0NNIn0..&quot;
        + data.iv + &quot;.&quot; + data.ct + &quot;.&quot; + adata
    );
};

local.jwtAes256KeyCreate = function () {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.numberToRomanNumerals" id="apidoc.elem.utility2.numberToRomanNumerals">
        function <span class="apidocSignatureSpan">utility2.</span>numberToRomanNumerals
        <span class="apidocSignatureSpan">(num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToRomanNumerals = function (num) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert num to a roman-numeral
 * https://stackoverflow.com/questions/9083037/convert-a-number-into-a-roman-numeral-in-javascript
 */
</span>    let digits;
    let ii;
    let key;
    let roman;
    digits = String(num).split(&quot;&quot;);
    key = [
        &quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;,
        &quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;,
        &quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;
    ];
    roman = &quot;&quot;;
    ii = 3;
    while (ii) {
        ii -= 1;
        roman = (key[Number(digits.pop()) + (ii * 10)] || &quot;&quot;) + roman;
    }
    return new Array(Number(digits.join(&quot;&quot;) + 1)).join(&quot;M&quot;) + roman;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &quot;XCVIII&quot;,
        &quot;XCIX&quot;,
        &quot;C&quot;
    ];
    opt.ii = 0;
    while (opt.ii &lt; 10) {
        local.assertJsonEqual(
            local.<span class="apidocCodeKeywordSpan">numberToRomanNumerals</span>(opt.ii),
            opt.list[opt.ii]
        );
        opt.ii += 1;
    }
    onError(undefined, opt);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.objectAssignDefault" id="apidoc.elem.utility2.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.objectSetDefault" id="apidoc.elem.utility2.objectSetDefault">
        function <span class="apidocSignatureSpan">utility2.</span>objectSetDefault
        <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectSetDefault = function (dict, defaults, depth) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set defaults for undefined-items in dict
 */
</span>    dict = dict || {};
    defaults = defaults || {};
    Object.keys(defaults).forEach(function (key) {
        let defaults2;
        let dict2;
        dict2 = dict[key];
        // handle misbehaving getter
        try {
            defaults2 = defaults[key];
        } catch (ignore) {}
        if (defaults2 === undefined) {
            return;
        }
        // init dict[key] to default value defaults[key]
        switch (dict2) {
        case &quot;&quot;:
        case null:
        case undefined:
            dict[key] = defaults2;
            return;
        }
        // if dict2 and defaults2 are both non-undefined and non-array objects,
        // then recurse with dict2 and defaults2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.objectSetDefault(dict2, defaults2, depth - 1);
        }
    });
    return dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.<span class="apidocCodeKeywordSpan">objectSetDefault</span>(dict2, defaults2, depth - 1);
        }
    });
    return dict;
};

local.stringHtmlSafe = function (text) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.objectSetOverride" id="apidoc.elem.utility2.objectSetOverride">
        function <span class="apidocSignatureSpan">utility2.</span>objectSetOverride
        <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectSetOverride = function (dict, overrides, depth, env) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set overrides for items in dict
 */
</span>    dict = dict || {};
    env = env || (typeof process === &quot;object&quot; &amp;&amp; process.env) || {};
    overrides = overrides || {};
    Object.keys(overrides).forEach(function (key) {
        let dict2;
        let overrides2;
        dict2 = dict[key];
        overrides2 = overrides[key];
        if (overrides2 === undefined) {
            return;
        }
        // if both dict2 and overrides2 are non-undefined and non-array objects,
        // then recurse with dict2 and overrides2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // overrides2 is a non-undefined and non-array object
            &amp;&amp; typeof overrides2 === &quot;object&quot; &amp;&amp; overrides2
            &amp;&amp; !Array.isArray(overrides2)
        ) {
            local.objectSetOverride(dict2, overrides2, depth - 1, env);
            return;
        }
        // else set dict[key] with overrides[key]
        dict[key] = (
            dict === env
            // if dict is env, then overrides falsy-value with empty-string
            ? overrides2 || &quot;&quot;
            : overrides2
        );
    });
    return dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.jsonStringifyOrdered(
local.<span class="apidocCodeKeywordSpan">objectSetOverride</span>(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.on" id="apidoc.elem.utility2.on">
        function <span class="apidocSignatureSpan">utility2.</span>on
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         */
let bufList;
bufList = [];
xhr.resHeaders = resStream.headers || xhr.resHeaders;
xhr.resStream = resStream;
xhr.statusCode = resStream.statusCode;
resStream.dataLength = 0;
resStream.<span class="apidocCodeKeywordSpan">on</span>(&quot;data&quot;, function (buf) {
    bufList.push(buf);
});
resStream.on(&quot;end&quot;, function () {
    xhr.response = (
        local.isBrowser
        ? bufList[0]
        : Buffer.concat(bufList)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorDefault" id="apidoc.elem.utility2.onErrorDefault">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorDefault
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorDefault = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then print it to stderr
 */
</span>    if (err) {
        console.error(err);
    }
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.onParallel(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.<span class="apidocCodeKeywordSpan">onErrorDefault</span>(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
        return true;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorThrow" id="apidoc.elem.utility2.onErrorThrow">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorThrow
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorThrow = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then throw it
 */
</span>    if (err) {
        throw err;
    }
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_onErrorThrow_err = function (opt, onError) {
/*
 * this function will test onErrorThrow&apos;s err handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">onErrorThrow</span>(local.errDefault);
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorWithStack" id="apidoc.elem.utility2.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack.replace((
        /(.*?)\n.*?$/m
    ), &quot;$1&quot;);
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errDefault
            &amp;&amp; String(err.stack).indexOf(stack.split(&quot;\n&quot;)[2]) &lt; 0
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onFileModifiedRestart" id="apidoc.elem.utility2.onFileModifiedRestart">
        function <span class="apidocSignatureSpan">utility2.</span>onFileModifiedRestart
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFileModifiedRestart = function (file) {
<span class="apidocCodeCommentSpan">/*
 * this function will watch the file, and if modified, then restart the process
 */
</span>    if (
        local.env.npm_config_mode_auto_restart
        &amp;&amp; local.fs.existsSync(file)
        &amp;&amp; local.fs.statSync(file).isFile()
    ) {
        local.fs.watchFile(file, {
            interval: 1000,
            persistent: false
        }, function (stat2, stat1) {
            if (stat2.mtime &gt; stat1.mtime) {
                console.error(&quot;file modified - &quot; + file);
                setTimeout(function () {
                    process.exit(77);
                }, 1000);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[
    __dirname + &quot;/lib.jslint.js&quot;,
    __filename,
    &quot;undefined&quot;
].forEach(function (file) {
    local.fs.exists(file, function (exists) {
        if (exists) {
            local.<span class="apidocCodeKeywordSpan">onFileModifiedRestart</span>(file);
        }
    });
});
local.fs.readdirSync(process.cwd()).forEach(function (file) {
    file = process.cwd() + &quot;/&quot; + file;
    // if the file is modified, then restart the process
    local.onFileModifiedRestart(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onParallel" id="apidoc.elem.utility2.onParallel">
        function <span class="apidocSignatureSpan">utility2.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if counter === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement counter
        onParallel.counter -= 1;
        // validate counter
        if (!(onParallel.counter &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.counter = &quot; + onParallel.counter
            );
        // ensure onError is run only once
        } else if (onParallel.counter &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure counter &lt;= 0
            onParallel.counter = -Math.abs(onParallel.counter);
        }
        // call onError when isDone
        if (onParallel.counter &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init counter
    onParallel.counter = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onParallelList" id="apidoc.elem.utility2.onParallelList">
        function <span class="apidocSignatureSpan">utility2.</span>onParallelList
        <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallelList = function (opt, onEach, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. async-run onEach in parallel,
 *    with given &lt;opt&gt;.rateLimit and &lt;opt&gt;.retryLimit
 * 2. call &lt;onError&gt; when onParallel.ii + 1 === &lt;opt&gt;.list.length
 */
</span>    let isListEnd;
    let onEach2;
    let onParallel;
    opt.list = opt.list || [];
    onEach2 = function () {
        while (true) {
            if (!(onParallel.ii + 1 &lt; opt.list.length)) {
                isListEnd = true;
                return;
            }
            if (!(onParallel.counter &lt; opt.rateLimit + 1)) {
                return;
            }
            onParallel.ii += 1;
            onEach({
                elem: opt.list[onParallel.ii],
                ii: onParallel.ii,
                list: opt.list,
                retry: 0
            }, onParallel);
        }
    };
    onParallel = local.onParallel(onError, onEach2, function (err, data) {
        if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
            local.onErrorDefault(err);
            data.retry += 1;
            setTimeout(function () {
                onParallel.counter -= 1;
                onEach(data, onParallel);
            }, 1000);
            return true;
        }
        // restart if opt.list has grown
        if (isListEnd &amp;&amp; (onParallel.ii + 1 &lt; opt.list.length)) {
            isListEnd = undefined;
            onEach2();
        }
    });
    onParallel.ii = -1;
    opt.rateLimit = Number(opt.rateLimit) || 6;
    opt.rateLimit = Math.max(opt.rateLimit, 1);
    opt.retryLimit = Number(opt.retryLimit) || 2;
    onParallel.counter += 1;
    onEach2();
    onParallel();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        method: &quot;DELETE&quot;,
        sha: data.sha,
        url: opt.url
    }, opt.gotoNext);
    return;
}
// delete tree
local.<span class="apidocCodeKeywordSpan">onParallelList</span>({
    list: data
}, function (option2, onParallel) {
    onParallel.counter += 1;
    // recurse
    local.githubCrudContentDelete({
        httpReq: opt.httpReq,
        message: opt.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onTimeout" id="apidoc.elem.utility2.onTimeout">
        function <span class="apidocSignatureSpan">utility2.</span>onTimeout
        <span class="apidocSignatureSpan">(onError, timeout, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onTimeout = function (onError, timeout, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will create &lt;timeout&gt;-handler,
 * that appends current-stack to any err encountered
 */
</span>    onError = local.onErrorWithStack(onError);
    // create timerTimeout
    return setTimeout(function () {
        onError(new Error(&quot;onTimeout - &quot; + timeout + &quot; ms - &quot; + message));
    // coerce to finite integer
    }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;.png&quot;
);
opt.url = opt.url.replace(
    &quot;{{timeExit}}&quot;,
    Date.now() + local.timeoutDefault
);
// init timerTimeout
timerTimeout = local.<span class="apidocCodeKeywordSpan">onTimeout</span>(
    opt.gotoNext,
    local.timeoutDefault,
    testName
);
// create puppeteer browser
local.puppeteerLaunch({
    args: [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.once" id="apidoc.elem.utility2.once">
        function <span class="apidocSignatureSpan">utility2.</span>once
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
if (cb) this.<span class="apidocCodeKeywordSpan">once</span>(&apos;close&apos;, cb);

//
// Terminate all associated clients.
//
if (this.clients) {
  for (const client of this.clients) client.terminate();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.profile" id="apidoc.elem.utility2.profile">
        function <span class="apidocSignatureSpan">utility2.</span>profile
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profile = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will profile async &lt;fnc&gt; in milliseconds
 * with callback &lt;onError&gt;
 */
</span>    let timeStart;
    timeStart = Date.now();
    // run async fnc
    fnc(function (err) {
        // call onError with difference in milliseconds
        // between Date.now() and timeStart
        onError(err, Date.now() - timeStart);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
// validate timeElapsed
local.assertOrThrow(
    0 &lt;= opt.timeElapsed &amp;&amp; opt.timeElapsed &lt; 1000,
    opt.timeElapsed
);
// test profile&apos;s async handling-behavior
local.<span class="apidocCodeKeywordSpan">profile</span>(function (onError) {
    setTimeout(onError);
}, function (err, timeElapsed) {
    // handle err
    local.assertOrThrow(!err, err);
    opt.timeElapsed = timeElapsed;
    // validate timeElapsed
    local.assertOrThrow((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.profileSync" id="apidoc.elem.utility2.profileSync">
        function <span class="apidocSignatureSpan">utility2.</span>profileSync
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profileSync = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will profile sync &lt;fnc&gt; in milliseconds
 */
</span>    let timeStart;
    timeStart = Date.now();
    // run sync fnc
    fnc();
    // return difference in milliseconds between Date.now() and timeStart
    return Date.now() - timeStart;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.testCase_profileXxx_default = function (opt, onError) {
/*
* this function will test profileXxx&apos;s default handling-behavior
*/
   opt = {};
   // test profileSync&apos;s handling-behavior
   opt.timeElapsed = local.<span class="apidocCodeKeywordSpan">profileSync</span>(function () {
       return;
   });
   // validate timeElapsed
   local.assertOrThrow(
       0 &lt;= opt.timeElapsed &amp;&amp; opt.timeElapsed &lt; 1000,
       opt.timeElapsed
   );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteerLaunch" id="apidoc.elem.utility2.puppeteerLaunch">
        function <span class="apidocSignatureSpan">utility2.</span>puppeteerLaunch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppeteerLaunch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init timerTimeout
timerTimeout = local.onTimeout(
    opt.gotoNext,
    local.timeoutDefault,
    testName
);
// create puppeteer browser
local.<span class="apidocCodeKeywordSpan">puppeteerLaunch</span>({
    args: [
        &quot;--headless&quot;,
        &quot;--incognito&quot;,
        &quot;--no-sandbox&quot;,
        &quot;--remote-debugging-port=0&quot;
    ],
    dumpio: !opt.modeSilent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.querySelector" id="apidoc.elem.utility2.querySelector">
        function <span class="apidocSignatureSpan">utility2.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.querySelectorAll" id="apidoc.elem.utility2.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.removeEventListener" id="apidoc.elem.utility2.removeEventListener">
        function <span class="apidocSignatureSpan">utility2.</span>removeEventListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEventListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.<span class="apidocCodeKeywordSpan">removeEventListener
</span>(&quot;load&quot;,this.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),
window.removeEventListener(&quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,
this.a.accelerometerCollector,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent
&amp;&amp;(document.detachEvent(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.removeListener" id="apidoc.elem.utility2.removeListener">
        function <span class="apidocSignatureSpan">utility2.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i &lt; listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.<span class="apidocCodeKeywordSpan">removeListener</span>(method, listeners[i]);
      }
    }
  }
};

exports_websockets_ws_lib_event_target = EventTarget;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.replStart" id="apidoc.elem.utility2.replStart">
        function <span class="apidocSignatureSpan">utility2.</span>replStart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replStart = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will start repl-debugger
 */
</span>    let that;
    if (globalThis.utility2_repl1) {
        return;
    }
    // start repl
    that = require(&quot;repl&quot;).start({
        useGlobal: true
    });
    globalThis.utility2_repl1 = that;
    // save eval-function
    that.evalDefault = that.eval;
    // hook custom-eval-function
    that.eval = function (script, context, file, onError) {
        script.replace((
            /^(\S+)\u0020(.*?)\n/
        ), function (ignore, match1, match2) {
            switch (match1) {
            // syntax-sugar - run shell-command
            case &quot;$&quot;:
                switch (match2) {
                // syntax-sugar - run git diff
                case &quot;git diff&quot;:
                    match2 = &quot;git diff --color | cat&quot;;
                    break;
                // syntax-sugar - run git log
                case &quot;git log&quot;:
                    match2 = &quot;git log -n 4 | cat&quot;;
                    break;
                // syntax-sugar - run ll
                case &quot;ll&quot;:
                    match2 = &quot;ls -Fal&quot;;
                    break;
                }
                // source lib.utility2.sh
                if (
                    process.platform !== &quot;win32&quot;
                    &amp;&amp; process.env.npm_config_dir_utility2 &amp;&amp; (match2 !== &quot;:&quot;)
                ) {
                    match2 = (
                        &quot;. &quot; + process.env.npm_config_dir_utility2
                        + &quot;/lib.utility2.sh;&quot; + match2
                    );
                }
                // run shell-command
                require(&quot;child_process&quot;).spawn(match2, {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                // print exitCode
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&quot;exitCode &quot; + exitCode);
                    that.evalDefault(&quot;\n&quot;, context, file, onError);
                });
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - map text with charCodeAt
            case &quot;charCode&quot;:
                console.error(
                    match2.split(&quot;&quot;).map(function (chr) {
                        return (
                            &quot;\\u&quot;
                            + chr.charCodeAt(0).toString(16).padStart(4, 0)
                        );
                    }).join(&quot;&quot;)
                );
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - sort chr
            case &quot;charSort&quot;:
                console.error(JSON.stringify(match2.split(&quot;&quot;).sort().join(&quot;&quot;)));
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - grep current dir
            case &quot;grep&quot;:
                // run shell-command
                require(&quot;child_process&quot;).spawn((
                    &quot;find . -type f | grep -v -E &quot;
/* jslint ignore:start */
+ &apos;&quot;\
/\\.|~\$|(\\b|_)(\\.\\d|\
archive|artifact|\
bower_component|build|\
coverage|\
doc|\
external|\
fixture|\
git_module|\
jquery|\
log|\
min|misc|mock|\
node_module|\
raw|\rollup|\
swp|\
tmp|\
vendor)s{0,1}(\\b|_)\
&quot; &apos;
/* jslint ignore:end */
                    + &quot;| tr \&quot;\\n\&quot; \&quot;\\000\&quot; | xargs -0 grep -HIin -E \&quot;&quot;
                    + match2 + &quot;\&quot;&quot;
                ), {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&quot;exitCode &quot; + exitCode);
                    that.evalDefault(&quot;\n&quot;, context, file, onError);...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict[&quot;utility2.start&quot;] = function () {
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.<span class="apidocCodeKeywordSpan">replStart</span>();
   local.testRunServer({});
};

local.cliDict[&quot;utility2.swaggerValidateFile&quot;] = function () {
/*
* &lt;file/url&gt;
* will swagger-validate file/url
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.requireReadme" id="apidoc.elem.utility2.requireReadme">
        function <span class="apidocSignatureSpan">utility2.</span>requireReadme
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireReadme = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will require and export example.js embedded in README.md
 */
</span>    let code;
    let module;
    let tmp;
    // init module.exports
    module = {};
    if (local.isBrowser) {
        module.exports = local.objectSetDefault(
            globalThis.utility2_rollup || globalThis.local,
            local
        );
        return module.exports;
    }
    // start repl-debugger
    local.replStart();
    // debug dir
    [
        __dirname + &quot;/lib.jslint.js&quot;,
        __filename,
        &quot;undefined&quot;
    ].forEach(function (file) {
        local.fs.exists(file, function (exists) {
            if (exists) {
                local.onFileModifiedRestart(file);
            }
        });
    });
    local.fs.readdirSync(process.cwd()).forEach(function (file) {
        file = process.cwd() + &quot;/&quot; + file;
        // if the file is modified, then restart the process
        local.onFileModifiedRestart(file);
        switch (local.path.basename(file)) {
        // swagger-validate assets.swgg.swagger.json
        case &quot;assets.swgg.swagger.json&quot;:
            local.fs.readFile(file, &quot;utf8&quot;, function (err, data) {
                local.tryCatchOnError(function () {
                    // handle err
                    local.assertOrThrow(!err, err);
                    local.swgg.swaggerValidate(JSON.parse(data));
                }, local.onErrorDefault);
            });
            break;
        }
    });
    // jslint process.cwd()
    if (!local.env.npm_config_mode_library) {
        local.child_process.spawn(&quot;node&quot;, [
            &quot;-e&quot;, (
                &quot;require(&quot;
                + JSON.stringify(__filename)
                + &quot;).jslint.jslintAndPrintDir(&quot;
                + JSON.stringify(process.cwd())
                + &quot;, {autofix:true,conditional:true}, process.exit);&quot;
            )
        ], {
            env: Object.assign({}, local.env, {
                npm_config_mode_library: &quot;1&quot;
            }),
            stdio: [
                &quot;ignore&quot;, &quot;ignore&quot;, 2
            ]
        });
    }
    if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
        // init assets
        local.assetsDict[&quot;/index.html&quot;] = (
            local.fsReadFileOrEmptyStringSync(&quot;index.html&quot;)
            || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
        );
        local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
        local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
            __filename,
            &quot;utf8&quot;
        ).replace((
            /^#!\//
        ), &quot;// &quot;);
        // init exports
        local[local.env.npm_package_nameLib] = local;
        module.exports = local;
        return module.exports;
    }
    // init file $npm_package_main
    globalThis.utility2_moduleExports = require(
        process.cwd() + &quot;/&quot; + local.env.npm_package_main
    );
    globalThis.utility2_moduleExports.globalThis = globalThis;
    // read code from README.md
    code = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.example.template.js&quot;],
        {}
    );
    local.tryCatchOnError(function () {
        tmp = (
            /```\w*?(\n[\W\s]*?example\.js[\n&quot;][\S\s]*?)\n```/
        ).exec(
            local.fs.readFileSync(&quot;README.md&quot;, &quot;utf8&quot;)
        );
        code = tmp.input.slice(0, tmp.index).replace((
            /.+/g
        ), &quot;&quot;) + tmp[1];
    }, local.nop);
    // alias require($npm_package_name) to utility2_moduleExports;
    code = code.replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_name + &quot;.\\)&quot;),
        &quot;globalThis.utility2_moduleExports&quot;
    ).replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_nameOriginal + &quot;.\\)&quot;),
        &quot;globalThis.uti...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
\n\
\n\
\n\
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.<span class="apidocCodeKeywordSpan">requireReadme</span>();\n\
globalThis.local = local;\n\
// init test\n\
local.testRunDefault(local);\n\
}());\n\
\n\
\n\
\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.semverCompare" id="apidoc.elem.utility2.semverCompare">
        function <span class="apidocSignatureSpan">utility2.</span>semverCompare
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">semverCompare = function (aa, bb) {
<span class="apidocCodeCommentSpan">/*
 * this function will compare semver versions aa ? bb and return
 * -1 if aa &lt; bb
 *  0 if aa = bb
 *  1 if aa &gt; bb
 * https://semver.org/#spec-item-11
 * example usage:
    semverCompare(&quot;2.2.2&quot;, &quot;10.2.2&quot;); // -1
    semverCompare(&quot;1.2.3&quot;, &quot;1.2.3&quot;);  //  0
    semverCompare(&quot;10.2.2&quot;, &quot;2.2.2&quot;); //  1
 */
</span>    let ii;
    let len;
    [
        aa, bb
    ] = [
        aa, bb
    ].map(function (val) {
        val = (
            /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z\-][0-9a-zA-Z\-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA
-Z\-][0-9a-zA-Z\-]*))*))?(?:\+([0-9a-zA-Z\-]+(?:\.[0-9a-zA-Z\-]+)*))?$/
        ).exec(val) || [
            &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;
        ];
        val[4] = val[4] || &quot;&quot;;
        return val.slice(1, 4).concat(val[4].split(&quot;.&quot;));
    });
    ii = -1;
    len = Math.max(aa.length, bb.length);
    while (true) {
        ii += 1;
        if (ii &gt;= len) {
            return 0;
        }
        aa[ii] = aa[ii] || &quot;&quot;;
        bb[ii] = bb[ii] || &quot;&quot;;
        if (ii === 3 &amp;&amp; aa[ii] !== bb[ii]) {
            // 1.2.3 &gt; 1.2.3-alpha
            if (!aa[ii]) {
                return 1;
            }
            // 1.2.3-alpha &lt; 1.2.3
            if (!bb[ii]) {
                return -1;
            }
        }
        if (aa[ii] !== bb[ii]) {
            aa = aa[ii];
            bb = bb[ii];
            return (
                Number(aa) &lt; Number(bb)
                ? -1
                : Number(aa) &gt; Number(bb)
                ? 1
                : aa &lt; bb
                ? -1
                : 1
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
), &quot;.&quot;));
bb = String(process.argv[2] || &quot;0.0.0&quot;).replace((
    /^(\d+?\.\d+?\.)(\d+)(\.*?)$/
), function (ignore, match1, match2, match3) {
    return match1 + (Number(match2) + 1) + match3;
});
packageJson.version = (
    local.<span class="apidocCodeKeywordSpan">semverCompare</span>(aa, bb) === 1
    ? aa
    : bb
);
console.error([
    aa, bb, packageJson.version
]);
// update package.json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverLocalReqHandler" id="apidoc.elem.utility2.serverLocalReqHandler">
        function <span class="apidocSignatureSpan">utility2.</span>serverLocalReqHandler
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverLocalReqHandler = function (req, res) {
    let that;
    that = {};
    local.gotoNext(that, function (err) {
        if (err || that.gotoState &gt;= local.middlewareList.length) {
            local.middlewareError(err, req, res);
            return;
        }
        // recurse with next middleware in middlewareList
        local.middlewareList[that.gotoState](req, res, that.gotoNext);
    });
    that.gotoState = -1;
    that.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isDone) {
        return;
    }
    isDone = true;
    data = _data;
    // async send req from client to server
    setTimeout(function () {
        local.<span class="apidocCodeKeywordSpan">serverLocalReqHandler</span>(req, res);
    });
},
headers: xhr.headers,
method: xhr.method,
on: function () {
    return xhr;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverLocalUrlTest" id="apidoc.elem.utility2.serverLocalUrlTest">
        function <span class="apidocSignatureSpan">utility2.</span>serverLocalUrlTest
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverLocalUrlTest = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will test if the url is local
 */
</span>    url = local.urlParse(url).pathname;
    return local.isBrowser &amp;&amp; !local.env.npm_config_mode_backend &amp;&amp; (
        /^\/test\./
    ).test(url);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    xhr.resHeaders = {};
    xhr.timeStart = xhr.timeStart || Date.now();
};
// init xhr - XMLHttpRequest
xhr = (
    local.isBrowser
    &amp;&amp; !opt.httpReq
    &amp;&amp; !(local2.serverLocalUrlTest &amp;&amp; local2.<span class="apidocCodeKeywordSpan">serverLocalUrlTest</span>(opt.url
))
    &amp;&amp; new XMLHttpRequest()
);
// init xhr - http.request
if (!xhr) {
    xhr = local.identity(local2.urlParse || require(&quot;url&quot;).parse)(opt.url);
    // init xhr
    xhrInit();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondCors" id="apidoc.elem.utility2.serverRespondCors">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondCors
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondCors = function (req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will enable cors for the req
 * http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
 */
</span>    local.serverRespondHeadSet(req, res, undefined, local.jsonCopy({
        &quot;access-control-allow-headers&quot;:
        req.headers[&quot;access-control-request-headers&quot;],
        &quot;access-control-allow-methods&quot;:
        req.headers[&quot;access-control-request-method&quot;],
        &quot;access-control-allow-origin&quot;: &quot;*&quot;
    }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let onError;
let opt;
let timerTimeout;
// handle preflight-cors
if (req.method === &quot;OPTIONS&quot; &amp;&amp; (
    /forward-proxy-url/
).test(req.headers[&quot;access-control-request-headers&quot;])) {
    local.<span class="apidocCodeKeywordSpan">serverRespondCors</span>(req, res);
    res.end();
    return;
}
if (!req.headers[&quot;forward-proxy-url&quot;]) {
    next();
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondDefault" id="apidoc.elem.utility2.serverRespondDefault">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondDefault
        <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondDefault = function (req, res, statusCode, err) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with a default message,
 * or &lt;err&gt;.stack for given statusCode
 */
</span>    // init statusCode and contentType
    local.serverRespondHeadSet(
        req,
        res,
        statusCode,
        {
            &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;
        }
    );
    if (err) {
        // debug statusCode / method / url
        local.errorMessagePrepend(
            err,
            res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url
            + &quot;\n&quot;
        );
        // print err.stack to stderr
        local.onErrorDefault(err);
        // end res with err.stack
        res.end(err.stack);
        return;
    }
    // end res with default statusCode message
    res.end(
        statusCode + &quot; &quot; + local.http.STATUS_CODES[statusCode]
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opt.gotoNext(null, data, meta);
    }
    break;
case 3:
    switch (crud.crudType[0]) {
    case &quot;fileGetOneById&quot;:
        if (!data) {
            local.<span class="apidocCodeKeywordSpan">serverRespondDefault</span>(req, res, 404);
            return;
        }
        local.serverRespondHeadSet(req, res, null, {
            &quot;Content-Type&quot;: data.fileContentType
        });
        res.end(local.base64ToBuffer(data.fileBlob));
        break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondEcho" id="apidoc.elem.utility2.serverRespondEcho">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondEcho
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondEcho = function (req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with debug info
 */
</span>    res.write(
        req.method + &quot; &quot; + req.url
        + &quot; HTTP/&quot; + req.httpVersion + &quot;\r\n&quot;
        + Object.keys(req.headers).map(function (key) {
            return key + &quot;: &quot; + req.headers[key] + &quot;\r\n&quot;;
        }).join(&quot;&quot;) + &quot;\r\n&quot;
    );
    req.pipe(res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;
// test http POST handling-behavior
case &quot;/test.echo&quot;:
    // test res-header handling-behavior
    local.serverRespondHeadSet(req, res, null, {
        &quot;X-Res-Header-Test&quot;: &quot;bb&quot;
    });
    local.<span class="apidocCodeKeywordSpan">serverRespondEcho</span>(req, res);
    break;
// test 500-internal-server-error handling-behavior
case &quot;/test.err-500&quot;:
    // test multiple-callback serverRespondHeadSet handling-behavior
    local.serverRespondHeadSet(req, res, null, {});
    next(local.errDefault);
    // test multiple-callback-error handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondHeadSet" id="apidoc.elem.utility2.serverRespondHeadSet">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondHeadSet
        <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondHeadSet = function (ignore, res, statusCode, headers) {
<span class="apidocCodeCommentSpan">/*
 * this function will set the &lt;res&gt; object&apos;s &lt;statusCode&gt; and &lt;headers&gt;
 */
</span>    if (res.headersSent) {
        return;
    }
    // init res.statusCode
    if (Number(statusCode)) {
        res.statusCode = Number(statusCode);
    }
    Object.keys(headers).forEach(function (key) {
        if (headers[key]) {
            res.setHeader(key, headers[key]);
        }
    });
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
    local.dbTableFile.crudSetManyById(crud.body, opt.gotoNext);
    break;
case &quot;userLoginByPassword&quot;:
case &quot;userLogout&quot;:
    // respond with 401 Unauthorized
    if (!user.isAuthenticated) {
        local.<span class="apidocCodeKeywordSpan">serverRespondHeadSet</span>(req, res, 401, {});
        req.swgg.crud.endArgList = [
            req, res
        ];
        opt.gotoState = Infinity;
        opt.gotoNext();
        return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondTimeoutDefault" id="apidoc.elem.utility2.serverRespondTimeoutDefault">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondTimeoutDefault
        <span class="apidocSignatureSpan">(req, res, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondTimeoutDefault = function (req, res, timeout) {
<span class="apidocCodeCommentSpan">/*
 * this function will create &lt;timeout&gt;-handler for server-&lt;req&gt;
 */
</span>    let isDone;
    let onError;
    onError = function () {
        if (isDone) {
            return;
        }
        isDone = true;
        // debug res
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(req.timeStart).toISOString(),
            type: &quot;serverResponse&quot;,
            method: req.method,
            url: req.url,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - req.timeStart,
            // extra
            reqContentLength: req.dataLength || 0,
            resContentLength: res.contentLength,
            reqHeaderXForwardedFor: req.headers[&quot;x-forwarded-for&quot;] || &quot;&quot;,
            reqHeaderOrigin: req.headers.origin || &quot;&quot;,
            reqHeaderReferer: req.headers.referer || &quot;&quot;,
            reqHeaderUserAgent: req.headers[&quot;user-agent&quot;]
        }));
        // cleanup timerTimeout
        clearTimeout(req.timerTimeout);
    };
    req.timeStart = Date.now();
    req.onTimeout = req.onTimeout || function (err) {
        local.serverRespondDefault(req, res, 500, err);
        setTimeout(function () {
            // cleanup &lt;req&gt; and &lt;res&gt;
            local.streamCleanup(req);
            local.streamCleanup(res);
        }, 1000);
    };
    // init timerTimeout
    req.timerTimeout = local.onTimeout(
        req.onTimeout,
        timeout || local.timeoutDefault,
        &quot;server &quot; + req.method + &quot; &quot; + req.url
    );
    res.contentLength = 0;
    res.writeContentLength = res.writeContentLength || res.write;
    res.write = function (buf, encoding, callback) {
        buf = local.bufferValidateAndCoerce(buf, typeof buf);
        res.contentLength += buf.length;
        res.writeContentLength(buf, encoding, callback);
    };
    res.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local._debugServerReqRes3 = local._debugServerReqRes2;
local._debugServerReqRes2 = local._debugServerReqRes1;
local._debugServerReqRes1 = {
    req,
    res
};
// init timerTimeout
local.<span class="apidocCodeKeywordSpan">serverRespondTimeoutDefault</span>(req, res, local.timeoutDefault);
// init req.urlParsed
req.urlParsed = local.urlParse(req.url);
// init res-header content-type
local.serverRespondHeadSet(req, res, undefined, {
    &quot;Content-Type&quot;: local.contentTypeDict[(
        /\.[^.]*?$|$/m
    ).exec(req.urlParsed.pathname)[0]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.setTimeoutOnError" id="apidoc.elem.utility2.setTimeoutOnError">
        function <span class="apidocSignatureSpan">utility2.</span>setTimeoutOnError
        <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeoutOnError = function (onError, timeout, err, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will after timeout has passed,
 * then call &lt;onError&gt;(&lt;err&gt;, &lt;data&gt;)
 */
</span>    if (typeof onError === &quot;function&quot;) {
        setTimeout(function () {
            onError(err, data);
        }, timeout);
    }
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           element.querySelector(
               &quot;[tabIndex]&quot;
           ).focus();
           // validate input
           local.uiEventListenerDict.onEventInputValidateAndAjax({
               targetOnEvent: element
           });
           local.<span class="apidocCodeKeywordSpan">setTimeoutOnError</span>(onError, 0, null, element);
       }
   );
};

local.uiEventListenerDict.onEventResourceDisplayAction = function (evt) {
/*
* this function will toggle the display of the resource
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng" id="apidoc.elem.utility2.sjcl.prng">
        function <span class="apidocSignatureSpan">utility2.</span>sjcl.prng
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b
=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this
.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHashScryptCreate" id="apidoc.elem.utility2.sjclHashScryptCreate">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHashScryptCreate
        <span class="apidocSignatureSpan">(password, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashScryptCreate = function (password, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a scrypt-hash of the password
 * with given &lt;opt&gt; (default = $s0$10801)
 * e.g.
 * $s0$e0801$epIxT/h6HbbwHaehFnh/bw==$7H0vs
 * XlY8UxxyW/BWx/9GuY7jEvGjT71GFd6O4SZND0=
 * https://github.com/wg/scrypt
 */
</span>    // init opt
    opt = String(opt || &quot;$s0$10801&quot;).split(&quot;$&quot;);
    // init salt
    if (!opt[3]) {
        opt[3] = local.sjcl.codec.base64.fromBits(
            local.sjcl.random.randomWords(4, 0)
        );
    }
    // init hash
    opt[4] = local.sjcl.codec.base64.fromBits(
        local.sjcl.misc.scrypt(
            password || &quot;&quot;,
            local.sjcl.codec.base64.toBits(opt[3]),
            Math.pow(2, parseInt(opt[2].slice(0, 1), 16)),
            parseInt(opt[2].slice(1, 2), 16),
            parseInt(opt[2].slice(3, 4), 16)
        )
    );
    return opt.slice(0, 5).join(&quot;$&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.sjclHashScryptValidate = function (password, hash) {
/*
* this function will validate the password against the scrypt-hash
* https://github.com/wg/scrypt
*/
   return local.<span class="apidocCodeKeywordSpan">sjclHashScryptCreate</span>(password, hash) === hash;
};

local.sjclHashSha1Create = function (data) {
/*
* this function will create a base64-encoded sha1 hash of the string data
*/
   return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha1.hash(data));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHashScryptValidate" id="apidoc.elem.utility2.sjclHashScryptValidate">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHashScryptValidate
        <span class="apidocSignatureSpan">(password, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashScryptValidate = function (password, hash) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the password against the scrypt-hash
 * https://github.com/wg/scrypt
 */
</span>    return local.sjclHashScryptCreate(password, hash) === hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.gotoState = Infinity;
    opt.gotoNext();
    break;
case 2:
    switch (crud.crudType[0]) {
    case &quot;userLoginByPassword&quot;:
        user.data = data;
        if (!local.<span class="apidocCodeKeywordSpan">sjclHashScryptValidate</span>(
            user.password,
            user.data &amp;&amp; user.data.password
        )) {
            opt.gotoState = Infinity;
            opt.gotoNext();
            return;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHashSha1Create" id="apidoc.elem.utility2.sjclHashSha1Create">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHashSha1Create
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashSha1Create = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha1 hash of the string data
 */
</span>    return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha1.hash(data));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_sjclHashShaXxxCreate_default = function (opt, onError) {
/*
* this function will test sjclHashShaXxxCreate&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">sjclHashSha1Create</span>(&quot;aa&quot;),
       &quot;4MkDWJjdUvxlxBRUzsnE0mEb+zc=&quot;
   );
   local.assertJsonEqual(
       local.sjclHashSha256Create(&quot;aa&quot;),
       &quot;lhtt0+3jy47LqsvWjeBAzXjrLtWIkTDM60xJJo6k1QY=&quot;
   );
   onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHashSha256Create" id="apidoc.elem.utility2.sjclHashSha256Create">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHashSha256Create
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashSha256Create = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha256 hash of the string data
 */
</span>    return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha256.hash(data));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will test sjclHashShaXxxCreate&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.sjclHashSha1Create(&quot;aa&quot;),
        &quot;4MkDWJjdUvxlxBRUzsnE0mEb+zc=&quot;
    );
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">sjclHashSha256Create</span>(&quot;aa&quot;),
        &quot;lhtt0+3jy47LqsvWjeBAzXjrLtWIkTDM60xJJo6k1QY=&quot;
    );
    onError(undefined, opt);
};

local.testCase_sjclHmacShaXxx_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHmacSha1Create" id="apidoc.elem.utility2.sjclHmacSha1Create">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHmacSha1Create
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHmacSha1Create = function (key, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha1 hmac
 * from the string key and string data
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    return local.sjcl.codec.base64.fromBits(
        (new Hmac(
            local.sjcl.codec.utf8String.toBits(key),
            local.sjcl.hash.sha1
        )).mac(local.sjcl.codec.utf8String.toBits(data))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_sjclHmacShaXxx_default = function (opt, onError) {
/*
* this function will test sjclHmacShaXxx&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">sjclHmacSha1Create</span>(&quot;aa&quot;, &quot;bb&quot;),
       &quot;15pOinCz63A+qZoxnv+mJB6UF1k=&quot;
   );
   local.assertJsonEqual(
       local.sjclHmacSha256Create(&quot;aa&quot;, &quot;bb&quot;),
       &quot;94Xv3VdPHA+ohKyjkM1pb0W5ZVAuMVcmIAAI2AqNRCQ=&quot;
   );
   onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjclHmacSha256Create" id="apidoc.elem.utility2.sjclHmacSha256Create">
        function <span class="apidocSignatureSpan">utility2.</span>sjclHmacSha256Create
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHmacSha256Create = function (key, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha256 hmac
 * from the string key and string data
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    return local.sjcl.codec.base64.fromBits(
        (new Hmac(
            local.sjcl.codec.utf8String.toBits(key),
            local.sjcl.hash.sha256
        )).mac(local.sjcl.codec.utf8String.toBits(data))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will test sjclHmacShaXxx&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.sjclHmacSha1Create(&quot;aa&quot;, &quot;bb&quot;),
        &quot;15pOinCz63A+qZoxnv+mJB6UF1k=&quot;
    );
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">sjclHmacSha256Create</span>(&quot;aa&quot;, &quot;bb&quot;),
        &quot;94Xv3VdPHA+ohKyjkM1pb0W5ZVAuMVcmIAAI2AqNRCQ=&quot;
    );
    onError(undefined, opt);
};

local.testCase_stringHtmlSafe_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stateInit" id="apidoc.elem.utility2.stateInit">
        function <span class="apidocSignatureSpan">utility2.</span>stateInit
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stateInit = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will init state &lt;opt&gt;
 */
</span>    local.objectSetOverride(local, opt, 10);
    // init swgg
    local.swgg.apiUpdate(local.swgg.swaggerJson);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   local.fsReadFileOrEmptyStringSync(&quot;assets.swgg.swagger.json&quot;)
   || local.assetsDict[&quot;/assets.swgg.swagger.json&quot;]
   || local.assetsDict[&quot;/assets.swgg.swagger.petstore.json&quot;]
);
// hack-coverage - test testRunServer&apos;s multiple-call handling-behavior
local.testRunServer(local);
// hack-coverage - stateInit
local.<span class="apidocCodeKeywordSpan">stateInit</span>({});
// init test-middleware
local.middlewareList.push(function (req, res, next) {
/*
* this function will run the test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stream" id="apidoc.elem.utility2.stream">
        function <span class="apidocSignatureSpan">utility2.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.streamCleanup" id="apidoc.elem.utility2.streamCleanup">
        function <span class="apidocSignatureSpan">utility2.</span>streamCleanup
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamCleanup = function (stream) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to end or destroy the stream
 */
</span>    let err;
    // try to end the stream
    try {
        stream.end();
    } catch (errCaught) {
        err = errCaught;
    }
    // if err, then try to destroy the stream
    if (err) {
        try {
            stream.destroy();
        } catch (ignore) {}
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // extra
        headers: opt.headers
    }));
    if (!err) {
        return;
    }
    // cleanup clientReq and clientRes
    local.<span class="apidocCodeKeywordSpan">streamCleanup</span>(opt.clientReq);
    local.streamCleanup(opt.clientReq);
    next(err);
};
// init opt
opt = local.urlParse(req.headers[&quot;forward-proxy-url&quot;]);
opt.method = req.method;
opt.url = req.headers[&quot;forward-proxy-url&quot;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringHtmlSafe" id="apidoc.elem.utility2.stringHtmlSafe">
        function <span class="apidocSignatureSpan">utility2.</span>stringHtmlSafe
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringHtmlSafe = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will make the text html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
</span>    return text.replace((
        /&amp;/g
    ), &quot;&amp;&quot;).replace((
        /&quot;/g
    ), &quot;&quot;&quot;).replace((
        /&apos;/g
    ), &quot;&apos;&quot;).replace((
        /&lt;/g
    ), &quot;&lt;&quot;).replace((
        /&gt;/g
    ), &quot;&gt;&quot;).replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/ig
    ), &quot;&amp;$1&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
// handle case where module is a function
elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
if (elem.typeof !== &quot;function&quot;) {
    return elem;
}
// init source
elem.source = local.<span class="apidocCodeKeywordSpan">stringHtmlSafe</span>(
    trimStart(toString(module[key])) || &quot;n/a&quot;
).replace((
    /\([\S\s]*?\)/
), function (match0) {
    // init signature
    elem.signature = match0.replace((
        /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringMerge" id="apidoc.elem.utility2.stringMerge">
        function <span class="apidocSignatureSpan">utility2.</span>stringMerge
        <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringMerge = function (str1, str2, rgx) {
<span class="apidocCodeCommentSpan">/*
 * this function will merge &lt;str2&gt; into &lt;str1&gt;,
 * for sections where both match &lt;rgx&gt;
 */
</span>    str2.replace(rgx, function (match2) {
        str1.replace(rgx, function (match1) {
            str1 = str1.replace(match1, function () {
                return match2;
            });
            return &quot;&quot;;
        });
        return &quot;&quot;;
    });
    return str1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
    ),
    // customize body after /* validateLineSortedReset */
    (
        /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
    )
].forEach(function (rgx) {
    opt.dataTo = local.<span class="apidocCodeKeywordSpan">stringMerge</span>(opt.dataTo, opt.dataFrom, rgx);
});
// customize local for assets.utility2.rollup.js
if (
    local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
    &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
) {
    opt.dataTo = opt.dataTo.replace(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringQuotedToAscii" id="apidoc.elem.utility2.stringQuotedToAscii">
        function <span class="apidocSignatureSpan">utility2.</span>stringQuotedToAscii
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringQuotedToAscii = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will replace non-ascii-chr to unicode-escaped-ascii-chr
 * in quoted-&lt;str&gt;
 */
</span>    return str.replace((
        /\r/g
    ), &quot;\\r&quot;).replace((
        /\t/g
    ), &quot;\\t&quot;).replace((
        /[^\n\u0020-\u007e]/g
    ), function (chr) {
        return &quot;\\u&quot; + (&quot;0000&quot; + chr.charCodeAt(0).toString(16)).slice(-4);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_stringQuotedToAscii_default = function (opt, onError) {
/*
 * this function will test stringQuotedToAscii&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">stringQuotedToAscii</span>(local.stringHelloEmoji),
        &quot;hello \\ud83d\\ude01\n&quot;
    );
    onError(undefined, opt);
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringRegexpEscape" id="apidoc.elem.utility2.stringRegexpEscape">
        function <span class="apidocSignatureSpan">utility2.</span>stringRegexpEscape
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringRegexpEscape = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will regexp-escape text
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
 */
</span>    return text.replace((
        /[\-\/\\\^$*+?.()|\[\]{}]/g
    ), &quot;\\$&amp;&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
* this function will test stringRegexpEscape&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">stringRegexpEscape</span>(local.stringCharsetAscii),
       (
           &quot;\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007&quot;
           + &quot;\b\t\n\u000b\f\r\u000e\u000f&quot;
           + &quot;\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017&quot;
           + &quot;\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f&quot;
           + &quot; !\&quot;#\\$%&amp;&apos;\\(\\)\\*\\+,\\-\\.\\/0123456789:;&lt;=&gt;\\?@&quot;
           + &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]\\^_`&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringTruncate" id="apidoc.elem.utility2.stringTruncate">
        function <span class="apidocSignatureSpan">utility2.</span>stringTruncate
        <span class="apidocSignatureSpan">(text, maxLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTruncate = function (text, maxLength) {
<span class="apidocCodeCommentSpan">/*
 * this function will truncate text to given maxLength
 */
</span>    return (
        text.length &gt; maxLength
        ? text.slice(0, maxLength - 3).trimEnd() + &quot;...&quot;
        : text
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
].forEach(function (ii) {
    opt[&quot;prefix&quot; + ii] = opt.prefix[ii] + opt.prefix.slice(
        ii + 1
    ).map(function (element) {
        return &quot;[&quot; + JSON.stringify(element) + &quot;]&quot;;
    }).join(&quot;&quot;);
});
opt.prefix0 += &quot; = &quot; + local.<span class="apidocCodeKeywordSpan">stringTruncate</span>(
    JSON.stringify(opt.data) || &quot;undefined&quot;,
    100
);
opt.schema2 = local.stringTruncate(
    JSON.stringify(opt.schema) || &quot;undefined&quot;,
    500
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringUniqueKey" id="apidoc.elem.utility2.stringUniqueKey">
        function <span class="apidocSignatureSpan">utility2.</span>stringUniqueKey
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringUniqueKey = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a string-key that is unique in given text
 */
</span>    let key;
    // seed the key with the least frequent letters in the english-language
    // https://en.wikipedia.org/wiki/Letter_frequency
    key = &quot;zqxj&quot;;
    do {
        key += Number(
            (1 + Math.random()) * 0x10000000000000
        ).toString(36).slice(1);
    } while (text.indexOf(key) &gt;= 0);
    return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let arg;
let argList;
let doubleBackslash;
let opt;
let quote;
arg = &quot;&quot;;
argList = [];
doubleBackslash = local.<span class="apidocCodeKeywordSpan">stringUniqueKey</span>(text);
// parse doubleBackslash
text = text.replace((
    /\\\\/g
), doubleBackslash);
// parse line-continuation
text = text.replace((
    /\\\n/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.templateRender" id="apidoc.elem.utility2.templateRender">
        function <span class="apidocSignatureSpan">utility2.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &apos;unless&apos; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in the template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.templateRenderMyApp" id="apidoc.elem.utility2.templateRenderMyApp">
        function <span class="apidocSignatureSpan">utility2.</span>templateRenderMyApp
        <span class="apidocSignatureSpan">(template, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRenderMyApp = function (template, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will render my-app-lite template with given &lt;opt&gt;.packageJson
 */
</span>    opt.packageJson = local.fsReadFileOrEmptyStringSync(&quot;package.json&quot;, &quot;json&quot;);
    local.objectSetDefault(opt.packageJson, {
        nameLib: opt.packageJson.name.replace((
            /\W/g
        ), &quot;_&quot;),
        repository: {
            url: (
                &quot;https://github.com/kaizhu256/node-&quot;
                + opt.packageJson.name
                + &quot;.git&quot;
            )
        }
    }, 2);
    opt.githubRepo = opt.packageJson.repository.url.replace((
        /\.git$/
    ), &quot;&quot;).split(&quot;/&quot;).slice(-2);
    template = template.replace((
        /kaizhu256(\.github\.io\/|%252F|\/)/g
    ), opt.githubRepo[0] + (&quot;$1&quot;));
    template = template.replace((
        /node-my-app-lite/g
    ), opt.githubRepo[1]);
    template = template.replace((
        /\bh1-my-app\b/g
    ), (
        opt.packageJson.nameHeroku
        || (&quot;h1-&quot; + opt.packageJson.nameLib.replace((
            /_/g
        ), &quot;-&quot;))
    ));
    template = template.replace((
        /my-app-lite/g
    ), opt.packageJson.name);
    template = template.replace((
        /my_app/g
    ), opt.packageJson.nameLib);
    template = template.replace((
        /\{\{packageJson\.(\S+)\}\}/g
    ), function (ignore, match1) {
        return opt.packageJson[match1];
    });
    return template;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let result;
local.objectSetDefault(opt, {
    customize: local.nop,
    dataFrom: local.fsReadFileOrEmptyStringSync(
        &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
        &quot;utf8&quot;
    ),
    dataTo: local.<span class="apidocCodeKeywordSpan">templateRenderMyApp</span>(
        local.assetsDict[&quot;/assets.my_app.template.js&quot;],
        opt
    )
});
// search-and-replace - customize dataTo
[
    // customize top-level comment-description
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testMock" id="apidoc.elem.utility2.testMock">
        function <span class="apidocSignatureSpan">utility2.</span>testMock
        <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testMock = function (mockList, onTestCase, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will mock the objects in mockList while running the onTestCase
 */
</span>    let onError2;
    onError2 = function (err) {
        // restore mock[0] from mock[2]
        mockList.reverse().forEach(function (mock) {
            Object.keys(mock[2]).forEach(function (key) {
                mock[0][key] = mock[2][key];
            });
        });
        onError(err);
    };
    // suppress console.error and console.log
    if (!(mockList[0] &amp;&amp; mockList[0][0] === console)) {
        mockList.unshift([
            console, {}
        ]);
    }
    local.objectSetDefault(mockList[0][1], {
        error: local.nop,
        log: local.nop
    });
    // mock-objects
    mockList.forEach(function (mock) {
        mock[2] = {};
        // backup mock[0] into mock[2]
        Object.keys(mock[1]).forEach(function (key) {
            mock[2][key] = (
                (
                    typeof process === &quot;object&quot;
                    &amp;&amp; process.env === mock[0]
                    &amp;&amp; mock[0][key] === undefined
                )
                // handle process.env
                ? &quot;&quot;
                : mock[0][key]
            );
        });
        // override mock[0] with mock[1]
        Object.keys(mock[1]).forEach(function (key) {
            mock[0][key] = mock[1][key];
        });
    });
    // try to call onError with mock-objects
    local.tryCatchOnError(function () {
        // run onTestCase
        onTestCase(onError2);
    }, onError2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                };
            }
        });
        mockList.push([
            tmp, mockDict
        ]);
    });
    local.<span class="apidocCodeKeywordSpan">testMock</span>(mockList, function (onError) {
        local.tryCatchOnError(function () {
            exports = require(file);
        }, local.onErrorDefault);
        onError();
    }, local.onErrorThrow);
    return exports;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testReportCreate" id="apidoc.elem.utility2.testReportCreate">
        function <span class="apidocSignatureSpan">utility2.</span>testReportCreate
        <span class="apidocSignatureSpan">(testReport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportCreate = function (testReport) {
<span class="apidocCodeCommentSpan">/*
 * this function will create test-report artifacts
 */
</span>    testReport = local.objectSetDefault(testReport, {
        testPlatformList: []
    });
    // print test-report summary
    console.error(
        &quot;\n&quot; + new Array(56).join(&quot;-&quot;)
        + &quot;\n&quot; + testReport.testPlatformList.filter(function (testPlatform) {
            // if testPlatform has no tests, then filter it out
            return testPlatform.testCaseList.length;
        }).map(function (testPlatform) {
            return (
                &quot;| test-report - &quot; + testPlatform.name + &quot;\n|&quot;
                + String(
                    testPlatform.timeElapsed + &quot; ms     &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsFailed + &quot; failed &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsPassed + &quot; passed &quot;
                ).padStart(16, &quot; &quot;)
                + &quot;     |\n&quot; + new Array(56).join(&quot;-&quot;)
            );
        }).join(&quot;\n&quot;) + &quot;\n&quot;
    );
    // create test-report.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/test-report.html&quot;,
        local.testReportMerge(testReport)
    );
    // create build.badge.svg
    local.fs.writeFileSync(
        &quot;tmp/build/build.badge.svg&quot;,
        local.assetsDict[&quot;/assets.buildBadge.template.svg&quot;].replace((
            /0000-00-00\u002000:00:00\u0020UTC\u0020-\u0020master\u0020-\u0020aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/g
        ), (
            new Date().toISOString().slice(0, 19).replace(&quot;T&quot;, &quot; &quot;)
            + &quot; - &quot; + local.env.CI_BRANCH + &quot; - &quot; + local.env.CI_COMMIT_ID
        ))
    );
    // create test-report.badge.svg
    local.fs.writeFileSync(
        &quot;tmp/build/test-report.badge.svg&quot;,
        local.assetsDict[&quot;/assets.testReportBadge.template.svg&quot;].replace((
            // edit number of tests failed
            /999/g
        ), testReport.testsFailed).replace((
            // edit badge color
            /d00/g
        ), (
            testReport.testsFailed
            ? &quot;d00&quot;
            : &quot;0d0&quot;
        ))
    );
    console.error(
        &quot;created test-report file &quot;
        + process.cwd() + &quot;/tmp/build/test-report.html\n&quot;
    );
    // if any test failed, then exit with non-zero exitCode
    console.error(
        &quot;\n&quot; + local.env.MODE_BUILD
        + &quot; - &quot; + testReport.testsFailed + &quot; failed tests\n&quot;
    );
    // print failed testCase
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testCaseList.forEach(function (testCase) {
            if (testCase.status !== &quot;passed&quot;) {
                console.error(JSON.stringify(testCase, undefined, 4));
            }
        });
    });
    return testReport;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict[&quot;utility2.testReportCreate&quot;] = function () {
/*
 *
 * will create test-report
 */
    process.exit(local.<span class="apidocCodeKeywordSpan">testReportCreate</span>(local.fsReadFileOrEmptyStringSync(
        local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
        &quot;json&quot;
    )).testsFailed);
};
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testReportMerge" id="apidoc.elem.utility2.testReportMerge">
        function <span class="apidocSignatureSpan">utility2.</span>testReportMerge
        <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportMerge = function (testReport1, testReport2) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. merge testReport2 into testReport1
 * 2. return testReport1 in html-format
 */
</span>    let errorStackList;
    let testCaseNumber;
    let testReport;
    testReport2 = testReport2 || {};
    // 1. merge testReport2 into testReport1
    [
        testReport1, testReport2
    ].forEach(function (testReport, ii) {
        ii += 1;
        local.objectSetDefault(testReport, {
            date: new Date().toISOString(),
            errorStackList: [],
            testPlatformList: [],
            timeElapsed: 0
        }, 8);
        // security - handle malformed testReport
        local.assertOrThrow(
            typeof testReport === &quot;object&quot; &amp;&amp; testReport,
            ii + &quot; invalid testReport &quot; + typeof testReport
        );
        // validate timeElapsed
        local.assertOrThrow(
            typeof testReport.timeElapsed === &quot;number&quot;,
            ii + &quot; invalid testReport.timeElapsed &quot;
            + typeof testReport.timeElapsed
        );
        // security - handle malformed testReport.testPlatformList
        testReport.testPlatformList.forEach(function (testPlatform) {
            local.objectSetDefault(testPlatform, {
                name: &quot;undefined&quot;,
                testCaseList: [],
                timeElapsed: 0
            }, 8);
            local.assertOrThrow(
                typeof testPlatform.name === &quot;string&quot;,
                ii + &quot; invalid testPlatform.name &quot; + typeof testPlatform.name
            );
            // insert $MODE_BUILD into testPlatform.name
            if (local.env.MODE_BUILD) {
                testPlatform.name = testPlatform.name.replace((
                    /^(browser|node)\b/
                ), local.env.MODE_BUILD + &quot; - $1&quot;);
            }
            // validate timeElapsed
            local.assertOrThrow(
                typeof testPlatform.timeElapsed === &quot;number&quot;,
                (
                    ii + &quot; invalid testPlatform.timeElapsed &quot;
                    + typeof testPlatform.timeElapsed
                )
            );
            // security - handle malformed testPlatform.testCaseList
            testPlatform.testCaseList.forEach(function (testCase) {
                local.objectSetDefault(testCase, {
                    errorStack: &quot;&quot;,
                    name: &quot;undefined&quot;,
                    timeElapsed: 0
                }, 8);
                local.assertOrThrow(
                    typeof testCase.errorStack === &quot;string&quot;,
                    ii + &quot; invalid testCase.errorStack &quot;
                    + typeof testCase.errorStack
                );
                local.assertOrThrow(
                    typeof testCase.name === &quot;string&quot;,
                    ii + &quot; invalid testCase.name &quot; + typeof testCase.name
                );
                // validate timeElapsed
                local.assertOrThrow(
                    typeof testCase.timeElapsed === &quot;number&quot;,
                    (
                        ii + &quot; invalid testCase.timeElapsed &quot;
                        + typeof testCase.timeElapsed
                    )
                );
            });
        });
    });
    // merge testReport2.testPlatformList into testReport1.testPlatformList
    testReport2.testPlatformList.forEach(function (testPlatform2) {
        // add testPlatform2 to testReport1.testPlatformList
        testReport1.testPlatformList.push(testPlatform2);
    });
    testReport = testReport1;
    testReport.testsFailed = 0;
    testReport.testsPassed = 0;
    testReport.testsPending = 0;
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testsFailed = 0;
        testPlatform.testsPassed = 0;
        testPlatform.testsPending = 0;
        testPlatform.testCaseList.forEach(function (testCase) {
            switch (testCase.status) {...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.istanbulCoverageMerge(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.<span class="apidocCodeKeywordSpan">testReportMerge</span>(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.counter += 1;
local.fs.writeFile(
    local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
    JSON.stringify(globalThis.utility2_testReport),
    function (err) {
        console.error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunBrowser" id="apidoc.elem.utility2.testRunBrowser">
        function <span class="apidocSignatureSpan">utility2.</span>testRunBrowser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunBrowser = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will run browser-tests
 */
</span>    // hide browser-tests
    if (local.querySelector(&quot;#htmlTestReport1&quot;).style.maxHeight !== &quot;0px&quot;) {
        local.uiAnimateSlideUp(local.querySelector(&quot;#htmlTestReport1&quot;));
        local.querySelector(
            &quot;#buttonTestRun1&quot;
        ).textContent = &quot;run browser-tests&quot;;
        return;
    }
    // show browser-tests
    local.uiAnimateSlideDown(local.querySelector(&quot;#htmlTestReport1&quot;));
    local.querySelector(&quot;#buttonTestRun1&quot;).textContent = &quot;hide browser-tests&quot;;
    local.modeTest = 1;
    local.testRunDefault(local);
    // reset output
    local.querySelectorAll(&quot;.onevent-reset-output&quot;).forEach(function (elem) {
        elem.textContent = &quot;&quot;;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };\n\
});\n\
local.objectAssignDefault(local, globalThis.domOnEventDelegateDict);\n\
globalThis.domOnEventDelegateDict = local;\n\
if ((\n\
    /\\bmodeTest=1\\b/\n\
).test(location.search)) {\n\
    local.<span class="apidocCodeKeywordSpan">testRunBrowser</span>();\n\
}\n\
}());\n\
\n\
\n\
\n\
// run node js\-env code - init-test\n\
(function () {\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunDefault" id="apidoc.elem.utility2.testRunDefault">
        function <span class="apidocSignatureSpan">utility2.</span>testRunDefault
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunDefault = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run tests in testPlatform.testCaseList
 */
</span>    let consoleError;
    let isCoverage;
    let processExit;
    let testPlatform;
    let testReport;
    let timerInterval;
    // run-server
    if (!local.isBrowser) {
        local.testRunServer(opt);
    }
    globalThis.utility2_modeTest = Number(
        globalThis.utility2_modeTest
        || opt.modeTest
        || local.modeTest
        || local.env.npm_config_mode_test
    );
    switch (globalThis.utility2_modeTest) {
    // init
    case 1:
        globalThis.utility2_modeTest += 1;
        // reset db
        globalThis.utility2_onReadyAfter(function () {
            local.testRunDefault(opt);
        });
        return;
    // test-run
    default:
        // test-ignore
        if (
            globalThis.utility2_onReadyBefore.counter
            || !globalThis.utility2_modeTest
            || globalThis.utility2_modeTest &gt; 2
        ) {
            return;
        }
        // test-run
        globalThis.utility2_modeTest += 1;
    }
    // visual notification - testRun
    local.ajaxProgressUpdate();
    // mock console.error
    consoleError = console.error;
    isCoverage = (
        typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
        &amp;&amp; Object.keys(globalThis.__coverage__).length
    );
    console.error = function (...argList) {
    /*
     * this function will ignore serverLog-messages during test-run
     */
        if (!isCoverage &amp;&amp; !(
            /^serverLog\u0020-\u0020\{/
        ).test(argList[0])) {
            consoleError(...argList);
        }
    };
    // mock proces.exit
    if (!local.isBrowser) {
        processExit = process.exit;
        process.exit = local.nop;
    }
    // init modeTestCase
    local.modeTestCase = (
        local.modeTestCase
        || local.env.npm_config_mode_test_case || &quot;&quot;
    );
    // init testReport
    testReport = globalThis.utility2_testReport;
    // init testReport timer
    local.timeElapsedStart(testReport);
    // init testPlatform
    testPlatform = testReport.testPlatformList[0];
    // init testPlatform timer
    local.timeElapsedStart(testPlatform);
    // reset testPlatform.testCaseList
    testPlatform.testCaseList.length = 0;
    // add tests into testPlatform.testCaseList
    Object.keys(opt).forEach(function (key) {
        // add testCase opt[key] to testPlatform.testCaseList
        if (
            typeof opt[key] === &quot;function&quot; &amp;&amp; (
                local.modeTestCase
                ? local.modeTestCase.split(
                    /[,\s]/g
                ).indexOf(key) &gt;= 0
                : key.indexOf(&quot;testCase_&quot;) === 0
            )
        ) {
            testPlatform.testCaseList.push({
                isBrowser: local.isBrowser,
                name: key,
                status: &quot;pending&quot;,
                onTestCase: opt[key]
            });
        }
    });
    local.testReportMerge(testReport);
    local.querySelectorAll(&quot;#htmlTestReport1&quot;).forEach(function (elem) {
        local.uiAnimateSlideDown(elem);
        elem.innerHTML = local.testReportMerge(testReport);
    });
    local.emit(&quot;utility2.testRunStart&quot;, testReport);
    // testRunProgressUpdate every 2000 ms until isDone
    timerInterval = setInterval(function () {
        // update testPlatform.timeElapsed
        local.timeElapsedPoll(testPlatform);
        local.querySelector(
            &quot;#htmlTestReport1&quot;
        ).innerHTML = local.testReportMerge(testReport);
        local.emit(&quot;utility2.testRunProgressUpdate&quot;, testReport);
        // cleanup timerInterval
        if (!testReport.testsPending) {
            clearInterval(timerInterval);
        }
        // list pending testCase every 5000 ms
        if (testPlatform.timeElapsed % 5000 &lt; 2000) {
            consoleError(
                &quot;testRunDefault - &quot;
                + testPlatform.timeEl...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.requireReadme();\n\
globalThis.local = local;\n\
// init test\n\
local.<span class="apidocCodeKeywordSpan">testRunDefault</span>(local);\n\
}());\n\
\n\
\n\
\n\
// run shared js\-env code - function\n\
(function () {\n\
return;\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunServer" id="apidoc.elem.utility2.testRunServer">
        function <span class="apidocSignatureSpan">utility2.</span>testRunServer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunServer = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. create server from local.middlewareList
 * 2. start server on local.env.PORT
 * 3. run tests
 */
</span>    // 1. create server from local.middlewareList
    local.middlewareList = local.middlewareList || [
        local.middlewareInit,
        local.middlewareForwardProxy,
        local.middlewareAssetsCached,
        local.middlewareJsonpStateInit,
        local.middlewareFileServer
    ];
    if (local.env.npm_config_mode_library || globalThis.utility2_serverHttp1) {
        return;
    }
    globalThis.utility2_onReadyBefore.counter += 1;
    local.serverLocalReqHandler = function (req, res) {
        let that;
        that = {};
        local.gotoNext(that, function (err) {
            if (err || that.gotoState &gt;= local.middlewareList.length) {
                local.middlewareError(err, req, res);
                return;
            }
            // recurse with next middleware in middlewareList
            local.middlewareList[that.gotoState](req, res, that.gotoNext);
        });
        that.gotoState = -1;
        that.gotoNext();
    };
    globalThis.utility2_serverHttp1 = local.http.createServer(
        local.serverLocalReqHandler
    );
    // 2. start server on local.env.PORT
    console.error(&quot;http-server listening on port &quot; + local.env.PORT);
    globalThis.utility2_onReadyBefore.counter += 1;
    globalThis.utility2_serverHttp1.listen(
        local.env.PORT,
        globalThis.utility2_onReadyBefore
    );
    // 3. run tests
    local.testRunDefault(opt);
    globalThis.utility2_onReadyBefore();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.replStart();
   local.<span class="apidocCodeKeywordSpan">testRunServer</span>({});
};

local.cliDict[&quot;utility2.swaggerValidateFile&quot;] = function () {
/*
* &lt;file/url&gt;
* will swagger-validate file/url
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.throwError" id="apidoc.elem.utility2.throwError">
        function <span class="apidocSignatureSpan">utility2.</span>throwError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will throw new err
 */
</span>    throw new Error();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_throwError_default = function (opt, onError) {
/*
 * this function will test throwError&apos;s default handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">throwError</span>();
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.timeElapsedPoll" id="apidoc.elem.utility2.timeElapsedPoll">
        function <span class="apidocSignatureSpan">utility2.</span>timeElapsedPoll
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedPoll = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will poll &lt;opt&gt;.timeElapsed
 */
</span>    opt = local.timeElapsedStart(opt);
    opt.timeElapsed = Date.now() - opt.timeStart;
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &gt; bb.status.replace(&quot;passed&quot;, &quot;z&quot;) + bb.name
        ? 1
        : -1
    );
});
// stop testReport timer
if (!testReport.testsPending) {
    local.<span class="apidocCodeKeywordSpan">timeElapsedPoll</span>(testReport);
}
// 2. return testReport1 in html-format
// json-copy testReport that will be modified for html templating
testReport = local.jsonCopy(testReport1);
// update timeElapsed
local.timeElapsedPoll(testReport);
testReport.testPlatformList.forEach(function (testPlatform) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.timeElapsedStart" id="apidoc.elem.utility2.timeElapsedStart">
        function <span class="apidocSignatureSpan">utility2.</span>timeElapsedStart
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedStart = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will start &lt;opt&gt;.timeElapsed
 */
</span>    opt = opt || {};
    opt.timeStart = opt.timeStart || Date.now();
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.modeTestCase = (
    local.modeTestCase
    || local.env.npm_config_mode_test_case || &quot;&quot;
);
// init testReport
testReport = globalThis.utility2_testReport;
// init testReport timer
local.<span class="apidocCodeKeywordSpan">timeElapsedStart</span>(testReport);
// init testPlatform
testPlatform = testReport.testPlatformList[0];
// init testPlatform timer
local.timeElapsedStart(testPlatform);
// reset testPlatform.testCaseList
testPlatform.testCaseList.length = 0;
// add tests into testPlatform.testCaseList
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.tryCatchOnError" id="apidoc.elem.utility2.tryCatchOnError">
        function <span class="apidocSignatureSpan">utility2.</span>tryCatchOnError
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryCatchOnError = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the fnc in a tryCatch block,
 * else call onError with errCaught
 */
</span>    let result;
    // validate onError
    local.assertOrThrow(typeof onError === &quot;function&quot;, typeof onError);
    try {
        // reset errCaught
        local._debugTryCatchError = null;
        result = fnc();
        local._debugTryCatchError = null;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return elem;
};
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.<span class="apidocCodeKeywordSpan">tryCatchOnError</span>(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideAccordian" id="apidoc.elem.utility2.uiAnimateSlideAccordian">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideAccordian
        <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideAccordian = function (elem, elemList, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown &lt;elem&gt;, but slideUp elements in &lt;elemList&gt;
 */
</span>    elemList.forEach(function (elem2) {
        if (elem2 !== elem) {
            local.uiAnimateSlideUp(elem2);
        }
    });
    setTimeout(function () {
        local.uiAnimateSlideDown(elem, onError);
    }, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// show parent resource
local.uiAnimateSlideDown(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideAccordian</span>(
    element.querySelector(
        &quot;.operation &gt; form&quot;
    ),
    Array.from(element.closest(
        &quot;.operationList&quot;
    ).querySelectorAll(
        &quot;.operation &gt; form&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideDown" id="apidoc.elem.utility2.uiAnimateSlideDown">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideDown
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideDown = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown dom-&lt;elem&gt;
 */
</span>    onError = onError || local.nop;
    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;100%&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        onError();
        return;
    }
    elem.style.borderBottom = &quot;&quot;;
    elem.style.borderTop = &quot;&quot;;
    elem.style.marginBottom = &quot;&quot;;
    elem.style.marginTop = &quot;&quot;;
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + &quot;px&quot;;
    elem.style.paddingBottom = &quot;&quot;;
    elem.style.paddingTop = &quot;&quot;;
    setTimeout(function () {
        elem.style.maxHeight = &quot;100%&quot;;
        onError();
    }, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &quot;.operation&quot;
);
location.hash = &quot;!&quot; + element.id;
element.closest(
    &quot;.resource&quot;
).classList.remove(&quot;expanded&quot;);
// show parent resource
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideDown</span>(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.uiAnimateSlideAccordian(
    element.querySelector(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideUp" id="apidoc.elem.utility2.uiAnimateSlideUp">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideUp
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideUp = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideUp dom-&lt;elem&gt;
 */
</span>    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;0px&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        local.setTimeoutOnError(onError);
        return;
    }
    elem.style.borderBottom = &quot;0&quot;;
    elem.style.borderTop = &quot;0&quot;;
    elem.style.marginBottom = &quot;0&quot;;
    elem.style.marginTop = &quot;0&quot;;
    elem.style.maxHeight = &quot;0&quot;;
    elem.style.paddingBottom = &quot;0&quot;;
    elem.style.paddingTop = &quot;0&quot;;
    local.setTimeoutOnError(onError, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
// collapse all operations in the resource
if (evt.currentTarget.classList.contains(&quot;expanded&quot;)) {
    evt.currentTarget.classList.remove(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
        local.<span class="apidocCodeKeywordSpan">uiAnimateSlideUp</span>(element);
    });
// expand all operations in the resource
} else {
    evt.currentTarget.classList.add(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.urlJoin" id="apidoc.elem.utility2.urlJoin">
        function <span class="apidocSignatureSpan">utility2.</span>urlJoin
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlJoin = function (aa, bb) {
<span class="apidocCodeCommentSpan">/*
 * this function will if bb is relative, url-join aa with bb
 */
</span>    // bb is absolute-url
    if ((
        /^\w+?:\/\//
    ).test(bb)) {
        return bb;
    }
    // bb is absolute-url without protocol
    if (bb.slice(0, 2) === &quot;//&quot;) {
        return aa.split(&quot;/&quot;)[0] + bb;
    }
    // bb is absolute-url without host
    if (bb[0] === &quot;/&quot;) {
        return aa.split(&quot;/&quot;).slice(0, 3).join(&quot;/&quot;) + bb;
    }
    // bb is relative-url
    if (aa.split(&quot;/&quot;).length &lt; 4) {
        aa += &quot;/&quot;;
    }
    return aa.replace((
        /[?#].*?$/
    ), &quot;&quot;).replace((
        /[^\/]*?$/
    ), &quot;&quot;) + bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_urlJoin_default = function (opt, onError) {
/*
* this function will test urlJoin&apos;s default handling-behavior
*/
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">urlJoin</span>(&quot;&quot;, &quot;&quot;), &quot;/&quot;);
   local.assertJsonEqual(local.urlJoin(&quot;http://aa/bb&quot;, &quot;zz&quot;), &quot;http://aa/zz&quot;);
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;zz&quot;),
       &quot;http://aa/bb/zz&quot;
   );
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;/zz&quot;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.urlParse" id="apidoc.elem.utility2.urlParse">
        function <span class="apidocSignatureSpan">utility2.</span>urlParse
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlParse = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will parse &lt;url&gt; according to below spec, plus a query param
 * https://developer.mozilla.org/en-US/docs/Web/API/URL
 */
</span>    let urlParsed;
    urlParsed = {};
    // try to parse url
    local.tryCatchOnError(function () {
        // resolve host-less url
        if (local.isBrowser) {
            local.serverLocalHost = (
                local.serverLocalHost
                || location.protocol + &quot;//&quot; + location.host
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = (
                    local.serverLocalHost
                    + location.pathname.replace((
                        /\/[^\/]*?$/
                    ), &quot;&quot;) + &quot;/&quot; + url
                );
            }
            urlParsed = new globalThis.URL(url);
            urlParsed.path = (
                &quot;/&quot; + urlParsed.href.split(&quot;/&quot;).slice(3).join(&quot;/&quot;).split(&quot;#&quot;)[0]
            );
        } else {
            local.env.PORT = local.env.PORT || &quot;8081&quot;;
            local.serverLocalHost = (
                local.serverLocalHost
                || (&quot;http://127.0.0.1:&quot; + local.env.PORT)
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = local.serverLocalHost + &quot;/&quot; + url;
            }
            urlParsed = local.url.parse(url);
        }
        // init query
        urlParsed.query = {};
        local.coalesce(urlParsed.search, &quot;&quot;).slice(1).replace((
            /[^&amp;]+/g
        ), function (item) {
            item = item.split(&quot;=&quot;);
            item[0] = decodeURIComponent(item[0]);
            item[1] = decodeURIComponent(item.slice(1).join(&quot;=&quot;));
            // parse repeating query-param as an array
            if (urlParsed.query[item[0]]) {
                if (!Array.isArray(urlParsed.query[item[0]])) {
                    urlParsed.query[item[0]] = [
                        urlParsed.query[item[0]]
                    ];
                }
                urlParsed.query[item[0]].push(item[1]);
            } else {
                urlParsed.query[item[0]] = item[1];
            }
        });
        urlParsed.basename = urlParsed.pathname.replace((
            /^.*\//
        ), &quot;&quot;);
    }, local.nop);
    // https://developer.mozilla.org/en/docs/Web/API/URL#Properties
    return {
        basename: urlParsed.basename || &quot;&quot;,
        hash: urlParsed.hash || &quot;&quot;,
        host: urlParsed.host || &quot;&quot;,
        hostname: urlParsed.hostname || &quot;&quot;,
        href: urlParsed.href || &quot;&quot;,
        path: urlParsed.path || &quot;&quot;,
        pathname: urlParsed.pathname || &quot;&quot;,
        port: urlParsed.port || &quot;&quot;,
        protocol: urlParsed.protocol || &quot;&quot;,
        query: urlParsed.query || {},
        search: urlParsed.search || &quot;&quot;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
}
// init url
opt.url = &quot;&quot;;
opt.url += (
    local.identity(
        that[&quot;x-swgg-schemes&quot;] || local.swaggerJson.schemes || []
    )[0] || local.<span class="apidocCodeKeywordSpan">urlParse</span>(&quot;&quot;).protocol.slice(0, -1)
);
opt.url += &quot;://&quot;;
opt.url += (
    that[&quot;x-swgg-host&quot;]
    || local.swaggerJson.host
    || local.urlParse(&quot;&quot;).host
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uuid4Create" id="apidoc.elem.utility2.uuid4Create">
        function <span class="apidocSignatureSpan">utility2.</span>uuid4Create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid4Create = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random uuid,
 * with format &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;
 */
</span>    // code derived from http://jsperf.com/uuid4
    let id;
    let ii;
    id = &quot;&quot;;
    ii = 0;
    while (ii &lt; 32) {
        switch (ii) {
        case 8:
        case 20:
            id += &quot;-&quot;;
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
            break;
        case 12:
            id += &quot;-&quot;;
            id += &quot;4&quot;;
            break;
        case 16:
            id += &quot;-&quot;;
            id += local.identity((Math.random() * 4) | 8).toString(16);
            break;
        default:
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
        }
        ii += 1;
    }
    return id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_uuid4Create_default = function (opt, onError) {
/*
 * this function will test uuid4Create&apos;s default handling-behavior
 */
    local.assertOrThrow(
        local.regexpValidateUuid.test(local.<span class="apidocCodeKeywordSpan">uuid4Create</span>()),
        local.uuid4Create()
    );
    onError(undefined, opt);
};

local.testCase_webpage_err = function (opt, onError) {
/*
...</pre></li>
    </ul>












































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.FormData" id="apidoc.module.utility2.FormData">module utility2.FormData</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.FormData.FormData" id="apidoc.elem.utility2.FormData.FormData">
        function <span class="apidocSignatureSpan">utility2.</span>FormData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FormData = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a serverLocal-compatible FormData instance
 * The FormData(form) constructor must run these steps:
 * 1. Let fd be a new FormData object.
 * 2. If form is given, set fd&apos;s entries to the result
 *    of constructing the form data set for form. (not implemented)
 * 3. Return fd.
 * https://xhr.spec.whatwg.org/#dom-formdata
 */
</span>    this.entryList = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
})[0];
// init default
local.objectSetDefault(opt, {
    inForm: (
        that._consumes0 === &quot;multipart/form-data&quot;
        ? new local.<span class="apidocCodeKeywordSpan">FormData</span>()
        : &quot;&quot;
    ),
    inHeader: {},
    inPath: that._path.replace((
        /#.*?$/
    ), &quot;&quot;),
    inQuery: &quot;&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.FormData.prototype" id="apidoc.module.utility2.FormData.prototype">module utility2.FormData.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.FormData.prototype.append" id="apidoc.elem.utility2.FormData.prototype.append">
        function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>append
        <span class="apidocSignatureSpan">(name, value, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (name, value, filename) {
<span class="apidocCodeCommentSpan">/*
 * The append(name, value, filename) method, when invoked, must run these steps:
 * 1. If the filename argument is given, set value to a new File object
 *    whose contents are value and name is filename.
 * 2. Append a new entry whose name is name, and value is value,
 *    to context object&apos;s list of entries.
 * https://xhr.spec.whatwg.org/#dom-formdata-append
 */
</span>    if (filename) {
        // bug-workaround - chromium cannot assign name to Blob instance
        local.tryCatchOnError(function () {
            value.name = filename;
        }, local.nop);
    }
    this.entryList.push({
        name,
        value
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &quot;\n&lt;&quot; + schemaP.name + &quot;&gt;&quot; + &quot;&lt;![CDATA[&quot;
        + tmp.replace((
            /\]\]&gt;/g
        ), &quot;]]&amp;#x3e;&quot;) + &quot;]]&gt;&lt;/&quot; + schemaP.name + &quot;&gt;&quot;
    );
    break;
case &quot;multipart/form-data&quot;:
    opt.inForm.<span class="apidocCodeKeywordSpan">append</span>(schemaP.name, tmp, tmp &amp;&amp; tmp.name);
    break;
default:
    if (opt.inForm) {
        opt.inForm += &quot;&amp;&quot;;
    }
    opt.inForm += (
        encodeURIComponent(schemaP.name) + &quot;=&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.FormData.prototype.read" id="apidoc.elem.utility2.FormData.prototype.read">
        function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>read
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will read from formData as a buffer, e.g.
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;key&quot;\r\n
 * \r\n
 * value\r\n
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;input1&quot;; filename=&quot;file1.png&quot;\r\n
 * Content-Type: image/jpeg\r\n
 * \r\n
 * &lt;data1&gt;\r\n
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;input2&quot;; filename=&quot;file2.png&quot;\r\n
 * Content-Type: image/jpeg\r\n
 * \r\n
 * &lt;data2&gt;\r\n
 * --Boundary--\r\n
 * https://tools.ietf.org/html/rfc7578
 */
</span>    let boundary;
    let result;
    // handle null-case
    if (!this.entryList.length) {
        onError();
        return;
    }
    // init boundary
    boundary = &quot;--&quot; + Date.now().toString(16) + Math.random().toString(16);
    // init result
    result = [];
    local.onParallelList({
        list: this.entryList
    }, function (option2, onParallel) {
        let value;
        value = option2.elem.value;
        if (!(value &amp;&amp; value.constructor === local.Blob)) {
            result[option2.ii] = [
                (
                    boundary + &quot;\r\nContent-Disposition: form-data; name=\&quot;&quot;
                    + option2.elem.name + &quot;\&quot;\r\n\r\n&quot;
                ), value, &quot;\r\n&quot;
            ];
            onParallel.counter += 1;
            onParallel();
            return;
        }
        // read from blob in parallel
        onParallel.counter += 1;
        local.blobRead(value, function (err, data) {
            result[option2.ii] = !err &amp;&amp; [
                (
                    boundary + &quot;\r\nContent-Disposition: form-data; name=\&quot;&quot;
                    + option2.elem.name + &quot;\&quot;&quot; + (
                        (value &amp;&amp; value.name)
                        // read param filename
                        ? &quot;; filename=\&quot;&quot; + value.name + &quot;\&quot;&quot;
                        : &quot;&quot;
                    ) + &quot;\r\n&quot; + (
                        (value &amp;&amp; value.type)
                        // read param Content-Type
                        ? &quot;Content-Type: &quot; + value.type + &quot;\r\n&quot;
                        : &quot;&quot;
                    ) + &quot;\r\n&quot;
                ), data, &quot;\r\n&quot;
            ];
            onParallel(err);
        });
    }, function (err) {
        // add closing boundary
        result.push([
            boundary + &quot;--\r\n&quot;
        ]);
        // concatenate result
        onError(
            err,
            // flatten result
            !err
            &amp;&amp; local.bufferConcat(result.flat())
        );
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.<span class="apidocCodeKeywordSpan">read</span>();

        while (c) {
            switch (c) {

/*
 * Potential tokens:
 * - COMMENT
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module" id="apidoc.module.utility2.Module">module utility2.Module</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.Module.Module" id="apidoc.elem.utility2.Module.Module">
        function <span class="apidocSignatureSpan">utility2.</span>Module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init example.js
tmp = process.cwd() + &quot;/example.js&quot;;
// jslint code
local.jslintAndPrint(code, tmp);
// cover code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.<span class="apidocCodeKeywordSpan">Module</span>(tmp);
require.cache[tmp] = module;
// load code into module
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._debug" id="apidoc.elem.utility2.Module._debug">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_debug
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return Reflect.construct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._findPath" id="apidoc.elem.utility2.Module._findPath">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_findPath
        <span class="apidocSignatureSpan">(request, paths, isMain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, paths, isMain) {
  const absoluteRequest = path.isAbsolute(request);
  if (absoluteRequest) {
    paths = [&apos;&apos;];
  } else if (!paths || paths.length === 0) {
    return false;
  }

  const cacheKey = request + &apos;\x00&apos; +
                (paths.length === 1 ? paths[0] : paths.join(&apos;\x00&apos;));
  const entry = Module._pathCache[cacheKey];
  if (entry)
    return entry;

  var exts;
  var trailingSlash = request.length &gt; 0 &amp;&amp;
    request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH;
  if (!trailingSlash) {
    trailingSlash = /(?:^|\/)\.?\.$/.test(request);
  }

  // For each path
  for (var i = 0; i &lt; paths.length; i++) {
    // Don&apos;t search further if path doesn&apos;t exist
    const curPath = paths[i];
    if (curPath &amp;&amp; stat(curPath) &lt; 1) continue;
    var basePath = resolveExports(curPath, request, absoluteRequest);
    var filename;

    var rc = stat(basePath);
    if (!trailingSlash) {
      if (rc === 0) {  // File.
        if (!isMain) {
          if (preserveSymlinks) {
            filename = path.resolve(basePath);
          } else {
            filename = toRealPath(basePath);
          }
        } else if (preserveSymlinksMain) {
          // For the main module, we use the preserveSymlinksMain flag instead
          // mainly for backward compatibility, as the preserveSymlinks flag
          // historically has not applied to the main module.  Most likely this
          // was intended to keep .bin/ binaries working, as following those
          // symlinks is usually required for the imports in the corresponding
          // files to resolve; that said, in some use cases following symlinks
          // causes bigger problems which is why the preserveSymlinksMain option
          // is needed.
          filename = path.resolve(basePath);
        } else {
          filename = toRealPath(basePath);
        }
      }

      if (!filename) {
        // Try it with each of the extensions
        if (exts === undefined)
          exts = Object.keys(Module._extensions);
        filename = tryExtensions(basePath, exts, isMain);
      }
    }

    if (!filename &amp;&amp; rc === 1) {  // Directory.
      // try it with each of the extensions at &quot;index&quot;
      if (exts === undefined)
        exts = Object.keys(Module._extensions);
      filename = tryPackage(basePath, exts, isMain, request);
    }

    if (filename) {
      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._initPaths" id="apidoc.elem.utility2.Module._initPaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_initPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var homeDir;
  var nodePath;
  if (isWindows) {
    homeDir = process.env.USERPROFILE;
    nodePath = process.env.NODE_PATH;
  } else {
    homeDir = safeGetenv(&apos;HOME&apos;);
    nodePath = safeGetenv(&apos;NODE_PATH&apos;);
  }

  // $PREFIX/lib/node, where $PREFIX is the root of the Node.js installation.
  var prefixDir;
  // process.execPath is $PREFIX/bin/node except on Windows where it is
  // $PREFIX\node.exe.
  if (isWindows) {
    prefixDir = path.resolve(process.execPath, &apos;..&apos;);
  } else {
    prefixDir = path.resolve(process.execPath, &apos;..&apos;, &apos;..&apos;);
  }
  var paths = [path.resolve(prefixDir, &apos;lib&apos;, &apos;node&apos;)];

  if (homeDir) {
    paths.unshift(path.resolve(homeDir, &apos;.node_libraries&apos;));
    paths.unshift(path.resolve(homeDir, &apos;.node_modules&apos;));
  }

  if (nodePath) {
    paths = nodePath.split(path.delimiter).filter(function pathsFilterCB(path) {
      return !!path;
    }).concat(paths);
  }

  modulePaths = paths;

  // Clone as a shallow copy, for introspection.
  Module.globalPaths = modulePaths.slice(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._load" id="apidoc.elem.utility2.Module._load">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_load
        <span class="apidocSignatureSpan">(request, parent, isMain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent, isMain) {
  let relResolveCacheIdentifier;
  if (parent) {
    debug(&apos;Module._load REQUEST %s parent: %s&apos;, request, parent.id);
    // Fast path for (lazy loaded) modules in the same directory. The indirect
    // caching is required to allow cache invalidation without changing the old
    // cache key names.
    relResolveCacheIdentifier = `${parent.path}\x00${request}`;
    const filename = relativeResolveCache[relResolveCacheIdentifier];
    if (filename !== undefined) {
      const cachedModule = Module._cache[filename];
      if (cachedModule !== undefined) {
        updateChildren(parent, cachedModule, true);
        return cachedModule.exports;
      }
      delete relativeResolveCache[relResolveCacheIdentifier];
    }
  }

  const filename = Module._resolveFilename(request, parent, isMain);

  const cachedModule = Module._cache[filename];
  if (cachedModule !== undefined) {
    updateChildren(parent, cachedModule, true);
    return cachedModule.exports;
  }

  const mod = loadNativeModule(filename, request, experimentalModules);
  if (mod &amp;&amp; mod.canBeRequiredByUsers) return mod.exports;

  // Don&apos;t call updateChildren(), Module constructor already does.
  const module = new Module(filename, parent);

  if (isMain) {
    process.mainModule = module;
    module.id = &apos;.&apos;;
  }

  Module._cache[filename] = module;
  if (parent !== undefined) {
    relativeResolveCache[relResolveCacheIdentifier] = filename;
  }

  let threw = true;
  try {
    module.load(filename);
    threw = false;
  } finally {
    if (threw) {
      delete Module._cache[filename];
      if (parent !== undefined) {
        delete relativeResolveCache[relResolveCacheIdentifier];
      }
    }
  }

  return module.exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._nodeModulePaths" id="apidoc.elem.utility2.Module._nodeModulePaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_nodeModulePaths
        <span class="apidocSignatureSpan">(from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(from) {
  // Guarantee that &apos;from&apos; is absolute.
  from = path.resolve(from);
  // Return early not only to avoid unnecessary work, but to *avoid* returning
  // an array of two items for a root: [ &apos;//node_modules&apos;, &apos;/node_modules&apos; ]
  if (from === &apos;/&apos;)
    return [&apos;/node_modules&apos;];

  // note: this approach *only* works when the path is guaranteed
  // to be absolute.  Doing a fully-edge-case-correct path.split
  // that works on both Windows and Posix is non-trivial.
  const paths = [];
  var p = 0;
  var last = from.length;
  for (var i = from.length - 1; i &gt;= 0; --i) {
    const code = from.charCodeAt(i);
    if (code === CHAR_FORWARD_SLASH) {
      if (p !== nmLen)
        paths.push(from.slice(0, last) + &apos;/node_modules&apos;);
      last = i;
      p = 0;
    } else if (p !== -1) {
      if (nmChars[p] === code) {
        ++p;
      } else {
        p = -1;
      }
    }
  }

  // Append /node_modules to handle root paths.
  paths.push(&apos;/node_modules&apos;);

  return paths;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._preloadModules" id="apidoc.elem.utility2.Module._preloadModules">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_preloadModules
        <span class="apidocSignatureSpan">(requests)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(requests) {
  if (!Array.isArray(requests))
    return;

  // Preloaded modules have a dummy parent module which is deemed to exist
  // in the current working directory. This seeds the search path for
  // preloaded modules.
  const parent = new Module(&apos;internal/preload&apos;, null);
  try {
    parent.paths = Module._nodeModulePaths(process.cwd());
  } catch (e) {
    if (e.code !== &apos;ENOENT&apos;) {
      throw e;
    }
  }
  for (var n = 0; n &lt; requests.length; n++)
    parent.require(requests[n]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._resolveFilename" id="apidoc.elem.utility2.Module._resolveFilename">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveFilename
        <span class="apidocSignatureSpan">(request, parent, isMain, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent, isMain, options) {
  if (NativeModule.canBeRequiredByUsers(request)) {
    return request;
  }

  var paths;

  if (typeof options === &apos;object&apos; &amp;&amp; options !== null) {
    if (Array.isArray(options.paths)) {
      const isRelative = request.startsWith(&apos;./&apos;) ||
          request.startsWith(&apos;../&apos;) ||
          (isWindows &amp;&amp; request.startsWith(&apos;.\\&apos;) ||
          request.startsWith(&apos;..\\&apos;));

      if (isRelative) {
        paths = options.paths;
      } else {
        const fakeParent = new Module(&apos;&apos;, null);

        paths = [];

        for (var i = 0; i &lt; options.paths.length; i++) {
          const path = options.paths[i];
          fakeParent.paths = Module._nodeModulePaths(path);
          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);

          for (var j = 0; j &lt; lookupPaths.length; j++) {
            if (!paths.includes(lookupPaths[j]))
              paths.push(lookupPaths[j]);
          }
        }
      }
    } else if (options.paths === undefined) {
      paths = Module._resolveLookupPaths(request, parent);
    } else {
      throw new ERR_INVALID_OPT_VALUE(&apos;options.paths&apos;, options.paths);
    }
  } else {
    paths = Module._resolveLookupPaths(request, parent);
  }

  // Look up the filename first, since that&apos;s the cache key.
  const filename = Module._findPath(request, paths, isMain);
  if (!filename) {
    const requireStack = [];
    for (var cursor = parent;
      cursor;
      cursor = cursor.parent) {
      requireStack.push(cursor.filename || cursor.id);
    }
    let message = `Cannot find module &apos;${request}&apos;`;
    if (requireStack.length &gt; 0) {
      message = message + &apos;\nRequire stack:\n- &apos; + requireStack.join(&apos;\n- &apos;);
    }
    // eslint-disable-next-line no-restricted-syntax
    var err = new Error(message);
    err.code = &apos;MODULE_NOT_FOUND&apos;;
    err.requireStack = requireStack;
    throw err;
  }
  return filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._resolveLookupPaths" id="apidoc.elem.utility2.Module._resolveLookupPaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveLookupPaths
        <span class="apidocSignatureSpan">(request, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent) {
  if (NativeModule.canBeRequiredByUsers(request)) {
    debug(&apos;looking for %j in []&apos;, request);
    return null;
  }

  // Check for node modules paths.
  if (request.charAt(0) !== &apos;.&apos; ||
      (request.length &gt; 1 &amp;&amp;
      request.charAt(1) !== &apos;.&apos; &amp;&amp;
      request.charAt(1) !== &apos;/&apos; &amp;&amp;
      (!isWindows || request.charAt(1) !== &apos;\\&apos;))) {

    let paths = modulePaths;
    if (parent != null &amp;&amp; parent.paths &amp;&amp; parent.paths.length) {
      paths = parent.paths.concat(paths);
    }

    debug(&apos;looking for %j in %j&apos;, request, paths);
    return paths.length &gt; 0 ? paths : null;
  }

  // With --eval, parent.id is not set and parent.filename is null.
  if (!parent || !parent.id || !parent.filename) {
    // Make require(&apos;./path/to/foo&apos;) work - normally the path is taken
    // from realpath(__filename) but with eval there is no filename
    const mainPaths = [&apos;.&apos;].concat(Module._nodeModulePaths(&apos;.&apos;), modulePaths);

    debug(&apos;looking for %j in %j&apos;, request, mainPaths);
    return mainPaths;
  }

  debug(&apos;RELATIVE: requested: %s from parent.id %s&apos;, request, parent.id);

  const parentDir = [path.dirname(parent.filename)];
  debug(&apos;looking for %j&apos;, parentDir);
  return parentDir;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.createRequire" id="apidoc.elem.utility2.Module.createRequire">
        function <span class="apidocSignatureSpan">utility2.Module.</span>createRequire
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRequire(filename) {
  let filepath;

  if (filename instanceof URL ||
      (typeof filename === &apos;string&apos; &amp;&amp; !path.isAbsolute(filename))) {
    try {
      filepath = fileURLToPath(filename);
    } catch {
      throw new ERR_INVALID_ARG_VALUE(&apos;filename&apos;, filename,
                                      createRequireError);
    }
  } else if (typeof filename !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_VALUE(&apos;filename&apos;, filename, createRequireError);
  } else {
    filepath = filename;
  }
  return createRequireFromPath(filepath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.createRequireFromPath" id="apidoc.elem.utility2.Module.createRequireFromPath">
        function <span class="apidocSignatureSpan">utility2.Module.</span>createRequireFromPath
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRequireFromPath(filename) {
  // Allow a directory to be passed as the filename
  const trailingSlash =
    filename.endsWith(&apos;/&apos;) || (isWindows &amp;&amp; filename.endsWith(&apos;\\&apos;));

  const proxyPath = trailingSlash ?
    path.join(filename, &apos;noop.js&apos;) :
    filename;

  const m = new Module(proxyPath);
  m.filename = proxyPath;

  m.paths = Module._nodeModulePaths(m.path);
  return makeRequireFunction(m, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.runMain" id="apidoc.elem.utility2.Module.runMain">
        function <span class="apidocSignatureSpan">utility2.Module.</span>runMain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  // Load the main module--the command line argument.
  if (experimentalModules) {
    asyncESM.loaderPromise.then((loader) =&gt; {
      return loader.import(pathToFileURL(process.argv[1]).href);
    })
    .catch((e) =&gt; {
      internalBinding(&apos;errors&apos;).triggerUncaughtException(
        e,
        true<span class="apidocCodeCommentSpan"> /* fromPromise */
</span>      );
    });
    return;
  }
  Module._load(process.argv[1], null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        process.argv.splice(1, 1, __dirname + &quot;/lib.istanbul.js&quot;, &quot;cover&quot;);
        local.istanbul.cliDict[process.argv[2]]();
        return;
    }
    // start
    process.argv.splice(1, 1);
    process.argv[1] = local.path.resolve(process.cwd(), process.argv[1]);
    local.Module.<span class="apidocCodeKeywordSpan">runMain</span>();
}
}());
}());
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module._extensions" id="apidoc.module.utility2.Module._extensions">module utility2.Module._extensions</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module.prototype" id="apidoc.module.utility2.Module.prototype">module utility2.Module.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype._compile" id="apidoc.elem.utility2.Module.prototype._compile">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>_compile
        <span class="apidocSignatureSpan">(content, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(content, filename) {
  let moduleURL;
  let redirects;
  if (manifest) {
    moduleURL = pathToFileURL(filename);
    redirects = manifest.getRedirector(moduleURL);
    manifest.assertIntegrity(moduleURL, content);
  }

  content = stripShebang(content);
  maybeCacheSourceMap(filename, content, this);

  let compiledWrapper;
  if (patched) {
    const wrapper = Module.wrap(content);
    compiledWrapper = vm.runInThisContext(wrapper, {
      filename,
      lineOffset: 0,
      displayErrors: true,
      importModuleDynamically: experimentalModules ? async (specifier) =&gt; {
        const loader = await asyncESM.loaderPromise;
        return loader.import(specifier, normalizeReferrerURL(filename));
      } : undefined,
    });
  } else {
    let compiled;
    try {
      compiled = compileFunction(
        content,
        filename,
        0,
        0,
        undefined,
        false,
        undefined,
        [],
        [
          &apos;exports&apos;,
          &apos;require&apos;,
          &apos;module&apos;,
          &apos;__filename&apos;,
          &apos;__dirname&apos;,
        ]
      );
    } catch (err) {
      if (experimentalModules) {
        enrichCJSError(err);
      }
      throw err;
    }

    if (experimentalModules) {
      const { callbackMap } = internalBinding(&apos;module_wrap&apos;);
      callbackMap.set(compiled.cacheKey, {
        importModuleDynamically: async (specifier) =&gt; {
          const loader = await asyncESM.loaderPromise;
          return loader.import(specifier, normalizeReferrerURL(filename));
        }
      });
    }
    compiledWrapper = compiled.function;
  }

  var inspectorWrapper = null;
  if (getOptionValue(&apos;--inspect-brk&apos;) &amp;&amp; process._eval == null) {
    if (!resolvedArgv) {
      // We enter the repl if we&apos;re not given a filename argument.
      if (process.argv[1]) {
        resolvedArgv = Module._resolveFilename(process.argv[1], null, false);
      } else {
        resolvedArgv = &apos;repl&apos;;
      }
    }

    // Set breakpoint on module start
    if (!hasPausedEntry &amp;&amp; filename === resolvedArgv) {
      hasPausedEntry = true;
      inspectorWrapper = internalBinding(&apos;inspector&apos;).callAndPauseOnStart;
    }
  }
  const dirname = path.dirname(filename);
  const require = makeRequireFunction(this, redirects);
  var result;
  const exports = this.exports;
  const thisValue = exports;
  const module = this;
  if (requireDepth === 0) statCache = new Map();
  if (inspectorWrapper) {
    result = inspectorWrapper(compiledWrapper, thisValue, exports,
                              require, module, filename, dirname);
  } else {
    result = compiledWrapper.call(thisValue, exports, require, module,
                                  filename, dirname);
  }
  if (requireDepth === 0) statCache = null;
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.jslintAndPrint(code, tmp);
// cover code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.Module(tmp);
require.cache[tmp] = module;
// load code into module
module.<span class="apidocCodeKeywordSpan">_compile</span>(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
);
// init assets
tmp = process.cwd() + &quot;/&quot; + local.env.npm_package_main;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype.load" id="apidoc.elem.utility2.Module.prototype.load">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>load
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(filename) {
  debug(&apos;load %j for module %j&apos;, filename, this.id);

  assert(!this.loaded);
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);
  Module._extensions[extension](this, filename);
  this.loaded = true;

  if (experimentalModules) {
    const ESMLoader = asyncESM.ESMLoader;
    const url = `${pathToFileURL(filename)}`;
    const module = ESMLoader.moduleMap.get(url);
    // Create module entry at load time to snapshot exports correctly
    const exports = this.exports;
    if (module !== undefined) { // Called from cjs translator
      if (module.reflect) {
        module.reflect.onReady((reflect) =&gt; {
          reflect.exports.default.set(exports);
        });
      }
    } else { // preemptively cache
      ESMLoader.moduleMap.set(
        url,
        new ModuleJob(ESMLoader, url, async () =&gt; {
          return createDynamicModule(
            [], [&apos;default&apos;], url, (reflect) =&gt; {
              reflect.exports.default.set(exports);
            });
        })
      );
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype.require" id="apidoc.elem.utility2.Module.prototype.require">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>require
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateString(id, &apos;id&apos;);
  if (id === &apos;&apos;) {
    throw new ERR_INVALID_ARG_VALUE(&apos;id&apos;, id,
                                    &apos;must be a non-empty string&apos;);
  }
  requireDepth++;
  try {
    return Module._load(id, this, /* isMain */ false);
  } finally {
    requireDepth--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2._http" id="apidoc.module.utility2._http">module utility2._http</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2._http.createServer" id="apidoc.elem.utility2._http.createServer">
        function <span class="apidocSignatureSpan">utility2._http.</span>createServer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s http.createServer function
 * https://nodejs.org/dist/v0.12.18/docs/api/all.html#all_http_createserver_requestlistener
 */
</span>    return {
        listen: function (port, onError) {
            onError(undefined, port);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (options.port == null &amp;&amp; !options.server &amp;&amp; !options.noServer) {
      throw new TypeError(
&apos;One of the &quot;port&quot;, &quot;server&quot;, or &quot;noServer&quot; options must be specified&apos;
      );
    }

    if (options.port != null) {
      this._server = http.<span class="apidocCodeKeywordSpan">createServer</span>((req, res) =&gt; {
const body = http.STATUS_CODES[426];

res.writeHead(426, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos;
});
res.end(body);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._http.request" id="apidoc.elem.utility2._http.request">
        function <span class="apidocSignatureSpan">utility2._http.</span>request
        <span class="apidocSignatureSpan">(xhr, onResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (xhr, onResponse) {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s http.request function
 * https://nodejs.org/dist/v0.12.18/docs/api/all.html#all_http_request_options_callback
 */
</span>    let bufList;
    let data;
    let handler;
    let isDone;
    let req;
    let res;
    xhr = {
        end: function (_data) {
            if (isDone) {
                return;
            }
            isDone = true;
            data = _data;
            // async send req from client to server
            setTimeout(function () {
                local.serverLocalReqHandler(req, res);
            });
        },
        headers: xhr.headers,
        method: xhr.method,
        on: function () {
            return xhr;
        },
        timeout: xhr.timeout,
        url: xhr.href
    };
    bufList = [];
    handler = new globalThis.EventTarget();
    req = {
        emit: function (type, data) {
            handler.dispatchEvent(new globalThis.CustomEvent(&quot;req.&quot; + type, {
                detail: data
            }));
        },
        headers: xhr.headers,
        httpVersion: &quot;1.1&quot;,
        method: xhr.method,
        on: function (type, onEvent) {
            handler.addEventListener(&quot;req.&quot; + type, function (evt) {
                onEvent(evt.detail);
            });
            if (req.readable &amp;&amp; type === &quot;end&quot;) {
                req.readable = null;
                req.emit(&quot;data&quot;, data);
                req.emit(&quot;end&quot;);
            }
            return req;
        },
        pipe: function (writable) {
            req.on(&quot;data&quot;, function (buf) {
                writable.write(buf);
            });
            req.on(&quot;end&quot;, function () {
                writable.end();
            });
            return writable;
        },
        readable: true,
        url: xhr.url
    };
    res = {
        emit: function (type, data) {
            handler.dispatchEvent(new globalThis.CustomEvent(&quot;res.&quot; + type, {
                detail: data
            }));
        },
        end: function (data) {
            if (res._isDone) {
                return;
            }
            res._isDone = true;
            bufList.push(data);
            // notify server res is finished
            res.emit(&quot;finish&quot;);
            // pass res to client
            onResponse(res);
            res.emit(&quot;data&quot;, local.bufferConcat(bufList));
            res.emit(&quot;end&quot;);
        },
        on: function (type, onEvent) {
            handler.addEventListener(&quot;res.&quot; + type, function (evt) {
                onEvent(evt.detail);
            });
            return res;
        },
        setHeader: function (key, val) {
            xhr.resHeaders[key.toLowerCase()] = val;
        },
        statusCode: 200,
        write: function (data) {
            bufList.push(data);
        }
    };
    return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}, local.nop);
// debug opt
local._debugForwardProxy = opt;
opt.clientReq = (
    opt.protocol === &quot;https:&quot;
    ? local.https
    : local.http
).<span class="apidocCodeKeywordSpan">request</span>(opt, function (clientReq) {
    opt.clientReq = clientReq.on(&quot;error&quot;, onError);
    res.statusCode = opt.clientReq.statusCode;
    // pipe clientReq to res
    opt.clientReq.pipe(res);
}).on(&quot;error&quot;, onError);
opt.timeStart = Date.now();
// handle evt
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.apidoc" id="apidoc.module.utility2.apidoc">module utility2.apidoc</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.apidoc.apidocCreate" id="apidoc.elem.utility2.apidoc.apidocCreate">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create the apidoc from &lt;opt&gt;.dir
 */
</span>    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given &lt;module&gt;
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(&quot;.&quot;);
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(&quot;.&quot;);
        elem.id = encodeURIComponent(&quot;apidoc.elem.&quot; + prefix + &quot;.&quot; + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + &quot; &lt;span class=\&quot;apidocSignatureSpan\&quot;&gt;&quot;
            + elem.moduleName + &quot;.&lt;/span&gt;&quot; + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
        if (elem.typeof !== &quot;function&quot;) {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || &quot;n/a&quot;
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), &quot;&quot;).replace((
                /,/g
            ), &quot;, &quot;).replace((
                /\s+/g
            ), &quot; &quot;);
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), &quot;&lt;span class=\&quot;apidocCodeCommentSpan\&quot;&gt;$1&lt;/span&gt;&quot;).replace((
            /^function\u0020\(/
        ), key + &quot; = function (&quot;);
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp(&quot;((?:\n.*?){8}\\.)(&quot; + key + &quot;)(\\((?:.*?\n){8})&quot;),
                function (ignore, match1, match2, match3) {
                    elem.example = &quot;...&quot; + trimStart(
                        local.stringHtmlSafe(match1)
                        + &quot;&lt;span class=\&quot;apidocCodeKeywordSpan\&quot;&gt;&quot;
                        + local.stringHtmlSafe(match2)
                        + &quot;&lt;/span&gt;&quot;
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + &quot;\n...&quot;;
                    return &quot;&quot;;
                }
            );
            return elem.example;
        });
        elem.example = elem.example || &quot;n/a&quot;;
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = local.path.resolve(opt.dir, file);
            console.error(&quot;apidocCreate - readExample &quot; + file);
            result = &quot;&quot;;
            result = local.identity(
                &quot;\n\n\n\n\n\n\n\n&quot;
                // bug-workaround - truncate example to manageable size
                + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
                + &quot;\n\n\n\n\n\n\n\n&quot;
            ).replace((
                /\r\n*/g
            ), &quot;\n&quot;);
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = &quot;&quot;;
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (text) {
    /...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.write(local.<span class="apidocCodeKeywordSpan">apidocCreate</span>({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.apidocModuleDictAdd" id="apidoc.elem.utility2.apidoc.apidocModuleDictAdd">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocModuleDictAdd
        <span class="apidocSignatureSpan">(opt, moduleDict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocModuleDictAdd = function (opt, moduleDict) {
<span class="apidocCodeCommentSpan">/*
 * this function will add the modules in &lt;moduleDict&gt; to &lt;opt&gt;.moduleDict
 */
</span>    let isModule;
    let objectKeys;
    let tmp;
    objectKeys = function (dict) {
    /*
     * this function will return a list of the dict&apos;s keys, with valid getters
     */
        return Object.keys(dict).sort().filter(function (key) {
            return local.tryCatchOnError(function () {
                return dict[key] || true;
            }, local.nop);
        });
    };
    [
        &quot;child&quot;, &quot;prototype&quot;, &quot;grandchild&quot;, &quot;prototype&quot;
    ].forEach(function (elem) {
        objectKeys(moduleDict).forEach(function (prefix) {
            if (!(
                /^\w[\w\-.]*?$/
            ).test(prefix)) {
                return;
            }
            objectKeys(moduleDict[prefix]).forEach(function (key) {
                if (!(
                    /^\w[\w\-.]*?$/
                ).test(key) || !moduleDict[prefix][key]) {
                    return;
                }
                tmp = (
                    elem === &quot;prototype&quot;
                    ? {
                        module: moduleDict[prefix][key].prototype,
                        name: prefix + &quot;.&quot; + key + &quot;.prototype&quot;
                    }
                    : {
                        module: moduleDict[prefix][key],
                        name: prefix + &quot;.&quot; + key
                    }
                );
                if (
                    !tmp.module
                    || !(
                        typeof tmp.module === &quot;function&quot;
                        || typeof tmp.module === &quot;object&quot;
                    )
                    || Array.isArray(tmp.module)
                    || opt.moduleDict[tmp.name]
                    || opt.circularSet.has(tmp.module)
                ) {
                    return;
                }
                isModule = Array.from([
                    tmp.module,
                    tmp.module.prototype
                ]).some(function (dict) {
                    return objectKeys(dict || {}).some(function (key) {
                        return typeof dict[key] === &quot;function&quot;;
                    });
                });
                if (!isModule) {
                    return;
                }
                opt.circularSet.add(tmp.module);
                opt.moduleDict[tmp.name] = tmp.module;
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.circularSet.add(opt.moduleDict[key]);
});
// init circularSet - prototype
opt.circularSet.forEach(function (elem) {
    opt.circularSet.add(elem &amp;&amp; elem.prototype);
});
// init moduleDict child
local.<span class="apidocCodeKeywordSpan">apidocModuleDictAdd</span>(opt, opt.moduleDict);
// init swgg.apiDict
Object.keys(
    (moduleMain.swgg &amp;&amp; moduleMain.swgg.apiDict) || {}
).forEach(function (key) {
    tmp = &quot;swgg.apiDict&quot;;
    opt.moduleDict[tmp] = opt.moduleDict[tmp] || {};
    tmp = opt.moduleDict[tmp];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.assert" id="apidoc.elem.utility2.apidoc.assert">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.assertOrThrow" id="apidoc.elem.utility2.apidoc.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.cliRun" id="apidoc.elem.utility2.apidoc.cliRun">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.coalesce" id="apidoc.elem.utility2.apidoc.coalesce">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.events" id="apidoc.elem.utility2.apidoc.events">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.fsRmrfSync" id="apidoc.elem.utility2.apidoc.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.functionOrNop" id="apidoc.elem.utility2.apidoc.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.identity" id="apidoc.elem.utility2.apidoc.identity">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.moduleDirname" id="apidoc.elem.utility2.apidoc.moduleDirname">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>moduleDirname
        <span class="apidocSignatureSpan">(module, pathList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moduleDirname = function (module, pathList) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
 */
</span>    let result;
    // search process.cwd()
    if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
        return require(&quot;path&quot;).resolve(process.cwd(), module || &quot;&quot;);
    }
    // search pathList
    Array.from([
        pathList,
        require(&quot;module&quot;).globalPaths,
        [
            process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
        ]
    ]).flat().some(function (path) {
        try {
            result = require(&quot;path&quot;).resolve(
                process.cwd(),
                path + &quot;/&quot; + module
            );
            result = require(&quot;fs&quot;).statSync(result).isDirectory() &amp;&amp; result;
            return result;
        } catch (ignore) {
            result = &quot;&quot;;
        }
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return match0.replace((
            /(.{128}(?:\b|\w+))/g
        ), &quot;$1\n&quot;).trimEnd();
    });
    return text;
};
// init opt
opt.dir = local.<span class="apidocCodeKeywordSpan">moduleDirname</span>(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.nop" id="apidoc.elem.utility2.apidoc.nop">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.objectAssignDefault" id="apidoc.elem.utility2.apidoc.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.objectSetDefault" id="apidoc.elem.utility2.apidoc.objectSetDefault">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectSetDefault
        <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectSetDefault = function (dict, defaults, depth) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set defaults for undefined-items in dict
 */
</span>    dict = dict || {};
    defaults = defaults || {};
    Object.keys(defaults).forEach(function (key) {
        let defaults2;
        let dict2;
        dict2 = dict[key];
        // handle misbehaving getter
        try {
            defaults2 = defaults[key];
        } catch (ignore) {}
        if (defaults2 === undefined) {
            return;
        }
        // init dict[key] to default value defaults[key]
        switch (dict2) {
        case &quot;&quot;:
        case null:
        case undefined:
            dict[key] = defaults2;
            return;
        }
        // if dict2 and defaults2 are both non-undefined and non-array objects,
        // then recurse with dict2 and defaults2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.objectSetDefault(dict2, defaults2, depth - 1);
        }
    });
    return dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.<span class="apidocCodeKeywordSpan">objectSetDefault</span>(dict2, defaults2, depth - 1);
        }
    });
    return dict;
};

local.stringHtmlSafe = function (text) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.querySelector" id="apidoc.elem.utility2.apidoc.querySelector">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.querySelectorAll" id="apidoc.elem.utility2.apidoc.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.stream" id="apidoc.elem.utility2.apidoc.stream">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.stringHtmlSafe" id="apidoc.elem.utility2.apidoc.stringHtmlSafe">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>stringHtmlSafe
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringHtmlSafe = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will make the text html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
</span>    return text.replace((
        /&amp;/g
    ), &quot;&amp;&quot;).replace((
        /&quot;/g
    ), &quot;&quot;&quot;).replace((
        /&apos;/g
    ), &quot;&apos;&quot;).replace((
        /&lt;/g
    ), &quot;&lt;&quot;).replace((
        /&gt;/g
    ), &quot;&gt;&quot;).replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/ig
    ), &quot;&amp;$1&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
// handle case where module is a function
elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
if (elem.typeof !== &quot;function&quot;) {
    return elem;
}
// init source
elem.source = local.<span class="apidocCodeKeywordSpan">stringHtmlSafe</span>(
    trimStart(toString(module[key])) || &quot;n/a&quot;
).replace((
    /\([\S\s]*?\)/
), function (match0) {
    // init signature
    elem.signature = match0.replace((
        /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.templateRender" id="apidoc.elem.utility2.apidoc.templateRender">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &apos;unless&apos; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in the template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.tryCatchOnError" id="apidoc.elem.utility2.apidoc.tryCatchOnError">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>tryCatchOnError
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryCatchOnError = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the fnc in a tryCatch block,
 * else call onError with errCaught
 */
</span>    let result;
    // validate onError
    local.assertOrThrow(typeof onError === &quot;function&quot;, typeof onError);
    try {
        // reset errCaught
        local._debugTryCatchError = null;
        result = fnc();
        local._debugTryCatchError = null;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return elem;
};
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.<span class="apidocCodeKeywordSpan">tryCatchOnError</span>(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
...</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.apidoc.cliDict" id="apidoc.module.utility2.apidoc.cliDict">module utility2.apidoc.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.apidoc.cliDict._default" id="apidoc.elem.utility2.apidoc.cliDict._default">
        function <span class="apidocSignatureSpan">utility2.apidoc.cliDict.</span>_default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_default = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
</span>    // jslint files
    process.stdout.write(local.apidocCreate({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       local.cliDict._help();
       return;
   }
   if (local.cliDict[process.argv[2]]) {
       local.cliDict[process.argv[2]]();
       return;
   }
   local.cliDict.<span class="apidocCodeKeywordSpan">_default</span>();
};

local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.cliDict" id="apidoc.module.utility2.cliDict">module utility2.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.browserTest" id="apidoc.elem.utility2.cliDict.utility2.browserTest">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.browserTest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.browserTest = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;urlList&gt; &lt;mode&gt;
 * will browser-test in parallel, comma-separated &lt;urlList&gt; with given &lt;mode&gt;
 */
</span>    local.browserTest({
        url: process.argv[3]
    }, local.onErrorDefault);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentDelete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentDelete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
 * will delete from github &lt;fileRemote|dirRemote&gt;
 */
</span>    local.github_crud.githubCrudContentDelete({
        message: process.argv[4],
        url: process.argv[3]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentGet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentGet = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt;
 * will get from github &lt;fileRemote&gt;
 */
</span>    local.github_crud.githubCrudContentGet({
        url: process.argv[3]
    }, function (err, data) {
        try {
            process.stdout.write(data);
        } catch (ignore) {}
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentPut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentPut = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt;, &lt;fileLocal&gt;
 */
</span>    local.github_crud.githubCrudContentPutFile({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentTouch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentTouch = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemoteList&gt; &lt;commitMessage&gt;
 * will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
 */
</span>    local.github_crud.githubCrudContentTouchList({
        message: process.argv[4],
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate" id="apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudRepoCreate = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoCreateList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete" id="apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoDelete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudRepoDelete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoDeleteList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.start" id="apidoc.elem.utility2.cliDict.utility2.start">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.start = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;port&gt;
 * will start utility2 http-server on given &lt;port&gt; (default 8081)
 */
</span>    local.env.PORT = process.argv[3] || local.env.PORT;
    globalThis.local = local;
    local.replStart();
    local.testRunServer({});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.swaggerValidateFile" id="apidoc.elem.utility2.cliDict.utility2.swaggerValidateFile">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.swaggerValidateFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.swaggerValidateFile = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;file/url&gt;
 * will swagger-validate file/url
 */
</span>    setTimeout(function () {
        local.swgg.swaggerValidateFile({
            file: process.argv[3]
        }, function (err, data) {
            console.error(data);
            process.exit(err);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.testReportCreate" id="apidoc.elem.utility2.cliDict.utility2.testReportCreate">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.testReportCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.testReportCreate = function () {
<span class="apidocCodeCommentSpan">/*
 *
 * will create test-report
 */
</span>    process.exit(local.testReportCreate(local.fsReadFileOrEmptyStringSync(
        local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
        &quot;json&quot;
    )).testsFailed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.github_crud" id="apidoc.module.utility2.github_crud">module utility2.github_crud</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.github_crud.ajax" id="apidoc.elem.utility2.github_crud.ajax">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>ajax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send an ajax-req
 * with given &lt;opt&gt;.url and callback &lt;onError&gt;
 * with err and timeout handling
 * example usage:
    local.ajax({
        data: &quot;hello world&quot;,
        header: {&quot;x-header-hello&quot;: &quot;world&quot;},
        method: &quot;POST&quot;,
        url: &quot;/index.html&quot;
    }, function (err, xhr) {
        console.log(xhr.statusCode);
        console.log(xhr.responseText);
    });
 */
</span>    let ajaxProgressUpdate;
    let bufferValidateAndCoerce;
    let isDone;
    let local2;
    let onError2;
    let onEvent;
    let stack;
    let streamCleanup;
    let timeout;
    let tmp;
    let xhr;
    let xhrInit;
    // init local2
    local2 = opt.local2 || local.utility2 || {};
    // init function
    ajaxProgressUpdate = local2.ajaxProgressUpdate || function () {
        return;
    };
    bufferValidateAndCoerce = local2.bufferValidateAndCoerce || function (
        buf,
        mode
    ) {
    /*
     * this function will validate and coerce/convert
     * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
     */
        // coerce ArrayBuffer to Buffer
        if (Object.prototype.toString.call(buf) === &quot;[object ArrayBuffer]&quot;) {
            buf = new Uint8Array(buf);
        }
        // convert Buffer to utf8
        if (mode === &quot;string&quot; &amp;&amp; typeof buf !== &quot;string&quot;) {
            buf = String(buf);
        }
        return buf;
    };
    onEvent = function (evt) {
    /*
     * this function will handle events
     */
        if (Object.prototype.toString.call(evt) === &quot;[object Error]&quot;) {
            xhr.err = xhr.err || evt;
            xhr.onEvent({
                type: &quot;error&quot;
            });
            return;
        }
        // init statusCode
        xhr.statusCode = (xhr.statusCode || xhr.status) | 0;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
        case &quot;load&quot;:
            if (isDone) {
                return;
            }
            isDone = true;
            // decrement counter
            ajaxProgressUpdate.counter = Math.max(
                ajaxProgressUpdate.counter - 1,
                0
            );
            ajaxProgressUpdate();
            // handle abort or err event
            switch (!xhr.err &amp;&amp; evt.type) {
            case &quot;abort&quot;:
            case &quot;error&quot;:
                xhr.err = new Error(&quot;ajax - event &quot; + evt.type);
                break;
            case &quot;load&quot;:
                if (xhr.statusCode &gt;= 400) {
                    xhr.err = new Error(
                        &quot;ajax - statusCode &quot; + xhr.statusCode
                    );
                }
                break;
            }
            // debug statusCode / method / url
            if (xhr.err) {
                xhr.statusCode = xhr.statusCode || 500;
                xhr.err.statusCode = xhr.statusCode;
                tmp = (
                    (
                        local.isBrowser
                        ? &quot;browser&quot;
                        : &quot;node&quot;
                    )
                    + &quot; - &quot; + xhr.statusCode + &quot; &quot; + xhr.method + &quot; &quot; + xhr.url
                    + &quot;\n&quot;
                );
                xhr.err.message = tmp + xhr.err.message;
                xhr.err.stack = tmp + xhr.err.stack;
            }
            // update resHeaders
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
            if (xhr.getAllResponseHeaders) {
                xhr.getAllResponseHeaders().replace((
                    /(.*?):\u0020*(.*?)\r\n/g
                ), function (ignore, key, val) {
                    xhr.resHeaders[key.toLowerCase()] = val;
                });
            }
            // debug ajaxResponse
            xhr.resContentLength =...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/* validateLineSortedReset */
local.ajax = function (opt, onError) {
/*
* this function will send an ajax-req
* with given &lt;opt&gt;.url and callback &lt;onError&gt;
* with err and timeout handling
* example usage:
   local.<span class="apidocCodeKeywordSpan">ajax</span>({
       data: &quot;hello world&quot;,
       header: {&quot;x-header-hello&quot;: &quot;world&quot;},
       method: &quot;POST&quot;,
       url: &quot;/index.html&quot;
   }, function (err, xhr) {
       console.log(xhr.statusCode);
       console.log(xhr.responseText);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.assert" id="apidoc.elem.utility2.github_crud.assert">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.assertOrThrow" id="apidoc.elem.utility2.github_crud.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliRun" id="apidoc.elem.utility2.github_crud.cliRun">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.coalesce" id="apidoc.elem.utility2.github_crud.coalesce">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.events" id="apidoc.elem.utility2.github_crud.events">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.fsRmrfSync" id="apidoc.elem.utility2.github_crud.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.functionOrNop" id="apidoc.elem.utility2.github_crud.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudAjax" id="apidoc.elem.utility2.github_crud.githubCrudAjax">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudAjax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudAjax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will make a low-level content-req to github
 * https://developer.github.com/v3/repos/contents/
 */
</span>    // init opt
    opt = {
        content: opt.content,
        headers: Object.assign({
            // github oauth authentication
            Authorization: &quot;token &quot; + (
                typeof process === &quot;object&quot;
                &amp;&amp; process &amp;&amp; process.env.GITHUB_TOKEN
            ),
            // bug-workaround
            // https://developer.github.com/v3/#user-agent-required
            &quot;User-Agent&quot;: &quot;undefined&quot;
        }, opt.headers),
        httpReq: opt.httpReq,
        message: opt.message,
        method: opt.method || &quot;GET&quot;,
        responseJson: {},
        sha: opt.sha,
        url: opt.url
    };
    // parse https://github.com/:owner/:repo/blob/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/github.com\/([^\/]+?\/[^\/]+?)\/blob\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://github.com/:owner/:repo/tree/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/github.com\/([^\/]+?\/[^\/]+?)\/tree\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://raw.githubusercontent.com/:owner/:repo/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/raw.githubusercontent.com\/([^\/]+?\/[^\/]+?)\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://:owner.github.io/:repo/:path
    opt.url = opt.url.replace((
        /^https:\/\/([^.]+?)\.github\.io\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/$2/contents/$3?branch=gh-pages&quot;);
    // parse :owner/:repo
    opt.url = opt.url.replace((
        /^([^\/]+?\/[^\/]+?)$/
    ), &quot;https://github.com/$1&quot;);
    opt.url = opt.url.replace((
        /\?branch=(.*)/
    ), function (match0, match1) {
        opt.branch = match1;
        if (opt.method === &quot;GET&quot;) {
            match0 = match0.replace(&quot;branch&quot;, &quot;ref&quot;);
        }
        return match0;
    });
    if ((
        /^https:\/\/github\.com\/[^\/]+?\/[^\/]+?$/
    ).test(opt.url)) {
        opt.data = JSON.stringify({
            name: opt.url.split(&quot;/&quot;)[4]
        });
        switch (opt.method) {
        case &quot;DELETE&quot;:
            opt.url = (
                &quot;https://api.github.com/repos/&quot;
                + opt.url.split(&quot;/&quot;).slice(3).join(&quot;/&quot;)
            );
            break;
        case &quot;POST_ORG&quot;:
            opt.url = (
                &quot;https://api.github.com/orgs/&quot;
                + opt.url.split(&quot;/&quot;)[3] + &quot;/repos&quot;
            );
            break;
        case &quot;POST_USER&quot;:
            opt.url = &quot;https://api.github.com/user/repos&quot;;
            break;
        }
        opt.method = opt.method.split(&quot;_&quot;)[0];
    } else {
        if (opt.url.indexOf(&quot;https://api.github.com/repos/&quot;) !== 0) {
            console.error(&quot;githubCrud - invalid url &quot; + opt.url);
            onError(new Error(&quot;invalid url &quot; + opt.url));
            return;
        }
        if (opt.method !== &quot;GET&quot;) {
            opt.message = (
                opt.message
                || &quot;[ci skip] &quot; + opt.method + &quot; file &quot;
                + opt.url.replace((
                    /\?.*/
                ), &quot;&quot;)
            );
            opt.url += &quot;&amp;message=&quot; + encodeURIComponent(opt.message);
            if (opt.sha) {
                opt.url += &quot;&amp;sha=&quot; + opt.sha;
            }
            opt.data = JSON.stringify({
                branch: opt.branch,
                content: Buffer.from(opt.content || &quot;&quot;).toString(&quot;base64&quot;),
                message: opt.message,...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message: opt.message,
    url: opt.url
};
local.gotoNext(opt, function (err, data) {
    switch (opt.gotoState) {
    case 1:
        // get sha
        local.<span class="apidocCodeKeywordSpan">githubCrudAjax</span>({
            httpReq: opt.httpReq,
            url: opt.url
        }, opt.gotoNext);
        break;
    case 2:
        // delete file with sha
        if (!err &amp;&amp; data.sha) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentDelete" id="apidoc.elem.utility2.github_crud.githubCrudContentDelete">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentDelete
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentDelete = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#delete-a-file
 */
</span>    opt = {
        httpReq: opt.httpReq,
        message: opt.message,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // delete file with sha
            if (!err &amp;&amp; data.sha) {
                local.githubCrudAjax({
                    httpReq: opt.httpReq,
                    message: opt.message,
                    method: &quot;DELETE&quot;,
                    sha: data.sha,
                    url: opt.url
                }, opt.gotoNext);
                return;
            }
            // delete tree
            local.onParallelList({
                list: data
            }, function (option2, onParallel) {
                onParallel.counter += 1;
                // recurse
                local.githubCrudContentDelete({
                    httpReq: opt.httpReq,
                    message: opt.message,
                    url: option2.elem.url
                }, onParallel);
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    // delete tree
    local.onParallelList({
        list: data
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        // recurse
        local.<span class="apidocCodeKeywordSpan">githubCrudContentDelete</span>({
            httpReq: opt.httpReq,
            message: opt.message,
            url: option2.elem.url
        }, onParallel);
    }, opt.gotoNext);
    break;
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentGet" id="apidoc.elem.utility2.github_crud.githubCrudContentGet">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentGet
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentGet = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will get github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#get-contents
 */
</span>    opt = {
        httpReq: opt.httpReq,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            opt.gotoNext(null, Buffer.from(data.content || &quot;&quot;, &quot;base64&quot;));
            break;
        default:
            onError(err, !err &amp;&amp; data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict.get = function () {
/*
* &lt;fileRemote&gt;
* will get from github &lt;fileRemote&gt;
*/
   local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentGet</span>({
       url: process.argv[3]
   }, function (err, data) {
       try {
           process.stdout.write(data);
       } catch (ignore) {}
       process.exit(Boolean(err));
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentPut" id="apidoc.elem.utility2.github_crud.githubCrudContentPut">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPut
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentPut = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will put &lt;opt&gt;.content to github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#create-a-file
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        content: opt.content,
        httpReq: opt.httpReq,
        message: opt.message,
        modeErrorIgnore: true,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // put file with sha
            local.githubCrudAjax({
                content: opt.content,
                httpReq: opt.httpReq,
                message: opt.message,
                method: &quot;PUT&quot;,
                sha: data.sha,
                url: opt.url
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
        return;
    }
    // get file
    local.fs.readFile(opt.file, opt.gotoNext);
    break;
case 2:
    local.<span class="apidocCodeKeywordSpan">githubCrudContentPut</span>({
        content: data,
        httpReq: opt.httpReq,
        message: opt.message,
        // resolve file in url
        url: (
            (
                /\/$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentPutFile" id="apidoc.elem.utility2.github_crud.githubCrudContentPutFile">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPutFile
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentPutFile = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will put opt.file to github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        file: opt.file,
        httpReq: opt.httpReq,
        message: opt.message,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get file from url
            if ((
                /^(?:http|https):\/\//
            ).test(opt.file)) {
                local.ajax({
                    httpReq: opt.httpReq,
                    url: opt.file
                }, function (err, res) {
                    opt.gotoNext(err, res &amp;&amp; res.data);
                });
                return;
            }
            // get file
            local.fs.readFile(opt.file, opt.gotoNext);
            break;
        case 2:
            local.githubCrudContentPut({
                content: data,
                httpReq: opt.httpReq,
                message: opt.message,
                // resolve file in url
                url: (
                    (
                        /\/$/
                    ).test(opt.url)
                    ? opt.url + local.path.basename(opt.file)
                    : opt.url
                )
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict.put = function () {
/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt; to &lt;fileLocal&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentPutFile</span>({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentTouch" id="apidoc.elem.utility2.github_crud.githubCrudContentTouch">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouch
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentTouch = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will touch github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        httpReq: opt.httpReq,
        message: opt.message,
        modeErrorIgnore: true,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // put file with sha
            local.githubCrudAjax({
                content: Buffer.from(data.content || &quot;&quot;, &quot;base64&quot;),
                httpReq: opt.httpReq,
                message: opt.message,
                method: &quot;PUT&quot;,
                sha: data.sha,
                url: opt.url
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will touch github-files &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudContentTouch</span>({
            httpReq: opt.httpReq,
            message: opt.message,
            url: option2.elem
        }, onParallel);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentTouchList" id="apidoc.elem.utility2.github_crud.githubCrudContentTouchList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouchList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentTouchList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will touch github-files &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.githubCrudContentTouch({
            httpReq: opt.httpReq,
            message: opt.message,
            url: option2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict.touch = function () {
/*
* &lt;fileRemoteList&gt; &lt;commitMessage&gt;
* will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
*/
   local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentTouchList</span>({
       message: process.argv[4],
       urlList: process.argv[3].split(
           /[,\s]/g
       ).filter(local.identity)
   }, function (err) {
       process.exit(Boolean(err));
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreate" id="apidoc.elem.utility2.github_crud.githubCrudRepoCreate">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreate
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoCreate = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will create github-repo &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/#create
 */
</span>    local.githubCrudAjax({
        httpReq: opt.httpReq,
        method: &quot;POST_ORG&quot;,
        url: opt.url
    }, function (err, data) {
        if (!(err &amp;&amp; err.statusCode === 404)) {
            onError(err, data);
            return;
        }
        local.githubCrudAjax({
            httpReq: opt.httpReq,
            method: &quot;POST_USER&quot;,
            url: opt.url
        }, onError);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will create github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#create
 */
    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudRepoCreate</span>({
            httpReq: opt.httpReq,
            url: option2.elem
        }, onParallel);
    }, onError);
};

local.githubCrudRepoDelete = function (opt, onError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreateList" id="apidoc.elem.utility2.github_crud.githubCrudRepoCreateList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreateList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoCreateList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will create github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#create
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.githubCrudRepoCreate({
            httpReq: opt.httpReq,
            url: option2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict.repo_create = function () {
/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudRepoCreateList</span>({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoDelete" id="apidoc.elem.utility2.github_crud.githubCrudRepoDelete">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDelete
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoDelete = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-repo &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
</span>    local.githubCrudAjax({
        httpReq: opt.httpReq,
        method: &quot;DELETE&quot;,
        url: opt.url
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will delete github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudRepoDelete</span>({
            httpReq: opt.httpReq,
            url: option2.elem
        }, onParallel);
    }, onError);
};
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList" id="apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDeleteList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoDeleteList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (option2, onParallel) {
        onParallel.counter += 1;
        local.githubCrudRepoDelete({
            httpReq: opt.httpReq,
            url: option2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict.repo_delete = function () {
/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudRepoDeleteList</span>({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.gotoNext" id="apidoc.elem.utility2.github_crud.gotoNext">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>gotoNext
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoNext = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
 * and append current-stack to any err
 */
</span>    opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
        try {
            opt.gotoState += (
                (err &amp;&amp; !opt.modeErrorIgnore)
                ? 1000
                : 1
            );
            if (opt.modeDebug) {
                console.error(&quot;gotoNext - &quot; + JSON.stringify({
                    gotoState: opt.gotoState,
                    errorMessage: err &amp;&amp; err.message
                }));
                if (err &amp;&amp; err.stack) {
                    console.error(err.stack);
                }
            }
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.gotoNext(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.<span class="apidocCodeKeywordSpan">gotoNext</span>(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
};

local.onErrorDefault = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.identity" id="apidoc.elem.utility2.github_crud.identity">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.nop" id="apidoc.elem.utility2.github_crud.nop">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.objectAssignDefault" id="apidoc.elem.utility2.github_crud.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onErrorDefault" id="apidoc.elem.utility2.github_crud.onErrorDefault">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorDefault
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorDefault = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then print it to stderr
 */
</span>    if (err) {
        console.error(err);
    }
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.onParallel(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.<span class="apidocCodeKeywordSpan">onErrorDefault</span>(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
        return true;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onErrorWithStack" id="apidoc.elem.utility2.github_crud.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack.replace((
        /(.*?)\n.*?$/m
    ), &quot;$1&quot;);
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errDefault
            &amp;&amp; String(err.stack).indexOf(stack.split(&quot;\n&quot;)[2]) &lt; 0
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onParallel" id="apidoc.elem.utility2.github_crud.onParallel">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if counter === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement counter
        onParallel.counter -= 1;
        // validate counter
        if (!(onParallel.counter &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.counter = &quot; + onParallel.counter
            );
        // ensure onError is run only once
        } else if (onParallel.counter &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure counter &lt;= 0
            onParallel.counter = -Math.abs(onParallel.counter);
        }
        // call onError when isDone
        if (onParallel.counter &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init counter
    onParallel.counter = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onParallelList" id="apidoc.elem.utility2.github_crud.onParallelList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallelList
        <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallelList = function (opt, onEach, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. async-run onEach in parallel,
 *    with given &lt;opt&gt;.rateLimit and &lt;opt&gt;.retryLimit
 * 2. call &lt;onError&gt; when onParallel.ii + 1 === &lt;opt&gt;.list.length
 */
</span>    let isListEnd;
    let onEach2;
    let onParallel;
    opt.list = opt.list || [];
    onEach2 = function () {
        while (true) {
            if (!(onParallel.ii + 1 &lt; opt.list.length)) {
                isListEnd = true;
                return;
            }
            if (!(onParallel.counter &lt; opt.rateLimit + 1)) {
                return;
            }
            onParallel.ii += 1;
            onEach({
                elem: opt.list[onParallel.ii],
                ii: onParallel.ii,
                list: opt.list,
                retry: 0
            }, onParallel);
        }
    };
    onParallel = local.onParallel(onError, onEach2, function (err, data) {
        if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
            local.onErrorDefault(err);
            data.retry += 1;
            setTimeout(function () {
                onParallel.counter -= 1;
                onEach(data, onParallel);
            }, 1000);
            return true;
        }
        // restart if opt.list has grown
        if (isListEnd &amp;&amp; (onParallel.ii + 1 &lt; opt.list.length)) {
            isListEnd = undefined;
            onEach2();
        }
    });
    onParallel.ii = -1;
    opt.rateLimit = Number(opt.rateLimit) || 6;
    opt.rateLimit = Math.max(opt.rateLimit, 1);
    opt.retryLimit = Number(opt.retryLimit) || 2;
    onParallel.counter += 1;
    onEach2();
    onParallel();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        method: &quot;DELETE&quot;,
        sha: data.sha,
        url: opt.url
    }, opt.gotoNext);
    return;
}
// delete tree
local.<span class="apidocCodeKeywordSpan">onParallelList</span>({
    list: data
}, function (option2, onParallel) {
    onParallel.counter += 1;
    // recurse
    local.githubCrudContentDelete({
        httpReq: opt.httpReq,
        message: opt.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.querySelector" id="apidoc.elem.utility2.github_crud.querySelector">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.querySelectorAll" id="apidoc.elem.utility2.github_crud.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.stream" id="apidoc.elem.utility2.github_crud.stream">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.github_crud.cliDict" id="apidoc.module.utility2.github_crud.cliDict">module utility2.github_crud.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.delete" id="apidoc.elem.utility2.github_crud.cliDict.delete">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>delete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
 * will delete from github &lt;fileRemote|dirRemote&gt;
 */
</span>    local.github_crud.githubCrudContentDelete({
        message: process.argv[4],
        url: process.argv[3]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    socket.write(headers.concat(&apos;\r\n&apos;).join(&apos;\r\n&apos;));
    socket.removeListener(&apos;error&apos;, socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on(&apos;close&apos;, () =&gt; this.clients.<span class="apidocCodeKeywordSpan">delete</span>(ws));
    }

    cb(ws);
  }
}

exports_websockets_ws_lib_websocket_server = WebSocketServer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.get" id="apidoc.elem.utility2.github_crud.cliDict.get">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt;
 * will get from github &lt;fileRemote&gt;
 */
</span>    local.github_crud.githubCrudContentGet({
        url: process.argv[3]
    }, function (err, data) {
        try {
            process.stdout.write(data);
        } catch (ignore) {}
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this._supports();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.<span class="apidocCodeKeywordSpan">get</span>();
                                if (!this.options.strict) {

//fire error event
this.fire({
    type:       &quot;error&quot;,
    error:      null,
    message:    &quot;Unknown @ rule: &quot; + tokenStream.LT(0).value + &quot;.&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.put" id="apidoc.elem.utility2.github_crud.cliDict.put">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>put
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt; to &lt;fileLocal&gt;
 */
</span>    local.github_crud.githubCrudContentPutFile({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.repo_create" id="apidoc.elem.utility2.github_crud.cliDict.repo_create">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repo_create = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoCreateList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.repo_delete" id="apidoc.elem.utility2.github_crud.cliDict.repo_delete">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_delete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repo_delete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoDeleteList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.touch" id="apidoc.elem.utility2.github_crud.cliDict.touch">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemoteList&gt; &lt;commitMessage&gt;
 * will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
 */
</span>    local.github_crud.githubCrudContentTouchList({
        message: process.argv[4],
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul" id="apidoc.module.utility2.istanbul">module utility2.istanbul</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport" id="apidoc.elem.utility2.istanbul.HtmlReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>HtmlReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlReport(opts) {
    Report.call(this);
    this.opts = opts || {};
    this.opts.dir = this.opts.dir || path.resolve(process.cwd(), &apos;html-report&apos;);
    this.opts.sourceStore = this.opts.sourceStore || Store.create(&apos;fslookup&apos;);
    this.opts.linkMapper = this.opts.linkMapper || this.standardLinkMapper();
    this.opts.writer = this.opts.writer || null;
    // hack-coverage - new Date() bugfix
    this.opts.templateData = { datetime: new Date().toGMTString() };
    this.opts.watermarks = this.opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.<span class="apidocCodeKeywordSpan">HtmlReport</span>(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * 3. return instrumented code
 */
    // 1. normalize the file
    file = local._istanbul_path.resolve(&quot;/&quot;, file);
    // 2. save code to __coverageCodeDict__[file] for future html-report
    globalThis.__coverageCodeDict__[file] = true;
    // 3. return instrumented code
    return new local.<span class="apidocCodeKeywordSpan">Instrumenter</span>({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
};

local.util = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.TextReport" id="apidoc.elem.utility2.istanbul.TextReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>TextReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextReport(opts) {
    Report.call(this);
    opts = opts || {};
    this.dir = opts.dir || process.cwd();
    this.file = opts.file;
    this.summary = opts.summary;
    this.maxCols = opts.maxCols || 0;
    this.watermarks = opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
    + &quot;\&quot;&gt;\n&quot;
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.<span class="apidocCodeKeywordSpan">TextReport</span>(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul._istanbul_module" id="apidoc.elem.utility2.istanbul._istanbul_module">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>_istanbul_module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.assert" id="apidoc.elem.utility2.istanbul.assert">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.assertOrThrow" id="apidoc.elem.utility2.istanbul.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliRun" id="apidoc.elem.utility2.istanbul.cliRun">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coalesce" id="apidoc.elem.utility2.istanbul.coalesce">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageMerge" id="apidoc.elem.utility2.istanbul.coverageMerge">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageMerge
        <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageMerge = function (coverage1, coverage2) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge coverage2 into coverage1
 */
</span>    let dict1;
    let dict2;
    coverage1 = coverage1 || {};
    coverage2 = coverage2 || {};
    Object.keys(coverage2).forEach(function (file) {
        if (!coverage2[file]) {
            return;
        }
        // if file is undefined in coverage1, then add it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge file from coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (count, ii) {
                        dict1[key][ii] += count;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
opt = {};
opt.dir = process.cwd() + &quot;/tmp/build/coverage.html&quot;;
// merge previous coverage
if (!local.isBrowser &amp;&amp; process.env.npm_config_mode_coverage_merge) {
    console.log(&quot;merging file &quot; + opt.dir + &quot;/coverage.json to coverage&quot;);
    try {
        local.<span class="apidocCodeKeywordSpan">coverageMerge</span>(opt.coverage, JSON.parse(
            local.fs.readFileSync(opt.dir + &quot;/coverage.json&quot;, &quot;utf8&quot;)
        ));
    } catch (ignore) {}
    try {
        Object.keys(JSON.parse(local.fs.readFileSync(
            opt.dir + &quot;/coverage.code-dict.json&quot;,
            &quot;utf8&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageReportCreate" id="apidoc.elem.utility2.istanbul.coverageReportCreate">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. print coverage in text-format to stdout
 * 2. write coverage in html-format to filesystem
 * 3. return coverage in html-format as single document
 */
</span>    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    opt = {};
    opt.dir = process.cwd() + &quot;/tmp/build/coverage.html&quot;;
    // merge previous coverage
    if (!local.isBrowser &amp;&amp; process.env.npm_config_mode_coverage_merge) {
        console.log(&quot;merging file &quot; + opt.dir + &quot;/coverage.json to coverage&quot;);
        try {
            local.coverageMerge(opt.coverage, JSON.parse(
                local.fs.readFileSync(opt.dir + &quot;/coverage.json&quot;, &quot;utf8&quot;)
            ));
        } catch (ignore) {}
        try {
            Object.keys(JSON.parse(local.fs.readFileSync(
                opt.dir + &quot;/coverage.code-dict.json&quot;,
                &quot;utf8&quot;
            ))).forEach(function (key) {
                globalThis.__coverageCodeDict__[key] = (
                    globalThis.__coverageCodeDict__[key]
                    || true
                );
            });
        } catch (ignore) {}
    }
    // init writer
    local.coverageReportHtml = &quot;&quot;;
    local.coverageReportHtml += (
        &quot;&lt;div class=\&quot;coverageReportDiv\&quot;&gt;\n&quot;
        + &quot;&lt;h1&gt;coverage-report&lt;/h1&gt;\n&quot;
        + &quot;&lt;div style=\&quot;&quot;
        + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
        + &quot;\&quot;&gt;\n&quot;
    );
    local.writerData = &quot;&quot;;
    opt.sourceStore = {};
    opt.writer = local.writer;
    // 1. print coverage in text-format to stdout
    new local.TextReport(opt).writeReport(local.collector);
    // 2. write coverage in html-format to filesystem
    new local.HtmlReport(opt).writeReport(local.collector);
    local.writer.writeFile(&quot;&quot;, local.nop);
    if (!local.isBrowser) {
        // write coverage.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.json&quot;,
            JSON.stringify(opt.coverage)
        );
        // write coverage.code-dict.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.code-dict.json&quot;,
            JSON.stringify(globalThis.__coverageCodeDict__)
        );
        // write coverage.badge.svg
        opt.pct = local.coverageReportSummary.root.metrics.lines.pct;
        local.fsWriteFileWithMkdirpSync(
            local._istanbul_path.dirname(opt.dir) + &quot;/coverage.badge.svg&quot;,
            // edit coverage badge percent
            // edit coverage badge color
            local.templateCoverageBadgeSvg.replace((
                /100.0/g
            ), opt.pct).replace((
                /0d0/g
            ), (
                Math.round((100 - opt.pct) * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + Math.round(opt.pct * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + &quot;00&quot;
            ))
        );
    }
    console.log(&quot;created coverage file &quot; + opt.dir + &quot;/index.html&quot;);
    // 3. return coverage in html-format as a single document
    local.coverageReportHtml += &quot;&lt;/div&gt;\n&lt;/div&gt;\n&quot;;
    // write coverage.rollup.html
    if (!local.isBrowser) {
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.rollup.html&quot;,
            local.coverageReportHtml
        );
    }
    return local.coverageReportHtml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;\n\
}\n\
};\n\
// handle evt\n\
local.on(&quot;utility2.testRunEnd&quot;, function () {\n\
local.querySelector(\n\
    &quot;#htmlCoverageReport1&quot;\n\
).innerHTML = local.istanbul.<span class="apidocCodeKeywordSpan">coverageReportCreate</span>({\n\
    coverage: globalThis.__coverage__\n\
});\n\
});\n\
local.on(&quot;utility2.testRunProgressUpdate&quot;, function (testReport) {\n\
local.querySelector(\n\
    &quot;#htmlTestReport2&quot;\n\
).innerHTML = local.testReportMerge(testReport, {});\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.events" id="apidoc.elem.utility2.istanbul.events">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.fsRmrfSync" id="apidoc.elem.utility2.istanbul.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.functionOrNop" id="apidoc.elem.utility2.istanbul.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.identity" id="apidoc.elem.utility2.istanbul.identity">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.instrumentInPackage" id="apidoc.elem.utility2.istanbul.instrumentInPackage">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument the code
 * only if the macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in the code
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.instrumentSync" id="apidoc.elem.utility2.istanbul.instrumentSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. normalize the file
 * 2. save code to __coverageCodeDict__[file] for future html-report
 * 3. return instrumented code
 */
</span>    // 1. normalize the file
    file = local._istanbul_path.resolve(&quot;/&quot;, file);
    // 2. save code to __coverageCodeDict__[file] for future html-report
    globalThis.__coverageCodeDict__[file] = true;
    // 3. return instrumented code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               ) &gt;= 0
               || code.indexOf(
                   &quot;/* istanbul instrument in package &quot;
                   + process.env.npm_config_mode_coverage + &quot; */\n&quot;
               ) &gt;= 0
           )
       )
       ? local.<span class="apidocCodeKeywordSpan">instrumentSync</span>(code, file)
       : code
   );
};

local.instrumentSync = function (code, file) {
/*
* this function will
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.nop" id="apidoc.elem.utility2.istanbul.nop">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.objectAssignDefault" id="apidoc.elem.utility2.istanbul.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.querySelector" id="apidoc.elem.utility2.istanbul.querySelector">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.querySelectorAll" id="apidoc.elem.utility2.istanbul.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require" id="apidoc.elem.utility2.istanbul.require">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.stream" id="apidoc.elem.utility2.istanbul.stream">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.HtmlReport" id="apidoc.module.utility2.istanbul.HtmlReport">module utility2.istanbul.HtmlReport</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.HtmlReport" id="apidoc.elem.utility2.istanbul.HtmlReport.HtmlReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>HtmlReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlReport(opts) {
    Report.call(this);
    this.opts = opts || {};
    this.opts.dir = this.opts.dir || path.resolve(process.cwd(), &apos;html-report&apos;);
    this.opts.sourceStore = this.opts.sourceStore || Store.create(&apos;fslookup&apos;);
    this.opts.linkMapper = this.opts.linkMapper || this.standardLinkMapper();
    this.opts.writer = this.opts.writer || null;
    // hack-coverage - new Date() bugfix
    this.opts.templateData = { datetime: new Date().toGMTString() };
    this.opts.watermarks = this.opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.<span class="apidocCodeKeywordSpan">HtmlReport</span>(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.HtmlReport.prototype" id="apidoc.module.utility2.istanbul.HtmlReport.prototype">module utility2.istanbul.HtmlReport.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.fillTemplate" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.fillTemplate">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>fillTemplate
        <span class="apidocSignatureSpan">(node, templateData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillTemplate = function (node, templateData) {
    var opts = this.opts,
        linkMapper = opts.linkMapper;

    templateData.entity = node.name || &apos;All files&apos;;
    templateData.metrics = node.metrics;
    templateData.reportClass = getReportClass(node.metrics.statements, opts.watermarks.statements);
    templateData.pathHtml = pathTemplate({ html: this.getPathHtml(node, linkMapper) });
    templateData.prettify = {
        js: linkMapper.asset(node, &apos;prettify.js&apos;),
        css: linkMapper.asset(node, &apos;prettify.css&apos;)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.getPathHtml" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.getPathHtml">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>getPathHtml
        <span class="apidocSignatureSpan">(node, linkMapper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPathHtml = function (node, linkMapper) {
    var parent = node.parent,
        nodePath = [],
        linkPath = [],
        i;

    while (parent) {
        nodePath.push(parent);
        parent = parent.parent;
    }

    for (i = 0; i &lt; nodePath.length; i += 1) {
        linkPath.push(&apos;&lt;a href=&quot;&apos; + linkMapper.ancestor(node, i + 1) + &apos;&quot;&gt;&apos; +
            (nodePath[i].relativeName || &apos;All files&apos;) + &apos;&lt;/a&gt;&apos;);
    }
    linkPath.reverse();
    return linkPath.length &gt; 0 ? linkPath.join(&apos; &amp;#187; &apos;) + &apos; &amp;#187; &apos; +
        node.displayShortName() : &apos;&apos;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.standardLinkMapper" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.standardLinkMapper">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>standardLinkMapper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">standardLinkMapper = function () {
    return {
        fromParent: function (node) {
            var i = 0,
                relativeName = node.relativeName,
                ch;
            if (SEP !== &apos;/&apos;) {
                relativeName = &apos;&apos;;
                for (i = 0; i &lt; node.relativeName.length; i += 1) {
                    ch = node.relativeName.charAt(i);
                    if (ch === SEP) {
                        relativeName += &apos;/&apos;;
                    } else {
                        relativeName += ch;
                    }
                }
            }
            return node.kind === &apos;dir&apos; ? relativeName + &apos;index.html&apos; : relativeName + &apos;.html&apos;;
        },
        ancestorHref: function (node, num) {
            var href = &apos;&apos;,
                separated,
                levels,
                i,
                j;
            for (i = 0; i &lt; num; i += 1) {
                separated = node.relativeName.split(SEP);
                levels = separated.length - 1;
                for (j = 0; j &lt; levels; j += 1) {
                    href += &apos;../&apos;;
                }
                node = node.parent;
            }
            return href;
        },
        ancestor: function (node, num) {
            return this.ancestorHref(node, num) + &apos;index.html&apos;;
        },
        asset: function (node, name) {
            var i = 0,
                parent = node.parent;
            while (parent) { i += 1; parent = parent.parent; }
            return this.ancestorHref(node, i) + name;
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeDetailPage" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeDetailPage">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeDetailPage
        <span class="apidocSignatureSpan">(writer, node, fileCoverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeDetailPage = function (writer, node, fileCoverage) {
    var opts = this.opts,
        sourceStore = opts.sourceStore,
        templateData = opts.templateData,
        sourceText = fileCoverage.code &amp;&amp; Array.isArray(fileCoverage.code) ?
            fileCoverage.code.join(&apos;\n&apos;) + &apos;\n&apos; : sourceStore.get(fileCoverage.path),
        code = sourceText.split(/(?:\r?\n)|\r/),
        count = 0,
        structured = code.map(function (str) { count += 1; return { line: count, covered: null, text: new InsertionText(str, true
) }; }),
        context;

    structured.unshift({ line: 0, covered: null, text: new InsertionText(&quot;&quot;) });

    this.fillTemplate(node, templateData);
    writer.write(headerTemplate(templateData));
    writer.write(&apos;&lt;pre&gt;&lt;table class=&quot;coverage&quot;&gt;\n&apos;);

    annotateLines(fileCoverage, structured);
    //note: order is important, since statements typically result in spanning the whole line and doing branches late
    //causes mismatched tags
    annotateBranches(fileCoverage, structured);
    annotateFunctions(fileCoverage, structured);
    annotateStatements(fileCoverage, structured);

    structured.shift();
    context = {
        structured: structured,
        maxLines: structured.length,
        fileCoverage: fileCoverage
    };
    writer.write(detailTemplate(context));
    writer.write(&apos;&lt;/table&gt;&lt;/pre&gt;\n&apos;);
    writer.write(footerTemplate(templateData));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeFiles" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeFiles">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeFiles
        <span class="apidocSignatureSpan">(writer, node, dir, collector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFiles = function (writer, node, dir, collector) {
    var that = this,
        indexFile = path.resolve(dir, &apos;index.html&apos;),
        childFile;
    if (this.opts.verbose) { console.error(&apos;Writing &apos; + indexFile); }
    writer.writeFile(indexFile, function (contentWriter) {
        that.writeIndexPage(contentWriter, node);
    });
    node.children.forEach(function (child) {
        if (child.kind === &apos;dir&apos;) {
            that.writeFiles(writer, child, path.resolve(dir, child.relativeName), collector);
        } else {
            childFile = path.resolve(dir, child.relativeName + &apos;.html&apos;);
            if (that.opts.verbose) { console.error(&apos;Writing &apos; + childFile); }
            writer.writeFile(childFile, function (contentWriter) {
                that.writeDetailPage(contentWriter, child, collector.fileCoverageFor(child.fullPath()));
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeIndexPage" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeIndexPage">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeIndexPage
        <span class="apidocSignatureSpan">(writer, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIndexPage = function (writer, node) {
    var linkMapper = this.opts.linkMapper,
        templateData = this.opts.templateData,
        children = Array.prototype.slice.apply(node.children),
        watermarks = this.opts.watermarks;

    children.sort(function (a, b) {
        return a.name &lt; b.name ? -1 : 1;
    });

    this.fillTemplate(node, templateData);
    writer.write(headerTemplate(templateData));
    writer.write(summaryTableHeader);
    children.forEach(function (child) {
        var metrics = child.metrics,
            reportClasses = {
                statements: getReportClass(metrics.statements, watermarks.statements),
                lines: getReportClass(metrics.lines, watermarks.lines),
                functions: getReportClass(metrics.functions, watermarks.functions),
                branches: getReportClass(metrics.branches, watermarks.branches)
            },
            data = {
                metrics: metrics,
                reportClasses: reportClasses,
                file: child.displayShortName(),
                output: linkMapper.fromParent(child)
            };
        writer.write(summaryLineTemplate(data) + &apos;\n&apos;);
    });
    writer.write(summaryTableFooter);
    writer.write(footerTemplate(templateData));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeReport" id="apidoc.elem.utility2.istanbul.HtmlReport.prototype.writeReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.HtmlReport.prototype.</span>writeReport
        <span class="apidocSignatureSpan">(collector, sync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeReport = function (collector, sync) {
    var opts = this.opts,
        dir = opts.dir,
        summarizer = new TreeSummarizer(),
        writer = opts.writer || new FileWriter(sync),
        tree;

    collector.files().forEach(function (key) {
        summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));
    });
    tree = summarizer.getTreeSummary();
    fs.readdirSync(path.resolve(__dirname, &apos;..&apos;, &apos;vendor&apos;)).forEach(function (f) {
        var resolvedSource = path.resolve(__dirname, &apos;..&apos;, &apos;vendor&apos;, f),
            resolvedDestination = path.resolve(dir, f),
            stat = fs.statSync(resolvedSource);

        if (stat.isFile()) {
            if (opts.verbose) {
                console.log(&apos;Write asset: &apos; + resolvedDestination);
            }
            writer.copyFile(resolvedSource, resolvedDestination);
        }
    });
    //console.log(JSON.stringify(tree.root, undefined, 4));
    this.writeFiles(writer, tree.root, dir, collector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
    + &quot;\&quot;&gt;\n&quot;
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.TextReport(opt).<span class="apidocCodeKeywordSpan">writeReport</span>(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.Instrumenter" id="apidoc.module.utility2.istanbul.Instrumenter">module utility2.istanbul.Instrumenter</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * 3. return instrumented code
 */
    // 1. normalize the file
    file = local._istanbul_path.resolve(&quot;/&quot;, file);
    // 2. save code to __coverageCodeDict__[file] for future html-report
    globalThis.__coverageCodeDict__[file] = true;
    // 3. return instrumented code
    return new local.<span class="apidocCodeKeywordSpan">Instrumenter</span>({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
};

local.util = {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.Instrumenter.prototype" id="apidoc.module.utility2.istanbul.Instrumenter.prototype">module utility2.istanbul.Instrumenter.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>arrowBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowBlockConverter = function (node) {
    var retStatement;
    if (node.expression) { // turn expression nodes into a block with a return statement
        retStatement = astgen.returnStatement(node.body);
        // ensure the generated return statement is covered
        retStatement.loc = node.body.loc;
        node.body = this.convertToBlock(retStatement);
        node.expression = false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchIncrementExprAst
        <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchIncrementExprAst = function (varName, branchIndex, down) {
    var ret = astgen.postIncrement(
        astgen.subscript(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;b&apos;)),
                astgen.stringLiteral(varName)
            ),
            astgen.numericLiteral(branchIndex)
        ),
        down
    );
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchLocationFor
        <span class="apidocSignatureSpan">(name, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchLocationFor = function (name, index) {
    return this.coverState.branchMap[name].locations[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchName
        <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchName = function (type, startLine, pathLocations) {
    var bName,
        paths = [],
        locations = [],
        i,
        ignoring = !!this.currentState.ignoring;
    this.currentState.branch += 1;
    bName = this.currentState.branch;
    for (i = 0; i &lt; pathLocations.length; i += 1) {
        pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;
        locations.push(pathLocations[i]);
        paths.push(0);
    }
    this.coverState.b[bName] = paths;
    this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
    return bName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>conditionalBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalBranchInjector = function (node, walker) {
    var bName = this.branchName(&apos;cond-expr&apos;, walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate
 ])),
        ast1 = this.branchIncrementExprAst(bName, 0),
        ast2 = this.branchIncrementExprAst(bName, 1);

    node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));
    node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));
    node.consequent = astgen.sequence(ast1, node.consequent);
    node.alternate = astgen.sequence(ast2, node.alternate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>convertToBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertToBlock = function (node) {
    if (!node) {
        return { type: &apos;BlockStatement&apos;, body: [] };
    } else if (node.type === &apos;BlockStatement&apos;) {
        return node;
    } else {
        return { type: &apos;BlockStatement&apos;, body: [ node ] };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverExport
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverExport = function (node, walker) {
    var sName, incrStatementCount;

    if ( !node.declaration || !node.declaration.declarations ) { return; }

    this.maybeSkipNode(node, &apos;next&apos;);

    sName = this.statementName(node.declaration.loc);
    incrStatementCount = astgen.statement(
        astgen.postIncrement(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                astgen.stringLiteral(sName)
            )
        )
    );

    this.splice(incrStatementCount, node, walker);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverFunction
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverFunction = function (node, walker) {
    var id,
        body = node.body,
        blockBody = body.body,
        popped;

    this.maybeSkipNode(node, &apos;next&apos;);

    id = this.functionName(node, walker.startLineForNode(node), {
        start: node.loc.start,
        end: { line: node.body.loc.start.line, column: node.body.loc.start.column }
    });

    if (blockBody.length &gt; 0 &amp;&amp; this.isUseStrictExpression(blockBody[0])) {
        popped = blockBody.shift();
    }
    blockBody.unshift(
        astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;f&apos;)),
                    astgen.stringLiteral(id)
                )
            )
        )
    );
    if (popped) {
        blockBody.unshift(popped);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverMetaProperty
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
   node.skipSelf = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverStatement
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverStatement = function (node, walker) {
    var sName,
        incrStatementCount,
        parent,
        grandParent;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (this.isUseStrictExpression(node)) {
        grandParent = walker.ancestor(2);
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: difficult to test */
</span>        if (grandParent) {
            if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||
                grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &amp;&amp;
                walker.parent().node.body[0] === node) {
                return;
            }
        }
    }

    if (node.type === SYNTAX.FunctionDeclaration.name) {
        // Called for the side-effect of setting the function&apos;s statement count to 1.
        this.statementName(node.loc, 1);
    } else {
        // We let `coverExport` handle ExportNamedDeclarations.
        parent = walker.parent();
        if (parent &amp;&amp; parent.node.type === SYNTAX.ExportNamedDeclaration.name) {
            return;
        }

        sName = this.statementName(node.loc);

        incrStatementCount = astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                    astgen.stringLiteral(sName)
                )
            )
        );

        this.splice(incrStatementCount, node, walker);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>endIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endIgnore = function () {
    this.currentState.ignoring -= 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>extractCurrentHint
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractCurrentHint = function (node) {
    if (!node.range) { return; }
    var i = this.currentState.lastHintPosition + 1,
        hints = this.currentState.hints,
        nodeStart = node.range[0],
        hint;
    this.currentState.currentHint = null;
    // hack-coverage - allow top-level istanbul-ignore-next
    if (node.type === &quot;Program&quot;) { return; }
    while (i &lt; hints.length) {
        hint = hints[i];
        if (hint.end &lt; nodeStart) {
            this.currentState.currentHint = hint;
            this.currentState.lastHintPosition = i;
            i += 1;
        } else {
            break;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>filterHints
        <span class="apidocSignatureSpan">(comments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterHints = function (comments) {
    var ret = [],
        i,
        comment,
        groups;
    if (!(comments &amp;&amp; isArray(comments))) {
        return ret;
    }
    for (i = 0; i &lt; comments.length; i += 1) {
        comment = comments[i];
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: paranoid check */
</span>        if (comment &amp;&amp; comment.value &amp;&amp; comment.range &amp;&amp; isArray(comment.range)) {
            groups = String(comment.value).match(COMMENT_RE);
            if (groups) {
                ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });
            }
        }
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>findLeaves
        <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLeaves = function (node, accumulator, parent, property) {
    if (node.type === SYNTAX.LogicalExpression.name) {
        this.findLeaves(node.left, accumulator, node, &apos;left&apos;);
        this.findLeaves(node.right, accumulator, node, &apos;right&apos;);
    } else {
        accumulator.push({ node: node, parent: parent, property: property });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>fixColumnPositions
        <span class="apidocSignatureSpan">(coverState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixColumnPositions = function (coverState) {
    var offset = LEADER_WRAP.length,
        fixer = function (loc) {
            if (loc.start.line === 1) {
                loc.start.column -= offset;
            }
            if (loc.end.line === 1) {
                loc.end.column -= offset;
            }
        },
        k,
        obj,
        i,
        locations;

    obj = coverState.statementMap;
    for (k in obj) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: has own property */
</span>        if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
    }
    obj = coverState.fnMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
    }
    obj = coverState.branchMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) {
            locations = obj[k].locations;
            for (i = 0; i &lt; locations.length; i += 1) {
                fixer(locations[i]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>functionName
        <span class="apidocSignatureSpan">(node, line, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionName = function (node, line, location) {
    this.currentState.func += 1;
    var id = this.currentState.func,
        ignoring = !!this.currentState.ignoring,
        name = node.id ? node.id.name : &apos;(anonymous_&apos; + id + &apos;)&apos;,
        clone = function (attr) {
            var obj = location[attr] || /* istanbul ignore next */ {};
            return { line: obj.line, column: obj.column };
        };
    this.coverState.fnMap[id] = {
        name: name, line: line,
        loc: {
            start: clone(&apos;start&apos;),
            end: clone(&apos;end&apos;)
        },
        skip: ignoring || undefined
    };
    this.coverState.f[id] = 0;
    return id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>getPreamble
        <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPreamble = function (sourceCode, emitUseStrict) {
    var varName = this.opts.coverageVariable || &apos;__coverage__&apos;,
        file = this.coverState.path.replace(/\\/g, &apos;\\\\&apos;),
        tracker = this.currentState.trackerVar,
        coverState,
        strictLine = emitUseStrict ? &apos;&quot;use strict&quot;;&apos; : &apos;&apos;,
        // return replacements using the function to ensure that the replacement is
        // treated like a dumb string and not as a string with RE replacement patterns
        replacer = function (s) {
            return function () { return s; };
        },
        code;
    if (!this.opts.noAutoWrap) {
        this.fixColumnPositions(this.coverState);
    }
    if (this.opts.embedSource) {
        this.coverState.code = sourceCode.split(/(?:\r?\n)|\r/);
    }
    coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
    code = [
        &quot;%STRICT%&quot;,
        &quot;var %VAR% = (Function(&apos;return this&apos;))();&quot;,
        &quot;if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }&quot;,
        &quot;%VAR% = %VAR%.%GLOBAL%;&quot;,
        &quot;if (!(%VAR%[&apos;%FILE%&apos;])) {&quot;,
        &quot;   %VAR%[&apos;%FILE%&apos;] = %OBJECT%;&quot;,
        &quot;}&quot;,
        &quot;%VAR% = %VAR%[&apos;%FILE%&apos;];&quot;
    ].join(&quot;\n&quot;)
        .replace(/%STRICT%/g, replacer(strictLine))
        .replace(/%VAR%/g, replacer(tracker))
        .replace(/%GLOBAL%/g, replacer(varName))
        .replace(/%FILE%/g, replacer(file))
        .replace(/%OBJECT%/g, replacer(coverState));
    return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBlockConverter = function (node) {
    node.consequent = this.convertToBlock(node.consequent);
    node.alternate = this.convertToBlock(node.alternate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBranchInjector = function (node, walker) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThen = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;if&apos;,
        ignoreElse = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;else&apos;,
        line = node.loc.start.line,
        col = node.loc.start.column,
        makeLoc = function () { return  { line: line, column: col }; },
        bName = this.branchName(&apos;if&apos;, walker.startLineForNode(node), [
            { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },
            { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }
        ]),
        thenBody = node.consequent.body,
        elseBody = node.alternate.body,
        child;
    thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
    elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
    if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
    if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrument
        <span class="apidocSignatureSpan">(code, filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function (code, filename, callback) {

    if (!callback &amp;&amp; typeof filename === &apos;function&apos;) {
        callback = filename;
        filename = null;
    }
    try {
        callback(null, this.instrumentSync(code, filename));
    } catch (ex) {
        callback(ex);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentASTSync
        <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentASTSync = function (program, filename, originalCode) {
    var usingStrict = false,
        codegenOptions,
        generated,
        preamble,
        lineCount,
        i;
    filename = filename || String(new Date().getTime()) + &apos;.js&apos;;
    this.sourceMap = null;
    this.coverState = {
        path: filename,
        s: {},
        b: {},
        f: {},
        fnMap: {},
        statementMap: {},
        branchMap: {}
    };
    this.currentState = {
        trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
        func: 0,
        branch: 0,
        variable: 0,
        statement: 0,
        hints: this.filterHints(program.comments),
        currentHint: null,
        lastHintPosition: -1,
        ignoring: 0
    };
    if (program.body &amp;&amp; program.body.length &gt; 0 &amp;&amp; this.isUseStrictExpression(program.body[0])) {
        //nuke it
        program.body.shift();
        //and add it back at code generation time
        usingStrict = true;
    }
    this.walker.startWalk(program);
    codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
    codegenOptions.comment = this.opts.preserveComments;
    //console.log(JSON.stringify(program, undefined, 2));

    generated = ESPGEN.generate(program, codegenOptions);
    preamble = this.getPreamble(originalCode || &apos;&apos;, usingStrict);

    if (generated.map &amp;&amp; generated.code) {
        lineCount = preamble.split(/\r\n|\r|\n/).length;
        // offset all the generated line numbers by the number of lines in the preamble
        for (i = 0; i &lt; generated.map._mappings._array.length; i += 1) {
            generated.map._mappings._array[i].generatedLine += lineCount;
        }
        this.sourceMap = generated.map;
        generated = generated.code;
    }

    return preamble + &apos;\n&apos; + generated + &apos;\n&apos;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, filename) {
    var program;

    //protect from users accidentally passing in a Buffer object instead
    if (typeof code !== &apos;string&apos;) { throw new Error(&apos;Code must be string&apos;); }
    if (code.charAt(0) === &apos;#&apos;) { //shebang, &apos;comment&apos; it out, won&apos;t affect syntax tree locations for things we care about
        code = &apos;//&apos; + code;
    }
    if (!this.opts.noAutoWrap) {
        code = LEADER_WRAP + code + TRAILER_WRAP;
    }
    try {
        // hack-coverage - acorn opt
        var opt = {
            locations: true,
            onComment: [],
            onToken: this.opts.preserveComments,
            ranges: true,
            sourceType: this.opts.esModules ? &apos;module&apos; : &apos;script&apos;
        };
        program = ESP.parse(code, opt);
        program.comments = opt.onComment
    } catch (e) {
        console.log(&apos;Failed to parse file: &apos; + filename);
        throw e;
    }
    if (this.opts.preserveComments) {
        program = ESPGEN.attachComments(program, program.comments, program.tokens);
    }
    if (!this.opts.noAutoWrap) {
        program = {
            type: SYNTAX.Program.name,
            body: program.body[0].expression.callee.body.body,
            comments: program.comments
        };
    }
    return this.instrumentASTSync(program, filename, code);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               ) &gt;= 0
               || code.indexOf(
                   &quot;/* istanbul instrument in package &quot;
                   + process.env.npm_config_mode_coverage + &quot; */\n&quot;
               ) &gt;= 0
           )
       )
       ? local.<span class="apidocCodeKeywordSpan">instrumentSync</span>(code, file)
       : code
   );
};

local.instrumentSync = function (code, file) {
/*
* this function will
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>isUseStrictExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUseStrictExpression = function (node) {
    return node &amp;&amp; node.type === SYNTAX.ExpressionStatement.name &amp;&amp;
        node.expression  &amp;&amp; node.expression.type === SYNTAX.Literal.name &amp;&amp;
        node.expression.value === &apos;use strict&apos;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastFileCoverage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastFileCoverage = function () {
    return this.coverState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastSourceMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastSourceMap = function () {
    return this.sourceMap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>locationsForNodes
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locationsForNodes = function (nodes) {
    var ret = [],
        i;
    for (i = 0; i &lt; nodes.length; i += 1) {
        ret.push(nodes[i].loc);
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>logicalExpressionBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpressionBranchInjector = function (node, walker) {
    var parent = walker.parent(),
        leaves = [],
        bName,
        tuple,
        i;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (parent &amp;&amp; parent.node.type === SYNTAX.LogicalExpression.name) {
        //already covered
        return;
    }

    this.findLeaves(node, leaves);
    bName = this.branchName(&apos;binary-expr&apos;,
        walker.startLineForNode(node),
        this.locationsForNodes(leaves.map(function (item) { return item.node; }))
    );
    for (i = 0; i &lt; leaves.length; i += 1) {
        tuple = leaves[i];
        tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
        tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>loopBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loopBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddSkip
        <span class="apidocSignatureSpan">(branchLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddSkip = function (branchLocation) {
    return function (node) {
        var alreadyIgnoring = !!this.currentState.ignoring,
            hint = this.currentState.currentHint,
            ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;next&apos;;
        if (ignoreThis) {
            this.startIgnore();
            node.postprocessor = this.endIgnore;
        }
        if (ignoreThis || alreadyIgnoring) {
            branchLocation.skip = true;
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddType = function (node) {
    var props = node.properties,
        i,
        child;
    for (i = 0; i &lt; props.length; i += 1) {
        child = props[i];
        if (!child.type) {
            child.type = SYNTAX.Property.name;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeSkipNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeSkipNode = function (node, type) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === type;

    if (ignoreThis) {
        this.startIgnore();
        node.postprocessor = this.endIgnore;
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>paranoidHandlerCheck
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">paranoidHandlerCheck = function (node) {
    // if someone is using an older esprima on the browser
    // convert handlers array to single handler attribute
    // containing its first element
<span class="apidocCodeCommentSpan">    /* istanbul ignore next */
</span>    if (!node.handler &amp;&amp; node.handlers) {
        node.handler = node.handlers[0];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipInit
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipInit = function (node) {
    if (node.init) {
        node.init.skipWalk = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipLeft
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLeft = function (node) {
    node.left.skipWalk = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>splice
        <span class="apidocSignatureSpan">(statements, node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (statements, node, walker) {
    var targetNode = walker.isLabeled() ? walker.parent().node : node;
    targetNode.prepend = targetNode.prepend || [];
    pushAll(targetNode.prepend, statements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
};

Reference.prototype.remove = function remove() {
    if (isArray(this.parent)) {
        this.parent.<span class="apidocCodeKeywordSpan">splice</span>(this.key, 1);
        return true;
    } else {
        this.replace(null);
        return false;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>startIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startIgnore = function () {
    this.currentState.ignoring += 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>statementName
        <span class="apidocSignatureSpan">(location, initValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statementName = function (location, initValue) {
    var sName,
        ignoring = !!this.currentState.ignoring;

    location.skip = ignoring || undefined;
    initValue = initValue || 0;
    this.currentState.statement += 1;
    sName = this.currentState.statement;
    this.coverState.statementMap[sName] = location;
    this.coverState.s[sName] = initValue;
    return sName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchBranchInjector = function (node, walker) {
    var cases = node.cases,
        bName,
        i;

    if (!(cases &amp;&amp; cases.length &gt; 0)) {
        return;
    }
    bName = this.branchName(&apos;switch&apos;, walker.startLineForNode(node), this.locationsForNodes(cases));
    for (i = 0; i &lt; cases.length; i += 1) {
        cases[i].branchLocation = this.branchLocationFor(bName, i);
        cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchCaseInjector
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCaseInjector = function (node) {
    var location = node.branchLocation;
    delete node.branchLocation;
    if (this.maybeSkipNode(node, &apos;next&apos;)) {
        location.skip = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>withBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.TextReport" id="apidoc.module.utility2.istanbul.TextReport">module utility2.istanbul.TextReport</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.TextReport.TextReport" id="apidoc.elem.utility2.istanbul.TextReport.TextReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>TextReport
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextReport(opts) {
    Report.call(this);
    opts = opts || {};
    this.dir = opts.dir || process.cwd();
    this.file = opts.file;
    this.summary = opts.summary;
    this.maxCols = opts.maxCols || 0;
    this.watermarks = opts.watermarks || defaults.watermarks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
    + &quot;\&quot;&gt;\n&quot;
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.<span class="apidocCodeKeywordSpan">TextReport</span>(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.TextReport.prototype" id="apidoc.module.utility2.istanbul.TextReport.prototype">module utility2.istanbul.TextReport.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.TextReport.prototype.writeReport" id="apidoc.elem.utility2.istanbul.TextReport.prototype.writeReport">
        function <span class="apidocSignatureSpan">utility2.istanbul.TextReport.prototype.</span>writeReport
        <span class="apidocSignatureSpan">(collector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeReport = function (collector) {
    var summarizer = new TreeSummarizer(),
        tree,
        root,
        nameWidth,
        statsWidth = 4 * ( PCT_COLS + 2),
        maxRemaining,
        strings = [],
        text;

    collector.files().forEach(function (key) {
        summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));
    });
    tree = summarizer.getTreeSummary();
    root = tree.root;
    nameWidth = findNameWidth(root);
    if (this.maxCols &gt; 0) {
        maxRemaining = this.maxCols - statsWidth - 2;
        if (nameWidth &gt; maxRemaining) {
            nameWidth = maxRemaining;
        }
    }
    walk(root, nameWidth, strings, 0, this.watermarks);
    text = strings.join(&apos;\n&apos;) + &apos;\n&apos;;
    if (this.file) {
        mkdirp.sync(this.dir);
        fs.writeFileSync(path.join(this.dir, this.file), text, &apos;utf8&apos;);
    } else {
        console.log(text);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
    + &quot;\&quot;&gt;\n&quot;
);
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.TextReport(opt).<span class="apidocCodeKeywordSpan">writeReport</span>(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul._istanbul_fs" id="apidoc.module.utility2.istanbul._istanbul_fs">module utility2.istanbul._istanbul_fs</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul._istanbul_fs.readFileSync" id="apidoc.elem.utility2.istanbul._istanbul_fs.readFileSync">
        function <span class="apidocSignatureSpan">utility2.istanbul._istanbul_fs.</span>readFileSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (file) {
    // return head.txt or foot.txt
    file = local[file.slice(-8)];
    if (local.isBrowser) {
        file = file.replace(&quot;&lt;!doctype html&gt;\n&quot;, &quot;&quot;).replace((
            /(&lt;\/?)(?:body|html)/g
        ), &quot;$1div&quot;);
    }
    if (!local.isBrowser &amp;&amp; process.env.npm_package_homepage) {
        file = file.replace(
            &quot;https://github.com/kaizhu256/node-utility2&quot;,
            process.env.npm_package_homepage
        ).replace(
            &quot;utility2&quot;,
            process.env.npm_package_name
        ).replace(
            &quot;2019.10.8&quot;,
            process.env.npm_package_version
        );
    } else {
        file = file.replace((
            /&lt;h1\u0020[\S\s]*&lt;\/h1&gt;/
        ), &quot;&quot;);
    }
    return file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    local.tryCatchOnError(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.<span class="apidocCodeKeywordSpan">readFileSync</span>(file, &quot;utf8&quot;).slice(0, 262144)
            + &quot;\n\n\n\n\n\n\n\n&quot;
        ).replace((
            /\r\n*/g
        ), &quot;\n&quot;);
    }, console.error);
    return result;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul._istanbul_fs.readdirSync" id="apidoc.elem.utility2.istanbul._istanbul_fs.readdirSync">
        function <span class="apidocSignatureSpan">utility2.istanbul._istanbul_fs.</span>readdirSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function () {
    return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
].forEach(function (file) {
    local.fs.exists(file, function (exists) {
        if (exists) {
            local.onFileModifiedRestart(file);
        }
    });
});
local.fs.<span class="apidocCodeKeywordSpan">readdirSync</span>(process.cwd()).forEach(function (file) {
    file = process.cwd() + &quot;/&quot; + file;
    // if the file is modified, then restart the process
    local.onFileModifiedRestart(file);
    switch (local.path.basename(file)) {
    // swagger-validate assets.swgg.swagger.json
    case &quot;assets.swgg.swagger.json&quot;:
        local.fs.readFile(file, &quot;utf8&quot;, function (err, data) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.cliDict" id="apidoc.module.utility2.istanbul.cliDict">module utility2.istanbul.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.cover" id="apidoc.elem.utility2.istanbul.cliDict.cover">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>cover
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cover = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt;
 */
</span>    let tmp;
    try {
        tmp = JSON.parse(local.fs.readFileSync(&quot;package.json&quot;, &quot;utf8&quot;));
        process.env.npm_package_nameLib = (
            process.env.npm_package_nameLib
            || tmp.nameLib
            || tmp.name.replace((
                /-/g
            ), &quot;_&quot;)
        );
    } catch (ignore) {}
    process.env.npm_config_mode_coverage = (
        process.env.npm_config_mode_coverage
        || process.env.npm_package_nameLib
        || &quot;all&quot;
    );
    // add coverage hook to require
    local._istanbul_moduleExtensionsJs = (
        local._istanbul_module._extensions[&quot;.js&quot;]
    );
    local._istanbul_module._extensions[&quot;.js&quot;] = function (module, file) {
        if (typeof file === &quot;string&quot; &amp;&amp; (
            file.indexOf(process.env.npm_config_mode_coverage_dir) === 0 || (
                file.indexOf(process.cwd()) === 0
                &amp;&amp; (
                    process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                    || file.indexOf(process.cwd() + &quot;/node_modules/&quot;) !== 0
                )
            )
        )) {
            module._compile(local.instrumentInPackage(
                local.fs.readFileSync(file, &quot;utf8&quot;),
                file
            ), file);
            return;
        }
        local._istanbul_moduleExtensionsJs(module, file);
    };
    // init process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.cwd(), process.argv[1]);
    console.log(&quot;\ncovering $ &quot; + process.argv.join(&quot; &quot;));
    // create coverage on exit
    process.on(&quot;exit&quot;, function () {
        local.coverageReportCreate({
            coverage: globalThis.__coverage__
        });
    });
    // re-init cli
    local._istanbul_module.runMain();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.instrument" id="apidoc.elem.utility2.istanbul.cliDict.instrument">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>instrument
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will instrument &lt;script&gt; and print result to stdout
 */
</span>    process.argv[3] = local.path.resolve(process.cwd(), process.argv[3]);
    process.stdout.write(local.instrumentSync(
        local.fs.readFileSync(process.argv[3], &quot;utf8&quot;),
        process.argv[3]
    ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.report" id="apidoc.elem.utility2.istanbul.cliDict.report">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>report
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;coverageJson&gt;
 * will create coverage-report from file &lt;coverageJson&gt;
 */
</span>    process.argv[3] = local.path.resolve(process.cwd(), process.argv[3]);
    globalThis.__coverage__ = JSON.parse(
        local.fs.readFileSync(process.argv[3])
    );
    globalThis.__coverageCodeDict__ = {};
    Object.entries(globalThis.__coverage__).forEach(function (entry) {
        globalThis.__coverageCodeDict__[entry[0]] = true;
        entry[1].code = entry[1].code || entry[1].text.split(&quot;\n&quot;);
    });
    local.coverageReportCreate({
        coverage: globalThis.__coverage__
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.test" id="apidoc.elem.utility2.istanbul.cliDict.test">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt; if env-var $npm_config_mode_coverage is set
 */
</span>    if (process.env.npm_config_mode_coverage) {
        process.argv[2] = &quot;cover&quot;;
        // re-init cli
        local.cliDict[process.argv[2]]();
        return;
    }
    // restart node with __filename removed from process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.cwd(), process.argv[1]);
    // re-init cli
    local._istanbul_module.runMain();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return {
elemList: Object.keys(module).filter(function (key) {
    return local.tryCatchOnError(function () {
        return (
            key
            &amp;&amp; (
                /^\w[\w\-.]*?$/
            ).<span class="apidocCodeKeywordSpan">test</span>(key)
            &amp;&amp; key.indexOf(&quot;testCase_&quot;) !== 0
            &amp;&amp; (
                module[key] !== opt.blacklistDict[key]
                || opt.whitelistDict[key]
            )
        );
    }, console.error);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.collector" id="apidoc.module.utility2.istanbul.collector">module utility2.istanbul.collector</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.collector.fileCoverageFor" id="apidoc.elem.utility2.istanbul.collector.fileCoverageFor">
        function <span class="apidocSignatureSpan">utility2.istanbul.collector.</span>fileCoverageFor
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fileCoverageFor = function (file) {
    return globalThis.__coverage__[file];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.collector.files" id="apidoc.elem.utility2.istanbul.collector.files">
        function <span class="apidocSignatureSpan">utility2.istanbul.collector.</span>files
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">files = function () {
    return Object.keys(globalThis.__coverage__).filter(function (key) {
        if (
            globalThis.__coverage__[key]
            &amp;&amp; globalThis.__coverageCodeDict__[key]
        ) {
            // reset derived info
            globalThis.__coverage__[key].l = null;
            return true;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.coverageUtils" id="apidoc.module.utility2.istanbul.coverageUtils">module utility2.istanbul.coverageUtils</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfo" id="apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfo">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>addDerivedInfo
        <span class="apidocSignatureSpan">(coverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addDerivedInfo(coverage) {
    Object.keys(coverage).forEach(function (k) {
        addDerivedInfoForFile(coverage[k]);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfoForFile" id="apidoc.elem.utility2.istanbul.coverageUtils.addDerivedInfoForFile">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>addDerivedInfoForFile
        <span class="apidocSignatureSpan">(fileCoverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addDerivedInfoForFile(fileCoverage) {
    var statementMap = fileCoverage.statementMap,
        statements = fileCoverage.s,
        lineMap;

    if (!fileCoverage.l) {
        fileCoverage.l = lineMap = {};
        Object.keys(statements).forEach(function (st) {
            var line = statementMap[st].start.line,
                count = statements[st],
                prevVal = lineMap[line];
            if (count === 0 &amp;&amp; statementMap[st].skip) { count = 1; }
            if (typeof prevVal === &apos;undefined&apos; || prevVal &lt; count) {
                lineMap[line] = count;
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.blankSummary" id="apidoc.elem.utility2.istanbul.coverageUtils.blankSummary">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>blankSummary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blankSummary() {
    return {
        lines: {
            total: 0,
            covered: 0,
            skipped: 0,
            pct: &apos;Unknown&apos;
        },
        statements: {
            total: 0,
            covered: 0,
            skipped: 0,
            pct: &apos;Unknown&apos;
        },
        functions: {
            total: 0,
            covered: 0,
            skipped: 0,
            pct: &apos;Unknown&apos;
        },
        branches: {
            total: 0,
            covered: 0,
            skipped: 0,
            pct: &apos;Unknown&apos;
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.mergeFileCoverage" id="apidoc.elem.utility2.istanbul.coverageUtils.mergeFileCoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>mergeFileCoverage
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeFileCoverage(first, second) {
    var ret = JSON.parse(JSON.stringify(first)),
        i;

    delete ret.l; //remove derived info

    Object.keys(second.s).forEach(function (k) {
        ret.s[k] += second.s[k];
    });
    Object.keys(second.f).forEach(function (k) {
        ret.f[k] += second.f[k];
    });
    Object.keys(second.b).forEach(function (k) {
        var retArray = ret.b[k],
            secondArray = second.b[k];
        for (i = 0; i &lt; retArray.length; i += 1) {
            retArray[i] += secondArray[i];
        }
    });

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.mergeSummaryObjects" id="apidoc.elem.utility2.istanbul.coverageUtils.mergeSummaryObjects">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>mergeSummaryObjects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeSummaryObjects() {
    var ret = blankSummary(),
        args = Array.prototype.slice.call(arguments),
        keys = [&apos;lines&apos;, &apos;statements&apos;, &apos;branches&apos;, &apos;functions&apos;],
        increment = function (obj) {
            if (obj) {
                keys.forEach(function (key) {
                    ret[key].total += obj[key].total;
                    ret[key].covered += obj[key].covered;
                    ret[key].skipped += obj[key].skipped;
                });
            }
        };
    args.forEach(function (arg) {
        increment(arg);
    });
    keys.forEach(function (key) {
        ret[key].pct = percent(ret[key].covered, ret[key].total);
    });

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.removeDerivedInfo" id="apidoc.elem.utility2.istanbul.coverageUtils.removeDerivedInfo">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>removeDerivedInfo
        <span class="apidocSignatureSpan">(coverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeDerivedInfo(coverage) {
    Object.keys(coverage).forEach(function (k) {
        delete coverage[k].l;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.summarizeCoverage" id="apidoc.elem.utility2.istanbul.coverageUtils.summarizeCoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>summarizeCoverage
        <span class="apidocSignatureSpan">(coverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function summarizeCoverage(coverage) {
    var fileSummary = [];
    Object.keys(coverage).forEach(function (key) {
        fileSummary.push(summarizeFileCoverage(coverage[key]));
    });
    return mergeSummaryObjects.apply(null, fileSummary);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.summarizeFileCoverage" id="apidoc.elem.utility2.istanbul.coverageUtils.summarizeFileCoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>summarizeFileCoverage
        <span class="apidocSignatureSpan">(fileCoverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function summarizeFileCoverage(fileCoverage) {
    var ret = blankSummary();
    addDerivedInfoForFile(fileCoverage);
    ret.lines = computeSimpleTotals(fileCoverage, &apos;l&apos;);
    ret.functions = computeSimpleTotals(fileCoverage, &apos;f&apos;, &apos;fnMap&apos;);
    ret.statements = computeSimpleTotals(fileCoverage, &apos;s&apos;, &apos;statementMap&apos;);
    ret.branches = computeBranchTotals(fileCoverage);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageUtils.toYUICoverage" id="apidoc.elem.utility2.istanbul.coverageUtils.toYUICoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.coverageUtils.</span>toYUICoverage
        <span class="apidocSignatureSpan">(coverage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toYUICoverage(coverage) {
    var ret = {};

    addDerivedInfo(coverage);

    Object.keys(coverage).forEach(function (k) {
        var fileCoverage = coverage[k],
            lines = fileCoverage.l,
            functions = fileCoverage.f,
            fnMap = fileCoverage.fnMap,
            o;

        o = ret[k] = {
            lines: {},
            calledLines: 0,
            coveredLines: 0,
            functions: {},
            calledFunctions: 0,
            coveredFunctions: 0
        };
        Object.keys(lines).forEach(function (k) {
            o.lines[k] = lines[k];
            o.coveredLines += 1;
            if (lines[k] &gt; 0) {
                o.calledLines += 1;
            }
        });
        Object.keys(functions).forEach(function (k) {
            var name = fnMap[k].name + &apos;:&apos; + fnMap[k].line;
            o.functions[name] = functions[k];
            o.coveredFunctions += 1;
            if (functions[k] &gt; 0) {
                o.calledFunctions += 1;
            }
        });
    });
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.escodegen" id="apidoc.module.utility2.istanbul.escodegen">module utility2.istanbul.escodegen</a></h1>




    <h2>
        <a href="#apidoc.elem.utility2.istanbul.escodegen.attachComments" id="apidoc.elem.utility2.istanbul.escodegen.attachComments">
        function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.escodegen.generate" id="apidoc.elem.utility2.istanbul.escodegen.generate">
        function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>generate
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(node, options) {
    var defaultOptions = getDefaultOptions(), result, pair;

    if (options != null) {
        // Obsolete options
        //
        //   `options.indent`
        //   `options.base`
        //
        // Instead of them, we can use `option.format.indent`.
        if (typeof options.indent === &apos;string&apos;) {
            defaultOptions.format.indent.style = options.indent;
        }
        if (typeof options.base === &apos;number&apos;) {
            defaultOptions.format.indent.base = options.base;
        }
        options = updateDeeply(defaultOptions, options);
        indent = options.format.indent.style;
        if (typeof options.base === &apos;string&apos;) {
            base = options.base;
        } else {
            base = stringRepeat(indent, options.format.indent.base);
        }
    } else {
        options = defaultOptions;
        indent = options.format.indent.style;
        base = stringRepeat(indent, options.format.indent.base);
    }
    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = json ? false : options.format.hexadecimal;
    quotes = json ? &apos;double&apos; : options.format.quotes;
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;
    if (options.format.compact) {
        newline = space = indent = base = &apos;&apos;;
    }
    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = json ? null : options.parse;
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines &amp;&amp; sourceCode !== null;
    extra = options;

    if (sourceMap) {
        if (!exports.browser) {
            // We assume environment is node.js
            // And prevent from including source-map by browserify
            SourceNode = require(&apos;source-map&apos;).SourceNode;
        } else {
            SourceNode = global.sourceMap.SourceNode;
        }
    }

    result = generateInternal(node);

    if (!sourceMap) {
        pair = {code: result.toString(), map: null};
        return options.sourceMapWithCode ? pair : pair.code;
    }

    pair = result.toStringWithSourceMap({
        file: options.file,
        sourceRoot: options.sourceMapRoot
    });

    if (options.sourceContent) {
        pair.map.setSourceContent(options.sourceMap,
                                  options.sourceContent);
    }

    if (options.sourceMapWithCode) {
        return pair;
    }

    return pair.map.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima" id="apidoc.module.utility2.istanbul.esprima">module utility2.istanbul.esprima</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Node" id="apidoc.elem.utility2.istanbul.esprima.Node">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Node
        <span class="apidocSignatureSpan">(parser, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(parser, pos, loc) {
  this.type = &quot;&quot;;
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser" id="apidoc.elem.utility2.istanbul.esprima.Parser">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : options.sourceType === &quot;module&quot; ? &quot;5module&quot; : 5]);
  var reserved = &quot;&quot;;
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&apos;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Position" id="apidoc.elem.utility2.istanbul.esprima.Position">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line;
  this.column = col;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.SourceLocation" id="apidoc.elem.utility2.istanbul.esprima.SourceLocation">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>SourceLocation
        <span class="apidocSignatureSpan">(p, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.TokContext" id="apidoc.elem.utility2.istanbul.esprima.TokContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokContext
        <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Token" id="apidoc.elem.utility2.istanbul.esprima.Token">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Token
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.TokenType" id="apidoc.elem.utility2.istanbul.esprima.TokenType">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokenType
        <span class="apidocSignatureSpan">(label, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.getLineInfo" id="apidoc.elem.utility2.istanbul.esprima.getLineInfo">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>getLineInfo
        <span class="apidocSignatureSpan">(input, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match &amp;&amp; match.index &lt; offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierChar" id="apidoc.elem.utility2.istanbul.esprima.isIdentifierChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierChar
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierChar(code, astral) {
  if (code &lt; 48) { return code === 36 }
  if (code &lt; 58) { return true }
  if (code &lt; 65) { return false }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierStart" id="apidoc.elem.utility2.istanbul.esprima.isIdentifierStart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(code, astral) {
  if (code &lt; 65) { return code === 36 }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isNewLine" id="apidoc.elem.utility2.istanbul.esprima.isNewLine">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isNewLine
        <span class="apidocSignatureSpan">(code, ecma2019String)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String &amp;&amp; (code === 0x2028 || code === 0x2029))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.parse" id="apidoc.elem.utility2.istanbul.esprima.parse">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(input, options) {
  return Parser.parse(input, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.<span class="apidocCodeKeywordSpan">parse</span>(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
        }, console.error);
    }
});
Object.keys(opt.packageJson).forEach(function (key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.parseExpressionAt" id="apidoc.elem.utility2.istanbul.esprima.parseExpressionAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.<span class="apidocCodeKeywordSpan">parseExpressionAt</span>(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.tokenizer" id="apidoc.elem.utility2.istanbul.esprima.tokenizer">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.<span class="apidocCodeKeywordSpan">tokenizer</span>(input, options)
}

exports.Node = Node;
exports.Parser = Parser;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.TokContext = TokContext;
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima.Parser.prototype" id="apidoc.module.utility2.istanbul.esprima.Parser.prototype">module utility2.istanbul.esprima.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>adaptDirectivePrologue
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.<span class="apidocCodeKeywordSpan">adaptDirectivePrologue</span>(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>afterTrailingComma
        <span class="apidocSignatureSpan">(tokType, notNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from &apos;...&apos;]
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
if (!first) {
  this.expect(types.comma);
  if (this.<span class="apidocCodeKeywordSpan">afterTrailingComma</span>(types.braceR)) { break }
} else { first = false; }

var node = this.startNode();
node.local = this.parseIdent(true);
node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
this.checkExport(exports, node.exported.name, node.exported.start);
nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>braceIsBlock
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name &amp;&amp; this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType ===
types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (out === types$1.b_stat &amp;&amp; this.curContext().token === &quot;function&quot;) {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.<span class="apidocCodeKeywordSpan">braceIsBlock</span>(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>buildBinary
        <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? &quot;LogicalExpression&quot; : &quot;BinaryExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.<span class="apidocCodeKeywordSpan">buildBinary</span>(leftStartPos, leftStartLoc, left, right, op, logical
);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>canInsertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.<span class="apidocCodeKeywordSpan">canInsertSemicolon</span>()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExport
        <span class="apidocSignatureSpan">(exports, name, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, &quot;Duplicate export &apos;&quot; + name + &quot;&apos;&quot;); }
  exports[name] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.<span class="apidocCodeKeywordSpan">checkExport</span>(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types._class) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExpressionErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign &gt;= 0 || doubleProto &gt;= 0 }
  if (shorthandAssign &gt;= 0)
    { this.raise(shorthandAssign, &quot;Shorthand property assignments are valid only in destructuring patterns&quot;); }
  if (doubleProto &gt;= 0)
    { this.raiseRecoverable(doubleProto, &quot;Redefinition of __proto__ property&quot;); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.<span class="apidocCodeKeywordSpan">checkExpressionErrors</span>(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLVal
        <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case &quot;Identifier&quot;:
    if (bindingType === BIND_LEXICAL &amp;&amp; expr.name === &quot;let&quot;)
      { this.raiseRecoverable(expr.start, &quot;let is disallowed as a lexically bound name&quot;); }
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in strict mode&quot;); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case &quot;MemberExpression&quot;:
    if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
    break

  case &quot;ObjectPattern&quot;:
    for (var i = 0, list = expr.properties; i &lt; list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case &quot;Property&quot;:
    // AssignmentProperty has type === &quot;Property&quot;
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case &quot;ArrayPattern&quot;:
    for (var i$1 = 0, list$1 = expr.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case &quot;AssignmentPattern&quot;:
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case &quot;RestElement&quot;:
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case &quot;ParenthesizedExpression&quot;:
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; rvalue&quot;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.<span class="apidocCodeKeywordSpan">checkLVal</span>(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLocalExport
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &amp;&amp;
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];

      this.checkUnreserved(spec.local);
      // check if export is defined
      this.<span class="apidocCodeKeywordSpan">checkLocalExport</span>(spec.local);
    }

    node.source = null;
  }
  this.semicolon();
}
return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkParams
        <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.<span class="apidocCodeKeywordSpan">checkParams</span>(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, &quot;Comma is not permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case &quot;ObjectPattern&quot;:
      case &quot;ArrayPattern&quot;:
      case &quot;RestElement&quot;:
break

      case &quot;ObjectExpression&quot;:
node.type = &quot;ObjectPattern&quot;;
if (refDestructuringErrors) { this.<span class="apidocCodeKeywordSpan">checkPatternErrors</span>(refDestructuringErrors, true); }
for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
  var prop = list[i];

this.toAssignable(prop, isBinding);
  // Early error:
  //   AssignmentRestProperty[Yield, Await] :
  //     `...` DestructuringAssignmentTarget[Yield, Await]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternExport
        <span class="apidocSignatureSpan">(exports, pat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, pat) {
  var type = pat.type;
  if (type === &quot;Identifier&quot;)
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === &quot;ObjectPattern&quot;)
    { for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === &quot;ArrayPattern&quot;)
    { for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === &quot;Property&quot;)
    { this.checkPatternExport(exports, pat.value); }
  else if (type === &quot;AssignmentPattern&quot;)
    { this.checkPatternExport(exports, pat.left); }
  else if (type === &quot;RestElement&quot;)
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === &quot;ParenthesizedExpression&quot;)
    { this.checkPatternExport(exports, pat.expression); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (type === &quot;Identifier&quot;)
{ this.checkExport(exports, pat.name, pat.start); }
    else if (type === &quot;ObjectPattern&quot;)
{ for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
  {
    var prop = list[i];

    this.<span class="apidocCodeKeywordSpan">checkPatternExport</span>(exports, prop);
  } }
    else if (type === &quot;ArrayPattern&quot;)
{ for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
  var elt = list$1[i$1];

    if (elt) { this.checkPatternExport(exports, elt); }
} }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPropClash
        <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; prop.type === &quot;SpreadElement&quot;)
    { return }
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case &quot;Identifier&quot;: name = key.name; break
  case &quot;Literal&quot;: name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &gt;= 6) {
    if (name === &quot;__proto__&quot; &amp;&amp; kind === &quot;init&quot;) {
      if (propHash.proto) {
        if (refDestructuringErrors &amp;&amp; refDestructuringErrors.doubleProto &lt; 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, &quot;Redefinition of __proto__ property&quot;); }
      }
      propHash.proto = true;
    }
    return
  }
  name = &quot;$&quot; + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === &quot;init&quot;) {
      redefinition = this.strict &amp;&amp; other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, &quot;Redefinition of property&quot;); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.<span class="apidocCodeKeywordSpan">checkPropClash</span>(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkUnreserved
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator &amp;&amp; name === &quot;yield&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;yield&apos; as identifier inside a generator&quot;); }
  if (this.inAsync &amp;&amp; name === &quot;await&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  if (this.keywords.test(name))
    { this.raise(start, (&quot;Unexpected keyword &apos;&quot; + name + &quot;&apos;&quot;)); }
  if (this.options.ecmaVersion &lt; 6 &amp;&amp;
    this.input.slice(start, end).indexOf(&quot;\\&quot;) !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync &amp;&amp; name === &quot;await&quot;)
      { this.raiseRecoverable(start, &quot;Cannot use keyword &apos;await&apos; outside an async function&quot;); }
    this.raiseRecoverable(start, (&quot;The keyword &apos;&quot; + name + &quot;&apos; is reserved&quot;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
} else {
  for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
    // check for keywords used as local names
    var spec = list[i];

    this.<span class="apidocCodeKeywordSpan">checkUnreserved</span>(spec.local);
    // check if export is defined
    this.checkLocalExport(spec.local);
  }

  node.source = null;
}
this.semicolon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkVariableExport
        <span class="apidocSignatureSpan">(exports, decls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i &lt; list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.shouldParseExportStatement()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.<span class="apidocCodeKeywordSpan">checkVariableExport</span>(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.parseExportSpecifiers(exports);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.yieldPos &amp;&amp; (!this.awaitPos || this.yieldPos &lt; this.awaitPos))
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.<span class="apidocCodeKeywordSpan">checkYieldAwaitInDefaultParams</span>();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.context[this.context.length - 1]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
var parent = this.<span class="apidocCodeKeywordSpan">curContext</span>();
if (parent === types$1.f_expr || parent === types$1.f_stat)
  { return true }
if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
  { return !parent.isExpr }

// The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
// after a `yield` or `of` construct. See the `updateContext` for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.type = types.eof;
// For tokens that include more information than their type, the value
this.value = null;
// Its start and end offset
this.start = this.end = this.pos;
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc = this.endLoc = this.<span class="apidocCodeKeywordSpan">curPosition</span>();

// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.scopeStack[this.scopeStack.length - 1]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.<span class="apidocCodeKeywordSpan
">currentScope</span>()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentThisScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR &amp;&amp; !(scope.flags &amp; SCOPE_ARROW)) { return scope }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentThisScope</span>().flags
 &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentVarScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR) { return scope }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentVarScope</span>().flags
 &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>declareName
        <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) &gt; -1 || scope.functions.indexOf(name) &gt; -1 || scope.var.indexOf(name) &gt; -1;
    scope.lexical.push(name);
    if (this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1 || scope$2.var.indexOf(name) &gt; -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i &gt;= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) &gt; -1 &amp;&amp; !((scope$3.flags &amp; SCOPE_SIMPLE_CATCH) &amp;&amp; scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) &amp;&amp; scope$3.functions.indexOf(name) &gt; -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule &amp;&amp; (scope$3.flags &amp; SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags &amp; SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, (&quot;Identifier &apos;&quot; + name + &quot;&apos; has already been declared&quot;)); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
    { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in
 strict mode&quot;); }
  if (checkClashes) {
    if (has(checkClashes, expr.name))
      { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
    checkClashes[expr.name] = true;
  }
  if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.<span class="apidocCodeKeywordSpan">declareName</
span>(expr.name, bindingType, expr.start); }
  break

case &quot;MemberExpression&quot;:
  if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
  break

case &quot;ObjectPattern&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eat
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.<span class="apidocCodeKeywordSpan">eat</span>(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eatContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">eatContextual</span>(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>enterScope
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(flags) {
  this.scopeStack.push(new Scope(flags));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.<span class="apidocCodeKeywordSpan">enterScope</span>(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>exitScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.scopeStack.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.<span class="apidocCodeKeywordSpan">exitScope</span>();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
};

pp$1.parseThrowStatement = function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  this.eat(type) || this.unexpected();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.<span class="apidocCodeKeywordSpan">expect</span>(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expectContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.<span class="apidocCodeKeywordSpan">expectContextual</span>(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.<span class="apidocCodeKeywordSpan">finishNode</span>(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNodeAt
        <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.checkExpressionErrors(refDestructuringErrors, true);
  this.yieldPos = oldYieldPos || this.yieldPos;
  this.awaitPos = oldAwaitPos || this.awaitPos;

  if (exprList.length &gt; 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.<span class="apidocCodeKeywordSpan">finishNodeAt</span>(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }
} else {
  val = this.parseParenExpression();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishOp
        <span class="apidocSignatureSpan">(type, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.<span class="apidocCodeKeywordSpan">finishOp</span>(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishToken
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.<span class="apidocCodeKeywordSpan">finishToken</span>(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>fullCharCodeAtPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.<span class="apidocCodeKeywordSpan">fullCharCodeAtPos</span>()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.next();
  return new Token(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// When `locations` is on, `loc` properties holding objects with
// `start` and `end` properties in `{line, column}` form (with
// line being 1-based and column 0-based) will be attached to the
// nodes.
locations: false,
// A function can be passed as `onToken` option, which will
// cause Acorn to call that function with object in the same
// format as tokens returned from `tokenizer().<span class="apidocCodeKeywordSpan">getToken</span>()`. Note
// that you are not allowed to call the parser from the
// callbackthat will corrupt its internal state.
onToken: null,
// A function can be passed as `onComment` option, which will
// cause Acorn to call that function with `(block, text, start,
// end)` parameters whenever a comment is skipped. `block` is a
// boolean indicating whether this is a block (`/* */`) comment,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getTokenFromCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // &apos;.&apos;
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // &apos;`&apos;
    if (this.options.ecmaVersion &lt; 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // &apos;0&apos;
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // &apos;0x&apos;, &apos;0X&apos; - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // &apos;/&apos;
    return this.readToken_slash()

  case 37: case 42: // &apos;%*&apos;
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // &apos;|&amp;&apos;
    return this.readToken_pipe_amp(code)

  case 94: // &apos;^&apos;
    return this.readToken_caret()

  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.readToken_eq_excl(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.<span class="apidocCodeKeywordSpan">getTokenFromCode</span>(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inGeneratorContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.context.length - 1; i &gt;= 1; i--) {
    var context = this.context[i];
    if (context.token === &quot;function&quot;)
      { return context.generator }
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; prevType !== types.dot) {
    if (this.value === &quot;of&quot; &amp;&amp; !this.exprAllowed ||
        this.value === &quot;yield&quot; &amp;&amp; this.<span class="apidocCodeKeywordSpan">inGeneratorContext</span>())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inNonArrowFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION) &gt; 0 }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var meta = this.parseIdent(true);
if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
  node.meta = meta;
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== &quot;target&quot; || containsEsc)
    { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
  if (!this.<span class="apidocCodeKeywordSpan">inNonArrowFunction</span>())
    { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
  return this.finishNode(node, &quot;MetaProperty&quot;)
}
var startPos = this.start, startLoc = this.startLoc;
node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
  this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.id = null;
  if (this.options.ecmaVersion &gt;= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion &gt;= 8) { node.async = false; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement &amp; FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.<span class="apidocCodeKeywordSpan">initFunction</span>(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initialContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return [types$1.b_stat]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.<span class="apidocCodeKeywordSpan">initialContext</span>();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.strictDirective(this.pos);

// Used to signify the start of a potential arrow function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>insertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) &amp;&amp; !this.<span class="apidocCodeKeywordSpan">insertSemicolon</span>()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>invalidStringToken
        <span class="apidocSignatureSpan">(position, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(position, message) {
  if (this.inTemplateElement &amp;&amp; this.options.ecmaVersion &gt;= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.<span class="apidocCodeKeywordSpan">invalidStringToken</span>(codePos, &quot;Code point out of
 bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &lt; 8 || !this.isContextual(&quot;async&quot;))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &amp;&amp;
    this.input.slice(next, next + 8) === &quot;function&quot; &amp;&amp;
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// If the statement does not start with a statement keyword or a
// brace, it&apos;s an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
    default:
if (this.<span class="apidocCodeKeywordSpan">isAsyncFunction</span>()) {
  if (context) { this.unexpected(); }
  this.next();
  return this.parseFunctionStatement(node, true, !context)
}

var maybeName = this.value, expr = this.parseExpression();
if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncProp
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  return !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp; prop.key.name === &quot;async&quot; &amp;&amp;
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type
.keyword || (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.type === types.star)) &amp;&amp;
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    startLoc = this.startLoc;
  }
  if (!isPattern)
    { isGenerator = this.eat(types.star); }
}
var containsEsc = this.containsEsc;
this.parsePropertyName(prop);
if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.<span
 class="apidocCodeKeywordSpan">isAsyncProp</span>(prop)) {
  isAsync = true;
  isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  this.parsePropertyName(prop, refDestructuringErrors);
} else {
  isAsync = false;
}
this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.isContextual = function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">isContextual</span>(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isDirectiveCandidate
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
    typeof statement.expression.value === &quot;string&quot; &amp;&amp;
    // Reject parenthesized strings.
    (this.input[statement.start] === &quot;\&quot;&quot; || this.input[statement.start] === &quot;&apos;&quot;)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">isDirectiveCandidate</span>(statements
[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isLet
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // &apos;[&apos;
  if (context) { return false }

  if (nextCh === 123) { return true } // &apos;{&apos;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
var starttype = this.type, node = this.startNode(), kind;

if (this.<span class="apidocCodeKeywordSpan">isLet</span>(context)) {
  starttype = types._var;
  kind = &quot;let&quot;;
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleAssignTarget
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.<span class="apidocCodeKeywordSpan">isSimpleAssignTarget</span>(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
};

var pp$1 = Parser.prototype;

// ### Statement parsing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleParamList
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(params) {
  for (var i = 0, list = params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== &quot;Identifier&quot;) { return false
  } }
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.checkParams(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.<span class="apidocCodeKeywordSpan">isSimpleParamList</span>(
node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (useStrict &amp;&amp; nonSimple)
      { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list
&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.<span class="apidocCodeKeywordSpan">nextToken</span>();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.<span class="apidocCodeKeywordSpan">parse</span>(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
        }, console.error);
    }
});
Object.keys(opt.packageJson).forEach(function (key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseArrowExpression
        <span class="apidocSignatureSpan">(node, params, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;ArrowFunctionExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  if (this.awaitIdentPos &gt; 0)
    { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.<span class="apidocCodeKeywordSpan">parseArrowExpression</span>(this.startNodeAt(startPos, startLoc), exprList, true
)
}
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
var node$1 = this.startNodeAt(startPos, startLoc);
node$1.callee = base;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseAwait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, &quot;AwaitExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
))) {
    expr = this.<span class="apidocCodeKeywordSpan">parseAwait</span>();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &gt;= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.next();
node.block = this.parseBlock();
node.handler = null;
if (this.type === types._catch) {
  var clause = this.startNode();
  this.next();
  if (this.eat(types.parenL)) {
    clause.param = this.<span class="apidocCodeKeywordSpan">parseBindingAtom</span>();
    var simple = clause.param.type === &quot;Identifier&quot;;
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types.parenR);
  } else {
    if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
    clause.param = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingList
        <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty &amp;&amp; this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.<span class="apidocCodeKeywordSpan">parseBindingList</span>(types.parenR, false, this.options.ecmaVersion &
gt;= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingListItem
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(param) {
  return param
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.parseRestBinding();
  this.<span class="apidocCodeKeywordSpan">parseBindingListItem</span>(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, &quot;BlockStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.<span class="apidocCodeKeywordSpan">parseBlock</span>(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBreakContinueStatement
        <span class="apidocSignatureSpan">(node, keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i &lt; this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) { break }
      if (node.label &amp;&amp; isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, &quot;Unsyntactic &quot; + keyword); }
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.<span class="apidocCodeKeywordSpan">parseBreakContinueStatement</span>(node
, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClass
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
        if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, &quot;ClassBody&quot;);
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseClass</span>(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassElement
        <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, &quot;Identifier&quot;);
    return false
  };

  method.kind = &quot;method&quot;;
  method.static = tryContextual(&quot;static&quot;);
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; tryContextual(&quot;async&quot;, true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    } else if (tryContextual(&quot;get&quot;)) {
      method.kind = &quot;get&quot;;
    } else if (tryContextual(&quot;set&quot;)) {
      method.kind = &quot;set&quot;;
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; ||
      key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
    if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
    if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
    if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
    method.kind = &quot;constructor&quot;;
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
    this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.parseClassId(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.<span class="apidocCodeKeywordSpan">parseClassElement</span>(node.superClass !== null);
  if (element) {
    classBody.body.push(element);
    if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
      if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
      hadConstructor = true;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassId
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.next();

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.<span class="apidocCodeKeywordSpan">parseClassId</span>(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassMethod
        <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
  method.kind = &quot;constructor&quot;;
  allowsDirectSuper = constructorAllowsSuper;
} else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
  this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
}
this.<span class="apidocCodeKeywordSpan">parseClassMethod</span>(method, isGenerator, isAsync, allowsDirectSuper);
if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
  { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
  { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
  { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
return method
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassSuper
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.parseClassId(node, isStatement);
this.<span class="apidocCodeKeywordSpan">parseClassSuper</span>(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
  if (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDebuggerStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, &quot;DebuggerStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.<span class="apidocCodeKeywordSpan">parseDebuggerStatement</span>(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDoStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.<span class="apidocCodeKeywordSpan">parseDoStatement</span>(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDynamicImport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, &quot;Import&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.parseNew()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.<span class="apidocCodeKeywordSpan">parseDynamicImport</span>()
  } else {
    return this.unexpected()
  }

default:
  this.unexpected();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseEmptyStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  return this.finishNode(node, &quot;EmptyStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.<span class="apidocCodeKeywordSpan">parseEmptyStatement</span>(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 40) // &apos;(&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExport
        <span class="apidocSignatureSpan">(node, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.expectContextual(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, &quot;nullableID&quot;);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === &quot;VariableDeclaration&quot;)
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from &apos;...&apos;]
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual(&quot;from&quot;)) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.parseImport(node) : this.<span class="apidocCodeKeywordSpan">parseExport</span>(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExportSpecifiers
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from &apos;...&apos;]
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.<span class="apidocCodeKeywordSpan">parseExportSpecifiers</span>(exports);
  if (this.eatContextual(&quot;from&quot;)) {
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprAtom
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL &amp;&amp; !this.allowDirectSuper)
      { this.raise(node.start, &quot;super() call outside constructor of a subclass&quot;); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot &amp;&amp; this.type !== types.bracketL &amp;&amp; this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, &quot;Super&quot;)

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, &quot;ThisExpression&quot;)

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; !containsEsc &amp;&amp; id.name === &quot;async&quot; &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types._function
))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow &amp;&amp; !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === &quot;async&quot; &amp;&amp; this.type === types.name &amp;&amp; !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, &quot;Literal&quot;)

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind &lt; 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, &quot;ArrayExpression&quot;)

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion &gt; 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  pp$1.parseExport = function(node, exports) {
this.next();
// export * from &apos;...&apos;
if (this.eat(types.star)) {
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.<span class="apidocCodeKeywordSpan">parseExprAtom</span>();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprList
        <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty &amp;&amp; this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (computed) { this.expect(types.bracketR); }
  base = this.finishNode(node, &quot;MemberExpression&quot;);
} else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  var exprList = this.<span class="apidocCodeKeywordSpan">parseExprList</span>(types.parenR, this.options.ecmaVersion &gt;= 8 &amp
;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors);
  if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
    this.checkPatternErrors(refDestructuringErrors, false);
    this.checkYieldAwaitInDefaultParams();
    if (this.awaitIdentPos &gt; 0)
      { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOp
        <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.<span class="apidocCodeKeywordSpan
">parseExprOp</span>(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOps
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos, startLoc, -
1, noIn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseExprOps</span>(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprSubscripts
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.<span class="apidocCodeKeywordSpan">parseExprSubscripts</span>() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, &quot;SequenceExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.<span class="apidocCodeKeywordSpan">parseExpression</span>()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpressionStatement
        <span class="apidocSignatureSpan">(node, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, &quot;ExpressionStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case types._export:
    case types._import:
if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 40) // &apos;(&apos;
    { return this.<span class="apidocCodeKeywordSpan">parseExpressionStatement</span>(node, this.parseExpression()) }
}

if (!this.options.allowImportExportEverywhere) {
  if (!topLevel)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
  if (!this.inModule)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&
quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFor
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, &quot;ForStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.next();
var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
)) &amp;&amp; this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
this.labels.push(loopLabel);
this.enterScope(0);
this.expect(types.parenL);
if (this.type === types.semi) {
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.<span class="apidocCodeKeywordSpan">parseFor</span>(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.parseVar(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForIn
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === &quot;VariableDeclaration&quot; &amp;&amp;
    init.declarations[0].init != null &amp;&amp;
    (
      !isForIn ||
      this.options.ecmaVersion &lt; 8 ||
      this.strict ||
      init.kind !== &quot;var&quot; ||
      init.declarations[0].id.type !== &quot;Identifier&quot;
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    return this.<span class="apidocCodeKeywordSpan">parseForIn</span>(node, init$1)
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors;
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction)) &amp;&amp;
this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, &quot;VariableDeclaration&quot;);
    if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init$1.declarations.length ===
1) {
      if (this.options.ecmaVersion &gt;= 9) {
        if (this.type === types._in) {
          if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt &gt; -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.<span class="apidocCodeKeywordSpan">parseForStatement</span>(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  if (statement &amp; FUNC_STATEMENT) {
    node.id = (statement &amp; FUNC_NULLABLE_ID) &amp;&amp; this.type !== types.name ? null : this.parseIdent();
    if (node.id &amp;&amp; !(statement &amp; FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL
 : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.<span class="apidocCodeKeywordSpan">parseFunction</span>(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT
), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionBody
        <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &amp;&amp; nonSimple)
        { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list&quot;); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; !isMethod &amp;&amp; this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn&apos;t a forbidden identifier in strict mode, e.g. &apos;eval&apos;
  if (this.strict &amp;&amp; node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.<span class="apidocCodeKeywordSpan">parseFunctionBody</span>(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionParams
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.<span class="apidocCodeKeywordSpan">parseFunctionParams</span>(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionStatement
        <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseFunctionStatement</span>(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIdent
        <span class="apidocSignatureSpan">(liberal, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === &quot;class&quot; || node.name === &quot;function&quot;) &amp;&amp;
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, &quot;Identifier&quot;);
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.<span class="apidocCodeKeywordSpan">parseIdent</span>();
  this.semicolon();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIfStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
  node.alternate = this.eat(types._else) ? this.parseStatement(&quot;if&quot;) : null;
  return this.finishNode(node, &quot;IfStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.<span class="apidocCodeKeywordSpan">parseIfStatement</span>(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.<span class="apidocCodeKeywordSpan">parseImport</span>(node) : this.parseExport(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImportSpecifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from &apos;...&apos;
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, &quot;ImportDefaultSpecifier&quot;));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual(&quot;as&quot;);
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, &quot;ImportNamespaceSpecifier&quot;));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual(&quot;as&quot;)) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$1.parseImport = function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.<span class="apidocCodeKeywordSpan">parseImportSpecifiers</span>();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLabeledStatement
        <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 &lt; list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, &quot;Label &apos;&quot; + maybeName + &quot;&apos; is already declared&quot;);
  } }
  var kind = this.type.isLoop ? &quot;loop&quot; : this.type === types._switch ? &quot;switch&quot; : null;
  for (var i = this.labels.length - 1; i &gt;= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf(&quot;label&quot;) === -1 ? context + &quot;label&quot; : context : &quot;label&quot;);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, &quot;LabeledStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.<span class="apidocCodeKeywordSpan">parseLabeledStatement</span>(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
    }
  }
  return id

case types.regexp:
  var value = this.value;
  node = this.<span class="apidocCodeKeywordSpan">parseLiteral</span>(value.value);
  node.regex = {pattern: value.pattern, flags: value.flags};
  return node

case types.num: case types.string:
  return this.parseLiteral(this.value)

case types._null: case types._true: case types._false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeAssign
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual(&quot;yield&quot;)) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn&apos;t that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -
1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;AssignmentExpression&quot;)
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign &gt; -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma &gt; -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign &gt; -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.<span class="apidocCodeKeywordSpan">parseMaybeAssign</span>();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeConditional
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;ConditionalExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  refDestructuringErrors = new DestructuringErrors;
  ownDestructuringErrors = true;
}

var startPos = this.start, startLoc = this.startLoc;
if (this.type === types.parenL || this.type === types.name)
  { this.potentialArrowAt = this.start; }
var left = this.<span class="apidocCodeKeywordSpan">parseMaybeConditional</span>(noIn, refDestructuringErrors);
if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
if (this.type.isAssign) {
  var node = this.startNodeAt(startPos, startLoc);
  node.operator = this.value;
  node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
  if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
  refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeDefault
        <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion &lt; 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, &quot;AssignmentPattern&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.<span class="apidocCodeKeywordSpan">parseMaybeDefault</span>(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeUnary
        <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict &amp;&amp; node.operator === &quot;delete&quot; &amp;&amp;
             node.argument.type === &quot;Identifier&quot;)
      { this.raiseRecoverable(node.start, &quot;Deleting local variable in strict mode&quot;); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? &quot;UpdateExpression&quot; : &quot;UnaryExpression&quot;);
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, &quot;UpdateExpression&quot;);
    }
  }

  if (!sawUnary &amp;&amp; this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), &quot;**&quot;, false) }
  else
    { return expr }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseMaybeUnary</span>(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos
, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMethod
        <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.<span class="apidocCodeKeywordSpan">parseMethod</span>(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseNew
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== &quot;target&quot; || containsEsc)
      { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
    return this.finishNode(node, &quot;MetaProperty&quot;)
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
    this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; node.callee.type
 !== &quot;Import&quot;, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, &quot;NewExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.next();
  return this.parseFunction(node, 0)

case types._class:
  return this.parseClass(this.startNode(), false)

case types._new:
  return this.<span class="apidocCodeKeywordSpan">parseNew</span>()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.parseDynamicImport()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseObj
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.<span class="apidocCodeKeywordSpan">parseObj</span>(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
        <span class="apidocSignatureSpan">(canBeArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &gt;= 8;
  if (this.options.ecmaVersion &gt;= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length &gt; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, &quot;ParenthesizedExpression&quot;)
  } else {
    return val
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  node = this.startNode();
  node.value = this.type === types._null ? null : this.type === types._true;
  node.raw = this.type.keyword;
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)

case types.parenL:
  var start = this.start, expr = this.<span class="apidocCodeKeywordSpan">parseParenAndDistinguishExpression</span>(canBeArrow);
  if (refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
      { refDestructuringErrors.parenthesizedAssign = start; }
    if (refDestructuringErrors.parenthesizedBind &lt; 0)
      { refDestructuringErrors.parenthesizedBind = start; }
  }
  return expr
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenArrowList
        <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.expect(types.parenR);

if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.<span class="apidocCodeKeywordSpan">parseParenArrowList</span>(startPos, startLoc, exprList)
}

if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
if (spreadStart) { this.unexpected(spreadStart); }
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.<span class="apidocCodeKeywordSpan">parseParenExpression</span>();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenItem
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(item) {
  return item
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (this.type !== types.parenR) {
  first ? first = false : this.expect(types.comma);
  if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
    lastIsComma = true;
    break
  } else if (this.type === types.ellipsis) {
    spreadStart = this.start;
    exprList.push(this.<span class="apidocCodeKeywordSpan">parseParenItem</span>(this.parseRestBinding()));
    if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
    break
  } else {
    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
  }
}
var innerEndPos = this.start, innerEndLoc = this.startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseProperty
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;);
      }
      return this.finishNode(prop, &quot;RestElement&quot;)
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind &lt; 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma &amp;&amp; refDestructuringErrors &amp;&amp; refDestructuringErrors.trailingComma &lt; 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, &quot;SpreadElement&quot;)
  }
  if (this.options.ecmaVersion &gt;= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.<span class="apidocCodeKeywordSpan">parseProperty</span>(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyName
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  if (this.options.ecmaVersion &gt;= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.
allowReserved !== &quot;never&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  } else if (tryContextual(&quot;get&quot;)) {
    method.kind = &quot;get&quot;;
  } else if (tryContextual(&quot;set&quot;)) {
    method.kind = &quot;set&quot;;
  }
}
if (!method.key) { this.<span class="apidocCodeKeywordSpan">parsePropertyName</span>(method); }
var key = method.key;
var allowsDirectSuper = false;
if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor
&quot; ||
    key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
  if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors
);
    prop.kind = &quot;init&quot;;
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = &quot;init&quot;;
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern &amp;&amp; !containsEsc &amp;&amp;
             this.options.ecmaVersion &gt;= 5 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp;
             (prop.key.name === &quot;get&quot; || prop.key.name === &quot;set&quot;) &amp;&amp;
             (this.type !== types.comma &amp;&amp; this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === &quot;get&quot; ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === &quot;get&quot;)
        { this.raiseRecoverable(start, &quot;getter should have no params&quot;); }
      else
        { this.raiseRecoverable(start, &quot;setter should have exactly one param&quot;); }
    } else {
      if (prop.kind === &quot;set&quot; &amp;&amp; prop.value.params[0].type === &quot;RestElement&quot;)
        { this.raiseRecoverable(prop.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
    }
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot;) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = &quot;init&quot;;
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &lt; 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp
(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.<span class="apidocCodeKeywordSpan">parsePropertyValue</span>(prop, isPattern, isGenerator, isAsync, startPos, startLoc,
refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc
) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseRestBinding
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 &amp;&amp; this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, &quot;RestElement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (first) { first = false; }
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.<span class="apidocCodeKeywordSpan">parseRestBinding</span>();
  this.parseBindingListItem(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseReturnStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, &quot;&apos;return&apos; outside of function&quot;); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, &quot;ReturnStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.<span class="apidocCodeKeywordSpan">parseReturnStatement</span>(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSpread
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, &quot;SpreadElement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
  } else { first = false; }

  var elt = (void 0);
  if (allowEmpty &amp;&amp; this.type === types.comma)
    { elt = null; }
  else if (this.type === types.ellipsis) {
    elt = this.<span class="apidocCodeKeywordSpan">parseSpread</span>(refDestructuringErrors);
    if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
      { refDestructuringErrors.trailingComma = this.start; }
  } else {
    elt = this.parseMaybeAssign(false, refDestructuringErrors);
  }
  elts.push(elt);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseStatement
        <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = &quot;let&quot;;
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.options.ecmaVersion &gt;= 6) { this.unexpected
(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // &apos;(&apos;
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
      if (!this.inModule)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&quot;); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.<span class="apidocCodeKeywordSpan">parseStatement</span>(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscript
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== &quot;never&quot;);
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, &quot;MemberExpression&quot;);
  } else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors
);
    if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos &gt; 0)
        { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === &quot;Import&quot;) {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, &quot;import() requires exactly one argument&quot;);
      }

      var importArg = node$1.arguments[0];
      if (importArg &amp;&amp; importArg.type === &quot;SpreadElement&quot;) {
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &
quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &
quot;async&quot;;
  while (true) {
    var element = this.<span class="apidocCodeKeywordSpan">parseSubscript</span>(base, startPos, startLoc, noCalls, maybeAsyncArrow
);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscripts
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &quot;async&quot;;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this
.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.<span class="apidocCodeKeywordSpan">parseSubscripts</span>(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSwitchStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, &quot;Multiple default clauses&quot;); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.<span class="apidocCodeKeywordSpan">parseSwitchStatement</span>(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplate
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, &quot;TemplateLiteral&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.<span class="apidocCodeKeywordSpan">parseTemplate</span>({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplateElement
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, &quot;Bad escape sequence in untagged template literal&quot;);
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, &quot;\n&quot;),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, &quot;TemplateElement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pp$3.parseTemplate = function(ref) {
if ( ref === void 0 ) ref = {};
var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

var node = this.startNode();
this.next();
node.expressions = [];
var curElt = this.<span class="apidocCodeKeywordSpan">parseTemplateElement</span>({isTagged: isTagged});
node.quasis = [curElt];
while (!curElt.tail) {
  if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
  this.expect(types.dollarBraceL);
  node.expressions.push(this.parseExpression());
  this.expect(types.braceR);
  node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseThrowStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, &quot;Illegal newline after throw&quot;); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, &quot;ThrowStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.<span class="apidocCodeKeywordSpan">parseThrowStatement</span>(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.<span class="apidocCodeKeywordSpan">parseTopLevel</span>(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTryStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === &quot;Identifier&quot;;
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;);
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler &amp;&amp; !node.finalizer)
    { this.raise(node.start, &quot;Missing catch or finally clause&quot;); }
  return this.finishNode(node, &quot;TryStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.<span class="apidocCodeKeywordSpan">parseTryStatement</span>(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVar
        <span class="apidocSignatureSpan">(node, isFor, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, &quot;VariableDeclarator&quot;));
    if (!this.eat(types.comma)) { break }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.<span class="apidocCodeKeywordSpan">parseVar</span>(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarId
        <span class="apidocSignatureSpan">(decl, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === &quot;var&quot; ? BIND_VAR : BIND_LEXICAL, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.<span class="apidocCodeKeywordSpan">parseVarId</span>(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this
.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual
(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarStatement
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, &quot;VariableDeclaration&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseVarStatement</span>(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWhileStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;while&quot;);
  this.labels.pop();
  return this.finishNode(node, &quot;WhileStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.<span class="apidocCodeKeywordSpan">parseWhileStatement</span>(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWithStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (this.strict) { this.raise(this.start, &quot;&apos;with&apos; in strict mode&quot;); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(&quot;with&quot;);
  return this.finishNode(node, &quot;WithStatement&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.<span class="apidocCodeKeywordSpan">parseWithStatement</span>(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseYield
        <span class="apidocSignatureSpan">(noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star &amp;&amp; !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, &quot;YieldExpression&quot;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
if (this.isContextual(&quot;yield&quot;)) {
  if (this.inGenerator) { return this.<span class="apidocCodeKeywordSpan">parseYield</span>(noIn) }
  // The tokenizer will assume an expression is allowed after
  // `yield`, but this isn&apos;t that kind of yield
  else { this.exprAllowed = false; }
}

var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
if (refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raise
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.<span class="apidocCodeKeywordSpan">raise</span>(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raiseRecoverable
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.<span class="apidocCodeKeywordSpan">raiseRecoverable</span>(refDestructuringErrors.trailingComma, &quot;Comma is not
permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pp$9.readEscapedChar = function(inTemplate) {
var ch = this.input.charCodeAt(++this.pos);
++this.pos;
switch (ch) {
case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
case 117: return codePointToString$1(this.<span class="apidocCodeKeywordSpan">readCodePoint</span>()) // &apos;u&apos;
case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
case 10: // &apos; \n&apos;
  if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readEscapedChar
        <span class="apidocSignatureSpan">(inTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
  case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
  case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
  case 117: return codePointToString$1(this.readCodePoint()) // &apos;u&apos;
  case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
  case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
  case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
  case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
  case 10: // &apos; \n&apos;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return &quot;&quot;
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== &quot;0&quot; || ch === 56 || ch === 57) &amp;&amp; (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? &quot;Octal literal in template string&quot;
            : &quot;Octal literal in strict mode&quot;
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return &quot;&quot;
    }
    return String.fromCharCode(ch)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var out = &quot;&quot;, chunkStart = ++this.pos;
for (;;) {
  if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
  var ch = this.input.charCodeAt(this.pos);
  if (ch === quote) { break }
  if (ch === 92) { // &apos;\&apos;
    out += this.input.slice(chunkStart, this.pos);
    out += this.<span class="apidocCodeKeywordSpan">readEscapedChar</span>(false);
    chunkStart = this.pos;
  } else {
    if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    ++this.pos;
  }
}
out += this.input.slice(chunkStart, this.pos++);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readHexChar
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, &quot;Bad character escape sequence&quot;); }
  return n
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.<span class="apidocCodeKeywordSpan">readHexChar</span>(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInt
        <span class="apidocSignatureSpan">(radix, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code &gt;= 97) { val = code - 97 + 10; } // a
    else if (code &gt;= 65) { val = code - 65 + 10; } // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val &gt;= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) { return null }

  return total
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.<span class="apidocCodeKeywordSpan">readInt</span>(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInvalidTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (; this.pos &lt; this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case &quot;\\&quot;:
      ++this.pos;
      break

    case &quot;$&quot;:
      if (this.input[this.pos + 1] !== &quot;{&quot;) {
        break
      }
    // falls through

    case &quot;`&quot;:
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, &quot;Unterminated template&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.<span class="apidocCodeKeywordSpan">readInvalidTemplateToken</span>();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(startsWithDot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  var octal = this.pos - start &gt;= 2 &amp;&amp; this.input.charCodeAt(start) === 48;
  if (octal &amp;&amp; this.strict) { this.raise(start, &quot;Invalid number&quot;); }
  if (octal &amp;&amp; /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal &amp;&amp; !startsWithDot &amp;&amp; this.options.ecmaVersion &gt;= 11 &amp;&amp; next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== &quot;undefined&quot; ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 &amp;&amp; !octal) { // &apos;.&apos;
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) &amp;&amp; !octal) { // &apos;eE&apos;
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // &apos;+-&apos;
    if (this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.<span class="apidocCodeKeywordSpan">readNumber</span>(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRadixNumber
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 96: // &apos;`&apos;
  if (this.options.ecmaVersion &lt; 6) { break }
  ++this.pos;
  return this.finishToken(types.backQuote)

case 48: // &apos;0&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 120 || next === 88) { return this.<span class="apidocCodeKeywordSpan">readRadixNumber</span>(16) } // &apos;0x&apos
;, &apos;0X&apos; - hex number
  if (this.options.ecmaVersion &gt;= 6) {
    if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
    if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
  }

// Anything else beginning with a digit is an integer, octal
// number, or float.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRegexp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    if (!escaped) {
      if (ch === &quot;[&quot;) { inClass = true; }
      else if (ch === &quot;]&quot; &amp;&amp; inClass) { inClass = false; }
      else if (ch === &quot;/&quot; &amp;&amp; !inClass) { break }
      escaped = ch === &quot;\\&quot;;
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
// If a division operator appears in an expression position, the
// tokenizer got confused, and we force it to read a regexp instead.
if (this.type === types.slash) { this.<span class="apidocCodeKeywordSpan">readRegexp</span>(); }

var node, canBeArrow = this.potentialArrowAt === this.start;
switch (this.type) {
case types._super:
  if (!this.allowSuper)
    { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
  node = this.startNode();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readString
        <span class="apidocSignatureSpan">(quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(quote) {
  var out = &quot;&quot;, chunkStart = ++this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Anything else beginning with a digit is an integer, octal
// number, or float.
case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
  return this.readNumber(false)

// Quotes produce strings.
case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
  return this.<span class="apidocCodeKeywordSpan">readString</span>(code)

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readTmplToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var out = &quot;&quot;, chunkStart = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated template&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 &amp;&amp; this.input.charCodeAt(this.pos + 1) === 123) { // &apos;`&apos;, &apos;${&apos;
      if (this.pos === this.start &amp;&amp; (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += &quot;\n&quot;;
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.<span class="apidocCodeKeywordSpan">readTmplToken</span>();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.<span class="apidocCodeKeywordSpan">readToken</span>(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_caret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;^&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_caret</span>()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  pp$9.getTokenFromCode = function(code) {
switch (code) {
// The interpretation of a dot depends on whether it is followed
// by a digit or another two dots.
case 46: // &apos;.&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_dot</span>()

// Punctuation tokens.
case 40: ++this.pos; return this.finishToken(types.parenL)
case 41: ++this.pos; return this.finishToken(types.parenR)
case 59: ++this.pos; return this.finishToken(types.semi)
case 44: ++this.pos; return this.finishToken(types.comma)
case 91: ++this.pos; return this.finishToken(types.bracketL)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_eq_excl
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;=!&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // &apos;=&gt;&apos;
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.<span class="apidocCodeKeywordSpan">readToken_eq_excl</span>(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_lt_gt
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;&lt;&gt;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 &amp;&amp; code === 60 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_lt_gt</span>(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)

case 126: // &apos;~&apos;
  return this.finishOp(types.prefix, 1)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &gt;= 7 &amp;&amp; code === 42 &amp;&amp; next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_mult_modulo_exp</span>(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_pipe_amp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;|&amp;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_pipe_amp</span>(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_plus_min
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;+-&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 &amp;&amp;
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `--&gt;` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_plus_min</span>(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_slash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_slash</span>()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, &quot;Escape sequence in keyword &quot; + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.<span class="apidocCodeKeywordSpan">readWord</span>() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.containsEsc = false;
  var word = &quot;&quot;, first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion &gt;= 6;
  while (this.pos &lt; this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch &lt;= 0xffff ? 1 : 2;
    } else if (ch === 92) { // &quot;\&quot;
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // &quot;u&quot;
        { this.invalidStringToken(this.pos, &quot;Expecting Unicode escape sequence \\uXXXX&quot;); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, &quot;Invalid Unicode escape&quot;); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    escaped = ch === &quot;\\&quot;;
  } else { escaped = false; }
  ++this.pos;
}
var pattern = this.input.slice(start, this.pos);
++this.pos;
var flagsStart = this.pos;
var flags = this.<span class="apidocCodeKeywordSpan">readWord1</span>();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_alternative
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state.raise(&quot;Invalid named capture referenced&quot;);
  }
}
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_alternative</span>(state);
while (state.eat(0x7C /* | */)) {
  this.regexp_alternative(state);
}

// Make the same message as V8.
if (this.regexp_eatQuantifier(state, true)) {
  state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_classRanges
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
        state.raise(&quot;Range out of order in character class&quot;);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.<span class="apidocCodeKeywordSpan">regexp_classRanges</span>(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_disjunction
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
state.lastStringValue = &quot;&quot;;
state.lastAssertionIsQuantifiable = false;
state.numCapturingParens = 0;
state.maxBackReference = 0;
state.groupNames.length = 0;
state.backReferenceNames.length = 0;

this.<span class="apidocCodeKeywordSpan">regexp_disjunction</span>(state);

if (state.pos !== state.source.length) {
  // Make the same messages as V8.
  if (state.eat(0x29 /* ) */)) {
    state.raise(&quot;Unmatched &apos;)&apos;&quot;);
  }
  if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAssertion
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) &amp;&amp; state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion &gt;= 9) {
      lookbehind = state.eat(0x3C /* &lt; */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise(&quot;Unterminated group&quot;);
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatAssertion</span>(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.<span class="apidocCodeKeywordSpan">regexp_eatAtom</span>(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatAtomEscape</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBackReference
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n &lt;= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.<span class="apidocCodeKeywordSpan">regexp_eatBackReference</span>(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
          state.raise(&quot;numbers out of order in {} quantifier&quot;);
        }
        return true
      }
    }
    if (state.switchU &amp;&amp; !noError) {
      state.raise(&quot;Incomplete quantifier&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatBracedQuantifier</span>(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCControlLetter</span>(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise(&quot;Unterminated group&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCapturingGroup</span>(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClass
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClass</span>(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &amp;&amp;
    this.options.ecmaVersion &gt;= 9 &amp;&amp;
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatUnicodePropertyValueExpression(state) &amp;&amp;
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise(&quot;Invalid property name&quot;);
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClassEscape</span>(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterEscape</span>(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise(&quot;Invalid class escape&quot;);
      }
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.<span class="apidocCodeKeywordSpan">regexp_eatClassAtom</span>(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
  state.lastIntValue = 0x2D; /* - */
  return true
}

if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassControlLetter</span>(state)) {
    return true
  }
  state.pos = start;
}

return (
  this.regexp_eatCharacterClassEscape(state) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x62<span class="apidocCodeCommentSpan"> /* b */)) {
    state.lastIntValue = 0x08; /* &lt;BS&gt; */
</span>    return true
  }

  if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
var start = state.pos;

if (state.eat(0x5C /* \ */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassEscape</span>(state)) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    var ch$1 = state.current();
    if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
      state.raise(&quot;Invalid class escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (ch === 0x74<span class="apidocCodeCommentSpan"> /* t */) {
    state.lastIntValue = 0x09; /* \t */
</span>    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatControlEscape</span>(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatControlLetter</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalDigits</span>(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch &gt;= 0x31 /* 1 */ &amp;&amp; ch &lt;= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */)
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalEscape</span>(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedAtom</span>(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (
    ch !== -1 &amp;&amp;
    ch !== 0x24<span class="apidocCodeCommentSpan"> /* $ */ &amp;&amp;
    !(ch &gt;= 0x28 /* ( */ &amp;&amp; ch &lt;= 0x2B /* + */) &amp;&amp;
    ch !== 0x2E /* . */ &amp;&amp;
    ch !== 0x3F /* ? */ &amp;&amp;
    ch !== 0x5B /* [ */ &amp;&amp;
    ch !== 0x5E /* ^ */ &amp;&amp;
    ch !== 0x7C /* | */
</span>  ) {
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedPatternCharacter</span>(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
        <span class="apidocSignatureSpan">(state, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i &lt; length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
var start = state.pos;

if (state.eat(0x75 /* u */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatFixedHexDigits</span>(state, 4)) {
    var lead = state.lastIntValue;
    if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
      var leadSurrogateEnd = state.pos;
      if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
        var trail = state.lastIntValue;
        if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
          state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.regexp_eatRegExpIdentifierName(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatGroupName</span>(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state.lastIntValue = lead;
  }
  return true
}
if (
  state.switchU &amp;&amp;
  state.eat(0x7B /* { */) &amp;&amp;
  this.<span class="apidocCodeKeywordSpan">regexp_eatHexDigits</span>(state) &amp;&amp;
  state.eat(0x7D /* } */) &amp;&amp;
  isValidUnicode(state.lastIntValue)
) {
  return true
}
if (state.switchU) {
  state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatHexEscapeSequence</span>(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F<span class="apidocCodeCommentSpan"> /* / */)) {
      state.lastIntValue = 0x2F; /* / */
</span>      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ &amp;&amp; (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatIdentityEscape</span>(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatInvalidBracedQuantifier</span>(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatKGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise(&quot;Invalid named reference&quot;);
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatKGroupName</span>(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatLegacyOctalEscapeSequence</span>(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatLoneUnicodePropertyNameOrValue</span>(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatOctalDigit
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30;<span class="apidocCodeCommentSpan"> /* 0 */
</span>    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatOctalDigit</span>(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 &amp;&amp; !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatPatternCharacters</span>(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifier</span>(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifierPrefix</span>(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// GroupName[U] ::
//   `&lt;` RegExpIdentifierName[?U] `&gt;`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierName</span>(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierPart</span>(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierStart</span>(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &amp;&amp;
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatHexDigits(state) &amp;&amp;
      state.eat(0x7D /* } */) &amp;&amp;
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.pos = start;
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
var start = state.pos;
var ch = state.current();
state.advance();

if (ch === 0x5C /* \ */ &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpUnicodeEscapeSequence</span>(state)) {
  ch = state.lastIntValue;
}
if (isRegExpIdentifierStart(ch)) {
  state.lastIntValue = ch;
  return true
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatReverseSolidusAtomEscape</span>(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function isValidUnicode(ch) {
  return ch &gt;= 0 &amp;&amp; ch &lt;= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatSyntaxCharacter</span>(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatTerm
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatTerm</span>(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) &amp;&amp; state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise(&quot;Unterminated group&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatUncapturingGroup</span>(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyName</span>(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValue</span>(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
state.pos = start;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.options.ecmaVersion &gt;= 9 &amp;&amp;
  (ch === 0x50 /* P */ || ch === 0x70 /* p */)
) {
  state.lastIntValue = -1;
  state.advance();
  if (
    state.eat(0x7B /* { */) &amp;&amp;
    this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValueExpression</span>(state) &amp;&amp;
    state.eat(0x7D /* } */)
  ) {
    return true
  }
  state.raise(&quot;Invalid property name&quot;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatZero
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.current() === 0x30 /* 0 */ &amp;&amp; !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatZero</span>(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_groupSpecifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.<span class="apidocCodeKeywordSpan">regexp_groupSpecifier</span>(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_pattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = &quot;&quot;;
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise(&quot;Unmatched &apos;)&apos;&quot;);
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise(&quot;Lone quantifier brackets&quot;);
    }
  }
  if (state.maxBackReference &gt; state.numCapturingParens) {
    state.raise(&quot;Invalid escape&quot;);
  }
  for (var i = 0, list = state.backReferenceNames; i &lt; list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise(&quot;Invalid named capture referenced&quot;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_pattern</span>(state);

// The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
// parsing contains a |GroupName|, reparse with the goal symbol
// |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
// exception if _P_ did not conform to the grammar, if any elements of _P_
// were not matched by the parse, or if any Early Error conditions exist.
if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
        <span class="apidocSignatureSpan">(state, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise(&quot;Invalid property value&quot;); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameAndValue</span>(state, name, value);
    return true
  }
}
state.pos = start;

// LoneUnicodePropertyNameOrValue
if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state, nameOrValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise(&quot;Invalid property name&quot;); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameOrValue</span>(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.eat(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.parseIdent();
  this.<span class="apidocCodeKeywordSpan">semicolon</span>();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
  var lab = this.labels[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>shouldParseExportStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type.keyword === &quot;var&quot; ||
    this.type.keyword === &quot;const&quot; ||
    this.type.keyword === &quot;class&quot; ||
    this.type.keyword === &quot;function&quot; ||
    this.isLet() ||
    this.isAsyncFunction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    node.declaration = this.parseMaybeAssign();
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.<span class="apidocCodeKeywordSpan">shouldParseExportStatement</span>()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipBlockComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var start = this.pos, end = this.input.indexOf(&quot;*/&quot;, this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, &quot;Unterminated comment&quot;); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ++this.curLine;
    this.lineStart = this.pos;
  }
  break
case 47: // &apos;/&apos;
  switch (this.input.charCodeAt(this.pos + 1)) {
  case 42: // &apos;*&apos;
    this.<span class="apidocCodeKeywordSpan">skipBlockComment</span>();
    break
  case 47:
    this.skipLineComment(2);
    break
  default:
    break loop
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipLineComment
        <span class="apidocSignatureSpan">(startSkip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos &lt; this.input.length &amp;&amp; !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Labels in scope.
this.labels = [];
// Thus-far undefined exports.
this.undefinedExports = {};

// If enabled, skip leading hashbang line.
if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
  { this.<span class="apidocCodeKeywordSpan">skipLineComment</span>(2); }

// Scope tracking for duplicate variable names (see scope.js)
this.scopeStack = [];
this.enterScope(SCOPE_TOP);

// For RegExp validation
this.regexpState = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  loop: while (this.pos &lt; this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // &apos; &apos;
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // &apos;/&apos;
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // &apos;*&apos;
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  // Read a single token, updating the parser object&apos;s token-related
  // properties.

  pp$9.nextToken = function() {
var curContext = this.curContext();
if (!curContext || !curContext.preserveSpace) { this.<span class="apidocCodeKeywordSpan">skipSpace</span>(); }

this.start = this.pos;
if (this.options.locations) { this.startLoc = this.curPosition(); }
if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

if (curContext.override) { return curContext.override(this) }
else { this.readToken(this.fullCharCodeAtPos()); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return new Node(this, this.start, this.startLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.<span class="apidocCodeKeywordSpan">startNode</span>();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNodeAt
        <span class="apidocSignatureSpan">(pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, loc) {
  return new Node(this, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ( noLineBreak === void 0 ) noLineBreak = false;

  var start = this$1.start, startLoc = this$1.startLoc;
  if (!this$1.eatContextual(k)) { return false }
  if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
  if (method.key) { this$1.unexpected(); }
  method.computed = false;
  method.key = this$1.<span class="apidocCodeKeywordSpan">startNodeAt</span>(start, startLoc);
  method.key.name = k;
  this$1.finishNode(method.key, &quot;Identifier&quot;);
  return false
};

method.kind = &quot;method&quot;;
method.static = tryContextual(&quot;static&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>strictDirective
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === &quot;use strict&quot;) { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === &quot;;&quot;)
      { start++; }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.initialContext();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.<span class="apidocCodeKeywordSpan">strictDirective</span>(this.pos);

// Used to signify the start of a potential arrow function
this.potentialArrowAt = -1;

// Positions to delayed-check that yield/await does not exist in default parameters.
this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
// Labels in scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignable
        <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case &quot;Identifier&quot;:
      if (this.inAsync &amp;&amp; node.name === &quot;await&quot;)
        { this.raise(node.start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      break

    case &quot;ObjectPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;RestElement&quot;:
      break

    case &quot;ObjectExpression&quot;:
      node.type = &quot;ObjectPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === &quot;RestElement&quot; &amp;&amp;
          (prop.argument.type === &quot;ArrayPattern&quot; || prop.argument.type === &quot;ObjectPattern&quot;)
        ) {
          this.raise(prop.argument.start, &quot;Unexpected token&quot;);
        }
      }
      break

    case &quot;Property&quot;:
      // AssignmentProperty has type === &quot;Property&quot;
      if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot;); }
      this.toAssignable(node.value, isBinding);
      break

    case &quot;ArrayExpression&quot;:
      node.type = &quot;ArrayPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case &quot;SpreadElement&quot;:
      node.type = &quot;RestElement&quot;;
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === &quot;AssignmentPattern&quot;)
        { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
      break

    case &quot;AssignmentExpression&quot;:
      if (node.operator !== &quot;=&quot;) { this.raise(node.left.end, &quot;Only &apos;=&apos; operator can be used for specifying default value.&quot;); }
      node.type = &quot;AssignmentPattern&quot;;
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case &quot;AssignmentPattern&quot;:
      break

    case &quot;ParenthesizedExpression&quot;:
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case &quot;MemberExpression&quot;:
      if (!isBinding) { break }

    default:
      this.raise(node.start, &quot;Assigning to rvalue&quot;);
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
  if (this.options.ecmaVersion &gt;= 9) {
    if (this.type === types._in) {
      if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    } else { node.await = awaitAt &gt; -1; }
  }
  this.<span class="apidocCodeKeywordSpan">toAssignable</span>(init, false, refDestructuringErrors);
  this.checkLVal(init);
  return this.parseForIn(node, init)
} else {
  this.checkExpressionErrors(refDestructuringErrors, true);
}
if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
return this.parseFor(node, init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignableList
        <span class="apidocSignatureSpan">(exprList, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i &lt; end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 &amp;&amp; isBinding &amp;&amp; last &amp;&amp; last.type === &quot;RestElement&quot; &amp;&amp; last.argument.type !== &quot;Identifier
&quot;)
      { this.unexpected(last.argument.start); }
  }
  return exprList
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot
;); }
  this.toAssignable(node.value, isBinding);
  break

case &quot;ArrayExpression&quot;:
  node.type = &quot;ArrayPattern&quot;;
  if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  this.<span class="apidocCodeKeywordSpan">toAssignableList</span>(node.elements, isBinding);
  break

case &quot;SpreadElement&quot;:
  node.type = &quot;RestElement&quot;;
  this.toAssignable(node.argument, isBinding);
  if (node.argument.type === &quot;AssignmentPattern&quot;)
    { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(scope) {
  return (scope.flags &amp; SCOPE_FUNCTION) || !this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.<span class="apidocCodeKeywordSpan">treatFunctionsAsVarInScope
</span>(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>tryReadTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var types$1 = {
  b_stat: new TokContext(&quot;{&quot;, false),
  b_expr: new TokContext(&quot;{&quot;, true),
  b_tmpl: new TokContext(&quot;${&quot;, false),
  p_stat: new TokContext(&quot;(&quot;, false),
  p_expr: new TokContext(&quot;(&quot;, true),
  q_tmpl: new TokContext(&quot;`&quot;, true, true, function (p) { return p.<span class="apidocCodeKeywordSpan">tryReadTemplateToken
</span>(); }),
  f_stat: new TokContext(&quot;function&quot;, false),
  f_expr: new TokContext(&quot;function&quot;, true),
  f_expr_gen: new TokContext(&quot;function&quot;, true, false, null, true),
  f_gen: new TokContext(&quot;function&quot;, false, false, null, true)
};

var pp$7 = Parser.prototype;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>unexpected
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos) {
  this.raise(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.<span class="apidocCodeKeywordSpan">unexpected</span>(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var update, type = this.type;
  if (type.keyword &amp;&amp; prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.<span class="apidocCodeKeywordSpan">updateContext</span>(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpFlags
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i &lt; flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, &quot;Invalid regular expression flag&quot;);
    }
    if (flags.indexOf(flag, i + 1) &gt; -1) {
      this.raise(state.start, &quot;Duplicate regular expression flag&quot;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.<span class="apidocCodeKeywordSpan">validateRegExpFlags</span>(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpPattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.<span class="apidocCodeKeywordSpan">validateRegExpPattern</span>(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
  // ESTree requires null if it failed to instantiate RegExp object.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima.Position.prototype" id="apidoc.module.utility2.istanbul.esprima.Position.prototype">module utility2.istanbul.esprima.Position.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset" id="apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Position.prototype.</span>offset
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offset (n) {
  return new Position(this.line, this.column + n)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.estraverse" id="apidoc.module.utility2.istanbul.estraverse">module utility2.istanbul.estraverse</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller" id="apidoc.elem.utility2.istanbul.estraverse.Controller">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.attachComments" id="apidoc.elem.utility2.istanbul.estraverse.attachComments">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment" id="apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>cloneEnvironment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneEnvironment = function () { return clone({}); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.replace" id="apidoc.elem.utility2.istanbul.estraverse.replace">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
        description: &quot;example:&quot;,
        command: [
            &quot;--eval&quot;
        ]
    }
];
file = __filename.<span class="apidocCodeKeywordSpan">replace</span>((
    /.*\//
), &quot;&quot;);
opt = Object.assign({}, opt);
packageJson = require(&quot;./package.json&quot;);
// validate comment
opt.rgxComment = opt.rgxComment || (
    /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\
u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.traverse" id="apidoc.elem.utility2.istanbul.estraverse.traverse">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.estraverse.Controller.prototype" id="apidoc.module.utility2.istanbul.estraverse.Controller.prototype">module utility2.istanbul.estraverse.Controller.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__execute
        <span class="apidocSignatureSpan">(callback, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function __execute(callback, element) {
    var previous, result;

    result = undefined;

    previous  = this.__current;
    this.__current = element;
    this.__state = null;
    if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }
    this.__current = previous;

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        while (worklist.length) {
element = worklist.pop();

if (element === sentinel) {
    element = leavelist.pop();

    ret = this.<span class="apidocCodeKeywordSpan">__execute</span>(visitor.leave, element);

    if (this.__state === BREAK || ret === BREAK) {
        return;
    }
    continue;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__initialize
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;
    if (visitor.fallback === &apos;iteration&apos;) {
        this.__fallback = objectKeys;
    } else if (typeof visitor.fallback === &apos;function&apos;) {
        this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;
    if (visitor.keys) {
        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    key,
    current,
    current2,
    candidates,
    candidate,
    sentinel;

this.<span class="apidocCodeKeywordSpan">__initialize</span>(root, visitor);

sentinel = {};

// reference
worklist = this.__worklist;
leavelist = this.__leavelist;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">break = function () {
    this.notify(BREAK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>current
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function current() {
    return this.__current.node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.<span class="apidocCodeKeywordSpan">current</span>() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>notify
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notify(flag) {
    this.__state = flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
};

// API:
// skip child nodes of current node
Controller.prototype.skip = function () {
    this.<span class="apidocCodeKeywordSpan">notify</span>(SKIP);
};

// API:
// break traversals
Controller.prototype[&apos;break&apos;] = function () {
    this.notify(BREAK);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>parents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parents() {
    var i, iz, result;

    // first node is sentinel
    result = [];
    for (i = 1, iz = this.__leavelist.length; i &lt; iz; ++i) {
        result.push(this.__leavelist[i].node);
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>path
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
        if (isArray(path)) {
            for (j = 0, jz = path.length; j &lt; jz; ++j) {
                result.push(path[j]);
            }
        } else {
            result.push(path);
        }
    }

    // root node
    if (!this.__current.path) {
        return null;
    }

    // first node is sentinel, second node is root element
    result = [];
    for (i = 2, iz = this.__leavelist.length; i &lt; iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
    }
    addToPath(result, this.__current.path);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function () {
    this.notify(REMOVE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        function removeElem(element) {
            var i,
key,
nextElem,
parent;

            if (element.ref.<span class="apidocCodeKeywordSpan">remove</span>()) {
// When the reference is an element of an array.
key = element.ref.key;
parent = element.ref.parent;

// If removed from array, then decrease following items&apos; keys.
i = worklist.length;
while (i--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var worklist,
        leavelist,
        node,
        nodeType,
        target,
        element,
        current,
        current2,
        candidates,
        candidate,
        sentinel,
        outer,
        key;

    function removeElem(element) {
        var i,
            key,
            nextElem,
            parent;

        if (element.ref.remove()) {
            // When the reference is an element of an array.
            key = element.ref.key;
            parent = element.ref.parent;

            // If removed from array, then decrease following items&apos; keys.
            i = worklist.length;
            while (i--) {
                nextElem = worklist[i];
                if (nextElem.ref &amp;&amp; nextElem.ref.parent === parent) {
                    if  (nextElem.ref.key &lt; key) {
                        break;
                    }
                    --nextElem.ref.key;
                }
            }
        }
    }

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    outer = {
        root: root
    };
    element = new Element(root, null, null, new Reference(outer, &apos;root&apos;));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            target = this.__execute(visitor.leave, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
                // replace
                element.ref.replace(target);
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }
            continue;
        }

        target = this.__execute(visitor.enter, element);

        // node may be replaced with null,
        // so distinguish between undefined and null in this place
        if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
            // replace
            element.ref.replace(target);
            element.node = target;
        }

        if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
        }

        if (this.__state === BREAK || target === BREAK) {
            return outer.root;
        }

        // node may be null
        node = element.node;
        if (!node) {
            continue;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || target === SKIP) {
            continue;
        }

        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
            if (this.__fallback) {
                candidates = this.__fallback(node);
            } else {
                throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
            }
        }

        current = candidates.length;
        while ((current -= 1) &gt;= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
                continue;
            }

            if (isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) &gt;= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (isProperty(nodeType, candidates[current])) {
                        element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, new Reference(candidate, current2
));
                    } else if (isNode(candidat...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
        description: &quot;example:&quot;,
        command: [
            &quot;--eval&quot;
        ]
    }
];
file = __filename.<span class="apidocCodeKeywordSpan">replace</span>((
    /.*\//
), &quot;&quot;);
opt = Object.assign({}, opt);
packageJson = require(&quot;./package.json&quot;);
// validate comment
opt.rgxComment = opt.rgxComment || (
    /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\
u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>skip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function () {
    this.notify(SKIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var worklist,
        leavelist,
        element,
        node,
        nodeType,
        ret,
        key,
        current,
        current2,
        candidates,
        candidate,
        sentinel;

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            ret = this.__execute(visitor.leave, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }
            continue;
        }

        if (element.node) {

            ret = this.__execute(visitor.enter, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || ret === SKIP) {
                continue;
            }

            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
                }
            }

            current = candidates.length;
            while ((current -= 1) &gt;= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) &gt;= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, null);
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, null));
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    token = tokenStream.token();
    endChar = token.endChar;
    value = token.value + this._expr(inFunction).text;
    if (unary === null) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
    }
    tokenStream.mustMatch(Tokens.<span class="apidocCodeKeywordSpan">type</span>(endChar));
    value += endChar;
    this._readWhitespace();

//see if there&apos;s a simple match
} else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
        Tokens.ANGLE, Tokens.TIME,
        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.handlebars" id="apidoc.module.utility2.istanbul.handlebars">module utility2.istanbul.handlebars</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.compile" id="apidoc.elem.utility2.istanbul.handlebars.compile">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>compile
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (template) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a function
 * that will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    return function (dict) {
        let result;
        result = template;
        // render triple-curly-brace
        result = result.replace((
            /\{\{\{/g
        ), &quot;{{&quot;).replace((
            /\}\}\}/g
        ), &quot;}}&quot;);
        // render with-statement
        result = result.replace((
            /\{\{#with\u0020(.+?)\}\}([\S\s]+?)\{\{\/with\}\}/g
        ), function (ignore, match1, match2) {
            return local.handlebars.replace(match2, dict, match1 + &quot;.&quot;);
        });
        // render helper
        result = result.replace(
            &quot;{{#show_ignores metrics}}{{/show_ignores}}&quot;,
            function () {
                return local.handlebars.show_ignores(dict.metrics);
            }
        );
        result = result.replace((
            &quot;{{#show_line_execution_counts fileCoverage}}&quot;
            + &quot;{{maxLines}}{{/show_line_execution_counts}}&quot;
        ), function () {
            return local.handlebars.show_line_execution_counts(
                dict.fileCoverage,
                {
                    fn: function () {
                        return dict.maxLines;
                    }
                }
            );
        });
        result = result.replace(
            &quot;{{#show_lines}}{{maxLines}}{{/show_lines}}&quot;,
            function () {
                return local.handlebars.show_lines({
                    fn: function () {
                        return dict.maxLines;
                    }
                });
            }
        );
        result = result.replace(
            &quot;{{#show_picture}}{{metrics.statements.pct}}{{/show_picture}}&quot;,
            function () {
                return local.handlebars.show_picture({
                    fn: function () {
                        return dict.metrics.statements.pct;
                    }
                });
            }
        );
        result = local.handlebars.replace(result, dict, &quot;&quot;);
        // show code last
        result = result.replace(
            &quot;{{#show_code structured}}{{/show_code}}&quot;,
            function () {
                return local.handlebars.show_code(dict.structured);
            }
        );
        return result;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.registerHelper" id="apidoc.elem.utility2.istanbul.handlebars.registerHelper">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>registerHelper
        <span class="apidocSignatureSpan">(key, helper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerHelper = function (key, helper) {
<span class="apidocCodeCommentSpan">/*
 * this function will register the helper-function
 */
</span>    local.handlebars[key] = function (aa, bb) {
        try {
            return helper(aa, bb);
        } catch (ignore) {}
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.replace" id="apidoc.elem.utility2.istanbul.handlebars.replace">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>replace
        <span class="apidocSignatureSpan">(template, dict, withPrefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (template, dict, withPrefix) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let value;
    // search for keys in the template
    return template.replace((
        /\{\{.+?\}\}/g
    ), function (match0) {
        value = dict;
        // iteratively lookup nested values in the dict
        String(
            withPrefix + match0.slice(2, -2)
        ).split(&quot;.&quot;).forEach(function (key) {
            value = value &amp;&amp; value[key];
        });
        return (
            value === undefined
            ? match0
            : String(value)
        );
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
        description: &quot;example:&quot;,
        command: [
            &quot;--eval&quot;
        ]
    }
];
file = __filename.<span class="apidocCodeKeywordSpan">replace</span>((
    /.*\//
), &quot;&quot;);
opt = Object.assign({}, opt);
packageJson = require(&quot;./package.json&quot;);
// validate comment
opt.rgxComment = opt.rgxComment || (
    /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\
u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.show_code" id="apidoc.elem.utility2.istanbul.handlebars.show_code">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_code
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show_code = function (aa, bb) {
    try {
        return helper(aa, bb);
    } catch (ignore) {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.show_ignores" id="apidoc.elem.utility2.istanbul.handlebars.show_ignores">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_ignores
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show_ignores = function (aa, bb) {
    try {
        return helper(aa, bb);
    } catch (ignore) {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.show_line_execution_counts" id="apidoc.elem.utility2.istanbul.handlebars.show_line_execution_counts">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_line_execution_counts
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show_line_execution_counts = function (aa, bb) {
    try {
        return helper(aa, bb);
    } catch (ignore) {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.show_lines" id="apidoc.elem.utility2.istanbul.handlebars.show_lines">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_lines
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show_lines = function (aa, bb) {
    try {
        return helper(aa, bb);
    } catch (ignore) {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.handlebars.show_picture" id="apidoc.elem.utility2.istanbul.handlebars.show_picture">
        function <span class="apidocSignatureSpan">utility2.istanbul.handlebars.</span>show_picture
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show_picture = function (aa, bb) {
    try {
        return helper(aa, bb);
    } catch (ignore) {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.process" id="apidoc.module.utility2.istanbul.process">module utility2.istanbul.process</a></h1>




    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._debugEnd" id="apidoc.elem.utility2.istanbul.process._debugEnd">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugEnd() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._debugProcess" id="apidoc.elem.utility2.istanbul.process._debugProcess">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugProcess() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._fatalException" id="apidoc.elem.utility2.istanbul.process._fatalException">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_fatalException
        <span class="apidocSignatureSpan">(er, fromPromise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(er, fromPromise) =&gt; {
  // It&apos;s possible that defaultTriggerAsyncId was set for a constructor
  // call that threw and was never cleared. So clear it now.
  clearDefaultTriggerAsyncId();

  // If diagnostic reporting is enabled, call into its handler to see
  // whether it is interested in handling the situation.
  // Ignore if the error is scoped inside a domain.
  // use == in the checks as we want to allow for null and undefined
  if (er == null || er.domain == null) {
    try {
      const report = internalBinding(&apos;report&apos;);
      if (report != null &amp;&amp; report.shouldReportOnUncaughtException()) {
        report.writeReport(er ? er.message : &apos;Exception&apos;,
                           &apos;Exception&apos;,
                           null,
                           er ? er.stack : undefined);
      }
    } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.
  }

  const type = fromPromise ? &apos;unhandledRejection&apos; : &apos;uncaughtException&apos;;
  if (exceptionHandlerState.captureFn !== null) {
    exceptionHandlerState.captureFn(er);
  } else if (!process.emit(&apos;uncaughtException&apos;, er, type)) {
    // If someone handled it, then great. Otherwise, die in C++ land
    // since that means that we&apos;ll exit the process, emit the &apos;exit&apos; event.
    try {
      if (!process._exiting) {
        process._exiting = true;
        process.exitCode = 1;
        process.emit(&apos;exit&apos;, 1);
      }
    } catch {
      // Nothing to be done about it at this point.
    }
    return false;
  }

  // If we handled an error, then make sure any ticks get processed
  // by ensuring that the next Immediate cycle isn&apos;t empty.
  require(&apos;timers&apos;).setImmediate(noop);

  // Emit the after() hooks now that the exception has been handled.
  if (afterHooksExist()) {
    do {
      emitAfter(executionAsyncId());
    } while (hasAsyncIdStack());
  // Or completely empty the id stack.
  } else {
    clearAsyncIdStack();
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._getActiveHandles" id="apidoc.elem.utility2.istanbul.process._getActiveHandles">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveHandles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveHandles() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._getActiveRequests" id="apidoc.elem.utility2.istanbul.process._getActiveRequests">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveRequests
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveRequests() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._kill" id="apidoc.elem.utility2.istanbul.process._kill">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_kill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _kill() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._linkedBinding" id="apidoc.elem.utility2.istanbul.process._linkedBinding">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_linkedBinding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _linkedBinding(module) {
  module = String(module);
  let mod = bindingObj[module];
  if (typeof mod !== &apos;object&apos;)
    mod = bindingObj[module] = getLinkedBinding(module);
  return mod;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._rawDebug" id="apidoc.elem.utility2.istanbul.process._rawDebug">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_rawDebug
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _rawDebug(...args) {
  binding._rawDebug(format.apply(null, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier" id="apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_startProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _startProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier" id="apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_stopProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _stopProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._tickCallback" id="apidoc.elem.utility2.istanbul.process._tickCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_tickCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runNextTicks() {
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    runMicrotasks();
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    return;

  processTicksAndRejections();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.abort" id="apidoc.elem.utility2.istanbul.process.abort">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abort() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhrInit();
// init timerTimeout
xhr.timerTimeout = setTimeout(function () {
    xhr.err = xhr.err || new Error(
        &quot;onTimeout - &quot;
        + timeout + &quot; ms - &quot; + &quot;ajax &quot; + xhr.method + &quot; &quot; + xhr.url
    );
    xhr.<span class="apidocCodeKeywordSpan">abort</span>();
    // cleanup reqStream and resStream
    streamCleanup(xhr.reqStream);
    streamCleanup(xhr.resStream);
}, timeout);
// increment counter
ajaxProgressUpdate.counter |= 0;
ajaxProgressUpdate.counter += 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.assert" id="apidoc.elem.utility2.istanbul.process.assert">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return Reflect.construct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.binding" id="apidoc.elem.utility2.istanbul.process.binding">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>binding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function binding(module) {
  module = String(module);
  // Deprecated specific process.binding() modules, but not all, allow
  // selective fallback to internalBinding for the deprecated ones.
  if (internalBindingWhitelist.has(module)) {
    return internalBinding(module);
  }
  // eslint-disable-next-line no-restricted-syntax
  throw new Error(`No such module: ${module}`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                &amp;&amp; typeof dict[key] === &quot;function&quot;
            ) {
                local[tmp][key] = local[tmp][key] || String(dict[key]);
            }
        });
    });
    Object.keys(local[tmp]).forEach(function (key) {
        if (process.<span class="apidocCodeKeywordSpan">binding</span>(&quot;natives&quot;)[key]) {
            local[tmp][key] = undefined;
        }
    });
});
// autofix - local-function
dictFnc = {};
dictProp = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.chdir" id="apidoc.elem.utility2.istanbul.process.chdir">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>chdir
        <span class="apidocSignatureSpan">(directory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chdir(directory) {
  validateString(directory, &apos;directory&apos;);
  binding.chdir(directory);
  // Mark cache that it requires an update.
  cachedCwd = &apos;&apos;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.cpuUsage" id="apidoc.elem.utility2.istanbul.process.cpuUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cpuUsage
        <span class="apidocSignatureSpan">(prevValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuUsage(prevValue) {
  // If a previous value was passed in, ensure it has the correct shape.
  if (prevValue) {
    if (!previousValueIsValid(prevValue.user)) {
      if (typeof prevValue !== &apos;object&apos;)
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue&apos;, &apos;object&apos;, prevValue);

      if (typeof prevValue.user !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.user&apos;,
                                       &apos;number&apos;, prevValue.user);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.user&apos;,
                                                 prevValue.user);
    }

    if (!previousValueIsValid(prevValue.system)) {
      if (typeof prevValue.system !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.system&apos;,
                                       &apos;number&apos;, prevValue.system);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.system&apos;,
                                                 prevValue.system);
    }
  }

  // Call the native function to get the current values.
  const errmsg = _cpuUsage(cpuValues);
  if (errmsg) {
    throw new ERR_CPU_USAGE(errmsg);
  }

  // If a previous value was passed in, return diff of current from previous.
  if (prevValue) {
    return {
      user: cpuValues[0] - prevValue.user,
      system: cpuValues[1] - prevValue.system
    };
  }

  // If no previous value passed in, return current value.
  return {
    user: cpuValues[0],
    system: cpuValues[1]
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.cwd" id="apidoc.elem.utility2.istanbul.process.cwd">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cwd() {
  cachedCwd = binding.cwd();
  return cachedCwd;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
   // search process.<span class="apidocCodeKeywordSpan">cwd</span>()
   if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
       return require(&quot;path&quot;).resolve(process.cwd(), module || &quot;&quot;);
   }
   // search pathList
   Array.from([
       pathList,
       require(&quot;module&quot;).globalPaths,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.dlopen" id="apidoc.elem.utility2.istanbul.process.dlopen">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>dlopen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dlopen() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.emitWarning" id="apidoc.elem.utility2.istanbul.process.emitWarning">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>emitWarning
        <span class="apidocSignatureSpan">(warning, type, code, ctor, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitWarning(warning, type, code, ctor, now) {
  let detail;
  if (type !== null &amp;&amp; typeof type === &apos;object&apos; &amp;&amp; !Array.isArray(type)) {
    ctor = type.ctor;
    code = type.code;
    if (typeof type.detail === &apos;string&apos;)
      detail = type.detail;
    type = type.type || &apos;Warning&apos;;
  } else if (typeof type === &apos;function&apos;) {
    ctor = type;
    code = undefined;
    type = &apos;Warning&apos;;
  }
  if (type !== undefined &amp;&amp; typeof type !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;type&apos;, &apos;string&apos;, type);
  }
  if (typeof code === &apos;function&apos;) {
    ctor = code;
    code = undefined;
  } else if (code !== undefined &amp;&amp; typeof code !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;code&apos;, &apos;string&apos;, code);
  }
  if (typeof warning === &apos;string&apos;) {
    // Improve error creation performance by skipping the error frames.
    // They are added in the `captureStackTrace()` function below.
    const tmpStackLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    // eslint-disable-next-line no-restricted-syntax
    warning = new Error(warning);
    Error.stackTraceLimit = tmpStackLimit;
    warning.name = String(type || &apos;Warning&apos;);
    if (code !== undefined) warning.code = code;
    if (detail !== undefined) warning.detail = detail;
    // eslint-disable-next-line no-restricted-syntax
    Error.captureStackTrace(warning, ctor || process.emitWarning);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;warning&apos;, [&apos;Error&apos;, &apos;string&apos;], warning);
  }
  if (warning.name === &apos;DeprecationWarning&apos;) {
    if (process.noDeprecation)
      return;
    if (process.throwDeprecation)
      throw warning;
  }
  if (now) process.emit(&apos;warning&apos;, warning);
  else process.nextTick(doEmitWarning(warning));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.exit" id="apidoc.elem.utility2.istanbul.process.exit">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
* will delete from github &lt;fileRemote|dirRemote&gt;
*/
   local.github_crud.githubCrudContentDelete({
       message: process.argv[4],
       url: process.argv[3]
   }, function (err) {
       process.<span class="apidocCodeKeywordSpan">exit</span>(Boolean(err));
   });
};

local.cliDict.get = function () {
/*
* &lt;fileRemote&gt;
* will get from github &lt;fileRemote&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getegid" id="apidoc.elem.utility2.istanbul.process.getegid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getegid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getegid() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.geteuid" id="apidoc.elem.utility2.istanbul.process.geteuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>geteuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function geteuid() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getgid" id="apidoc.elem.utility2.istanbul.process.getgid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgid() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getgroups" id="apidoc.elem.utility2.istanbul.process.getgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgroups
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgroups() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getuid" id="apidoc.elem.utility2.istanbul.process.getuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getuid() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback" id="apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hasUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasUncaughtExceptionCaptureCallback() {
  return exceptionHandlerState.captureFn !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.hrtime" id="apidoc.elem.utility2.istanbul.process.hrtime">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hrtime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtime(time) {
  _hrtime(hrValues);

  if (time !== undefined) {
    if (!Array.isArray(time)) {
      throw new ERR_INVALID_ARG_TYPE(&apos;time&apos;, &apos;Array&apos;, time);
    }
    if (time.length !== 2) {
      throw new ERR_OUT_OF_RANGE(&apos;time&apos;, 2, time.length);
    }

    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];
    const nsec = hrValues[2] - time[1];
    const needsBorrow = nsec &lt; 0;
    return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];
  }

  return [
    hrValues[0] * 0x100000000 + hrValues[1],
    hrValues[2]
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.initgroups" id="apidoc.elem.utility2.istanbul.process.initgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>initgroups
        <span class="apidocSignatureSpan">(user, extraGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initgroups(user, extraGroup) {
  validateId(user, &apos;user&apos;);
  validateId(extraGroup, &apos;extraGroup&apos;);
  // Result is 0 on success, 1 if user is unknown, 2 if group is unknown.
  const result = _initgroups(user, extraGroup);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;User&apos;, user);
  } else if (result === 2) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, extraGroup);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.kill" id="apidoc.elem.utility2.istanbul.process.kill">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>kill
        <span class="apidocSignatureSpan">(pid, sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill(pid, sig) {
  var err;

  // eslint-disable-next-line eqeqeq
  if (pid != (pid | 0)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;pid&apos;, &apos;number&apos;, pid);
  }

  // Preserve null signal
  if (sig === (sig | 0)) {
    // XXX(joyeecheung): we have to use process._kill here because
    // it&apos;s monkey-patched by tests.
    err = process._kill(pid, sig);
  } else {
    sig = sig || &apos;SIGTERM&apos;;
    if (constants[sig]) {
      err = process._kill(pid, constants[sig]);
    } else {
      throw new ERR_UNKNOWN_SIGNAL(sig);
    }
  }

  if (err)
    throw errnoException(err, &apos;kill&apos;);

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let child_process;
let timerTimeout;
child_process = require(&quot;child_process&quot;);
// spawn child
child = child_process.spawn(command, args, opt).on(&quot;exit&quot;, function () {
    // cleanup timerTimeout
    try {
        process.<span class="apidocCodeKeywordSpan">kill</span>(timerTimeout.pid);
    } catch (ignore) {}
});
// init timerTimeout
timerTimeout = child_process.spawn(
    // convert timeout to integer seconds with 2 second delay
    &quot;sleep &quot;
    + Math.floor(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.memoryUsage" id="apidoc.elem.utility2.istanbul.process.memoryUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>memoryUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoryUsage() {
  _memoryUsage(memValues);
  return {
    rss: memValues[0],
    heapTotal: memValues[1],
    heapUsed: memValues[2],
    external: memValues[3]
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.nextTick" id="apidoc.elem.utility2.istanbul.process.nextTick">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &apos;function&apos;)
    throw new ERR_INVALID_CALLBACK(callback);

  if (process._exiting)
    return;

  var args;
  switch (arguments.length) {
    case 1: break;
    case 2: args = [arguments[1]]; break;
    case 3: args = [arguments[1], arguments[2]]; break;
    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;
    default:
      args = new Array(arguments.length - 1);
      for (var i = 1; i &lt; arguments.length; i++)
        args[i - 1] = arguments[i];
  }

  if (queue.isEmpty())
    setHasTickScheduled(true);
  const asyncId = newAsyncId();
  const triggerAsyncId = getDefaultTriggerAsyncId();
  const tickObject = {
    [async_id_symbol]: asyncId,
    [trigger_async_id_symbol]: triggerAsyncId,
    callback,
    args
  };
  if (initHooksExist())
    emitInit(asyncId, &apos;TickObject&apos;, triggerAsyncId, tickObject);
  queue.push(tickObject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //
    if (this.options.port != null) {
      server.close(() =&gt; this.emit(&apos;close&apos;));
      return;
    }
  }

  process.<span class="apidocCodeKeywordSpan">nextTick</span>(emitClose, this);
}

/**
 * See if a given request should be handled by this server instance.
 *
 * @param {http.IncomingMessage} req Request object to inspect
 * @return {Boolean} `true` if the request is valid, else `false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.openStdin" id="apidoc.elem.utility2.istanbul.process.openStdin">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>openStdin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  process.stdin.resume();
  return process.stdin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.reallyExit" id="apidoc.elem.utility2.istanbul.process.reallyExit">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>reallyExit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reallyExit() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.resourceUsage" id="apidoc.elem.utility2.istanbul.process.resourceUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>resourceUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resourceUsage() {
  _resourceUsage(resourceValues);
  return {
    userCPUTime: resourceValues[0],
    systemCPUTime: resourceValues[1],
    maxRSS: resourceValues[2],
    sharedMemorySize: resourceValues[3],
    unsharedDataSize: resourceValues[4],
    unsharedStackSize: resourceValues[5],
    minorPageFault: resourceValues[6],
    majorPageFault: resourceValues[7],
    swappedOut: resourceValues[8],
    fsRead: resourceValues[9],
    fsWrite: resourceValues[10],
    ipcSent: resourceValues[11],
    ipcReceived: resourceValues[12],
    signalsCount: resourceValues[13],
    voluntaryContextSwitches: resourceValues[14],
    involuntaryContextSwitches: resourceValues[15]
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback" id="apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(fn) {
  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();
  err.stack = err.stack + &apos;\n&apos; + &apos;-&apos;.repeat(40) + &apos;\n&apos; + domainRequireStack;
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setegid" id="apidoc.elem.utility2.istanbul.process.setegid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setegid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.seteuid" id="apidoc.elem.utility2.istanbul.process.seteuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>seteuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setgid" id="apidoc.elem.utility2.istanbul.process.setgid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setgroups" id="apidoc.elem.utility2.istanbul.process.setgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgroups
        <span class="apidocSignatureSpan">(groups)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setgroups(groups) {
  if (!Array.isArray(groups)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;groups&apos;, &apos;Array&apos;, groups);
  }
  for (var i = 0; i &lt; groups.length; i++) {
    validateId(groups[i], `groups[${i}]`);
  }
  // Result is 0 on success. A positive integer indicates that the
  // corresponding group was not found.
  const result = _setgroups(groups);
  if (result &gt; 0) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, groups[result - 1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setuid" id="apidoc.elem.utility2.istanbul.process.setuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.umask" id="apidoc.elem.utility2.istanbul.process.umask">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>umask
        <span class="apidocSignatureSpan">(mask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function umask(mask) {
  if (mask !== undefined) {
    mask = parseMode(mask, &apos;mask&apos;);
  }
  return binding.umask(mask);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.uptime" id="apidoc.elem.utility2.istanbul.process.uptime">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>uptime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uptime() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.require" id="apidoc.module.utility2.istanbul.require">module utility2.istanbul.require</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require.require" id="apidoc.elem.utility2.istanbul.require.require">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require.resolve" id="apidoc.elem.utility2.istanbul.require.resolve">
        function <span class="apidocSignatureSpan">utility2.istanbul.require.</span>resolve
        <span class="apidocSignatureSpan">(request, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request, options) {
  validateString(request, &apos;request&apos;);
  return Module._resolveFilename(request, mod, false, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
   // search process.cwd()
   if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
       return require(&quot;path&quot;).<span class="apidocCodeKeywordSpan">resolve</span>(process.cwd(), module || &quot;&quot;);
   }
   // search pathList
   Array.from([
       pathList,
       require(&quot;module&quot;).globalPaths,
       [
           process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.util" id="apidoc.module.utility2.istanbul.util">module utility2.istanbul.util</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.util.inherits" id="apidoc.elem.utility2.istanbul.util.inherits">
        function <span class="apidocSignatureSpan">utility2.istanbul.util.</span>inherits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.writer" id="apidoc.module.utility2.istanbul.writer">module utility2.istanbul.writer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.writer.write" id="apidoc.elem.utility2.istanbul.writer.write">
        function <span class="apidocSignatureSpan">utility2.istanbul.writer.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
    local.writerData += data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.<span class="apidocCodeKeywordSpan">write</span>(local.apidocCreate({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.writer.writeFile" id="apidoc.elem.utility2.istanbul.writer.writeFile">
        function <span class="apidocSignatureSpan">utility2.istanbul.writer.</span>writeFile
        <span class="apidocSignatureSpan">(file, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (file, onError) {
    local.coverageReportHtml += local.writerData + &quot;\n\n&quot;;
    if (!local.isBrowser &amp;&amp; local.writerFile) {
        local.fsWriteFileWithMkdirpSync(local.writerFile, local.writerData);
    }
    local.writerData = &quot;&quot;;
    local.writerFile = file;
    onError(local.writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.writerData = &quot;&quot;;
opt.sourceStore = {};
opt.writer = local.writer;
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.<span class="apidocCodeKeywordSpan">writeFile</span>(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint" id="apidoc.module.utility2.jslint">module utility2.jslint</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.jslint.assert" id="apidoc.elem.utility2.jslint.assert">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.assertOrThrow" id="apidoc.elem.utility2.jslint.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliRun" id="apidoc.elem.utility2.jslint.cliRun">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.coalesce" id="apidoc.elem.utility2.jslint.coalesce">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.events" id="apidoc.elem.utility2.jslint.events">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.fsRmrfSync" id="apidoc.elem.utility2.jslint.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.functionOrNop" id="apidoc.elem.utility2.jslint.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.identity" id="apidoc.elem.utility2.jslint.identity">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAndPrint" id="apidoc.elem.utility2.jslint.jslintAndPrint">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrint
        <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrint = function (code = &quot;&quot;, file = &quot;undefined&quot;, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint / csslint &lt;code&gt; and print any errors to stderr
 */
</span>    let ii;
    let tmp;
    if (!(opt &amp;&amp; opt.gotoState)) {
        local.jslintResult = {
            gotoState: 0
        };
    }
    opt = Object.assign(local.jslintResult, opt);
    opt.gotoState += 1;
    switch (opt.gotoState) {
    // jslint - init
    case 1:
        // cleanup
        opt.errList = [];
        opt.errMsg = &quot;&quot;;
        // preserve lineno
        if (opt.iiStart) {
            opt.lineOffset |= 0;
            ii = 0;
            while (true) {
                ii = code.indexOf(&quot;\n&quot;, ii);
                if (ii === 0 || ii &gt; opt.iiStart) {
                    break;
                }
                ii += 1;
                opt.lineOffset += 1;
            }
            code = code.slice(opt.iiStart, opt.iiEnd || code.length);
        }
        switch (opt.fileType0) {
        // deembed-js - &apos;\\n\\\n...\\n\\\n&apos;
        case &quot;.\\n\\&quot;:
            // rgx - remove \\n\\
            code = code.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || &quot;&quot;;
            });
            break;
        // deembed-js - &apos;\n...\n&apos;
        case &quot;.sh&quot;:
            // rgx - convert &apos;&quot;&apos;&quot;&apos; to &apos;
            code = code.replace((
                /&apos;&quot;&apos;&quot;&apos;/g
            ), &quot;&apos;&quot;);
            break;
        }
        // init
        opt = Object.assign(opt, {
            &quot;.css&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.html&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.js&quot;: (
                /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.md&quot;: (
                /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.sh&quot;: (
                /(^#\u0020jslint\u0020utility2:true$)/m
            ),
            code0: code,
            fileType: (
                /\.\w+?$|$/m
            ).exec(file)[0]
        });
        // jslint - .json
        if (
            code &amp;&amp; (opt.fileType === &quot;.js&quot; || opt.fileType === &quot;.json&quot;)
            &amp;&amp; !opt.fileType0
        ) {
            try {
                tmp = JSON.parse(code);
                opt.fileType = &quot;.json&quot;;
                if (opt.autofix) {
                    code = JSON.stringify(tmp, null, 4) + &quot;\n&quot;;
                    opt.code0 = code;
                }
                opt.gotoState = Infinity;
                break;
            } catch (errCaught) {
                if (opt.fileType === &quot;.json&quot;) {
                    opt.errList.push({
                        column: 0,
                        evidence: code.slice(0, 100),
                        line: 0,
                        message: errCaught.message
                    });
                    opt.gotoState = Infinity;
                    break;
                }
            }
        }
        try {
            opt.conditionalPassed = opt[opt.fileType].exec(code);
        } catch (ignore) {}
        opt.utility2 = (
            opt.conditionalPassed
            &amp;&amp; opt.conditionalPassed[1]
        ) || opt.autofix;
        if (
            opt.conditional
            &amp;&amp; (!opt.conditionalPassed || opt.coverage)
        ) {
            break;
        }
        opt.gotoState = 10;
        break;
    // jslint - autofix
    case 11:
        code = local.jslintAutofix(code, file, opt);
        local.jslintResult = opt;
        break;
    // jslint - csslint and jslint
    case 12:
        // restore lineOffset
        code = &quot;\n&quot;.rep...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    // read file
    local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
    break;
case 2:
    // jslint
    local.jslint.<span class="apidocCodeKeywordSpan">jslintAndPrint</span>(data, opt.file);
    local.assertOrThrow(
        !local.jslint.jslintResult.errMsg,
        local.jslint.jslintResult.errMsg.replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;)
    );
    // validate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAndPrintDir" id="apidoc.elem.utility2.jslint.jslintAndPrintDir">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrintDir
        <span class="apidocSignatureSpan">(dir, opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrintDir = function (dir, opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint files in shallow &lt;dir&gt;
 */
</span>    let onParallel;
    onParallel = local.onParallel(onError);
    local.fs.readdirSync(dir).forEach(function (file) {
        let timeStart;
        file = process.cwd() + &quot;/&quot; + file;
        switch ((
            /\.\w+?$|$/m
        ).exec(file)[0]) {
        case &quot;.css&quot;:
        case &quot;.html&quot;:
        case &quot;.js&quot;:
        case &quot;.json&quot;:
        case &quot;.md&quot;:
        case &quot;.sh&quot;:
            if ((
                /\b(?:assets\.app\.js|lock|min|raw|rollup)\b/
            ).test(file)) {
                return;
            }
            onParallel.counter += 1;
            // jslint file
            local.fs.readFile(file, &quot;utf8&quot;, function (err, data) {
                // handle err
                local.assertOrThrow(!err, err);
                timeStart = Date.now();
                local.jslintAndPrint(data, file, opt);
                console.error(
                    &quot;jslint - &quot; + (Date.now() - timeStart) + &quot;ms &quot; + file
                );
                onParallel();
            });
            break;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
// jslint process.cwd()
if (!local.env.npm_config_mode_library) {
    local.child_process.spawn(&quot;node&quot;, [
        &quot;-e&quot;, (
            &quot;require(&quot;
            + JSON.stringify(__filename)
            + &quot;).jslint.<span class="apidocCodeKeywordSpan">jslintAndPrintDir</span>(&quot;
            + JSON.stringify(process.cwd())
            + &quot;, {autofix:true,conditional:true}, process.exit);&quot;
        )
    ], {
        env: Object.assign({}, local.env, {
            npm_config_mode_library: &quot;1&quot;
        }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAutofix" id="apidoc.elem.utility2.jslint.jslintAutofix">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAutofix
        <span class="apidocSignatureSpan">(code, file, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAutofix = function (code, file, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint-autofix &lt;code&gt;
 */
</span>    let code0;
    let code2;
    let dataList;
    let ignoreList;
    let ii;
    let rgx1;
    let rgx2;
    let tmp;
    // autofix-all
    if (opt.autofix) {
        // autofix-all - normalize local-function
        if (
            globalThis.utility2
            &amp;&amp; typeof globalThis.utility2.jslintAutofixLocalFunction
            === &quot;function&quot;
        ) {
            code = globalThis.utility2.jslintAutofixLocalFunction(code, file);
        }
        // autofix-all - remove trailing-whitespace
        code = code.replace((
            /\u0020+$/gm
        ), &quot;&quot;);
        // autofix-all - remove leading-whitespace before )]}
        code = code.replace((
            /\n+?(\n\u0020*?[)\]}])/g
        ), &quot;$1&quot;);
        // autofix-all - normalize newlines to \n\n
        code = code.replace((
            /([^\n])\n{3}([^\n])/g
        ), &quot;$1\n\n$2&quot;);
        // autofix-all - normalize newlines to \n\n\n\n
        code = code.replace((
            /\n{5,}/g
        ), &quot;\n\n\n\n&quot;);
        // autofix-all - recurse &lt;script&gt;...&lt;/script&gt;, &lt;style&gt;...&lt;/style&gt;
        code = code.replace((
            /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/\\n\\\n(?:^.*?\\n\\\n)*?)(&apos;;$|&lt;\/script&gt;\\n\\$|&lt;\/style&gt;\\n\\$)/gm
        ), function (ignore, match1, match2, ii) {
            return local.jslintAndPrint(
                code,
                file + (
                    match2.indexOf(&quot;style&quot;) &gt; -1
                    ? &quot;.&lt;style&gt;.css&quot;
                    : &quot;.&lt;script&gt;.js&quot;
                ),
                Object.assign({}, opt, {
                    fileType0: &quot;.\\n\\&quot;,
                    iiEnd: ii + match1.length,
                    iiStart: ii,
                    gotoState: 0
                })
            ) + match2;
        });
    }
    switch (opt.autofix &amp;&amp; opt.fileType) {
    case &quot;.css&quot;:
        break;
    case &quot;.html&quot;:
        // autofix-html - recurse &lt;script&gt;...&lt;/script&gt;, &lt;style&gt;...&lt;/style&gt;
        code = code.replace((
            /^(\/\*\u0020jslint\u0020utility2:true\u0020\*\/\n[\S\s]*?\n)(&lt;\/(?:script|style)&gt;)$/gm
        ), function (ignore, match1, match2, ii) {
            return local.jslintAndPrint(
                code,
                file + (
                    match2.indexOf(&quot;style&quot;) &gt;= 0
                    ? &quot;.&lt;style&gt;.css&quot;
                    : &quot;.&lt;script&gt;.js&quot;
                ),
                Object.assign({}, opt, {
                    fileType0: opt.fileType,
                    iiEnd: ii + match1.length,
                    iiStart: ii,
                    gotoState: 0
                })
            ) + match2;
        });
        break;
    case &quot;.js&quot;:
        // autofix-js - demux code to [code, ignoreList]
        ignoreList = [];
        code = code.replace((
            /^\u0020*?\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]*?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
        ), function (match0) {
            ignoreList.push(match0);
            return &quot;/* jslint ignore:start:end */&quot;;
        });
        // autofix-js - escape non-ascii
        code = code.replace((
            /[^\n\r\t\u0020-\u007e]/g
        ), function (match0) {
            return &quot;\\u&quot; + (
                &quot;0000&quot;
                + match0.charCodeAt(0).toString(16)
            ).slice(-4);
        });
        // autofix-js - demux code2 to [code2, ignoreList]
        code2 = &quot;&quot;;
        dataList = [];
        ii = 0;
        rgx1 = (
            /\\.|\/\*|\*\/|\/\/!!|\/\/|[&quot;&apos;\/`]|$/gm
        );
        // parse rgx
        // https://github.com/douglascrockford/JSLint/blob/557afd32bcaa35480d31a86f02d3a8c06a4e5b5c/jslint.js#L1383
        rgx2 = (...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintGetColumnLine" id="apidoc.elem.utility2.jslint.jslintGetColumnLine">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintGetColumnLine
        <span class="apidocSignatureSpan">(code, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintGetColumnLine = function (code, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will transform &lt;code&gt; and &lt;ii&gt; to {column, line, evidence}
 */
</span>    let column;
    let evidence;
    let line;
    evidence = code.slice(0, ii).split(&quot;\n&quot;);
    line = evidence.length - 1;
    column = evidence[line].length;
    evidence = evidence[line] + code.slice(ii, ii + 100).split(&quot;\n&quot;)[0];
    return {
        column,
        evidence,
        line
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintUtility2" id="apidoc.elem.utility2.jslint.jslintUtility2">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintUtility2
        <span class="apidocSignatureSpan">(code, ignore, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintUtility2 = function (code, ignore, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint &lt;code&gt; with utiity2-specific rules
 */
</span>    let code2;
    let err;
    let indent;
    let previous;
    // jslintUtility2 - all
    if (opt.utility2) {
        code2 = code;
        code2 = code2.replace((
            /^\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]+?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
        ), function (match0) {
            // preserve lineno
            return match0.replace((
                /.+/g
            ), &quot;&quot;);
        });
        code2.replace((
            /^\u0020+?(?:\*|\/\/!!)|^\u0020+|[\r\t]/gm
        ), function (match0, ii) {
            switch (match0.slice(-1)) {
            case &quot; &quot;:
                if (match0.length % 4 === 0) {
                    return &quot;&quot;;
                }
                err = {
                    message: &quot;non 4-space indent&quot;
                };
                break;
            case &quot;\r&quot;:
                err = {
                    message: &quot;unexpected \\r&quot;
                };
                break;
            case &quot;\t&quot;:
                err = {
                    message: &quot;unexpected \\t&quot;
                };
                break;
            default:
                return &quot;&quot;;
            }
            Object.assign(err, local.jslintGetColumnLine(code2, ii));
            opt.errList.push({
                column: err.column + 1,
                evidence: JSON.stringify(err.evidence),
                line: err.line + 1,
                message: err.message
            });
            return &quot;&quot;;
        });
    }
    switch (opt.utility2 &amp;&amp; opt.fileType) {
    // jslintUtility2 - .css
    case &quot;.css&quot;:
        // ignore comment
        code2 = code2.replace((
            /^\u0020*?\/\*[\S\s]*?\*\/\u0020*?$/gm
        ), function (match0) {
            // preserve lineno
            return match0.replace((
                /.+/g
            ), &quot;&quot;);
        });
        code2.replace((
            /\S\u0020{2}|\u0020,|^\S.*?[,;{}]./gm
        ), function (match0, ii) {
            switch (match0.slice(-2)) {
            case &quot;  &quot;:
                err = {
                    colOffset: 2,
                    message: &quot;unexpected multi-whitespace&quot;
                };
                break;
            case &quot; ,&quot;:
                err = {
                    colOffset: 1,
                    message: &quot;unexpected whitespace before comma&quot;
                };
                break;
            default:
                err = {
                    colOffset: match0.length,
                    message: &quot;unexpected multiline-statement&quot;
                };
            }
            Object.assign(err, local.jslintGetColumnLine(code2, ii));
            opt.errList.push({
                column: err.column + err.colOffset,
                evidence: JSON.stringify(err.evidence),
                line: err.line + 1,
                message: err.message
            });
            return &quot;&quot;;
        });
        // validate line-sorted - css-selector
        previous = &quot;&quot;;
        code2 = code2.replace((
            /^.|[#.&gt;]|[,}]$|\u0020\{$|\b\w/gm
        ), function (match0) {
            switch (match0) {
            case &quot; &quot;:
                return match0;
            case &quot; {&quot;:
                return &quot;\u0001&quot; + match0;
            case &quot;#&quot;:
                return &quot;\u0002&quot; + match0;
            case &quot;,&quot;:
                return &quot;\u0000&quot; + match0;
            case &quot;.&quot;:
                return &quot;\u0001&quot; + match0;
            case &quot;&gt;&quot;:
                return &quot;\u0003&quot; + match0;
            case &quot;}&quot;:
                return match0;
            default:
                return &quot;\u0000&quot; + match0;
            }...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslint_extra" id="apidoc.elem.utility2.jslint.jslint_extra">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslint_extra
        <span class="apidocSignatureSpan">(source, opt, global_array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslint_extra = function (source, opt, global_array) {
<span class="apidocCodeCommentSpan">/*
 * this function will run with extra-features inside jslint-function jslint()
 */
</span>    // init
    line_ignore = null;
    lines = (
        Array.isArray(source)
        ? source
        : source.split(rx_crlf)
    );
    lines_extra = lines.map(function () {
        return {};
    });
    // jslint
    jslint_result = jslint0(lines, opt, global_array);
    // autofix
    // expected_space_a_b: &quot;Expected one space between &apos;{a}&apos; and &apos;{b}&apos;.&quot;,
    // unexpected_space_a_b: &quot;Unexpected space between &apos;{a}&apos; and &apos;{b}&apos;.&quot;,
    source = lines_extra.map(function (element, ii) {
        return element.source_autofix || lines[ii];
    }).join(&quot;\n&quot;).replace((
        /\s+?\u0000/g
    ), &quot;\u0000&quot;).replace((
        /(\n\u0020+)(.*?)\n\u0020*?(\/\/.*?)\u0000/g
    ), &quot;$1$3$1$2\u0000&quot;).replace((
        /\u0000expected_space_a_b\u0000/g
    ), &quot; &quot;).replace((
        /\u0000unexpected_space_a_b\u0000/g
    ), &quot;&quot;);
    jslint_result.lines_extra = lines_extra;
    jslint_result.source_autofix = source;
    return jslint_result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.nop" id="apidoc.elem.utility2.jslint.nop">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.objectAssignDefault" id="apidoc.elem.utility2.jslint.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.onErrorWithStack" id="apidoc.elem.utility2.jslint.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack.replace((
        /(.*?)\n.*?$/m
    ), &quot;$1&quot;);
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errDefault
            &amp;&amp; String(err.stack).indexOf(stack.split(&quot;\n&quot;)[2]) &lt; 0
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.onParallel" id="apidoc.elem.utility2.jslint.onParallel">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if counter === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement counter
        onParallel.counter -= 1;
        // validate counter
        if (!(onParallel.counter &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.counter = &quot; + onParallel.counter
            );
        // ensure onError is run only once
        } else if (onParallel.counter &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure counter &lt;= 0
            onParallel.counter = -Math.abs(onParallel.counter);
        }
        // call onError when isDone
        if (onParallel.counter &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init counter
    onParallel.counter = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.querySelector" id="apidoc.elem.utility2.jslint.querySelector">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.querySelectorAll" id="apidoc.elem.utility2.jslint.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.stream" id="apidoc.elem.utility2.jslint.stream">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.CSSLint" id="apidoc.module.utility2.jslint.CSSLint">module utility2.jslint.CSSLint</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter" id="apidoc.elem.utility2.jslint.CSSLint._Reporter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_Reporter
        <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reporter(lines, ruleset, allow, ignore) {
    &quot;use strict&quot;;

<span class="apidocCodeCommentSpan">    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
</span>    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.addFormatter" id="apidoc.elem.utility2.jslint.CSSLint.addFormatter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addFormatter
        <span class="apidocSignatureSpan">(formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatter) {
    // formatters.push(formatter);
    formatters[formatter.id] = formatter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.addRule" id="apidoc.elem.utility2.jslint.CSSLint.addRule">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(rule) {
    rules.push(rule);
    rules[rule.id] = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.clearRules" id="apidoc.elem.utility2.jslint.CSSLint.clearRules">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>clearRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    rules = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.format" id="apidoc.elem.utility2.jslint.CSSLint.format">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>format
        <span class="apidocSignatureSpan">(results, filename, formatId, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(results, filename, formatId, options) {
    var formatter = this.getFormatter(formatId),
        result = null;

    if (formatter) {
        result = formatter.startFormat();
        result += formatter.formatResults(results, filename, options || {});
        result += formatter.endFormat();
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
    ws.protocol = protocol;
  }
}

if (extensions[PerMessageDeflate.extensionName]) {
  const params = extensions[PerMessageDeflate.extensionName].params;
  const value = extension.<span class="apidocCodeKeywordSpan">format</span>({
    [PerMessageDeflate.extensionName]: [params]
  });
  headers.push(`Sec-WebSocket-Extensions: ${value}`);
  ws._extensions = extensions;
}

//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getFormatter" id="apidoc.elem.utility2.jslint.CSSLint.getFormatter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getFormatter
        <span class="apidocSignatureSpan">(formatId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatId) {
    return formatters[formatId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getRules" id="apidoc.elem.utility2.jslint.CSSLint.getRules">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    return [].concat(rules).sort(function(a, b) {
        return a.id &gt; b.id ? 1 : 0;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getRuleset" id="apidoc.elem.utility2.jslint.CSSLint.getRuleset">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRuleset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    var ruleset = {},
        i = 0,
        len = rules.length;

    while (i &lt; len) {
        ruleset[rules[i++].id] = 1;    // by default, everything is a warning
    }

    return ruleset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.hasFormat" id="apidoc.elem.utility2.jslint.CSSLint.hasFormat">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>hasFormat
        <span class="apidocSignatureSpan">(formatId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatId) {
    return formatters.hasOwnProperty(formatId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.verify" id="apidoc.elem.utility2.jslint.CSSLint.verify">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>verify
        <span class="apidocSignatureSpan">(text, ruleset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(text, ruleset) {

    var i = 0,
        reporter,
        lines,
        allow = {},
        ignore = [],
        report,
        parser = new parserlib.css.Parser({
            starHack: true,
            ieFilters: true,
            underscoreHack: true,
            strict: false
        });

    // normalize line endings
    lines = text.replace(/\n\r?/g, &quot;$split$&quot;).split(&quot;$split$&quot;);

    // find &apos;allow&apos; comments
    CSSLint.Util.forEach(lines, function (line, lineno) {
        var allowLine = line &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+allow:[ \t]*([^\*]*)\*\//i),
            allowRules = allowLine &amp;&amp; allowLine[1],
            allowRuleset = {};

        if (allowRules) {
            allowRules.toLowerCase().split(&quot;,&quot;).forEach(function(allowRule) {
                allowRuleset[allowRule.trim()] = true;
            });
            if (Object.keys(allowRuleset).length &gt; 0) {
                allow[lineno + 1] = allowRuleset;
            }
        }
    });

    var ignoreStart = null,
        ignoreEnd = null;
    CSSLint.Util.forEach(lines, function (line, lineno) {
        // Keep oldest, &quot;unclosest&quot; ignore:start
        if (ignoreStart === null &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+ignore:start[ \t]*\*\//i)) {
            ignoreStart = lineno;
        }

        if (line.match(/\/\*[ \t]*csslint[ \t]+ignore:end[ \t]*\*\//i)) {
            ignoreEnd = lineno;
        }

        if (ignoreStart !== null &amp;&amp; ignoreEnd !== null) {
            ignore.push([ignoreStart, ignoreEnd]);
            ignoreStart = ignoreEnd = null;
        }
    });

    // Close remaining ignore block, if any
    if (ignoreStart !== null) {
        ignore.push([ignoreStart, lines.length]);
    }

    if (!ruleset) {
        ruleset = this.getRuleset();
    }

    if (embeddedRuleset.test(text)) {
        // defensively copy so that caller&apos;s version does not get modified
        ruleset = clone(ruleset);
        ruleset = applyEmbeddedRuleset(text, ruleset);
    }

    reporter = new Reporter(lines, ruleset, allow, ignore);

    ruleset.errors = 2;       // always report parsing errors as errors
    for (i in ruleset) {
        if (ruleset.hasOwnProperty(i) &amp;&amp; ruleset[i]) {
            if (rules[i]) {
                rules[i].init(parser, reporter);
            }
        }
    }

    // capture most horrible error type
    try {
        parser.parse(text);
    } catch (ex) {
        reporter.error(&quot;Fatal error, cannot continue: &quot; + ex.message, ex.line, ex.col, {});
    }

    report = {
        messages    : reporter.messages,
        stats       : reporter.stats,
        ruleset     : reporter.ruleset,
        allow       : reporter.allow,
        ignore      : reporter.ignore
    };

    // sort by line numbers, rollups at the bottom
    report.messages.sort(function (a, b) {
        if (a.rollup &amp;&amp; !b.rollup) {
            return 1;
        } else if (!a.rollup &amp;&amp; b.rollup) {
            return -1;
        } else {
            return a.line - b.line;
        }
    });

    return report;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.CSSLint._Reporter.prototype" id="apidoc.module.utility2.jslint.CSSLint._Reporter.prototype">module utility2.jslint.CSSLint._Reporter.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>constructor
        <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reporter(lines, ruleset, allow, ignore) {
    &quot;use strict&quot;;

<span class="apidocCodeCommentSpan">    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
</span>    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>error
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;error&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule || {}
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.tryCatchOnError(function () {
        file = local.path.resolve(opt.dir, file);
        console.<span class="apidocCodeKeywordSpan">error</span>(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
            + &quot;\n\n\n\n\n\n\n\n&quot;
        ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>info
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;info&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>report
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;

    // Check if rule violation should be allowed
    if (this.allow.hasOwnProperty(line) &amp;&amp; this.allow[line].hasOwnProperty(rule.id)) {
        return;
    }

    var ignore = false;
    CSSLint.Util.forEach(this.ignore, function (range) {
        if (range[0] &lt;= line &amp;&amp; line &lt;= range[1]) {
            ignore = true;
        }
    });
    if (ignore) {
        return;
    }

    this.messages.push({
        type    : this.ruleset[rule.id] === 2 ? &quot;error&quot; : &quot;warning&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupError
        <span class="apidocSignatureSpan">(message, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;error&quot;,
        rollup  : true,
        message : message,
        rule    : rule
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupWarn
        <span class="apidocSignatureSpan">(message, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;warning&quot;,
        rollup  : true,
        message : message,
        rule    : rule
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>stat
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name, value) {
    &quot;use strict&quot;;
    this.stats[name] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let onParallel;
if (local.isBrowser) {
    onError(undefined, opt);
    return;
}
onParallel = local.onParallel(onError);
onParallel.counter += 1;
local.fs.<span class="apidocCodeKeywordSpan">stat</span>(__filename, function (err, stat) {
    // test default watchFile handling-behavior
    onParallel.counter += 1;
    local.fs.utimes(__filename, stat.atime, new Date(), onParallel);
    // test nop watchFile handling-behavior
    onParallel.counter += 1;
    setTimeout(function () {
        local.fs.utimes(__filename, stat.atime, stat.mtime, onParallel);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>warn
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.report(message, line, col, rule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options.source_map.add(
        mapping.token.file,
        mapping.line, mapping.col,
        mapping.token.line, mapping.token.col,
        !mapping.name &amp;&amp; mapping.token.type == &quot;name&quot; ? mapping.token.value : mapping.name
    );
} catch(ex) {
    mapping.token.file != null &amp;&amp; AST_Node.<span class="apidocCodeKeywordSpan">warn</span>(&quot;Couldn&apos;t figure out
 mapping for {file}:{line},{col}  {cline},{ccol} [{name}]&quot;, {
        file: mapping.token.file,
        line: mapping.token.line,
        col: mapping.token.col,
        cline: mapping.line,
        ccol: mapping.col,
        name: mapping.name || &quot;&quot;
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.cliDict" id="apidoc.module.utility2.jslint.cliDict">module utility2.jslint.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliDict._default" id="apidoc.elem.utility2.jslint.cliDict._default">
        function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>_default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_default = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;file1&gt; &lt;file2&gt; ...
 * will jslint &lt;file1&gt; &lt;file2&gt; ... and print errors to stderr
 */
</span>    // jslint files
    process.argv.slice(2).forEach(function (file) {
        if (file[0] === &quot;-&quot;) {
            return;
        }
        local.jslintAndPrint(
            local.fs.readFileSync(local.path.resolve(file), &quot;utf8&quot;),
            file,
            {
                autofix: process.argv.indexOf(&quot;--autofix&quot;) &gt;= 0,
                conditional: process.argv.indexOf(&quot;--conditional&quot;) &gt;= 0
            }
        );
    });
    // if err occurred, then exit with non-zero code
    process.exit(Boolean(local.jslintResult.errList.length));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       local.cliDict._help();
       return;
   }
   if (local.cliDict[process.argv[2]]) {
       local.cliDict[process.argv[2]]();
       return;
   }
   local.cliDict.<span class="apidocCodeKeywordSpan">_default</span>();
};

local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliDict.dir" id="apidoc.elem.utility2.jslint.cliDict.dir">
        function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>dir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;dir&gt;
 * will jslint files in shallow &lt;dir&gt;
 */
</span>    local.jslintAndPrintDir(process.argv[3], {
        autofix: process.argv.indexOf(&quot;--autofix&quot;) &gt;= 0,
        conditional: process.argv.indexOf(&quot;--conditional&quot;) &gt;= 0
    }, process.exit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked" id="apidoc.module.utility2.marked">module utility2.marked</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.marked" id="apidoc.elem.utility2.marked.marked">
        function <span class="apidocSignatureSpan">utility2.</span>marked
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer" id="apidoc.elem.utility2.marked.Lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser" id="apidoc.elem.utility2.marked.Parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer" id="apidoc.elem.utility2.marked.Renderer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.inlineLexer" id="apidoc.elem.utility2.marked.inlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>inlineLexer
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var i=new r(t,n);return i.output(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.lexer" id="apidoc.elem.utility2.marked.lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>lexer
        <span class="apidocSignatureSpan">(e, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, n){var r=new t(n);return r.lex(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.options" id="apidoc.elem.utility2.marked.options">
        function <span class="apidocSignatureSpan">utility2.marked.</span>options
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return l(c.defaults,e),c}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.parse" id="apidoc.elem.utility2.marked.parse">
        function <span class="apidocSignatureSpan">utility2.marked.</span>parse
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.<span class="apidocCodeKeywordSpan">parse</span>(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
        }, console.error);
    }
});
Object.keys(opt.packageJson).forEach(function (key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.parser" id="apidoc.elem.utility2.marked.parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>parser
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=new s(t,n);return r.parse
(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.setOptions" id="apidoc.elem.utility2.marked.setOptions">
        function <span class="apidocSignatureSpan">utility2.marked.</span>setOptions
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return l(c.defaults,e),c}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.InlineLexer" id="apidoc.module.utility2.marked.InlineLexer">module utility2.marked.InlineLexer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.output" id="apidoc.elem.utility2.marked.InlineLexer.output">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>output
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var i=new r(t,n);return i.output(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};n._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,n._href=/\s*&lt;?([\s\S]*?)&gt;?(?:\s+[&apos;&quot;]([\s\S]*?)[&apos;&quot;])?\s*/
,n.link=a(n.link)(&quot;inside&quot;,n._inside)(&quot;href&quot;,n._href)(),n.reflink=a(n.reflink)(&quot;inside&quot;
,n._inside)(),n.normal=l({},n),n.pedantic=l({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.<span class="apidocCodeKeywordSpan">output</span>(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.InlineLexer.prototype" id="apidoc.module.utility2.marked.InlineLexer.prototype">module utility2.marked.InlineLexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.mangle" id="apidoc.elem.utility2.marked.InlineLexer.prototype.mangle">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>mangle
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){if(!this.options.
mangle)return e;var t=&quot;&quot;,n=e.length,r=0,i;for(;r&lt;n;r++)i=e.charCodeAt(r),Math.random
()&gt;.5&amp;&amp;(i=&quot;x&quot;+i.toString(16)),t+=&quot;&amp;#&quot;+i+&quot;;&quot;;return t}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.output(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.<span class="apidocCodeKeywordSpan">mangle</span>(s[1].substring
(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.output" id="apidoc.elem.utility2.marked.InlineLexer.prototype.output">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>output
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};n._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,n._href=/\s*&lt;?([\s\S]*?)&gt;?(?:\s+[&apos;&quot;]([\s\S]*?)[&apos;&quot;])?\s*/
,n.link=a(n.link)(&quot;inside&quot;,n._inside)(&quot;href&quot;,n._href)(),n.reflink=a(n.reflink)(&quot;inside&quot;
,n._inside)(),n.normal=l({},n),n.pedantic=l({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.<span class="apidocCodeKeywordSpan">output</span>(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink" id="apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>outputLink
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.<span class="apidocCodeKeywordSpan">outputLink</span>(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants" id="apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>smartypants
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.<span class="apidocCodeKeywordSpan">smartypants</span>(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Lexer" id="apidoc.module.utility2.marked.Lexer">module utility2.marked.Lexer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.Lexer" id="apidoc.elem.utility2.marked.Lexer.Lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.lex" id="apidoc.elem.utility2.marked.Lexer.lex">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>lex
        <span class="apidocSignatureSpan">(e, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, n){var r=new t(n);return r.lex(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
e,t){return t=t.toLowerCase(),t===&quot;colon&quot;?&quot;:&quot;:t.charAt(0)===&quot;#&quot;?t.charAt(1)===&quot;x&quot;?
String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring
(1)):&quot;&quot;})}function a(e,t){return e=e.source,t=t||&quot;&quot;,function n(r,i){return r?(i=
i.source||i,i=i.replace(/(^|[^\[])\^/g,&quot;$1&quot;),e=e.replace(r,i),n):new RegExp(e,t)
}}function f(){}function l(e){var t=1,n,r;for(;t&lt;arguments.length;t++){n=arguments
[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r])}return e}function c
(e,n,r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.<span class="apidocCodeKeywordSpan">lex</span>(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Lexer.prototype" id="apidoc.module.utility2.marked.Lexer.prototype">module utility2.marked.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.prototype.lex" id="apidoc.elem.utility2.marked.Lexer.prototype.lex">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>lex
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e=
e.replace(/\r\n|\r/g,&quot;\n&quot;).replace(/\t/g,&quot;    &quot;).replace(/\u00a0/g,&quot; &quot;).replace(/\u2424/g
,&quot;\n&quot;),this.token(e,!0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
e,t){return t=t.toLowerCase(),t===&quot;colon&quot;?&quot;:&quot;:t.charAt(0)===&quot;#&quot;?t.charAt(1)===&quot;x&quot;?
String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring
(1)):&quot;&quot;})}function a(e,t){return e=e.source,t=t||&quot;&quot;,function n(r,i){return r?(i=
i.source||i,i=i.replace(/(^|[^\[])\^/g,&quot;$1&quot;),e=e.replace(r,i),n):new RegExp(e,t)
}}function f(){}function l(e){var t=1,n,r;for(;t&lt;arguments.length;t++){n=arguments
[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r])}return e}function c
(e,n,r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.<span class="apidocCodeKeywordSpan">lex</span>(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.prototype.token" id="apidoc.elem.utility2.marked.Lexer.prototype.token">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>token
        <span class="apidocSignatureSpan">(t, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(t, n, r){var t=t.replace(/^ +$/gm
,&quot;&quot;),i,s,o,u,a,f,l,c,h;while(t){if(o=this.rules.newline.exec(t))t=t.substring(o[0
].length),o[0].length&gt;1&amp;&amp;this.tokens.push({type:&quot;space&quot;});if(o=this.rules.code.exec
(t)){t=t.substring(o[0].length),o=o[0].replace(/^ {4}/gm,&quot;&quot;),this.tokens.push({type
:&quot;code&quot;,text:this.options.pedantic?o:o.replace(/\n+$/,&quot;&quot;)});continue}if(o=this.rules
.fences.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:&quot;code&quot;,lang:o
[2],text:o[3]||&quot;&quot;});continue}if(o=this.rules.heading.exec(t)){t=t.substring(o[0]
.length),this.tokens.push({type:&quot;heading&quot;,depth:o[1].length,text:o[2]});continue}
if(n&amp;&amp;(o=this.rules.nptable.exec(t))){t=t.substring(o[0].length),f={type:&quot;table&quot;
,header:o[1].replace(/^ *| *\| *$/g,&quot;&quot;).split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,&quot;&quot;).split(/ *\| */),cells:o[3].replace(/\n$/,&quot;&quot;).split(&quot;\n&quot;)};for(c=0;c&lt;f.align
.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]=&quot;right&quot;:/^ *:-+: *$/.test(f.
align[c])?f.align[c]=&quot;center&quot;:/^ *:-+ *$/.test(f.align[c])?f.align[c]=&quot;left&quot;:f.align
[c]=null;for(c=0;c&lt;f.cells.length;c++)f.cells[c]=f.cells[c].split(/ *\| */);this
.tokens.push(f);continue}if(o=this.rules.lheading.exec(t)){t=t.substring(o[0].length
),this.tokens.push({type:&quot;heading&quot;,depth:o[2]===&quot;=&quot;?1:2,text:o[1]});continue}if(
o=this.rules.hr.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:&quot;hr&quot;}
);continue}if(o=this.rules.blockquote.exec(t)){t=t.substring(o[0].length),this.tokens
.push({type:&quot;blockquote_start&quot;}),o=o[0].replace(/^ *&gt; ?/gm,&quot;&quot;),this.token(o,n,!0
),this.tokens.push({type:&quot;blockquote_end&quot;});continue}if(o=this.rules.list.exec(t
)){t=t.substring(o[0].length),u=o[2],this.tokens.push({type:&quot;list_start&quot;,ordered
:u.length&gt;1}),o=o[0].match(this.rules.item),i=!1,h=o.length,c=0;for(;c&lt;h;c++)f=o
[c],l=f.length,f=f.replace(/^ *([*+-]|\d+\.) +/,&quot;&quot;),~f.indexOf(&quot;\n &quot;)&amp;&amp;(l-=f.length
,f=this.options.pedantic?f.replace(/^ {1,4}/gm,&quot;&quot;):f.replace(new RegExp(&quot;^ {1,&quot;+
l+&quot;}&quot;,&quot;gm&quot;),&quot;&quot;)),this.options.smartLists&amp;&amp;c!==h-1&amp;&amp;(a=e.bullet.exec(o[c+1])[0],u!==
a&amp;&amp;!(u.length&gt;1&amp;&amp;a.length&gt;1)&amp;&amp;(t=o.slice(c+1).join(&quot;\n&quot;)+t,c=h-1)),s=i||/\n\n(?!\s*$)/
.test(f),c!==h-1&amp;&amp;(i=f.charAt(f.length-1)===&quot;\n&quot;,s||(s=i)),this.tokens.push({type
:s?&quot;loose_item_start&quot;:&quot;list_item_start&quot;}),this.token(f,!1,r),this.tokens.push({type
:&quot;list_item_end&quot;});this.tokens.push({type:&quot;list_end&quot;});continue}if(o=this.rules.
html.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:this.options.sanitize?&quot;paragraph&quot;
:&quot;html&quot;,pre:!this.options.sanitizer&amp;&amp;(o[1]===&quot;pre&quot;||o[1]===&quot;script&quot;||o[1]===&quot;style&quot;
),text:o[0]});continue}if(!r&amp;&amp;n&amp;&amp;(o=this.rules.def.exec(t))){t=t.substring(o[0].
length),this.tokens.links[o[1].toLowerCase()]={href:o[2],title:o[3]};continue}if(
n&amp;&amp;(o=this.rules.table.exec(t))){t=t.substring(o[0].length),f={type:&quot;table&quot;,header
:o[1].replace(/^ *| *\| *$/g,&quot;&quot;).split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,&quot;&quot;).split(/ *\| */),cells:o[3].replace(/(?: *\| *)?\n$/,&quot;&quot;).split(&quot;\n&quot;)};for(c=0
;c&lt;f.align.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]=&quot;right&quot;:/^ *:-+: *$/
.test(f.align[c])?f.align[c]=&quot;center&quot;:/^ *:-+ *$/.test(f.align[c])?f.align[c]=&quot;left&quot;
:f.align[c]=null;for(c=0;c&lt;f.cells.length;c++)f.cells[c]=f.cells[c].replace(/^ *\| *| *\| *$/g
,&quot;&quot;).split(/ *\| */);this.tokens.push(f);continue}if(n&amp;&amp;(o=this.rules.paragraph.
exec(t))){t=t.substring(o[0].length),this.tokens.push({type:&quot;paragraph&quot;,text:o[1
].charAt(o[1].length-1)===&quot;\n&quot;?o[1].slice(0,-1):o[1]});c...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        throw new SyntaxError(&quot;@import not allowed here.&quot;, token.startLine, token.startCol);
                    case Tokens.NAMESPACE_SYM:
                        token = tokenStream.LT(1);
                        this._namespace(false);
                        throw new SyntaxError(&quot;@namespace not allowed here.&quot;, token.startLine, token.startCol);
                    default:
                        tokenStream.get();  //get the last token
                        this._unexpectedToken(tokenStream.<span class="apidocCodeKeywordSpan">token</span>());
                }
            }
    }
} catch (ex) {
    if (ex instanceof SyntaxError &amp;&amp; !this.options.strict) {
        this.fire({
            type:       &quot;error&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Parser" id="apidoc.module.utility2.marked.Parser">module utility2.marked.Parser</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.Parser" id="apidoc.elem.utility2.marked.Parser.Parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.parse" id="apidoc.elem.utility2.marked.Parser.parse">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.</span>parse
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=new s(t,n);return r.parse
(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.<span class="apidocCodeKeywordSpan">parse</span>(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
        }, console.error);
    }
});
Object.keys(opt.packageJson).forEach(function (key) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Parser.prototype" id="apidoc.module.utility2.marked.Parser.prototype">module utility2.marked.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.next" id="apidoc.elem.utility2.marked.Parser.prototype.next">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.token=this.tokens.pop()}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.parse" id="apidoc.elem.utility2.marked.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.<span class="apidocCodeKeywordSpan">parse</span>(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
        }, console.error);
    }
});
Object.keys(opt.packageJson).forEach(function (key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.parseText" id="apidoc.elem.utility2.marked.Parser.prototype.parseText">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parseText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.<span class="apidocCodeKeywordSpan">parseText</span>():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot
;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.peek" id="apidoc.elem.utility2.marked.Parser.prototype.peek">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>peek
        <span class="apidocSignatureSpan">( )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( ){return this.tokens[this.tokens.length-1]||0}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.<span class="apidocCodeKeywordSpan">peek</span>() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.tok" id="apidoc.elem.utility2.marked.Parser.prototype.tok">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>tok
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
e,t,n){if(this.options.sanitize){try{var r=decodeURIComponent(u(e)).replace(/[^\w:]/g
,&quot;&quot;).toLowerCase()}catch(i){return&quot;&quot;}if(r.indexOf(&quot;javascript:&quot;)===0||r.indexOf(&quot;vbscript:&quot
;
)===0||r.indexOf(&quot;data:&quot;)===0)return&quot;&quot;}var s=&apos;&lt;a href=&quot;&apos;+e+&apos;&quot;&apos;;return t&amp
;&amp;(s+=&apos; title=&quot;&apos;+
t+&apos;&quot;&apos;),s+=&quot;&gt;&quot;+n+&quot;&lt;/a&gt;&quot;,s},i.prototype.image=function(e,t,n){var r=&apos;&lt;img src=&
quot;&apos;+e+&apos;&quot; alt=&quot;&apos;+
n+&apos;&quot;&apos;;return t&amp;&amp;(r+=&apos; title=&quot;&apos;+t+&apos;&quot;&apos;),r+=this.options.xhtml?&quot;/&gt;&quot
;:&quot;&gt;&quot;,r},i.prototype
.text=function(e){return e},s.parse=function(e,t,n){var r=new s(t,n);return r.parse
(e)},s.prototype.parse=function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.<span class="apidocCodeKeywordSpan">tok</span>();return t
},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Renderer" id="apidoc.module.utility2.marked.Renderer">module utility2.marked.Renderer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.Renderer" id="apidoc.elem.utility2.marked.Renderer.Renderer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Renderer.prototype" id="apidoc.module.utility2.marked.Renderer.prototype">module utility2.marked.Renderer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.blockquote" id="apidoc.elem.utility2.marked.Renderer.prototype.blockquote">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>blockquote
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;blockquote&gt;\n&quot;+e+&quot;&lt;/blockquote&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.<span class="apidocCodeKeywordSpan">blockquote</span>(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while
(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.br" id="apidoc.elem.utility2.marked.Renderer.prototype.br">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>br
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.options.xhtml?&quot;&lt;br/&gt;&quot;:&quot;&lt;br&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">br</span>();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.code" id="apidoc.elem.utility2.marked.Renderer.prototype.code">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>code
        <span class="apidocSignatureSpan">( e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e, t, n){if(this.options.highlight){var r=this.options.highlight(e,t);r!=null&amp;&amp;r!==
e&amp;&amp;(n=!0,e=r)}return t?&apos;&lt;pre&gt;&lt;code class=&quot;&apos;+this.options.langPrefix+o(t,!0)+&apos;&quot;&gt;&apos;+
(n?e:o(e,!0))+&quot;\n&lt;/code&gt;&lt;/pre&gt;\n&quot;:&quot;&lt;pre&gt;&lt;code&gt;&quot;+(n?e:o(e,!0))+&quot;\n&lt;/code&gt;&lt;/pre&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.<span class="apidocCodeKeywordSpan">code</span>(this.token.text,this.token.lang,this.token.escaped);case&quot
;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.codespan" id="apidoc.elem.utility2.marked.Renderer.prototype.codespan">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>codespan
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;code&gt;&quot;+
e+&quot;&lt;/code&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">codespan</span>(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.del" id="apidoc.elem.utility2.marked.Renderer.prototype.del">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>del
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;del&gt;&quot;+e+&quot;&lt;/del&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">del</span>(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.em" id="apidoc.elem.utility2.marked.Renderer.prototype.em">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>em
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;em&gt;&quot;+e+&quot;&lt;/em&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">em</span>(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.heading" id="apidoc.elem.utility2.marked.Renderer.prototype.heading">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>heading
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){return&quot;&lt;h&quot;+
t+&apos; id=&quot;&apos;+this.options.headerPrefix+n.toLowerCase().replace(/[^\w]+/g,&quot;-&quot;)+&apos;&quot;&gt;&apos;+
e+&quot;&lt;/h&quot;+t+&quot;&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.hr" id="apidoc.elem.utility2.marked.Renderer.prototype.hr">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>hr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.options.xhtml?&quot;&lt;hr/&gt;\n&quot;:&quot;&lt;hr&gt;\n&quot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.text=function(e){return e},s.parse=function(e,t,n){var r=new s(t,n);return r.parse
(e)},s.prototype.parse=function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.<span class="apidocCodeKeywordSpan">hr</span>();case&quot;heading&quot
;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.html" id="apidoc.elem.utility2.marked.Renderer.prototype.html">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>html
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.<span class="apidocCodeKeywordSpan">html</span>(a);case&quot;paragraph
&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
langPrefix:&quot;lang-&quot;,smartypants:!1,headerPrefix:&quot;&quot;,renderer:new i,xhtml:!1},c.Parser=
s,c.parser=s.parse,c.Renderer=i,c.Lexer=t,c.lexer=t.lex,c.InlineLexer=r,c.inlineLexer=
r.output,c.parse=c,typeof module!=&quot;undefined&quot;&amp;&amp;typeof exports==&quot;object&quot;?module.exports=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.image" id="apidoc.elem.utility2.marked.Renderer.prototype.image">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>image
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=&apos;&lt;img src=&quot;&apos;+e+&apos;&quot; alt=&quot;&apos;+
n+&apos;&quot;&apos;;return t&amp;&amp;(r+=&apos; title=&quot;&apos;+t+&apos;&quot;&apos;),r+=this.options.xhtml?&quot;/&gt;&quot;:&quot;&gt;&quot;,r}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.<span class="apidocCodeKeywordSpan">image</span>(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
mangle)return e;var t=&quot;&quot;,n=e.length,r=0,i;for(;r&lt;n;r++)i=e.charCodeAt(r),Math.random
()&gt;.5&amp;&amp;(i=&quot;x&quot;+i.toString(16)),t+=&quot;&amp;#&quot;+i+&quot;;&quot;;return t},i.prototype.code=function(
e,t,n){if(this.options.highlight){var r=this.options.highlight(e,t);r!=null&amp;&amp;r!==
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.link" id="apidoc.elem.utility2.marked.Renderer.prototype.link">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>link
        <span class="apidocSignatureSpan">( e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e, t, n){if(this.options.sanitize){try{var r=decodeURIComponent(u(e)).replace(/[^\w:]/g
,&quot;&quot;).toLowerCase()}catch(i){return&quot;&quot;}if(r.indexOf(&quot;javascript:&quot;)===0||r.indexOf(&quot;vbscript:&quot;
)===0||r.indexOf(&quot;data:&quot;)===0)return&quot;&quot;}var s=&apos;&lt;a href=&quot;&apos;+e+&apos;&quot;&apos;;return t&amp;&amp;(s+=&apos; title=&quot;&apos;+
t+&apos;&quot;&apos;),s+=&quot;&gt;&quot;+n+&quot;&lt;/a&gt;&quot;,s}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.output(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.<span class="apidocCodeKeywordSpan">link</span
>(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.list" id="apidoc.elem.utility2.marked.Renderer.prototype.list">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>list
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=t?&quot;ol&quot;:&quot;ul&quot;;return&quot;&lt;&quot;+n+&quot;&gt;\n&quot;+e+&quot;&lt;/&quot;+n+&quot;&gt;\n&quot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.<span class="apidocCodeKeywordSpan">list</span>(t,u);case&quot;list_item_start
&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.listitem" id="apidoc.elem.utility2.marked.Renderer.prototype.listitem">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>listitem
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;li&gt;&quot;+e+&quot;&lt;/li&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.<span class="apidocCodeKeywordSpan">listitem</span>(t);case&quot;loose_item_start&quot
;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.paragraph" id="apidoc.elem.utility2.marked.Renderer.prototype.paragraph">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>paragraph
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;p&gt;&quot;+e+&quot;&lt;/p&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.<span class="apidocCodeKeywordSpan">paragraph</span>(this.inline.output(this.token.text));case&quot;text&quot
;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
langPrefix:&quot;lang-&quot;,smartypants:!1,headerPrefix:&quot;&quot;,renderer:new i,xhtml:!1},c.Parser=
s,c.parser=s.parse,c.Renderer=i,c.Lexer=t,c.lexer=t.lex,c.InlineLexer=r,c.inlineLexer=
r.output,c.parse=c,typeof module!=&quot;undefined&quot;&amp;&amp;typeof exports==&quot;object&quot;?module.exports=
c:typeof define==&quot;function&quot;&amp;&amp;define.amd?define(function(){return c}):this.marked=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.strong" id="apidoc.elem.utility2.marked.Renderer.prototype.strong">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>strong
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;strong&gt;&quot;+e+&quot;&lt;/strong&gt;&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">strong</span>(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.table" id="apidoc.elem.utility2.marked.Renderer.prototype.table">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>table
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){return&quot;&lt;table&gt;\n&lt;thead&gt;\n&quot;+
e+&quot;&lt;/thead&gt;\n&quot;+&quot;&lt;tbody&gt;\n&quot;+t+&quot;&lt;/tbody&gt;\n&quot;+&quot;&lt;/table&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.<span class="apidocCodeKeywordSpan">table</span>(e,t);case&quot;blockquote_start
&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.tablecell" id="apidoc.elem.utility2.marked.Renderer.prototype.tablecell">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablecell
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=t.header?&quot;th&quot;
:&quot;td&quot;,r=t.align?&quot;&lt;&quot;+n+&apos; style=&quot;text-align:&apos;+t.align+&apos;&quot;&gt;&apos;:&quot;&lt;&quot;+n+&quot;&gt;&quot;;return r+e+&quot;&lt;/&quot;+
n+&quot;&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.<span class="apidocCodeKeywordSpan">tablecell</span>(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.tablerow" id="apidoc.elem.utility2.marked.Renderer.prototype.tablerow">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablerow
        <span class="apidocSignatureSpan">( e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e){return&quot;&lt;tr&gt;\n&quot;+e+&quot;&lt;/tr&gt;\n&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.<span class="apidocCodeKeywordSpan">tablerow</span>(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.text" id="apidoc.elem.utility2.marked.Renderer.prototype.text">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>text
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">text</span>(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.puppeteer" id="apidoc.module.utility2.puppeteer">module utility2.puppeteer</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.assert" id="apidoc.elem.utility2.puppeteer.assert">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.assertOrThrow" id="apidoc.elem.utility2.puppeteer.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.cliRun" id="apidoc.elem.utility2.puppeteer.cliRun">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.coalesce" id="apidoc.elem.utility2.puppeteer.coalesce">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.events" id="apidoc.elem.utility2.puppeteer.events">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.fsRmrfSync" id="apidoc.elem.utility2.puppeteer.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.functionOrNop" id="apidoc.elem.utility2.puppeteer.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.identity" id="apidoc.elem.utility2.puppeteer.identity">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.nop" id="apidoc.elem.utility2.puppeteer.nop">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.objectAssignDefault" id="apidoc.elem.utility2.puppeteer.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerLaunch" id="apidoc.elem.utility2.puppeteer.puppeteerLaunch">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerLaunch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppeteerLaunch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init timerTimeout
timerTimeout = local.onTimeout(
    opt.gotoNext,
    local.timeoutDefault,
    testName
);
// create puppeteer browser
local.<span class="apidocCodeKeywordSpan">puppeteerLaunch</span>({
    args: [
        &quot;--headless&quot;,
        &quot;--incognito&quot;,
        &quot;--no-sandbox&quot;,
        &quot;--remote-debugging-port=0&quot;
    ],
    dumpio: !opt.modeSilent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.querySelector" id="apidoc.elem.utility2.puppeteer.querySelector">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.querySelectorAll" id="apidoc.elem.utility2.puppeteer.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.stream" id="apidoc.elem.utility2.puppeteer.stream">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.puppeteer.puppeteerApi" id="apidoc.module.utility2.puppeteer.puppeteerApi">module utility2.puppeteer.puppeteerApi</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Accessibility
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Accessibility {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
  }

  /**
   * @param {{interestingOnly?: boolean, root?: ?Puppeteer.ElementHandle}=} options
   * @return {!Promise&lt;!SerializedAXNode&gt;}
   */
  async snapshot(options = {}) {
    const {
      interestingOnly = true,
      root = null,
    } = options;
    const {nodes} = await this._client.send(&apos;Accessibility.getFullAXTree&apos;);
    let backendNodeId = null;
    if (root) {
      const {node} = await this._client.send(&apos;DOM.describeNode&apos;, {objectId: root._remoteObject.objectId});
      backendNodeId = node.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find(node =&gt; node._payload.backendDOMNodeId === backendNodeId);
      if (!needle)
        return null;
    }
    if (!interestingOnly)
      return serializeTree(needle)[0];

    /** @type {!Set&lt;!AXNode&gt;} */
    const interestingNodes = new Set();
    collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle))
      return null;
    return serializeTree(needle, interestingNodes)[0];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Browser" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Browser">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Browser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Browser extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Array&lt;string&gt;} contextIds
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {?Puppeteer.ChildProcess} process
   * @param {function()=} closeCallback
   */
</span>  static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
    const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);
    await connection.send(&apos;Target.setDiscoverTargets&apos;, {discover: true});
    return browser;
  }

  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Array&lt;string&gt;} contextIds
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {?Puppeteer.ChildProcess} process
   * @param {(function():Promise)=} closeCallback
   */
  constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
    super();
    this._ignoreHTTPSErrors = ignoreHTTPSErrors;
    this._defaultViewport = defaultViewport;
    this._process = process;
    this._screenshotTaskQueue = new TaskQueue();
    this._connection = connection;
    this._closeCallback = closeCallback || new Function();

    this._defaultContext = new BrowserContext(this._connection, this, null);
    /** @type {Map&lt;string, BrowserContext&gt;} */
    this._contexts = new Map();
    for (const contextId of contextIds)
      this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));

    /** @type {Map&lt;string, Target&gt;} */
    this._targets = new Map();
    this._connection.on(Events.Connection.Disconnected, () =&gt; this.emit(Events.Browser.Disconnected));
    this._connection.on(&apos;Target.targetCreated&apos;, this._targetCreated.bind(this));
    this._connection.on(&apos;Target.targetDestroyed&apos;, this._targetDestroyed.bind(this));
    this._connection.on(&apos;Target.targetInfoChanged&apos;, this._targetInfoChanged.bind(this));
  }

  /**
   * @return {?Puppeteer.ChildProcess}
   */
  process() {
    return this._process;
  }

  /**
   * @return {!Promise&lt;!BrowserContext&gt;}
   */
  async createIncognitoBrowserContext() {
    const {browserContextId} = await this._connection.send(&apos;Target.createBrowserContext&apos;);
    const context = new BrowserContext(this._connection, this, browserContextId);
    this._contexts.set(browserContextId, context);
    return context;
  }

  /**
   * @return {!Array&lt;!BrowserContext&gt;}
   */
  browserContexts() {
    return [this._defaultContext, ...Array.from(this._contexts.values())];
  }

  /**
   * @return {!BrowserContext}
   */
  defaultBrowserContext() {
    return this._defaultContext;
  }

  /**
   * @param {?string} contextId
   */
  async _disposeContext(contextId) {
    await this._connection.send(&apos;Target.disposeBrowserContext&apos;, {browserContextId: contextId || undefined});
    this._contexts.delete(contextId);
  }

  /**
   * @param {!Protocol.Target.targetCreatedPayload} event
   */
  async _targetCreated(event) {
    const targetInfo = event.targetInfo;
    const {browserContextId} = targetInfo;
    const context = (browserContextId &amp;&amp; this._contexts.has(browserContextId)) ? this._contexts.get(browserContextId) : this._defaultContext
;

    const target = new Target(targetInfo, context, () =&gt; this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this
._defaultViewport, this._screenshotTaskQueue);
    assert(!this._targets.has(event.targetInfo.targetId), &apos;Target should not exist before targetCreated&apos;);
    this._targets.set(event.targetInfo.targetId, target);

    if (await target._initializedPromise) {
      this.emit(Events.Browser.TargetCreated, target);
      context.emit(Events.BrowserContext.TargetCreated, target);
    }
  }

  /**
   * @param {{targetId: string}} event
   */
  async _targetDestroyed(event) {
    const target = this._targets.get(e...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext" id="apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserContext
        <span class="apidocSignatureSpan">(connection, browser, contextId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BrowserContext extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Browser} browser
   * @param {?string} contextId
   */
</span>  constructor(connection, browser, contextId) {
    super();
    this._connection = connection;
    this._browser = browser;
    this._id = contextId;
  }

  /**
   * @return {!Array&lt;!Target&gt;} target
   */
  targets() {
    return this._browser.targets().filter(target =&gt; target.browserContext() === this);
  }

  /**
   * @param {function(!Target):boolean} predicate
   * @param {{timeout?: number}=} options
   * @return {!Promise&lt;!Target&gt;}
   */
  waitForTarget(predicate, options) {
    return this._browser.waitForTarget(target =&gt; target.browserContext() === this &amp;&amp; predicate(target), options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!Puppeteer.Page&gt;&gt;}
   */
  async pages() {
    const pages = await Promise.all(
        this.targets()
            .filter(target =&gt; target.type() === &apos;page&apos;)
            .map(target =&gt; target.page())
    );
    return pages.filter(page =&gt; !!page);
  }

  /**
   * @return {boolean}
   */
  isIncognito() {
    return !!this._id;
  }

  /**
   * @param {string} origin
   * @param {!Array&lt;string&gt;} permissions
   */
  async overridePermissions(origin, permissions) {
    const webPermissionToProtocol = new Map([
      [&apos;geolocation&apos;, &apos;geolocation&apos;],
      [&apos;midi&apos;, &apos;midi&apos;],
      [&apos;notifications&apos;, &apos;notifications&apos;],
      [&apos;push&apos;, &apos;push&apos;],
      [&apos;camera&apos;, &apos;videoCapture&apos;],
      [&apos;microphone&apos;, &apos;audioCapture&apos;],
      [&apos;background-sync&apos;, &apos;backgroundSync&apos;],
      [&apos;ambient-light-sensor&apos;, &apos;sensors&apos;],
      [&apos;accelerometer&apos;, &apos;sensors&apos;],
      [&apos;gyroscope&apos;, &apos;sensors&apos;],
      [&apos;magnetometer&apos;, &apos;sensors&apos;],
      [&apos;accessibility-events&apos;, &apos;accessibilityEvents&apos;],
      [&apos;clipboard-read&apos;, &apos;clipboardRead&apos;],
      [&apos;clipboard-write&apos;, &apos;clipboardWrite&apos;],
      [&apos;payment-handler&apos;, &apos;paymentHandler&apos;],
      // chrome-specific permissions we have.
      [&apos;midi-sysex&apos;, &apos;midiSysex&apos;],
    ]);
    permissions = permissions.map(permission =&gt; {
      const protocolPermission = webPermissionToProtocol.get(permission);
      if (!protocolPermission)
        throw new Error(&apos;Unknown permission: &apos; + permission);
      return protocolPermission;
    });
    await this._connection.send(&apos;Browser.grantPermissions&apos;, {origin, browserContextId: this._id || undefined, permissions});
  }

  async clearPermissionOverrides() {
    await this._connection.send(&apos;Browser.resetPermissions&apos;, {browserContextId: this._id || undefined});
  }

  /**
   * @return {!Promise&lt;!Puppeteer.Page&gt;}
   */
  newPage() {
    return this._browser._createPageInContext(this._id);
  }

  /**
   * @return {!Browser}
   */
  browser() {
    return this._browser;
  }

  async close() {
    assert(this._id, &apos;Non-incognito profiles cannot be closed!&apos;);
    await this._browser._disposeContext(this._id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession" id="apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>CDPSession
        <span class="apidocSignatureSpan">(connection, targetType, sessionId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CDPSession extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Connection} connection
   * @param {string} targetType
   * @param {string} sessionId
   */
</span>  constructor(connection, targetType, sessionId) {
    super();
    /** @type {!Map&lt;number, {resolve: function, reject: function, error: !Error, method: string}&gt;}*/
    this._callbacks = new Map();
    this._connection = connection;
    this._targetType = targetType;
    this._sessionId = sessionId;
  }

  /**
   * @param {string} method
   * @param {!Object=} params
   * @return {!Promise&lt;?Object&gt;}
   */
  send(method, params = {}) {
    if (!this._connection)
      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been
closed.`));
    const id = this._connection._rawSend({sessionId: this._sessionId, method, params});
    return new Promise((resolve, reject) =&gt; {
      this._callbacks.set(id, {resolve, reject, error: new Error(), method});
    });
  }

  /**
   * @param {{id?: number, method: string, params: Object, error: {message: string, data: any}, result?: *}} object
   */
  _onMessage(object) {
    if (object.id &amp;&amp; this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error)
        callback.reject(createProtocolError(callback.error, callback.method, object));
      else
        callback.resolve(object.result);
    } else {
      assert(!object.id);
      this.emit(object.method, object.params);
    }
  }

  async detach() {
    if (!this._connection)
      throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
    await this._connection.send(&apos;Target.detachFromTarget&apos;,  {sessionId: this._sessionId});
  }

  _onClosed() {
    for (const callback of this._callbacks.values())
      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
    this._callbacks.clear();
    this._connection = null;
    this.emit(Events.CDPSession.Disconnected);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ConsoleMessage
        <span class="apidocSignatureSpan">(type, text, args, location = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ConsoleMessage {
<span class="apidocCodeCommentSpan">  /**
   * @param {string} type
   * @param {string} text
   * @param {!Array&lt;!Puppeteer.JSHandle&gt;} args
   * @param {ConsoleMessage.Location} location
   */
</span>  constructor(type, text, args, location = {}) {
    this._type = type;
    this._text = text;
    this._args = args;
    this._location = location;
  }

  /**
   * @return {string}
   */
  type() {
    return this._type;
  }

  /**
   * @return {string}
   */
  text() {
    return this._text;
  }

  /**
   * @return {!Array&lt;!Puppeteer.JSHandle&gt;}
   */
  args() {
    return this._args;
  }

  /**
   * @return {Object}
   */
  location() {
    return this._location;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Coverage
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Coverage {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._jsCoverage = new JSCoverage(client);
    this._cssCoverage = new CSSCoverage(client);
  }

  /**
   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options
   */
  async startJSCoverage(options) {
    return await this._jsCoverage.start(options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!CoverageEntry&gt;&gt;}
   */
  async stopJSCoverage() {
    return await this._jsCoverage.stop();
  }

  /**
   * @param {{resetOnNavigation?: boolean}=} options
   */
  async startCSSCoverage(options) {
    return await this._cssCoverage.start(options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!CoverageEntry&gt;&gt;}
   */
  async stopCSSCoverage() {
    return await this._cssCoverage.stop();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Dialog
        <span class="apidocSignatureSpan">(string|undefined)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dialog {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {string} type
   * @param {string} message
   * @param {(string|undefined)} defaultValue
   */
</span>  constructor(client, type, message, defaultValue = &apos;&apos;) {
    this._client = client;
    this._type = type;
    this._message = message;
    this._handled = false;
    this._defaultValue = defaultValue;
  }

  /**
   * @return {string}
   */
  type() {
    return this._type;
  }

  /**
   * @return {string}
   */
  message() {
    return this._message;
  }

  /**
   * @return {string}
   */
  defaultValue() {
    return this._defaultValue;
  }

  /**
   * @param {string=} promptText
   */
  async accept(promptText) {
    assert(!this._handled, &apos;Cannot accept dialog which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleJavaScriptDialog&apos;, {
      accept: true,
      promptText: promptText
    });
  }

  async dismiss() {
    assert(!this._handled, &apos;Cannot dismiss dialog which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleJavaScriptDialog&apos;, {
      accept: false
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ElementHandle
        <span class="apidocSignatureSpan">(context, client, remoteObject, page, frameManager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ElementHandle extends JSHandle {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.ExecutionContext} context
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.RemoteObject} remoteObject
   * @param {!Puppeteer.Page} page
   * @param {!Puppeteer.FrameManager} frameManager
   */
</span>  constructor(context, client, remoteObject, page, frameManager) {
    super(context, client, remoteObject);
    this._client = client;
    this._remoteObject = remoteObject;
    this._page = page;
    this._frameManager = frameManager;
    this._disposed = false;
  }

  /**
   * @override
   * @return {?ElementHandle}
   */
  asElement() {
    return this;
  }

  /**
   * @return {!Promise&lt;?Puppeteer.Frame&gt;}
   */
  async contentFrame() {
    const nodeInfo = await this._client.send(&apos;DOM.describeNode&apos;, {
      objectId: this._remoteObject.objectId
    });
    if (typeof nodeInfo.node.frameId !== &apos;string&apos;)
      return null;
    return this._frameManager.frame(nodeInfo.node.frameId);
  }

  async _scrollIntoViewIfNeeded() {
    const error = await this.executionContext().evaluate(async(element, pageJavascriptEnabled) =&gt; {
      if (!element.isConnected)
        return &apos;Node is detached from document&apos;;
      if (element.nodeType !== Node.ELEMENT_NODE)
        return &apos;Node is not of type HTMLElement&apos;;
      // force-scroll if page&apos;s javascript is disabled.
      if (!pageJavascriptEnabled) {
        element.scrollIntoView({block: &apos;center&apos;, inline: &apos;center&apos;, behavior: &apos;instant&apos;});
        return false;
      }
      const visibleRatio = await new Promise(resolve =&gt; {
        const observer = new IntersectionObserver(entries =&gt; {
          resolve(entries[0].intersectionRatio);
          observer.disconnect();
        });
        observer.observe(element);
      });
      if (visibleRatio !== 1.0)
        element.scrollIntoView({block: &apos;center&apos;, inline: &apos;center&apos;, behavior: &apos;instant&apos;});
      return false;
    }, this, this._page._javascriptEnabled);
    if (error)
      throw new Error(error);
  }

  /**
   * @return {!Promise&lt;!{x: number, y: number}&gt;}
   */
  async _clickablePoint() {
    const [result, layoutMetrics] = await Promise.all([
      this._client.send(&apos;DOM.getContentQuads&apos;, {
        objectId: this._remoteObject.objectId
      }).catch(debugError),
      this._client.send(&apos;Page.getLayoutMetrics&apos;),
    ]);
    if (!result || !result.quads.length)
      throw new Error(&apos;Node is either not visible or not an HTMLElement&apos;);
    // Filter out quads that have too small area to click into.
    const {clientWidth, clientHeight} = layoutMetrics.layoutViewport;
    const quads = result.quads.map(quad =&gt; this._fromProtocolQuad(quad)).map(quad =&gt; this._intersectQuadWithViewport(quad, clientWidth
, clientHeight)).filter(quad =&gt; computeQuadArea(quad) &gt; 1);
    if (!quads.length)
      throw new Error(&apos;Node is either not visible or not an HTMLElement&apos;);
    // Return the middle point of the first quad.
    const quad = quads[0];
    let x = 0;
    let y = 0;
    for (const point of quad) {
      x += point.x;
      y += point.y;
    }
    return {
      x: x / 4,
      y: y / 4
    };
  }

  /**
   * @return {!Promise&lt;void|Protocol.DOM.getBoxModelReturnValue&gt;}
   */
  _getBoxModel() {
    return this._client.send(&apos;DOM.getBoxModel&apos;, {
      objectId: this._remoteObject.objectId
    }).catch(error =&gt; debugError(error));
  }

  /**
   * @param {!Array&lt;number&gt;} quad
   * @return {!Array&lt;{x: number, y: number}&gt;}
   */
  _fromProtocolQuad(quad) {
    return [
      {x: quad[0], y: quad[1]},
      {x: quad[2], y: quad[3]},
      {x: quad[4], y: quad[5]},
      {x: quad[6], y: quad[7]}
    ];
  }

  /**
   * @param {!Array&lt;{x: number, y: number}&gt;} quad
   * @param {number} width
   * @param {number} height
   * @return {!Array&lt;{x: number, y: number}&gt;}
   */
  _intersectQuadWithViewport(quad,...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ExecutionContext
        <span class="apidocSignatureSpan">(client, contextPayload, world)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExecutionContext {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.ExecutionContextDescription} contextPayload
   * @param {?Puppeteer.DOMWorld} world
   */
</span>  constructor(client, contextPayload, world) {
    this._client = client;
    this._world = world;
    this._contextId = contextPayload.id;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._world ? this._world.frame() : null;
  }

  /**
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return await this._evaluateInternal(true /* returnByValue */, pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;!JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return this._evaluateInternal(false /* returnByValue */, pageFunction, ...args);
  }

  /**
   * @param {boolean} returnByValue
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;*&gt;}
   */
  async _evaluateInternal(returnByValue, pageFunction, ...args) {
    const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;

    if (helper.isString(pageFunction)) {
      const contextId = this._contextId;
      const expression = /** @type {string} */ (pageFunction);
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + &apos;\n&apos; + suffix;
      const {exceptionDetails, result: remoteObject} = await this._client.send(&apos;Runtime.evaluate&apos;, {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError);
      if (exceptionDetails)
        throw new Error(&apos;Evaluation failed: &apos; + helper.getExceptionMessage(exceptionDetails));
      return returnByValue ? helper.valueFromRemoteObject(remoteObject) : createJSHandle(this, remoteObject);
    }

    if (typeof pageFunction !== &apos;function&apos;)
      throw new Error(`Expected to get |string| or |function| as the first argument, but got &quot;${pageFunction}&quot; instead.`);

    let functionText = pageFunction.toString();
    // hack-coverage - un-instrument
    functionText = functionText.replace((/\b__cov_.*?\+\+/g), &quot;0&quot;);
    try {
      new Function(&apos;(&apos; + functionText + &apos;)&apos;);
    } catch (e1) {
      // This means we might have a function shorthand. Try another
      // time prefixing &apos;function &apos;.
      if (functionText.startsWith(&apos;async &apos;))
        functionText = &apos;async function &apos; + functionText.substring(&apos;async &apos;.length);
      else
        functionText = &apos;function &apos; + functionText;
      try {
        new Function(&apos;(&apos; + functionText  + &apos;)&apos;);
      } catch (e2) {
        // We tried hard to serialize, but there&apos;s a weird beast here.
        throw new Error(&apos;Passed function is not well-serializable!&apos;);
      }
    }
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = this._client.send(&apos;Runtime.callFunctionOn&apos;, {
        functionDeclaration: functionText + &apos;\n&apos; + suffix + &apos;\n&apos;,
        executionContextId: this._contextId,
        arguments: args.map(convertArgument.bind(this)),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (err) {
      if (err instanceof TypeError &amp;&amp; err.message.startsWith(&apos;Converting circular structure to JSON&apos;))
        err.message += &apos; Are you passing a nested JSHandle?&apos;;
      throw err;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
    if (exceptionDetails)
      throw new Error(&apos;Evaluation failed: &apos; + helper.getExceptionMessage(exceptionDetails));
    return returnByValue ? helper.valueFromRemoteObject(remoteObject) : crea...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser" id="apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>FileChooser
        <span class="apidocSignatureSpan">(client, event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FileChooser {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {!Protocol.Page.fileChooserOpenedPayload} event
   */
</span>  constructor(client, event) {
    this._client = client;
    this._multiple = event.mode !== &apos;selectSingle&apos;;
    this._handled = false;
  }

  /**
   * @return {boolean}
   */
  isMultiple() {
    return this._multiple;
  }

  /**
   * @param {!Array&lt;string&gt;} filePaths
   * @return {!Promise}
   */
  async accept(filePaths) {
    assert(!this._handled, &apos;Cannot accept FileChooser which is already handled!&apos;);
    this._handled = true;
    const files = filePaths.map(filePath =&gt; path.resolve(filePath));
    await this._client.send(&apos;Page.handleFileChooser&apos;, {
      action: &apos;accept&apos;,
      files,
    });
  }

  /**
   * @return {!Promise}
   */
  async cancel() {
    assert(!this._handled, &apos;Cannot cancel FileChooser which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleFileChooser&apos;, {
      action: &apos;cancel&apos;,
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Frame" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Frame">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Frame
        <span class="apidocSignatureSpan">(frameManager, client, parentFrame, frameId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Frame {
<span class="apidocCodeCommentSpan">  /**
   * @param {!FrameManager} frameManager
   * @param {!Puppeteer.CDPSession} client
   * @param {?Frame} parentFrame
   * @param {string} frameId
   */
</span>  constructor(frameManager, client, parentFrame, frameId) {
    this._frameManager = frameManager;
    this._client = client;
    this._parentFrame = parentFrame;
    this._url = &apos;&apos;;
    this._id = frameId;
    this._detached = false;

    this._loaderId = &apos;&apos;;
    /** @type {!Set&lt;string&gt;} */
    this._lifecycleEvents = new Set();
    /** @type {!DOMWorld} */
    this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
    /** @type {!DOMWorld} */
    this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);

    /** @type {!Set&lt;!Frame&gt;} */
    this._childFrames = new Set();
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
  }

  /**
   * @param {string} url
   * @param {!{referer?: string, timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   * @return {!Promise&lt;?Puppeteer.Response&gt;}
   */
  async goto(url, options) {
    return await this._frameManager.navigateFrame(this, url, options);
  }

  /**
   * @param {!{timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   * @return {!Promise&lt;?Puppeteer.Response&gt;}
   */
  async waitForNavigation(options) {
    return await this._frameManager.waitForFrameNavigation(this, options);
  }

  /**
   * @return {!Promise&lt;!ExecutionContext&gt;}
   */
  executionContext() {
    return this._mainWorld.executionContext();
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;!Puppeteer.JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return this._mainWorld.evaluateHandle(pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return this._mainWorld.evaluate(pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @return {!Promise&lt;?Puppeteer.ElementHandle&gt;}
   */
  async $(selector) {
    return this._mainWorld.$(selector);
  }

  /**
   * @param {string} expression
   * @return {!Promise&lt;!Array&lt;!Puppeteer.ElementHandle&gt;&gt;}
   */
  async $x(expression) {
    return this._mainWorld.$x(expression);
  }

  /**
   * @param {string} selector
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;(!Object|undefined)&gt;}
   */
  async $eval(selector, pageFunction, ...args) {
    return this._mainWorld.$eval(selector, pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;(!Object|undefined)&gt;}
   */
  async $$eval(selector, pageFunction, ...args) {
    return this._mainWorld.$$eval(selector, pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @return {!Promise&lt;!Array&lt;!Puppeteer.ElementHandle&gt;&gt;}
   */
  async $$(selector) {
    return this._mainWorld.$$(selector);
  }

  /**
   * @return {!Promise&lt;String&gt;}
   */
  async content() {
    return this._secondaryWorld.content();
  }

  /**
   * @param {string} html
   * @param {!{timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   */
  async setContent(html, options = {}) {
    return this._secondaryWorld.setContent(html, options);
  }

  /**
   * @return {string}
   */
  name() {
    return this._name || &apos;&apos;;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {?Frame}
   */
  parentFrame() {
    return this._parentFrame;
  }

  /**
   * @return {!Array.&lt;!Frame&gt;}
   */
  childFrames() {
    return Array.from(this._childFrames);
  }

  /**
   * @return {boolean}
   */
  isDetached() {
    return this._detached;
  }

  /**
   * @param {!{url?: string,...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle" id="apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>JSHandle
        <span class="apidocSignatureSpan">(context, client, remoteObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class JSHandle {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.ExecutionContext} context
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.RemoteObject} remoteObject
   */
</span>  constructor(context, client, remoteObject) {
    this._context = context;
    this._client = client;
    this._remoteObject = remoteObject;
    this._disposed = false;
  }

  /**
   * @return {!Puppeteer.ExecutionContext}
   */
  executionContext() {
    return this._context;
  }

  /**
   * @param {string} propertyName
   * @return {!Promise&lt;?JSHandle&gt;}
   */
  async getProperty(propertyName) {
    const objectHandle = await this._context.evaluateHandle((object, propertyName) =&gt; {
      const result = {__proto__: null};
      result[propertyName] = object[propertyName];
      return result;
    }, this, propertyName);
    const properties = await objectHandle.getProperties();
    const result = properties.get(propertyName) || null;
    await objectHandle.dispose();
    return result;
  }

  /**
   * @return {!Promise&lt;!Map&lt;string, !JSHandle&gt;&gt;}
   */
  async getProperties() {
    const response = await this._client.send(&apos;Runtime.getProperties&apos;, {
      objectId: this._remoteObject.objectId,
      ownProperties: true
    });
    const result = new Map();
    for (const property of response.result) {
      if (!property.enumerable)
        continue;
      result.set(property.name, createJSHandle(this._context, property.value));
    }
    return result;
  }

  /**
   * @return {!Promise&lt;?Object&gt;}
   */
  async jsonValue() {
    if (this._remoteObject.objectId) {
      const response = await this._client.send(&apos;Runtime.callFunctionOn&apos;, {
        functionDeclaration: &apos;function() { return this; }&apos;,
        objectId: this._remoteObject.objectId,
        returnByValue: true,
        awaitPromise: true,
      });
      return helper.valueFromRemoteObject(response.result);
    }
    return helper.valueFromRemoteObject(this._remoteObject);
  }

  /**
   * @return {?Puppeteer.ElementHandle}
   */
  asElement() {
    return null;
  }

  async dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    await helper.releaseObject(this._client, this._remoteObject);
  }

  /**
   * @override
   * @return {string}
   */
  toString() {
    if (this._remoteObject.objectId) {
      const type =  this._remoteObject.subtype || this._remoteObject.type;
      return &apos;JSHandle@&apos; + type;
    }
    return &apos;JSHandle:&apos; + helper.valueFromRemoteObject(this._remoteObject);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Keyboard
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Keyboard {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
    this._modifiers = 0;
    this._pressedKeys = new Set();
  }

  /**
   * @param {string} key
   * @param {{text?: string}=} options
   */
  async down(key, options = { text: undefined }) {
    const description = this._keyDescriptionForString(key);

    const autoRepeat = this._pressedKeys.has(description.code);
    this._pressedKeys.add(description.code);
    this._modifiers |= this._modifierBit(description.key);

    const text = options.text === undefined ? description.text : options.text;
    await this._client.send(&apos;Input.dispatchKeyEvent&apos;, {
      type: text ? &apos;keyDown&apos; : &apos;rawKeyDown&apos;,
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      key: description.key,
      text: text,
      unmodifiedText: text,
      autoRepeat,
      location: description.location,
      isKeypad: description.location === 3
    });
  }

  /**
   * @param {string} key
   * @return {number}
   */
  _modifierBit(key) {
    if (key === &apos;Alt&apos;)
      return 1;
    if (key === &apos;Control&apos;)
      return 2;
    if (key === &apos;Meta&apos;)
      return 4;
    if (key === &apos;Shift&apos;)
      return 8;
    return 0;
  }

  /**
   * @param {string} keyString
   * @return {KeyDescription}
   */
  _keyDescriptionForString(keyString) {
    const shift = this._modifiers &amp; 8;
    const description = {
      key: &apos;&apos;,
      keyCode: 0,
      code: &apos;&apos;,
      text: &apos;&apos;,
      location: 0
    };

    const definition = keyDefinitions[keyString];
    assert(definition, `Unknown key: &quot;${keyString}&quot;`);

    if (definition.key)
      description.key = definition.key;
    if (shift &amp;&amp; definition.shiftKey)
      description.key = definition.shiftKey;

    if (definition.keyCode)
      description.keyCode = definition.keyCode;
    if (shift &amp;&amp; definition.shiftKeyCode)
      description.keyCode = definition.shiftKeyCode;

    if (definition.code)
      description.code = definition.code;

    if (definition.location)
      description.location = definition.location;

    if (description.key.length === 1)
      description.text = description.key;

    if (definition.text)
      description.text = definition.text;
    if (shift &amp;&amp; definition.shiftText)
      description.text = definition.shiftText;

    // if any modifiers besides shift are pressed, no text should be sent
    if (this._modifiers &amp; ~8)
      description.text = &apos;&apos;;

    return description;
  }

  /**
   * @param {string} key
   */
  async up(key) {
    const description = this._keyDescriptionForString(key);

    this._modifiers &amp;= ~this._modifierBit(description.key);
    this._pressedKeys.delete(description.code);
    await this._client.send(&apos;Input.dispatchKeyEvent&apos;, {
      type: &apos;keyUp&apos;,
      modifiers: this._modifiers,
      key: description.key,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      location: description.location
    });
  }

  /**
   * @param {string} char
   */
  async sendCharacter(char) {
    await this._client.send(&apos;Input.insertText&apos;, {text: char});
  }

  /**
   * @param {string} text
   * @param {{delay: (number|undefined)}=} options
   */
  async type(text, options) {
    let delay = 0;
    if (options &amp;&amp; options.delay)
      delay = options.delay;
    for (const char of text) {
      if (keyDefinitions[char])
        await this.press(char, {delay});
      else
        await this.sendCharacter(char);
      if (delay)
        await new Promise(f =&gt; setTimeout(f, delay));
    }
  }

  /**
   * @param {string} key
   * @param {!{delay?: number, text?: string}=} options
   */
  async press(key, options = {}) {
    const {delay = null} = options;
    await this.down(key, options);
    if (delay !== null)
      await new Promise(f =&gt; se...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Mouse
        <span class="apidocSignatureSpan">(client, keyboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Mouse {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {!Keyboard} keyboard
   */
</span>  constructor(client, keyboard) {
    this._client = client;
    this._keyboard = keyboard;
    this._x = 0;
    this._y = 0;
    /** @type {&apos;none&apos;|&apos;left&apos;|&apos;right&apos;|&apos;middle&apos;} */
    this._button = &apos;none&apos;;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {!{steps?: number}=} options
   */
  async move(x, y, options = {}) {
    const {steps = 1} = options;
    const fromX = this._x, fromY = this._y;
    this._x = x;
    this._y = y;
    for (let i = 1; i &lt;= steps; i++) {
      await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
        type: &apos;mouseMoved&apos;,
        button: this._button,
        x: fromX + (this._x - fromX) * (i / steps),
        y: fromY + (this._y - fromY) * (i / steps),
        modifiers: this._keyboard._modifiers
      });
    }
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {!{delay?: number, button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async click(x, y, options = {}) {
    const {delay = null} = options;
    if (delay !== null) {
      await Promise.all([
        this.move(x, y),
        this.down(options),
      ]);
      await new Promise(f =&gt; setTimeout(f, delay));
      await this.up(options);
    } else {
      await Promise.all([
        this.move(x, y),
        this.down(options),
        this.up(options),
      ]);
    }
  }

  /**
   * @param {!{button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async down(options = {}) {
    const {button = &apos;left&apos;, clickCount = 1} = options;
    this._button = button;
    await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
      type: &apos;mousePressed&apos;,
      button,
      x: this._x,
      y: this._y,
      modifiers: this._keyboard._modifiers,
      clickCount
    });
  }

  /**
   * @param {!{button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async up(options = {}) {
    const {button = &apos;left&apos;, clickCount = 1} = options;
    this._button = &apos;none&apos;;
    await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
      type: &apos;mouseReleased&apos;,
      button,
      x: this._x,
      y: this._y,
      modifiers: this._keyboard._modifiers,
      clickCount
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Page" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Page">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Page
        <span class="apidocSignatureSpan">(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Page extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Puppeteer.Target} target
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   * @return {!Promise&lt;!Page&gt;}
   */
</span>  static async create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
    const page = new Page(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
    await page._initialize();
    if (defaultViewport)
      await page.setViewport(defaultViewport);
    return page;
  }

  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Puppeteer.Target} target
   * @param {boolean} ignoreHTTPSErrors
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   */
  constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
    super();
    this._closed = false;
    this._client = client;
    this._target = target;
    this._keyboard = new Keyboard(client);
    this._mouse = new Mouse(client, this._keyboard);
    this._timeoutSettings = new TimeoutSettings();
    this._touchscreen = new Touchscreen(client, this._keyboard);
    this._accessibility = new Accessibility(client);
    /** @type {!FrameManager} */
    this._frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
    this._emulationManager = new EmulationManager(client);
    this._tracing = new Tracing(client);
    /** @type {!Map&lt;string, Function&gt;} */
    this._pageBindings = new Map();
    this._coverage = new Coverage(client);
    this._javascriptEnabled = true;
    /** @type {?Puppeteer.Viewport} */
    this._viewport = null;

    this._screenshotTaskQueue = screenshotTaskQueue;

    /** @type {!Map&lt;string, Worker&gt;} */
    this._workers = new Map();
    client.on(&apos;Target.attachedToTarget&apos;, event =&gt; {
      if (event.targetInfo.type !== &apos;worker&apos;) {
        // If we don&apos;t detach from service workers, they will never die.
        client.send(&apos;Target.detachFromTarget&apos;, {
          sessionId: event.sessionId
        }).catch(debugError);
        return;
      }
      const session = Connection.fromSession(client).session(event.sessionId);
      const worker = new Worker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this
));
      this._workers.set(event.sessionId, worker);
      this.emit(Events.Page.WorkerCreated, worker);
    });
    client.on(&apos;Target.detachedFromTarget&apos;, event =&gt; {
      const worker = this._workers.get(event.sessionId);
      if (!worker)
        return;
      this.emit(Events.Page.WorkerDestroyed, worker);
      this._workers.delete(event.sessionId);
    });

    this._frameManager.on(Events.FrameManager.FrameAttached, event =&gt; this.emit(Events.Page.FrameAttached, event));
    this._frameManager.on(Events.FrameManager.FrameDetached, event =&gt; this.emit(Events.Page.FrameDetached, event));
    this._frameManager.on(Events.FrameManager.FrameNavigated, event =&gt; this.emit(Events.Page.FrameNavigated, event));

    const networkManager = this._frameManager.networkManager();
    networkManager.on(Events.NetworkManager.Request, event =&gt; this.emit(Events.Page.Request, event));
    networkManager.on(Events.NetworkManager.Response, event =&gt; this.emit(Events.Page.Response, event));
    networkManager.on(Events.NetworkManager.RequestFailed, event =&gt; this.emit(Events.Page.RequestFailed, event));
    networkManager.on(Events.NetworkManager.RequestFinished, event =&gt; this.emit(Events.Page.RequestFinished, event));
    this._fileChooserInterceptionIsDisabled = false;
    this._fileChooserInterceptors = new Set();

    client.on(&apos;Page.domContentEventFired&apos;, event =&gt; this.emit(Events.Page.DOMContentLoaded));
    client.on(&apos;Page.loadEventFired&apos;, event =&gt; this.emit(Events.Page.Load));
    client.on(&apos;Runtime.consoleAPICalled&apos;, event =&gt; this._onConsoleAPI(event));
    client.on(&apos...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Puppeteer
        <span class="apidocSignatureSpan">(projectRoot, preferredRevision, isPuppeteerCore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class {
<span class="apidocCodeCommentSpan">  /**
   * @param {string} projectRoot
   * @param {string} preferredRevision
   * @param {boolean} isPuppeteerCore
   */
</span>  constructor(projectRoot, preferredRevision, isPuppeteerCore) {
    this._projectRoot = projectRoot;
    this._launcher = new Launcher(projectRoot, preferredRevision, isPuppeteerCore);
  }

  /**
   * @param {!(Launcher.LaunchOptions &amp; Launcher.ChromeArgOptions &amp; Launcher.BrowserOptions)=} options
   * @return {!Promise&lt;!Puppeteer.Browser&gt;}
   */
  launch(options) {
    return this._launcher.launch(options);
  }

  /**
   * @param {!(Launcher.BrowserOptions &amp; {browserWSEndpoint?: string, browserURL?: string, transport?: !Puppeteer.ConnectionTransport
})} options
   * @return {!Promise&lt;!Puppeteer.Browser&gt;}
   */
  connect(options) {
    return this._launcher.connect(options);
  }

  /**
   * @return {string}
   */
  executablePath() {
    return this._launcher.executablePath();
  }

  /**
   * @return {Object}
   */
  get devices() {
    return DeviceDescriptors;
  }

  /**
   * @return {Object}
   */
  get errors() {
    return Errors;
  }

  /**
   * @param {!Launcher.ChromeArgOptions=} options
   * @return {!Array&lt;string&gt;}
   */
  defaultArgs(options) {
    return this._launcher.defaultArgs(options);
  }

  /**
   * @param {!BrowserFetcher.Options=} options
   * @return {!BrowserFetcher}
   */
  createBrowserFetcher(options) {
    return new BrowserFetcher(this._projectRoot, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Request" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Request">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Request
        <span class="apidocSignatureSpan">(client, frame, interceptionId, allowInterception, event, redirectChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Request {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {?Puppeteer.Frame} frame
   * @param {string} interceptionId
   * @param {boolean} allowInterception
   * @param {!Protocol.Network.requestWillBeSentPayload} event
   * @param {!Array&lt;!Request&gt;} redirectChain
   */
</span>  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
    this._client = client;
    this._requestId = event.requestId;
    this._isNavigationRequest = event.requestId === event.loaderId &amp;&amp; event.type === &apos;Document&apos;;
    this._interceptionId = interceptionId;
    this._allowInterception = allowInterception;
    this._interceptionHandled = false;
    this._response = null;
    this._failureText = null;

    this._url = event.request.url;
    this._resourceType = event.type.toLowerCase();
    this._method = event.request.method;
    this._postData = event.request.postData;
    this._headers = {};
    this._frame = frame;
    this._redirectChain = redirectChain;
    for (const key of Object.keys(event.request.headers))
      this._headers[key.toLowerCase()] = event.request.headers[key];

    this._fromMemoryCache = false;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {string}
   */
  resourceType() {
    return this._resourceType;
  }

  /**
   * @return {string}
   */
  method() {
    return this._method;
  }

  /**
   * @return {string|undefined}
   */
  postData() {
    return this._postData;
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers;
  }

  /**
   * @return {?Response}
   */
  response() {
    return this._response;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._frame;
  }

  /**
   * @return {boolean}
   */
  isNavigationRequest() {
    return this._isNavigationRequest;
  }

  /**
   * @return {!Array&lt;!Request&gt;}
   */
  redirectChain() {
    return this._redirectChain.slice();
  }

  /**
   * @return {?{errorText: string}}
   */
  failure() {
    if (!this._failureText)
      return null;
    return {
      errorText: this._failureText
    };
  }

  /**
   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides
   */
  async continue(overrides = {}) {
    // Request interception is not supported for data: urls.
    if (this._url.startsWith(&apos;data:&apos;))
      return;
    assert(this._allowInterception, &apos;Request Interception is not enabled!&apos;);
    assert(!this._interceptionHandled, &apos;Request is already handled!&apos;);
    const {
      url,
      method,
      postData,
      headers
    } = overrides;
    this._interceptionHandled = true;
    await this._client.send(&apos;Fetch.continueRequest&apos;, {
      requestId: this._interceptionId,
      url,
      method,
      postData,
      headers: headers ? headersArray(headers) : undefined,
    }).catch(error =&gt; {
      // In certain cases, protocol will return error if the request was already canceled
      // or the page was closed. We should tolerate these errors.
      debugError(error);
    });
  }

  /**
   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response
   */
  async respond(response) {
    // Mocking responses for dataURL requests is not currently supported.
    if (this._url.startsWith(&apos;data:&apos;))
      return;
    assert(this._allowInterception, &apos;Request Interception is not enabled!&apos;);
    assert(!this._interceptionHandled, &apos;Request is already handled!&apos;);
    this._interceptionHandled = true;

    const responseBody = response.body &amp;&amp; helper.isString(response.body) ? Buffer.from(/** @type {string} */(response.body)) : /** @
type {?Buffer} */(response.body || null);

    /** @type {!Object&lt;string, string&gt;} */
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers))
        responseHeaders[header.toLowerCase()] = response.headers[header];
    }...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Response" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Response">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Response
        <span class="apidocSignatureSpan">(client, request, responsePayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Response {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Request} request
   * @param {!Protocol.Network.Response} responsePayload
   */
</span>  constructor(client, request, responsePayload) {
    this._client = client;
    this._request = request;
    this._contentPromise = null;

    this._bodyLoadedPromise = new Promise(fulfill =&gt; {
      this._bodyLoadedPromiseFulfill = fulfill;
    });

    this._remoteAddress = {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort,
    };
    this._status = responsePayload.status;
    this._statusText = responsePayload.statusText;
    this._url = request.url();
    this._fromDiskCache = !!responsePayload.fromDiskCache;
    this._fromServiceWorker = !!responsePayload.fromServiceWorker;
    this._headers = {};
    for (const key of Object.keys(responsePayload.headers))
      this._headers[key.toLowerCase()] = responsePayload.headers[key];
    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
  }

  /**
   * @return {{ip: string, port: number}}
   */
  remoteAddress() {
    return this._remoteAddress;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {boolean}
   */
  ok() {
    return this._status === 0 || (this._status &gt;= 200 &amp;&amp; this._status &lt;= 299);
  }

  /**
   * @return {number}
   */
  status() {
    return this._status;
  }

  /**
   * @return {string}
   */
  statusText() {
    return this._statusText;
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers;
  }

  /**
   * @return {?SecurityDetails}
   */
  securityDetails() {
    return this._securityDetails;
  }

  /**
   * @return {!Promise&lt;!Buffer&gt;}
   */
  buffer() {
    if (!this._contentPromise) {
      this._contentPromise = this._bodyLoadedPromise.then(async error =&gt; {
        if (error)
          throw error;
        const response = await this._client.send(&apos;Network.getResponseBody&apos;, {
          requestId: this._request._requestId
        });
        return Buffer.from(response.body, response.base64Encoded ? &apos;base64&apos; : &apos;utf8&apos;);
      });
    }
    return this._contentPromise;
  }

  /**
   * @return {!Promise&lt;string&gt;}
   */
  async text() {
    const content = await this.buffer();
    return content.toString(&apos;utf8&apos;);
  }

  /**
   * @return {!Promise&lt;!Object&gt;}
   */
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }

  /**
   * @return {!Request}
   */
  request() {
    return this._request;
  }

  /**
   * @return {boolean}
   */
  fromCache() {
    return this._fromDiskCache || this._request._fromMemoryCache;
  }

  /**
   * @return {boolean}
   */
  fromServiceWorker() {
    return this._fromServiceWorker;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._request.frame();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails" id="apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>SecurityDetails
        <span class="apidocSignatureSpan">(securityPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SecurityDetails {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Protocol.Network.SecurityDetails} securityPayload
   */
</span>  constructor(securityPayload) {
    this._subjectName = securityPayload[&apos;subjectName&apos;];
    this._issuer = securityPayload[&apos;issuer&apos;];
    this._validFrom = securityPayload[&apos;validFrom&apos;];
    this._validTo = securityPayload[&apos;validTo&apos;];
    this._protocol = securityPayload[&apos;protocol&apos;];
  }

  /**
   * @return {string}
   */
  subjectName() {
    return this._subjectName;
  }

  /**
   * @return {string}
   */
  issuer() {
    return this._issuer;
  }

  /**
   * @return {number}
   */
  validFrom() {
    return this._validFrom;
  }

  /**
   * @return {number}
   */
  validTo() {
    return this._validTo;
  }

  /**
   * @return {string}
   */
  protocol() {
    return this._protocol;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Target" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Target">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Target
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Target {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Protocol.Target.TargetInfo} targetInfo
   * @param {!Puppeteer.BrowserContext} browserContext
   * @param {!function():!Promise&lt;!Puppeteer.CDPSession&gt;} sessionFactory
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   */
</span>  constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
    this._targetInfo = targetInfo;
    this._browserContext = browserContext;
    this._targetId = targetInfo.targetId;
    this._sessionFactory = sessionFactory;
    this._ignoreHTTPSErrors = ignoreHTTPSErrors;
    this._defaultViewport = defaultViewport;
    this._screenshotTaskQueue = screenshotTaskQueue;
    /** @type {?Promise&lt;!Puppeteer.Page&gt;} */
    this._pagePromise = null;
    /** @type {?Promise&lt;!Worker&gt;} */
    this._workerPromise = null;
    this._initializedPromise = new Promise(fulfill =&gt; this._initializedCallback = fulfill).then(async success =&gt; {
      if (!success)
        return false;
      const opener = this.opener();
      if (!opener || !opener._pagePromise || this.type() !== &apos;page&apos;)
        return true;
      const openerPage = await opener._pagePromise;
      if (!openerPage.listenerCount(Events.Page.Popup))
        return true;
      const popupPage = await this.page();
      openerPage.emit(Events.Page.Popup, popupPage);
      return true;
    });
    this._isClosedPromise = new Promise(fulfill =&gt; this._closedCallback = fulfill);
    this._isInitialized = this._targetInfo.type !== &apos;page&apos; || this._targetInfo.url !== &apos;&apos;;
    if (this._isInitialized)
      this._initializedCallback(true);
  }

  /**
   * @return {!Promise&lt;!Puppeteer.CDPSession&gt;}
   */
  createCDPSession() {
    return this._sessionFactory();
  }

  /**
   * @return {!Promise&lt;?Page&gt;}
   */
  async page() {
    if ((this._targetInfo.type === &apos;page&apos; || this._targetInfo.type === &apos;background_page&apos;) &amp;&amp; !this._pagePromise) {
      this._pagePromise = this._sessionFactory()
          .then(client =&gt; Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue));
    }
    return this._pagePromise;
  }

  /**
   * @return {!Promise&lt;?Worker&gt;}
   */
  async worker() {
    if (this._targetInfo.type !== &apos;service_worker&apos; &amp;&amp; this._targetInfo.type !== &apos;shared_worker&apos;)
      return null;
    if (!this._workerPromise) {
      this._workerPromise = this._sessionFactory().then(async client =&gt; {
        // Top level workers have a fake page wrapping the actual worker.
        const [targetAttached] = await Promise.all([
          new Promise(x =&gt; client.once(&apos;Target.attachedToTarget&apos;, x)),
          client.send(&apos;Target.setAutoAttach&apos;, {autoAttach: true, waitForDebuggerOnStart: false, flatten: true}),
        ]);
        const session = Connection.fromSession(client).session(targetAttached.sessionId);
        // TODO(einbinder): Make workers send their console logs.
        return new Worker(session, this._targetInfo.url, () =&gt; {} /* consoleAPICalled */, () =&gt; {} /* exceptionThrown */);
      });
    }
    return this._workerPromise;
  }

  /**
   * @return {string}
   */
  url() {
    return this._targetInfo.url;
  }

  /**
   * @return {&quot;page&quot;|&quot;background_page&quot;|&quot;service_worker&quot;|&quot;shared_worker&quot;|&quot;other&quot;|&quot;browser&quot;}
   */
  type() {
    const type = this._targetInfo.type;
    if (type === &apos;page&apos; || type === &apos;background_page&apos; || type === &apos;service_worker&apos; || type === &apos;shared_worker&apos; || type === &apos;browser
&apos;)
      return type;
    return &apos;other&apos;;
  }

  /**
   * @return {!Puppeteer.Browser}
   */
  browser() {
    return this._browserContext.browser();
  }

  /**
   * @return {!Puppeteer.BrowserContext}
   */
  browserContext() {...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError" id="apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>TimeoutError
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TimeoutError extends CustomError {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Touchscreen
        <span class="apidocSignatureSpan">(client, keyboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Touchscreen {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {Keyboard} keyboard
   */
</span>  constructor(client, keyboard) {
    this._client = client;
    this._keyboard = keyboard;
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  async tap(x, y) {
    // Touches appear to be lost during the first frame after navigation.
    // This waits a frame before sending the tap.
    // @see https://crbug.com/613219
    await this._client.send(&apos;Runtime.evaluate&apos;, {
      expression: &apos;new Promise(x =&gt; requestAnimationFrame(() =&gt; requestAnimationFrame(x)))&apos;,
      awaitPromise: true
    });

    const touchPoints = [{x: Math.round(x), y: Math.round(y)}];
    await this._client.send(&apos;Input.dispatchTouchEvent&apos;, {
      type: &apos;touchStart&apos;,
      touchPoints,
      modifiers: this._keyboard._modifiers
    });
    await this._client.send(&apos;Input.dispatchTouchEvent&apos;, {
      type: &apos;touchEnd&apos;,
      touchPoints: [],
      modifiers: this._keyboard._modifiers
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Tracing
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Tracing {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
    this._recording = false;
    this._path = &apos;&apos;;
  }

  /**
   * @param {!{path?: string, screenshots?: boolean, categories?: !Array&lt;string&gt;}} options
   */
  async start(options = {}) {
    assert(!this._recording, &apos;Cannot start recording trace while already recording trace.&apos;);

    const defaultCategories = [
      &apos;-*&apos;, &apos;devtools.timeline&apos;, &apos;v8.execute&apos;, &apos;disabled-by-default-devtools.timeline&apos;,
      &apos;disabled-by-default-devtools.timeline.frame&apos;, &apos;toplevel&apos;,
      &apos;blink.console&apos;, &apos;blink.user_timing&apos;, &apos;latencyInfo&apos;, &apos;disabled-by-default-devtools.timeline.stack&apos;,
      &apos;disabled-by-default-v8.cpu_profiler&apos;, &apos;disabled-by-default-v8.cpu_profiler.hires&apos;
    ];
    const {
      path = null,
      screenshots = false,
      categories = defaultCategories,
    } = options;

    if (screenshots)
      categories.push(&apos;disabled-by-default-devtools.screenshot&apos;);

    this._path = path;
    this._recording = true;
    await this._client.send(&apos;Tracing.start&apos;, {
      transferMode: &apos;ReturnAsStream&apos;,
      categories: categories.join(&apos;,&apos;)
    });
  }

  /**
   * @return {!Promise&lt;!Buffer&gt;}
   */
  async stop() {
    let fulfill;
    const contentPromise = new Promise(x =&gt; fulfill = x);
    this._client.once(&apos;Tracing.tracingComplete&apos;, event =&gt; {
      helper.readProtocolStream(this._client, event.stream, this._path).then(fulfill);
    });
    await this._client.send(&apos;Tracing.end&apos;);
    this._recording = false;
    return contentPromise;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Worker" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Worker">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Worker
        <span class="apidocSignatureSpan">(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Worker extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {string} url
   * @param {function(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=):void} consoleAPICalled
   * @param {function(!Protocol.Runtime.ExceptionDetails):void} exceptionThrown
   */
</span>  constructor(client, url, consoleAPICalled, exceptionThrown) {
    super();
    this._client = client;
    this._url = url;
    this._executionContextPromise = new Promise(x =&gt; this._executionContextCallback = x);
    /** @type {function(!Protocol.Runtime.RemoteObject):!JSHandle} */
    let jsHandleFactory;
    this._client.once(&apos;Runtime.executionContextCreated&apos;, async event =&gt; {
      jsHandleFactory = remoteObject =&gt; new JSHandle(executionContext, client, remoteObject);
      const executionContext = new ExecutionContext(client, event.context, null);
      this._executionContextCallback(executionContext);
    });
    // This might fail if the target is closed before we recieve all execution contexts.
    this._client.send(&apos;Runtime.enable&apos;, {}).catch(debugError);

    this._client.on(&apos;Runtime.consoleAPICalled&apos;, event =&gt; consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace
));
    this._client.on(&apos;Runtime.exceptionThrown&apos;, exception =&gt; exceptionThrown(exception.exceptionDetails));
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {!Promise&lt;ExecutionContext&gt;}
   */
  async executionContext() {
    return this._executionContextPromise;
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return (await this._executionContextPromise).evaluate(pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;!JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl" id="apidoc.module.utility2.sjcl">module utility2.sjcl</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.decrypt" id="apidoc.elem.utility2.sjcl.decrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.</span>decrypt
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.<span class="apidocCodeKeywordSpan">decrypt</span>(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a
.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.encrypt" id="apidoc.elem.utility2.sjcl.encrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.</span>encrypt
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.<span class="apidocCodeKeywordSpan">encrypt</span>(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial
(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d
,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw
 new sjcl.exception.invalid(&quot;ccm: invalid tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng" id="apidoc.elem.utility2.sjcl.prng">
        function <span class="apidocSignatureSpan">utility2.sjcl.</span>prng
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b
=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this
.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.<span class="apidocCodeKeywordSpan">prng</span>(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
...</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.beware" id="apidoc.module.utility2.sjcl.beware">module utility2.sjcl.beware</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.bitArray" id="apidoc.module.utility2.sjcl.bitArray">module utility2.sjcl.bitArray</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.bitLength" id="apidoc.elem.utility2.sjcl.bitArray.bitLength">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>bitLength
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp
;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt
;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&
gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[
a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[
2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength
:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.<span class="apidocCodeKeywordSpan">bitLength</span>(a)!==sjcl.bitArray.bitLength(b))
return!1;var c=0,d;for(d=0;d&lt;a.length;d++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
sjcl.codec.base64={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,fromBits:function(a,b,c){var d
=&quot;&quot;,e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(c=0;6*
d.length&lt;h;)d+=f.charAt((g^a[c]&gt;&gt;&gt;e)&gt;&gt;&gt;26),6&gt;e?(g=a[c]&lt;&lt;6-e,e+=26,c++):(g&lt;&lt;=6,e-=6);for(;d.length
&amp;3&amp;&amp;!b;)d+=&quot;=&quot;;return d},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;);var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(d=0;d&lt;a.length;d++){h=f.indexOf(a.charAt(d));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.bitSlice" id="apidoc.elem.utility2.sjcl.bitArray.bitSlice">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>bitSlice
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(0&gt;h)throw new sjcl.exception.invalid(&quot;this isn&apos;t base64!&quot;);26&lt;e?(e-=26,c.push(g^h&gt;&gt;&gt;e),g=h&lt;&
lt;32-e):(e+=6,g^=h&lt;&lt;32-e)}e&amp;56&amp;&amp;c.push(sjcl.bitArray.partial(e&amp;56,g,1));return c}};sjcl.codec.base64url={
fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash
.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash
=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.<span class="apidocCodeKeywordSpan
">bitSlice</span>(b,h-e),h=(h-e)/8;if(7&gt;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(
b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl
.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.byteswapM" id="apidoc.elem.utility2.sjcl.bitArray.byteswapM">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>byteswapM
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00)&lt;&lt;8|c&lt;&lt;24;return a}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.clamp" id="apidoc.elem.utility2.sjcl.bitArray.clamp">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>clamp
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial
(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&quot;use strict&quot;;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString
=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a},invalid:function(a){this.toString=function(){return&quot;INVALID
: &quot;+this.message};this.message=a},bug:function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message
=a},notReady:function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp
;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt
;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&
gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[
a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[
2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.<span class="apidocCodeKeywordSpan">clamp</span>(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&
amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a
.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray
.$(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d
++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.concat" id="apidoc.elem.utility2.sjcl.bitArray.concat">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>concat
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a
.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    template: local.templateApidocHtml,
    whitelistDict: {}
}, 2);
// init exampleList
([
    1, 2, 3, 4
]).forEach(function (depth) {
    opt.exampleList = opt.exampleList.<span class="apidocCodeKeywordSpan">concat</span>(
        // find . -maxdepth 1 -mindepth 1 -name &quot;*.js&quot; -type f
        // https://stackoverflow.com/questions/4509624/how-to-limit-depth-for-recursive-file-list
        local.child_process.execSync(
            &quot;find \&quot;&quot; + opt.dir
            + &quot;\&quot; -maxdepth &quot; + depth + &quot; -mindepth &quot; + depth
            + &quot; -type f | sed -e \&quot;s|&quot; + opt.dir
            + &quot;/||\&quot; | grep -iv &quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.equal" id="apidoc.elem.utility2.sjcl.bitArray.equal">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>equal
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d++)c|=a[d]^b[d];
return 0===
c}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(0&gt;h)throw new sjcl.exception.invalid(&quot;this isn&apos;t base64!&quot;);26&lt;e?(e-=26,c.push(g^h&gt;&gt;&gt;e),g=h&lt;&
lt;32-e):(e+=6,g^=h&lt;&lt;32-e)}e&amp;56&amp;&amp;c.push(sjcl.bitArray.partial(e&amp;56,g,1));return c}};sjcl.codec.base64url={
fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash
.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash
=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.<span
 class="apidocCodeKeywordSpan">equal</span>(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.extract" id="apidoc.elem.utility2.sjcl.bitArray.extract">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>extract
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.getPartial" id="apidoc.elem.utility2.sjcl.bitArray.getPartial">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>getPartial
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){return Math.round(a/0x10000000000)||32}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&quot;use strict&quot;;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString
=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a},invalid:function(a){this.toString=function(){return&quot;INVALID
: &quot;+this.message};this.message=a},bug:function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message
=a},notReady:function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp
;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt
;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&
gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[
a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[
2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.<span class="apidocCodeKeywordSpan">getPartial</span>(c);return 32===d?a.concat(b):sjcl.bitArray
.$(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d
++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.i" id="apidoc.elem.utility2.sjcl.bitArray.i">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>i
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.bitArray.partial" id="apidoc.elem.utility2.sjcl.bitArray.partial">
        function <span class="apidocSignatureSpan">utility2.sjcl.bitArray.</span>partial
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp
;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt
;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&
gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[
a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[
2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength
:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.<span class="apidocCodeKeywordSpan">partial</span>(b,a[c
-1]&amp;2147483648&gt;&gt;b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial
:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength
(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d++)c|=a[d]^b[d];return 0===
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
sjcl.codec.base64={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,fromBits:function(a,b,c){var d
=&quot;&quot;,e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(c=0;6*
d.length&lt;h;)d+=f.charAt((g^a[c]&gt;&gt;&gt;e)&gt;&gt;&gt;26),6&gt;e?(g=a[c]&lt;&lt;6-e,e+=26,c++):(g&lt;&lt;=6,e-=6);for(;d.length
&amp;3&amp;&amp;!b;)d+=&quot;=&quot;;return d},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;);var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(d=0;d&lt;a.length;d++){h=f.indexOf(a.charAt(d));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.cipher" id="apidoc.module.utility2.sjcl.cipher">module utility2.sjcl.cipher</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.cipher.aes" id="apidoc.elem.utility2.sjcl.cipher.aes">
        function <span class="apidocSignatureSpan">utility2.sjcl.cipher.</span>aes
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp;6!==b&amp;&amp;8!==b)throw new
 sjcl.exception.invalid(&quot;invalid aes key size&quot;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===
a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[a]=d[a-b]^c}for(
b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0&gt;d||0&gt;c)throw new sjcl.exception.invalid(&quot;invalid params to pbkdf2&
quot;);&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl
.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length&lt;(d||1);k++){
e=f=a.encrypt(n.concat(b,[k]));for(g=1;g&lt;c;g++)for(f=a.encrypt(f),h=0;h&lt;f.length;h++)e[h]^=f[h];l=l.concat(e)}d&amp;&amp;(
l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.<span class="apidocCodeKeywordSpan">aes</span>(
this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this
),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting
 paranoia=0 will ruin your security; use it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0
 will ruin your security; use it only for testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.cipher.aes.prototype" id="apidoc.module.utility2.sjcl.cipher.aes.prototype">module utility2.sjcl.cipher.aes.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.O" id="apidoc.elem.utility2.sjcl.cipher.aes.prototype.O">
        function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>O
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&gt;&gt;7))^e]=e;for
(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*
e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
file https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js
shGithubDateCommitted https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js # 2017-07-04T08:55:03Z
curl https://raw.githubusercontent.com/bitwiseshiftleft/sjcl/1.0.8/sjcl.js &gt; /tmp/aa.js
*/
/* jslint ignore:start */
(function () { var module;
&quot;use strict&quot;;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString
=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a},invalid:function(a){this.toString=function(){return&quot;INVALID
: &quot;+this.message};this.message=a},bug:function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message
=a},notReady:function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.<span class="apidocCodeKeywordSpan">O</span>();var b,c,d,e,f=this.s[0][4],g=this
.s[1];b=a.length;var h=1;if(4!==b&amp;&amp;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot
;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24
^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt
;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt
;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength
:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d
++)c|=a[d]^b[d];return 0===
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.decrypt" id="apidoc.elem.utility2.sjcl.cipher.aes.prototype.decrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){return t(this,a,1)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.<span class="apidocCodeKeywordSpan">decrypt</span>(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a
.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.cipher.aes.prototype.encrypt" id="apidoc.elem.utility2.sjcl.cipher.aes.prototype.encrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.cipher.aes.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){return t(this,a,0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.<span class="apidocCodeKeywordSpan">encrypt</span>(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial
(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d
,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw
 new sjcl.exception.invalid(&quot;ccm: invalid tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.exception" id="apidoc.module.utility2.sjcl.exception">module utility2.sjcl.exception</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.exception.bug" id="apidoc.elem.utility2.sjcl.exception.bug">
        function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>bug
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message=a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.<span class="apidocCodeKeywordSpan">bug</span>(&quot;
ccm: can&apos;t deal with 4GiB or more data&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a
.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b
.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0
,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.exception.corrupt" id="apidoc.elem.utility2.sjcl.exception.corrupt">
        function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>corrupt
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.toString=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(0&gt;h)throw new sjcl.exception.invalid(&quot;this isn&apos;t base64!&quot;);26&lt;e?(e-=26,c.push(g^h&gt;&gt;&gt;e),g=h&lt;&
lt;32-e):(e+=6,g^=h&lt;&lt;32-e)}e&amp;56&amp;&amp;c.push(sjcl.bitArray.partial(e&amp;56,g,1));return c}};sjcl.codec.base64url={
fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash
.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash
=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.<span class="apidocCodeKeywordSpan">corrupt</span>(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.exception.invalid" id="apidoc.elem.utility2.sjcl.exception.invalid">
        function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>invalid
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.toString=function(){return&quot;INVALID: &quot;+this.message};this.message=a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
file https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js
shGithubDateCommitted https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js # 2017-07-04T08:55:03Z
curl https://raw.githubusercontent.com/bitwiseshiftleft/sjcl/1.0.8/sjcl.js &gt; /tmp/aa.js
*/
/* jslint ignore:start */
(function () { var module;
&quot;use strict&quot;;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString
=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a},invalid:function(a){this.toString=function(){return&quot;INVALID
: &quot;+this.message};this.message=a},bug:function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message
=a},notReady:function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&amp;&amp
;6!==b&amp;&amp;8!==b)throw new sjcl.exception.<span class="apidocCodeKeywordSpan">invalid</span>(&quot;invalid aes key size&quot
;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24
^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt
;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt
;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength
:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d
++)c|=a[d]^b[d];return 0===
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.exception.notReady" id="apidoc.elem.utility2.sjcl.exception.notReady">
        function <span class="apidocSignatureSpan">utility2.sjcl.exception.</span>notReady
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0&gt;d||0&gt;c)throw new sjcl.exception.invalid(&quot;invalid params to pbkdf2&
quot;);&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl
.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length&lt;(d||1);k++){
e=f=a.encrypt(n.concat(b,[k]));for(g=1;g&lt;c;g++)for(f=a.encrypt(f),h=0;h&lt;f.length;h++)e[h]^=f[h];l=l.concat(e)}d&amp;&amp;(
l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.<span class
="apidocCodeKeywordSpan">notReady</span>(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=
0,g;this.Z=e[0]=(new Date).valueOf()+this.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&
amp;&amp;(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c
.length&amp;&amp;(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.hash" id="apidoc.module.utility2.sjcl.hash">module utility2.sjcl.hash</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1" id="apidoc.elem.utility2.sjcl.hash.sha1">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.</span>sha1
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha1 = function (hash) {
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 5 big-endian words.
 */
sjcl.hash.sha1.hash = function (data) {
return (new sjcl.hash.<span class="apidocCodeKeywordSpan">sha1</span>()).update(data).finalize();
};

sjcl.hash.sha1.prototype = {
/**
 * The hash&apos;s block size, in bits.
 * @constant
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha256" id="apidoc.elem.utility2.sjcl.hash.sha256">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.</span>sha256
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.hash.sha1.prototype" id="apidoc.module.utility2.sjcl.hash.sha1.prototype">module utility2.sjcl.hash.sha1.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._S" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype._S">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_S
        <span class="apidocSignatureSpan">(n, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(n, x) {
  return (x &lt;&lt; n) | (x &gt;&gt;&gt; 32-n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    w = words;
}

a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4];

for (t=0; t&lt;=79; t++) {
  if (t &gt;= 16) {
    w[t] = this.<span class="apidocCodeKeywordSpan">_S</span>(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);
  }
  tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +
         this._key[Math.floor(t/20)]) | 0;
  e = d;
  d = c;
  c = this._S(30, b);
  b = a;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._block" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype._block">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_block
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_block = function (words) {
  var t, tmp, a, b, c, d, e,
  h = this._h;
  var w;
  if (typeof Uint32Array !== &apos;undefined&apos;) {
      // When words is passed to _block, it has 16 elements. SHA1 _block
      // function extends words with new elements (at the end there are 80 elements).
      // The problem is that if we use Uint32Array instead of Array,
      // the length of Uint32Array cannot be changed. Thus, we replace words with a
      // normal Array here.
      w = Array(80); // do not use Uint32Array here as the instantiation is slower
      for (var j=0; j&lt;16; j++){
          w[j] = words[j];
      }
  } else {
      w = words;
  }

  a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4];

  for (t=0; t&lt;=79; t++) {
    if (t &gt;= 16) {
      w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);
    }
    tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +
           this._key[Math.floor(t/20)]) | 0;
    e = d;
    d = c;
    c = this._S(30, b);
    b = a;
    a = tmp;
 }

 h[0] = (h[0]+a) |0;
 h[1] = (h[1]+b) |0;
 h[2] = (h[2]+c) |0;
 h[3] = (h[3]+d) |0;
 h[4] = (h[4]+e) |0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (typeof Uint32Array !== &apos;undefined&apos;) {
	var c = new Uint32Array(b);
	var j = 0;
	for (i = this.blockSize+ol - ((this.blockSize+ol) &amp; (this.blockSize-1)); i &lt;= nl;
		i+= this.blockSize) {
  	    this.<span class="apidocCodeKeywordSpan">_block</span>(c.subarray(16 * j, 16 * (j+1)));
  	    j += 1;
	}
	b.splice(0, 16 * j);
} else {
	for (i = this.blockSize+ol - ((this.blockSize+ol) &amp; (this.blockSize-1)); i &lt;= nl;
         i+= this.blockSize) {
  	     this._block(b.splice(0,16));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype._f" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype._f">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>_f
        <span class="apidocSignatureSpan">(t, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(t, b, c, d) {
  if (t &lt;= 19) {
    return (b &amp; c) | (~b &amp; d);
  } else if (t &lt;= 39) {
    return b ^ c ^ d;
  } else if (t &lt;= 59) {
    return (b &amp; c) | (b &amp; d) | (c &amp; d);
  } else if (t &lt;= 79) {
    return b ^ c ^ d;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4];

 for (t=0; t&lt;=79; t++) {
   if (t &gt;= 16) {
     w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);
   }
   tmp = (this._S(5, a) + this.<span class="apidocCodeKeywordSpan">_f</span>(t, b, c, d) + e + w[t] +
          this._key[Math.floor(t/20)]) | 0;
   e = d;
   d = c;
   c = this._S(30, b);
   b = a;
   a = tmp;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.finalize" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype.finalize">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
  var i, b = this._buffer, h = this._h;

  // Round out and push the buffer
  b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
  // Round out the buffer to a multiple of 16 words, less the 2 length words.
  for (i = b.length + 2; i &amp; 15; i++) {
    b.push(0);
  }

  // append the length
  b.push(Math.floor(this._length / 0x100000000));
  b.push(this._length | 0);

  while (b.length) {
    this._block(b.splice(0,16));
  }

  this.reset();
  return h;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
sjcl.codec.base64={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,fromBits:function(a,b,c){var d
=&quot;&quot;,e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(c=0;6*
d.length&lt;h;)d+=f.charAt((g^a[c]&gt;&gt;&gt;e)&gt;&gt;&gt;26),6&gt;e?(g=a[c]&lt;&lt;6-e,e+=26,c++):(g&lt;&lt;=6,e-=6);for(;d.length
&amp;3&amp;&amp;!b;)d+=&quot;=&quot;;return d},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;);var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(d=0;d&lt;a.length;d++){h=f.indexOf(a.charAt(d));
if(0&gt;h)throw new sjcl.exception.invalid(&quot;this isn&apos;t base64!&quot;);26&lt;e?(e-=26,c.push(g^h&gt;&gt;&gt;e),g=h&lt;&
lt;32-e):(e+=6,g^=h&lt;&lt;32-e)}e&amp;56&amp;&amp;c.push(sjcl.bitArray.partial(e&amp;56,g,1));return c}};sjcl.codec.base64url={
fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash
.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash
=function(a){return(new sjcl.hash.sha256).update(a).<span class="apidocCodeKeywordSpan">finalize</span>()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.reset" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype.reset">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  this._h = this._init.slice(0);
  this._buffer = [];
  this._length = 0;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
++this.pos;
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.<span class="apidocCodeKeywordSpan">reset</span>(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha1.prototype.update" id="apidoc.elem.utility2.sjcl.hash.sha1.prototype.update">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha1.prototype.</span>update
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data) {
  if (typeof data === &quot;string&quot;) {
    data = sjcl.codec.utf8String.toBits(data);
  }
  var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
      ol = this._length,
      nl = this._length = ol + sjcl.bitArray.bitLength(data);
  if (nl &gt; 9007199254740991){
    throw new sjcl.exception.invalid(&quot;Cannot hash more than 2^53 - 1 bits&quot;);
  }

  if (typeof Uint32Array !== &apos;undefined&apos;) {
	var c = new Uint32Array(b);
  	var j = 0;
  	for (i = this.blockSize+ol - ((this.blockSize+ol) &amp; (this.blockSize-1)); i &lt;= nl;
		i+= this.blockSize) {
    	    this._block(c.subarray(16 * j, 16 * (j+1)));
    	    j += 1;
  	}
  	b.splice(0, 16 * j);
  } else {
  	for (i = this.blockSize+ol - ((this.blockSize+ol) &amp; (this.blockSize-1)); i &lt;= nl;
           i+= this.blockSize) {
    	     this._block(b.splice(0,16));
    	}
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Destroy the socket if the client has already sent a FIN packet.
//
if (!socket.readable || !socket.writable) return socket.destroy();

const digest = crypto
  .createHash(&apos;sha1&apos;)
  .<span class="apidocCodeKeywordSpan">update</span>(key + GUID)
  .digest(&apos;base64&apos;);

const headers = [
  &apos;HTTP/1.1 101 Switching Protocols&apos;,
  &apos;Upgrade: websocket&apos;,
  &apos;Connection: Upgrade&apos;,
  `Sec-WebSocket-Accept: ${digest}`
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.hash.sha256.prototype" id="apidoc.module.utility2.sjcl.hash.sha256.prototype">module utility2.sjcl.hash.sha256.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.O" id="apidoc.elem.utility2.sjcl.hash.sha256.prototype.O">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>O
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if(0===c%d
){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
file https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js
shGithubDateCommitted https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/sjcl.js # 2017-07-04T08:55:03Z
curl https://raw.githubusercontent.com/bitwiseshiftleft/sjcl/1.0.8/sjcl.js &gt; /tmp/aa.js
*/
/* jslint ignore:start */
(function () { var module;
&quot;use strict&quot;;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString
=function(){return&quot;CORRUPT: &quot;+this.message};this.message=a},invalid:function(a){this.toString=function(){return&quot;INVALID
: &quot;+this.message};this.message=a},bug:function(a){this.toString=function(){return&quot;BUG: &quot;+this.message};this.message
=a},notReady:function(a){this.toString=function(){return&quot;NOT READY: &quot;+this.message};this.message=a}}};
sjcl.cipher.aes=function(a){this.s[0][0][0]||this.<span class="apidocCodeKeywordSpan">O</span>();var b,c,d,e,f=this.s[0][4],g=this
.s[1];b=a.length;var h=1;if(4!==b&amp;&amp;6!==b&amp;&amp;8!==b)throw new sjcl.exception.invalid(&quot;invalid aes key size&quot
;);this.b=[d=a.slice(0),e=[]];for(a=b;a&lt;4*b+28;a++){c=d[a-1];if(0===a%b||8===b&amp;&amp;4===a%b)c=f[c&gt;&gt;&gt;24]&lt;&lt;24
^f[c&gt;&gt;16&amp;255]&lt;&lt;16^f[c&gt;&gt;8&amp;255]&lt;&lt;8^f[c&amp;255],0===a%b&amp;&amp;(c=c&lt;&lt;8^c&gt;&gt;&gt;24^h&lt
;&lt;24,h=h&lt;&lt;1^283*(h&gt;&gt;7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&amp;3?a:a-4],e[b]=4&gt;=a||4&gt;b?c:g[0][f[c&gt;&gt
;&gt;24]]^g[1][f[c&gt;&gt;16&amp;255]]^g[2][f[c&gt;&gt;8&amp;255]]^g[3][f[c&amp;
255]]};
sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],
O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;0x100&gt;e;e++)k[(h[e]=e&lt;&lt;1^283*(e&
gt;&gt;7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g&lt;&lt;1^g&lt;&lt;2^g&lt;&lt;3^g&lt;&lt;4,m=m&gt;&gt;8^m&amp;255^99,
c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=0x1010101*n^0x10001*e^0x101*l^0x1010100*f,n=0x101*h[m]^0x1010100*m,e=0;4&gt;e;e++)a[e][f]=n=n&lt
;&lt;24^n&gt;&gt;&gt;8,b[e][m]=p=p&lt;&lt;24^p&gt;&gt;&gt;8;for(e=
0;5&gt;e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(&quot;invalid aes block size&quot;);var d=a.b[c],e=b[0]^d[0],
f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],
x=h[4];for(m=0;m&lt;n;m++)h=a[e&gt;&gt;&gt;24]^q[f&gt;&gt;16&amp;255]^v[g&gt;&gt;8&amp;255]^w[b&amp;255]^d[p],k=a[f&gt;&gt;&gt;24
]^q[g&gt;&gt;16&amp;255]^v[b&gt;&gt;8&amp;255]^w[e&amp;255]^d[p+1],l=a[g&gt;&gt;&gt;24]^q[b&gt;&gt;16&amp;255]^v[e&gt;&gt;8&amp;
255]^w[f&amp;255]^d[p+2],b=a[b&gt;&gt;&gt;24]^q[e&gt;&gt;16&amp;255]^v[f&gt;&gt;8&amp;255]^w[g&amp;255]^d[p+3],p+=4,e=h,f=k,g=l;
for(m=
0;4&gt;m;m++)r[c?3&amp;-m:m]=x[e&gt;&gt;&gt;24]&lt;&lt;24^x[f&gt;&gt;16&amp;255]&lt;&lt;16^x[g&gt;&gt;8&amp;255]&lt;&lt;8^x[b&amp
;255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}
sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&amp;31)).slice(1);return void 0===c?a:sjcl.bitArray
.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&amp;31);return((b+c-1^b)&amp;-32?a[b/32|0]&lt;&lt;32-d^a[b/32+1|0]&
gt;&gt;&gt;d:a[b/32|0]&gt;&gt;&gt;d)&amp;(1&lt;&lt;c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var
 c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength
:function(a){var b=a.length;return 0===
b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length&lt;b)return a;a=a.slice(0,Math.ceil(b/32));var
 c=a.length;b=b&amp;31;0&lt;c&amp;&amp;b&amp;&amp;(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&amp;2147483648&gt;&gt;b-1,1));return a},
partial:function(a,b,c){return 32===a?b:(c?b|0:b&lt;&lt;32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000
)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d&lt;a.length;d
++)c|=a[d]^b[d];return 0===
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.finalize" id="apidoc.elem.utility2.sjcl.hash.sha256.prototype.finalize">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0);b.
push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
c},$:function(a,b,c,d){var e;e=0;for(void 0===d&amp;&amp;(d=[]);32&lt;=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0
;e&lt;a.length;e++)d.push(c|a[e]&gt;&gt;&gt;b),c=a[e]&lt;&lt;32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push
(sjcl.bitArray.partial(b+a&amp;31,32&lt;b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[
3]]},byteswapM:function(a){var b,c;for(b=0;b&lt;a.length;++b)c=a[b],a[b]=c&gt;&gt;&gt;24|c&gt;&gt;&gt;8&amp;0xff00|(c&amp;0xff00
)&lt;&lt;8|c&lt;&lt;24;return a}};
sjcl.codec.utf8String={fromBits:function(a){var b=&quot;&quot;,c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d&lt;c/8;d++)0===(d&amp;
3)&amp;&amp;(e=a[d/4]),b+=String.fromCharCode(e&gt;&gt;&gt;8&gt;&gt;&gt;8&gt;&gt;&gt;8),e&lt;&lt;=8;return decodeURIComponent(escape
(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c&lt;a.length;c++)d=d&lt;&lt;8|a.charCodeAt(c),
3===(c&amp;3)&amp;&amp;(b.push(d),d=0);c&amp;3&amp;&amp;b.push(sjcl.bitArray.partial(8*(c&amp;3),d));return b}};
sjcl.codec.hex={fromBits:function(a){var b=&quot;&quot;,c;for(c=0;c&lt;a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr
(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,&quot;&quot;);d=a.length;a=a+&quot;00000000&quot;;for(b=0;b&lt;a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};
sjcl.codec.base32={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;,X:&quot;0123456789ABCDEFGHIJKLMNOPQRSTUV&quot;,BITS:32,BASE:5,
REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=&quot;&quot;,g=0,h=sjcl.codec
.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&amp;&amp;(h=sjcl.codec.base32.X);for(c=0;f.length*d&lt;l;)f+=h.charAt((k^a[c]&gt;&gt
;&gt;g)&gt;&gt;&gt;e),g&lt;d?(k=a[c]&lt;&lt;d-g,g+=e,c++):(k&lt;&lt;=d,g-=d);for(;f.length&amp;7&amp;&amp;!b;)f+=&quot;=&quot;;return
 f},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;).toUpperCase();var c=sjcl.codec.base32.BITS,
d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m=&quot;base32&quot;;b&amp;&amp;(k
=sjcl.codec.base32.X,m=&quot;base32hex&quot;);for(g=0;g&lt;a.length;g++){n=k.indexOf(a.charAt(g));if(0&gt;n){if(!b)try{return sjcl
.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid(&quot;this isn&apos;t &quot;+m+&quot;!&quot;);}h&gt;e?(h-=
e,f.push(l^n&gt;&gt;&gt;h),l=n&lt;&lt;c-h):(h+=d,l^=n&lt;&lt;c-h)}h&amp;56&amp;&amp;f.push(sjcl.bitArray.partial(h&amp;56,l,1));
return f}};
sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32
.toBits(a,1)}};
sjcl.codec.base64={B:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,fromBits:function(a,b,c){var d
=&quot;&quot;,e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(c=0;6*
d.length&lt;h;)d+=f.charAt((g^a[c]&gt;&gt;&gt;e)&gt;&gt;&gt;26),6&gt;e?(g=a[c]&lt;&lt;6-e,e+=26,c++):(g&lt;&lt;=6,e-=6);for(;d.length
&amp;3&amp;&amp;!b;)d+=&quot;=&quot;;return d},toBits:function(a,b){a=a.replace(/\s|=/g,&quot;&quot;);var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&amp;&amp;(f=f.substr(0,62)+&quot;-_&quot;);for(d=0;d&lt;a.length;d++){h=f.indexOf(a.charAt(d));
if(0&gt;h)throw new sjcl.exception.invalid(&quot;this isn&apos;t base64!&quot;);26&lt;e?(e-=26,c.push(g^h&gt;&gt;&gt;e),g=h&lt;&
lt;32-e):(e+=6,g^=h&lt;&lt;32-e)}e&amp;56&amp;&amp;c.push(sjcl.bitArray.partial(e&amp;56,g,1));return c}};sjcl.codec.base64url={
fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash
.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash
=function(a){return(new sjcl.hash.sha256).update(a).<span class="apidocCodeKeywordSpan">finalize</span>()};
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.reset" id="apidoc.elem.utility2.sjcl.hash.sha256.prototype.reset">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
++this.pos;
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.<span class="apidocCodeKeywordSpan">reset</span>(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.hash.sha256.prototype.update" id="apidoc.elem.utility2.sjcl.hash.sha256.prototype.update">
        function <span class="apidocSignatureSpan">utility2.sjcl.hash.sha256.prototype.</span>update
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this.l;a=this
.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2^53 - 1 bits&quot;);if
(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Destroy the socket if the client has already sent a FIN packet.
//
if (!socket.readable || !socket.writable) return socket.destroy();

const digest = crypto
  .createHash(&apos;sha1&apos;)
  .<span class="apidocCodeKeywordSpan">update</span>(key + GUID)
  .digest(&apos;base64&apos;);

const headers = [
  &apos;HTTP/1.1 101 Switching Protocols&apos;,
  &apos;Upgrade: websocket&apos;,
  &apos;Connection: Upgrade&apos;,
  `Sec-WebSocket-Accept: ${digest}`
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.json" id="apidoc.module.utility2.sjcl.json">module utility2.sjcl.json</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.decode" id="apidoc.elem.utility2.sjcl.json.decode">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>decode
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.
replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.<span class="apidocCodeKeywordSpan">decode</span>(b),c,d
)},encode:function(a){var b,c=&quot;{&quot;,d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw
new sjcl.exception.invalid(&quot;json encode: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
&quot;undefined&quot;!==typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=sjcl);&quot;function&quot;===typeof define
&amp;&amp;define([],function(){return sjcl});
local.sjcl = sjcl;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.decrypt" id="apidoc.elem.utility2.sjcl.json.decrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>decrypt
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat
([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V
:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw new sjcl.exception.invalid(&quot;ccm: invalid
 tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.<span class="apidocCodeKeywordSpan">decrypt</span>(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a
.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.encode" id="apidoc.elem.utility2.sjcl.json.encode">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>encode
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){var b,c=&quot;{&quot;,d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json
 encode: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object
&quot;:c+=&apos;&quot;&apos;+sjcl.codec.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}return
 c+&quot;}&quot;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.<span class="apidocCodeKeywordSpan">encode</span>(f)},ia:function
(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.
salt&amp;&amp;(b.salt=sjcl.codec.base64.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits
(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
&quot;undefined&quot;!==typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=sjcl);&quot;function&quot;===typeof define
&amp;&amp;define([],function(){return sjcl});
local.sjcl = sjcl;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.encrypt" id="apidoc.elem.utility2.sjcl.json.encrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>encrypt
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.<span class="apidocCodeKeywordSpan">encrypt</span>(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial
(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d
,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw
 new sjcl.exception.invalid(&quot;ccm: invalid tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.g" id="apidoc.elem.utility2.sjcl.json.g">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>g
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c){void 0===a&amp;&amp;(a={});if(void 0===b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d
])throw new sjcl.exception.invalid(&quot;required parameter overridden&quot;);a[d]=b[d]}return a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.<span class="apidocCodeKeywordSpan">g</span>({iv:sjcl.random.randomWords(4,0)},e.defaults
),g;e.g(f,c);c=f.adata;&quot;string&quot;===typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===
typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof
 a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.
ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.ia" id="apidoc.elem.utility2.sjcl.json.ia">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ia
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){c=c||{};d=d||{};var e=sjcl.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt
&amp;&amp;(b.salt=sjcl.codec.base64.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!
sjcl.cipher[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length
)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key
.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag
)).slice(0,b.ks/32));&quot;string&quot;===typeof f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt(g,b.ct,b.iv,b.tag,f,b.ts
):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String.fromBits(f)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.<span class="apidocCodeKeywordSpan">ia</span>(a,e.decode(b),c,d
)},encode:function(a){var b,c=&quot;{&quot;,d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw
new sjcl.exception.invalid(&quot;json encode: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
&quot;undefined&quot;!==typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=sjcl);&quot;function&quot;===typeof define
&amp;&amp;define([],function(){return sjcl});
local.sjcl = sjcl;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.ja" id="apidoc.elem.utility2.sjcl.json.ja">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ja
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string
&quot;===typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl
.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks
&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2
(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key
.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String
.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.ra" id="apidoc.elem.utility2.sjcl.json.ra">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>ra
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.json.sa" id="apidoc.elem.utility2.sjcl.json.sa">
        function <span class="apidocSignatureSpan">utility2.sjcl.json.</span>sa
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.misc" id="apidoc.module.utility2.sjcl.misc">module utility2.sjcl.misc</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.cachedPbkdf2" id="apidoc.elem.utility2.sjcl.misc.cachedPbkdf2">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>cachedPbkdf2
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice
(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice
(0),salt:c.slice(0)}}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.<span class="apidocCodeKeywordSpan">cachedPbkdf2</span>(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp
;a instanceof sjcl.ecc.elGamal.publicKey&amp;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof
 b&amp;&amp;(b=sjcl.codec.utf8String.toBits(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c
));g=new sjcl.cipher[f.cipher](a);e.g(d,f);d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer
.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
&quot;undefined&quot;!==typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=sjcl);&quot;function&quot;===typeof define
&amp;&amp;define([],function(){return sjcl});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac" id="apidoc.elem.utility2.sjcl.misc.hmac">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>hmac
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){this.W=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash
(a));for(d=0;d&lt;e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this
.w[0])}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.pbkdf2" id="apidoc.elem.utility2.sjcl.misc.pbkdf2">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>pbkdf2
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c, d, e){c=c||1E4;if(0&gt;d||0&gt;c)throw new sjcl.exception.invalid(&quot;invalid params to pbkdf2&quot;);&quot;string&quot;===typeof a&amp;&amp;(a=sjcl
.codec.utf8String.toBits(a));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k
,l=[],n=sjcl.bitArray;for(k=1;32*l.length&lt;(d||1);k++){e=f=a.encrypt(n.concat(b,[k]));for(g=1;g&lt;c;g++)for(f=a.encrypt(f),h=0;h&lt;f.
length;h++)e[h]^=f[h];l=l.concat(e)}d&amp;&amp;(l=n.clamp(l,d));return l}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.<span class="apidocCodeKeywordSpan">pbkdf2</span>(a,c,b.iter);return{key:d[c].slice(0),
salt:c.slice(0)}};
&quot;undefined&quot;!==typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=sjcl);&quot;function&quot;===typeof define
&amp;&amp;define([],function(){return sjcl});
local.sjcl = sjcl;



/*
file https://github.com/bitwiseshiftleft/sjcl/blob/1.0.8/core/sha1.js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.scrypt" id="apidoc.elem.utility2.sjcl.misc.scrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.</span>scrypt
        <span class="apidocSignatureSpan">(password, salt, N, r, p, length, Prff)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrypt = function (password, salt, N, r, p, length, Prff) {
  var SIZE_MAX = Math.pow(2, 32) - 1,
      self = sjcl.misc.scrypt;

  N = N || 16384;
  r = r || 8;
  p = p || 1;

  if (r * p &gt;= Math.pow(2, 30)) {
    throw sjcl.exception.invalid(&quot;The parameters r, p must satisfy r * p &lt; 2^30&quot;);
  }

  if ((N &lt; 2) || (N &amp; (N - 1) != 0)) {
    throw sjcl.exception.invalid(&quot;The parameter N must be a power of 2.&quot;);
  }

  if (N &gt; SIZE_MAX / 128 / r) {
    throw sjcl.exception.invalid(&quot;N too big.&quot;);
  }

  if (r &gt; SIZE_MAX / 128 / p) {
    throw sjcl.exception.invalid(&quot;r too big.&quot;);
  }

  var blocks = sjcl.misc.pbkdf2(password, salt, 1, p * 128 * r * 8, Prff),
      len = blocks.length / p;

  self.reverse(blocks);

  for (var i = 0; i &lt; p; i++) {
    var block = blocks.slice(i * len, (i + 1) * len);
    self.blockcopy(self.ROMix(block, N), 0, blocks, i * len);
  }

  self.reverse(blocks);

  return sjcl.misc.pbkdf2(password, blocks, 1, length, Prff);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!opt[3]) {
    opt[3] = local.sjcl.codec.base64.fromBits(
        local.sjcl.random.randomWords(4, 0)
    );
}
// init hash
opt[4] = local.sjcl.codec.base64.fromBits(
    local.sjcl.misc.<span class="apidocCodeKeywordSpan">scrypt</span>(
        password || &quot;&quot;,
        local.sjcl.codec.base64.toBits(opt[3]),
        Math.pow(2, parseInt(opt[2].slice(0, 1), 16)),
        parseInt(opt[2].slice(1, 2), 16),
        parseInt(opt[2].slice(3, 4), 16)
    )
);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.misc.hmac.prototype" id="apidoc.module.utility2.sjcl.misc.hmac.prototype">module utility2.sjcl.misc.hmac.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.digest" id="apidoc.elem.utility2.sjcl.misc.hmac.prototype.digest">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>digest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Destroy the socket if the client has already sent a FIN packet.
//
if (!socket.readable || !socket.writable) return socket.destroy();

const digest = crypto
  .createHash(&apos;sha1&apos;)
  .update(key + GUID)
  .<span class="apidocCodeKeywordSpan">digest</span>(&apos;base64&apos;);

const headers = [
  &apos;HTTP/1.1 101 Switching Protocols&apos;,
  &apos;Upgrade: websocket&apos;,
  &apos;Connection: Upgrade&apos;,
  `Sec-WebSocket-Accept: ${digest}`
];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.encrypt" id="apidoc.elem.utility2.sjcl.misc.hmac.prototype.encrypt">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt on already updated hmac called!&quot;);this.update(a);return this.digest
(a)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function
(a){&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this
.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff&lt;a)throw new sjcl.exception.invalid(&quot;Cannot hash more than 2
^53 - 1 bits&quot;);if(&quot;undefined&quot;!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&amp;0x1ff);b&
lt;=a;b+=512)u(this,d.subarray(16*e,
16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&amp;0x1ff);b&lt;=a;b+=512)u(this,c.splice(0,16));return this},finalize:
function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&amp;15;a++)b.push(0
);b.push(Math.floor(this.l/0x100000000));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],
O:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64&gt;b;c++){e=!0;for(d=2;d*d&lt;=c;d++)if
(0===c%d){e=
!1;break}e&amp;&amp;(8&gt;b&amp;&amp;(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64&gt;c;c++)16&gt;c?d=b[c]:(
d=b[c+1&amp;15],e=b[c+14&amp;15],d=b[c&amp;15]=(d&gt;&gt;&gt;7^d&gt;&gt;&gt;18^d&gt;&gt;&gt;3^d&lt;&lt;25^d&lt;&lt;14)+(e&gt;&gt
;&gt;17^e&gt;&gt;&gt;19^e&gt;&gt;&gt;10^e&lt;&lt;15^e&lt;&lt;13)+b[c&amp;15]+b[c+9&amp;15]|0),d=d+q+(m&gt;&gt;&gt;6^m&gt;&gt;&gt
;11^m&gt;&gt;&gt;25^m&lt;&lt;26^m&lt;&lt;21^m&lt;&lt;7)+(r^m&amp;(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&amp;l^n&amp;(
k^l))+(k&gt;&gt;&gt;2^k&gt;&gt;&gt;13^k&gt;&gt;&gt;22^k&lt;&lt;30^k&lt;&lt;19^k&lt;&lt;10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[
2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=
f[7]+q|0}
sjcl.mode.ccm={name:&quot;ccm&quot;,G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl
.mode.ccm.G.indexOf(a);-1&lt;a&amp;&amp;sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c&lt
;b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e
||64;d=d||[];if(7&gt;k)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(f=2;4&gt;f&amp;&amp;l&
gt;&gt;&gt;8*f;f++);f&lt;15-k&amp;&amp;(f=15-k);c=h.clamp(c,
8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,
e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7&gt
;g)throw new sjcl.exception.invalid(&quot;ccm: iv must be at least 7 bytes&quot;);for(b=2;4&gt;b&amp;&amp;h&gt;&gt;&gt;8*b;b++);
b&lt;15-g&amp;&amp;(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal
(k.tag,a))throw new sjcl.exception.corrupt(&quot;ccm: tag doesn&apos;t match&quot;);
return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2&lt;&lt;2|f-1)];d=h.concat
(d,c);d[3]|=e;d=a.<span class="apidocCodeKeywordSpan">encrypt</span>(d);if(b.length)for(c=h.bitLength(b)/8,65279&gt;=c?g=[h.partial
(16,c)]:0xffffffff&gt;=c&amp;&amp;(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b&lt;g.length;b+=4)d=a.encrypt(k(d
,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4&gt;e||16&lt;e)throw
 new sjcl.exception.invalid(&quot;ccm: invalid tag length&quot;);
if(0xffffffff&lt;d.length||0xffffffff&lt;b.length)throw new sjcl.exception.bug(&quot;ccm: can&apos;t deal with 4GiB or more data
&quot;);c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d&lt;b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));
return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat
([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g&lt;k
;g+=4)g&gt;n&amp;&amp;(sjcl.mode.ccm.fa(g/
k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};
sjcl.mode.ocb2={name:&quot;ocb2&quot;,encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception
.invalid(&quot;ocb iv must be 128 bits&quot;);var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m
,p=[];d=d||[];e=e||64;for(g=0;g+4&lt;b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice
(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l
(n,l(c,h(c))));
d.length&amp;&amp;(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){
if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid(&quot;ocb iv must be 128 bits&quot;);e=e||64;var g=sjcl.mode
.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4&lt;r/32;
c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice
(c),p).concat([0,
0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&amp;&amp;(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice
(b,r)))throw new sjcl.exception.corrupt(&quot;ocb: tag doesn&apos;t match&quot;);return q.concat(h.clamp(m,p))},pmac:function(a,
b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4&lt;b.length;c+=4
)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128&gt;e.bitLength(c)&amp;&amp;(h=f(h,d(h)),c=e.concat(c,[-2147483648
,0,0,0]));g=f(g,c);
return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]&lt;&lt;1^a[1]&gt;&gt;&gt;31,a[1]&lt;&lt;1^a[2]&gt;&gt;&gt;31,a[2]&
lt;&lt;1^a[3]&gt;&gt;&gt;31,a[3]&lt;&lt;1^135*(a[0]&gt;&gt;&gt;31)]}};
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.mac" id="apidoc.elem.utility2.sjcl.misc.hmac.prototype.mac">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>mac
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt on already updated hmac called!&quot;);this.update(a);return this.digest
(a)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
   let Hmac;
   Hmac = local.sjcl.misc.hmac;
   return local.sjcl.codec.base64.fromBits(
       (new Hmac(
           local.sjcl.codec.utf8String.toBits(key),
           local.sjcl.hash.sha1
       )).<span class="apidocCodeKeywordSpan">mac</span>(local.sjcl.codec.utf8String.toBits(data))
   );
};

local.sjclHmacSha256Create = function (key, data) {
/*
* this function will create a base64-encoded sha256 hmac
* from the string key and string data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.reset" id="apidoc.elem.utility2.sjcl.misc.hmac.prototype.reset">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){this.R=new this.W(this.w[0]);this.aa=!1}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
++this.pos;
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.<span class="apidocCodeKeywordSpan">reset</span>(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.misc.hmac.prototype.update" id="apidoc.elem.utility2.sjcl.misc.hmac.prototype.update">
        function <span class="apidocSignatureSpan">utility2.sjcl.misc.hmac.prototype.</span>update
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.aa=!0;this.R.update(a)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Destroy the socket if the client has already sent a FIN packet.
//
if (!socket.readable || !socket.writable) return socket.destroy();

const digest = crypto
  .createHash(&apos;sha1&apos;)
  .<span class="apidocCodeKeywordSpan">update</span>(key + GUID)
  .digest(&apos;base64&apos;);

const headers = [
  &apos;HTTP/1.1 101 Switching Protocols&apos;,
  &apos;Upgrade: websocket&apos;,
  &apos;Connection: Upgrade&apos;,
  `Sec-WebSocket-Accept: ${digest}`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.prng" id="apidoc.module.utility2.sjcl.prng">module utility2.sjcl.prng</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prng" id="apidoc.elem.utility2.sjcl.prng.prng">
        function <span class="apidocSignatureSpan">utility2.sjcl.</span>prng
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b
=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this
.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.<span class="apidocCodeKeywordSpan">prng</span>(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.sjcl.prng.prototype" id="apidoc.module.utility2.sjcl.prng.prototype">module utility2.sjcl.prng.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.addEntropy" id="apidoc.elem.utility2.sjcl.prng.prototype.addEntropy">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>addEntropy
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b, c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this.U[c]=this.ha++);
void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot;:void 0===b&amp;&amp;(b=1);this.c[g].update
([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c
&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,f,a.length].concat
(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length]);this.c[g].update(a);break;default
:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array of numbers or string&quot;);this.m[g]+=b;this.
f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.<span class="apidocCodeKeywordSpan
">addEntropy</span>([b,c],2,&quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.addEventListener" id="apidoc.elem.utility2.sjcl.prng.prototype.addEventListener">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>addEventListener
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){this.K[a][this.ga++]=b}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    streamCleanup(xhr.reqStream);
    streamCleanup(xhr.resStream);
}, timeout);
// increment counter
ajaxProgressUpdate.counter |= 0;
ajaxProgressUpdate.counter += 1;
// handle evt
xhr.<span class="apidocCodeKeywordSpan">addEventListener</span>(&quot;abort&quot;, xhr.onEvent);
xhr.addEventListener(&quot;error&quot;, xhr.onEvent);
xhr.addEventListener(&quot;load&quot;, xhr.onEvent);
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.ea" id="apidoc.elem.utility2.sjcl.prng.prototype.ea">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>ea
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation
){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this
,0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.getProgress" id="apidoc.elem.utility2.sjcl.prng.prototype.getProgress">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>getProgress
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){a=this.T[a?a:this.M];return this.o&gt;=a?1:this.f&gt;a?1:this.f/a}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0&gt;d||0&gt;c)throw new sjcl.exception.invalid(&quot;invalid params to pbkdf2&
quot;);&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl
.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length&lt;(d||1);k++){
e=f=a.encrypt(n.concat(b,[k]));for(g=1;g&lt;c;g++)for(f=a.encrypt(f),h=0;h&lt;f.length;h++)e[h]^=f[h];l=l.concat(e)}d&amp;&amp;(
l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.<span class="apidocCodeKeywordSpan">getProgress</span>()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.isReady" id="apidoc.elem.utility2.sjcl.prng.prototype.isReady">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>isReady
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf()&gt;this.Z?this.J|this.I:
this.I:this.f&gt;=a?this.J|this.u:this.u}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.mode.gcm={name:&quot;gcm&quot;,encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(!0,a,
f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||
128;d=d||[];e&lt;=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(!1,a,f,d,c,e);if(!g.equal(a.tag,b))
throw new sjcl.exception.corrupt(&quot;gcm: tag doesn&apos;t match&quot;);return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray
.i;e=[0,0,
0,0];f=b.slice(0);for(c=0;128&gt;c;c++){(d=0!==(a[Math.floor(c/32)]&amp;1&lt;&lt;31-c%32))&amp;&amp;(e=h(e,f));g=0!==(f[3]&amp;1
);for(d=3;0&lt;d;d--)f[d]=f[d]&gt;&gt;&gt;1|(f[d-1]&amp;1)&lt;&lt;31;f[0]&gt;&gt;&gt;=1;g&amp;&amp;(f[0]^=-0x1f000000)}return e},
j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d&lt;e;d+=4)b[0]^=0xffffffff&amp;c[d],b[1]^=0xffffffff&amp;c[d+1],b[2]^=
0xffffffff&amp;c[d+2],b[3]^=0xffffffff&amp;c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,
q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);
g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math
.floor(h/0x100000000),h&amp;0xffffffff]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c
));for(l=0;l&lt;m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&amp;&amp;(d=sjcl
.mode.gcm.j(g,h,c));a=[Math.floor(r/0x100000000),r&amp;0xffffffff,Math.floor(p/0x100000000),p&amp;0xffffffff];d=sjcl.mode.gcm.j(
g,d,a);k=b.encrypt(e);
d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl
.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length&gt;e&amp;&amp;(a=b.hash(a));for(d=0;d&lt;e
;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};
sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid(&quot;encrypt
 on already updated hmac called!&quot;);this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new
 this.W(this.w[0]);this.aa=!1};sjcl.misc.hmac.prototype.update=function(a){this.aa=!0;this.R.update(a)};sjcl.misc.hmac.prototype
.digest=function(){var a=this.R.finalize(),a=(new this.W(this.w[1])).update(a).finalize();this.reset();return a};
sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E4;if(0&gt;d||0&gt;c)throw new sjcl.exception.invalid(&quot;invalid params to pbkdf2&
quot;);&quot;string&quot;===typeof a&amp;&amp;(a=sjcl.codec.utf8String.toBits(a));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl
.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length&lt;(d||1);k++){
e=f=a.encrypt(n.concat(b,[k]));for(g=1;g&lt;c;g++)for(f=a.encrypt(f),h=0;h&lt;f.length;h++)e[h]^=f[h];l=l.concat(e)}d&amp;&amp;(
l=n.clamp(l,d));return l};
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.<span class="apidocCodeKeywordSpan">isReady</span>(b);var e;if(
d===this.u)throw new sjcl.exception.notReady(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var
 f=0,g;this.Z=e[0]=(new Date).valueOf()+this.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length
&amp;&amp;(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.
c.length&amp;&amp;(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.la" id="apidoc.elem.utility2.sjcl.prng.prototype.la">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>la
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){C(this,1)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.ma" id="apidoc.elem.utility2.sjcl.prng.prototype.ma">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>ma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){C(this,2)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.oa" id="apidoc.elem.utility2.sjcl.prng.prototype.oa">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>oa
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){var b,c;try{b=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy
([b,c],2,&quot;mouse&quot;);C(this,0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.qa" id="apidoc.elem.utility2.sjcl.prng.prototype.qa">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>qa
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.randomWords" id="apidoc.elem.utility2.sjcl.prng.prototype.randomWords">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>randomWords
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady(&quot;generator isn&apos;t seeded&quot;);if(d&amp;
this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|
0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c
.length&amp;&amp;(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=this.h[d]+
1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0
,a)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this
.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&
quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector
,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent&amp;&amp;(document.detachEvent
(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.<span class="apidocCodeKeywordSpan">randomWords</span>(4,0)},e.defaults
),g;e.g(f,c);c=f.adata;&quot;string&quot;===typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===
typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof
 a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.
ks||2&gt;f.iv.length||
4&lt;f.iv.length)throw new sjcl.exception.invalid(&quot;json encrypt: invalid parameters&quot;);&quot;string&quot;===typeof a?(g
=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof sjcl.ecc.elGamal.publicKey&amp
;&amp;(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));&quot;string&quot;===typeof b&amp;&amp;(b=sjcl.codec.utf8String.toBits
(b));&quot;string&quot;===typeof c&amp;&amp;(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);
d.key=a;f.ct=&quot;ccm&quot;===f.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;
b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt
:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl
.json;b=e.g(e.g(e.g({},e.defaults),b),c,!0);var f,g;f=b.adata;&quot;string&quot;===typeof b.salt&amp;&amp;(b.salt=sjcl.codec.base64
.toBits(b.salt));&quot;string&quot;===typeof b.iv&amp;&amp;(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher
[b.cipher]||&quot;string&quot;===
typeof a&amp;&amp;100&gt;=b.iter||64!==b.ts&amp;&amp;96!==b.ts&amp;&amp;128!==b.ts||128!==b.ks&amp;&amp;192!==b.ks&amp;&amp;0x100
!==b.ks||!b.iv||2&gt;b.iv.length||4&lt;b.iv.length)throw new sjcl.exception.invalid(&quot;json decrypt: invalid parameters&quot;);&
quot;string&quot;===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&amp;&amp;a instanceof
 sjcl.ecc.elGamal.secretKey&amp;&amp;(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));&quot;string&quot;===typeof
 f&amp;&amp;(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f=&quot;ccm&quot;===
b.mode&amp;&amp;sjcl.arrayBuffer&amp;&amp;sjcl.arrayBuffer.ccm&amp;&amp;b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt
(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String
.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c=&quot;{&quot;,
d=&quot;&quot;;for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid(&quot;json encode
: invalid property name&quot;);c+=d+&apos;&quot;&apos;+
b+&apos;&quot;:&apos;;d=&quot;,&quot;;switch(typeof a[b]){case &quot;number&quot;:case &quot;boolean&quot;:c+=a[b];break;case &quot
;string&quot;:c+=&apos;&quot;&apos;+escape(a[b])+&apos;&quot;&apos;;break;case &quot;object&quot;:c+=&apos;&quot;&apos;+sjcl.codec
.base64.fromBits(a[b],0)+&apos;&quot;&apos;;break;default:throw new sjcl.exception.bug(&quot;json encode: unsupported type&quot;);}}
return c+&quot;}&quot;},decode:function(a){a=a.replace(/\s/g,&quot;&quot;);if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);a=a.replace(/^\{|\}$/g,&quot;&quot;).split(/,/);var b={},c,d;for(c=0;c&lt;a.length;c++){if(!(d=a[c].match(/^\s*(?:([&quot;&apos;]?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|&quot;([a-z0-9+\/%*_.@=\-]*)&quot;|(true|false))$/i)))throw new sjcl.exception.invalid(&quot;json decode: this isn&apos;t json!&quot;);
null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape
(d[4]):null!=d[5]&amp;&amp;(b[d[2]]=&quot;true&quot;===d[5])}return b},g:function(a,b,c){void 0===a&amp;&amp;(a={});if(void 0===
b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&amp;&amp;void 0!==a[d]&amp;&amp;a[d]!==b[d])throw new sjcl.exception.invalid
(&quot;required parameter overridden&quot;);a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&amp;&
amp;a[d]!==b[d]&amp;&amp;(c[d]=a[d]);return c},ra:function(a,
b){var c={},d;for(d=0;d&lt;b.length;d++)void 0!==a[b[d]]&amp;&amp;(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl
.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1E3;c=c[a
]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&amp;&amp;b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt
?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.removeEventListener" id="apidoc.elem.utility2.sjcl.prng.prototype.removeEventListener">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>removeEventListener
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete
e[d]}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.<span class="apidocCodeKeywordSpan">removeEventListener
</span>(&quot;load&quot;,this.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),
window.removeEventListener(&quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,
this.a.accelerometerCollector,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent
&amp;&amp;(document.detachEvent(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.setDefaultParanoia" id="apidoc.elem.utility2.sjcl.prng.prototype.setDefaultParanoia">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>setDefaultParanoia
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(a, b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use it only for testing&quot;!==b)throw new sjcl.exception.invalid
(&quot;Setting paranoia=0 will ruin your security; use it only for testing&quot;);this.M=a}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.startCollectors" id="apidoc.elem.utility2.sjcl.prng.prototype.startCollectors">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>startCollectors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:B(this,this.oa),keyboardCollector:B(this,this.la
),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window.addEventListener)window.addEventListener(&quot;load
&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot;keypress&quot;,this
.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),window.addEventListener(&quot;touchmove
&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;onload&quot;,this.a.loadTimeCollector),document.attachEvent
(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug
(&quot;can&apos;t attach event&quot;);
this.D=!0}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.sjcl.prng.prototype.stopCollectors" id="apidoc.elem.utility2.sjcl.prng.prototype.stopCollectors">
        function <span class="apidocSignatureSpan">utility2.sjcl.prng.prototype.</span>stopCollectors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){this.D&amp;&amp;(window.removeEventListener?(window.removeEventListener(&quot;load&quot;,this.a.loadTimeCollector,!1),window.removeEventListener
(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.removeEventListener(&quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener
(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent
&amp;&amp;(document.detachEvent(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.swgg" id="apidoc.module.utility2.swgg">module utility2.swgg</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.swgg.Blob" id="apidoc.elem.utility2.swgg.Blob">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>Blob
        <span class="apidocSignatureSpan">(list, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Blob = function (list, opt) {
<span class="apidocCodeCommentSpan">    /*
     * this function will emulate in node, browser&apos;s Blob class
     * https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob
     */
</span>    this.buf = local.bufferConcat(list.map(function (elem) {
        if (
            typeof elem === &quot;string&quot;
            || Object.prototype.toString.call(elem) === &quot;[object Uint8Array]&quot;
        ) {
            return elem;
        }
        // emulate in node, browser-behavior - auto-stringify arbitrary data
        return String(elem);
    }));
    this.type = (opt &amp;&amp; opt.type) || &quot;&quot;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// run shared js-env code - function
(function () {
local.testCase_FormData_default = function (opt, onError) {
/*
* this function will test FormData&apos;s default handling-behavior
*/
   opt = {};
   opt.blob1 = new local.<span class="apidocCodeKeywordSpan">Blob</span>([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ]);
   opt.blob2 = new local.Blob([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ], {
       type: &quot;text/plain; charset=utf-8&quot;
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.FormData" id="apidoc.elem.utility2.swgg.FormData">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>FormData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FormData = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a serverLocal-compatible FormData instance
 * The FormData(form) constructor must run these steps:
 * 1. Let fd be a new FormData object.
 * 2. If form is given, set fd&apos;s entries to the result
 *    of constructing the form data set for form. (not implemented)
 * 3. Return fd.
 * https://xhr.spec.whatwg.org/#dom-formdata
 */
</span>    this.entryList = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
})[0];
// init default
local.objectSetDefault(opt, {
    inForm: (
        that._consumes0 === &quot;multipart/form-data&quot;
        ? new local.<span class="apidocCodeKeywordSpan">FormData</span>()
        : &quot;&quot;
    ),
    inHeader: {},
    inPath: that._path.replace((
        /#.*?$/
    ), &quot;&quot;),
    inQuery: &quot;&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.Module" id="apidoc.elem.utility2.swgg.Module">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>Module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init example.js
tmp = process.cwd() + &quot;/example.js&quot;;
// jslint code
local.jslintAndPrint(code, tmp);
// cover code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.<span class="apidocCodeKeywordSpan">Module</span>(tmp);
require.cache[tmp] = module;
// load code into module
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_buildApidoc_default" id="apidoc.elem.utility2.swgg._testCase_buildApidoc_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildApidoc_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApidoc_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApidoc&apos;s default handling-behavior
 */
</span>    let require2;
    require2 = function (file) {
    /*
     * this function will require &lt;file&gt; in sandbox-env
     */
        let exports;
        let mockDict;
        let mockList;
        mockList = [
            [
                globalThis, {
                    setImmediate: local.nop,
                    setInterval: local.nop,
                    setTimeout: local.nop
                }
            ]
        ];
        [
            [
                local, &quot;child_process&quot;
            ], [
                local, &quot;cluster&quot;
            ], [
                local, &quot;http&quot;
            ], [
                local, &quot;https&quot;
            ], [
                local, &quot;net&quot;
            ], [
                local, &quot;repl&quot;
            ], [
                local.events, &quot;prototype&quot;
            ], [
                globalThis, &quot;process&quot;
            ], [
                local.stream, &quot;prototype&quot;
            ], [
                process, &quot;stdin&quot;
            ]
        ].forEach(function (elem, tmp) {
            tmp = elem[0][elem[1]];
            mockDict = {};
            Object.keys(tmp).forEach(function (key) {
                if (typeof tmp[key] === &quot;function&quot; &amp;&amp; !(
                    /^(?:fs\.Read|fs\.read|process\.binding|process\.dlopen)/
                ).test(elem[1] + &quot;.&quot; + key)) {
                    mockDict[key] = function () {
                        return;
                    };
                }
            });
            mockList.push([
                tmp, mockDict
            ]);
        });
        local.testMock(mockList, function (onError) {
            local.tryCatchOnError(function () {
                exports = require(file);
            }, local.onErrorDefault);
            onError();
        }, local.onErrorThrow);
        return exports;
    };
    if (
        local.isBrowser
        || local.env.npm_config_mode_coverage
        || local.env.npm_config_mode_test_case
        !== &quot;testCase_buildApidoc_default&quot;
    ) {
        onError(undefined, opt);
        return;
    }
    // save apidoc.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/apidoc.html&quot;,
        local.apidocCreate(local.objectAssignDefault(opt, {
            blacklistDict: local,
            require: require2
        }))
    );
    console.error(
        &quot;created apidoc file &quot; + process.cwd() + &quot;/tmp/build/apidoc.html\n&quot;
    );
    onError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_buildApidoc_default = function (opt, onError) {
/*
* this function will test buildApidoc&apos;s default handling-behavior
*/
   local.<span class="apidocCodeKeywordSpan">_testCase_buildApidoc_default</span>({
       blacklistDict: {}
   }, onError, opt);
};

local.testCase_buildApp_default = function (opt, onError) {
/*
* this function will test buildApp&apos;s default handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_buildApp_default" id="apidoc.elem.utility2.swgg._testCase_buildApp_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildApp_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApp_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApp&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
    local.buildApp(opt, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            testCase_buildReadme_default: local.nop,
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default(null, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildApp_default</span>(null, local.nop);
    local._testCase_buildLib_default(null, local.nop);
    local._testCase_buildReadme_default(null, local.nop);
    local._testCase_buildTest_default(null, local.nop);
    local._testCase_webpage_default(null, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default(null, local.nop);
    onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_buildLib_default" id="apidoc.elem.utility2.swgg._testCase_buildLib_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildLib_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildLib_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildLib&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildLib({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default(null, local.nop);
    local._testCase_buildApp_default(null, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildLib_default</span>(null, local.nop);
    local._testCase_buildReadme_default(null, local.nop);
    local._testCase_buildTest_default(null, local.nop);
    local._testCase_webpage_default(null, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default(null, local.nop);
    onError(undefined, opt);
}, onError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_buildReadme_default" id="apidoc.elem.utility2.swgg._testCase_buildReadme_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildReadme_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildReadme_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildReadme&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildReadme({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                testCase_buildTest_default: local.nop
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildReadme_default</span>(null, local.nop);
        local._testCase_buildTest_default(null, local.nop);
        local._testCase_webpage_default(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_buildTest_default" id="apidoc.elem.utility2.swgg._testCase_buildTest_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_buildTest_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildTest_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildTest&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildTest({}, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local._testCase_buildReadme_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildTest_default</span>(null, local.nop);
        local._testCase_webpage_default(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg._testCase_webpage_default" id="apidoc.elem.utility2.swgg._testCase_webpage_default">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>_testCase_webpage_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_webpage_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test webpage&apos;s default handling-behavior
 */
</span>    local.domStyleValidate();
    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    local.browserTest({
        fileScreenshot: (
            local.env.npm_config_dir_build
            + &quot;/screenshot.&quot; + local.env.MODE_BUILD + &quot;.browser.%2F.png&quot;
        ),
        url: (
            local.assetsDict[&quot;/&quot;].indexOf(
                &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;
            ) &gt;= 0
            ? local.serverLocalHost
            + &quot;?modeTest=1&amp;timeoutDefault=&quot; + local.timeoutDefault
            : local.serverLocalHost
            + &quot;/assets.utility2.base.html?modeTest=1&amp;timeoutDefault=1&quot;
        ) + &quot;&amp;modeTestCase=&quot; + local.modeTestCase.replace((
            /_?testCase_webpage_default/
        ), &quot;&quot;)
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default(null, local.nop);
        local._testCase_buildApp_default(null, local.nop);
        local._testCase_buildLib_default(null, local.nop);
        local._testCase_buildReadme_default(null, local.nop);
        local._testCase_buildTest_default(null, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_webpage_default</span>(null, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default(null, local.nop);
        onError(undefined, opt);
    }, onError);
};

local.testCase_childProcessSpawnWithTimeout_default = function (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.ajax" id="apidoc.elem.utility2.swgg.ajax">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>ajax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send an ajax-req
 * with given &lt;opt&gt;.url and callback &lt;onError&gt;
 * with err and timeout handling
 * example usage:
    local.ajax({
        data: &quot;hello world&quot;,
        header: {&quot;x-header-hello&quot;: &quot;world&quot;},
        method: &quot;POST&quot;,
        url: &quot;/index.html&quot;
    }, function (err, xhr) {
        console.log(xhr.statusCode);
        console.log(xhr.responseText);
    });
 */
</span>    let ajaxProgressUpdate;
    let bufferValidateAndCoerce;
    let isDone;
    let local2;
    let onError2;
    let onEvent;
    let stack;
    let streamCleanup;
    let timeout;
    let tmp;
    let xhr;
    let xhrInit;
    // init local2
    local2 = opt.local2 || local.utility2 || {};
    // init function
    ajaxProgressUpdate = local2.ajaxProgressUpdate || function () {
        return;
    };
    bufferValidateAndCoerce = local2.bufferValidateAndCoerce || function (
        buf,
        mode
    ) {
    /*
     * this function will validate and coerce/convert
     * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
     */
        // coerce ArrayBuffer to Buffer
        if (Object.prototype.toString.call(buf) === &quot;[object ArrayBuffer]&quot;) {
            buf = new Uint8Array(buf);
        }
        // convert Buffer to utf8
        if (mode === &quot;string&quot; &amp;&amp; typeof buf !== &quot;string&quot;) {
            buf = String(buf);
        }
        return buf;
    };
    onEvent = function (evt) {
    /*
     * this function will handle events
     */
        if (Object.prototype.toString.call(evt) === &quot;[object Error]&quot;) {
            xhr.err = xhr.err || evt;
            xhr.onEvent({
                type: &quot;error&quot;
            });
            return;
        }
        // init statusCode
        xhr.statusCode = (xhr.statusCode || xhr.status) | 0;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
        case &quot;load&quot;:
            if (isDone) {
                return;
            }
            isDone = true;
            // decrement counter
            ajaxProgressUpdate.counter = Math.max(
                ajaxProgressUpdate.counter - 1,
                0
            );
            ajaxProgressUpdate();
            // handle abort or err event
            switch (!xhr.err &amp;&amp; evt.type) {
            case &quot;abort&quot;:
            case &quot;error&quot;:
                xhr.err = new Error(&quot;ajax - event &quot; + evt.type);
                break;
            case &quot;load&quot;:
                if (xhr.statusCode &gt;= 400) {
                    xhr.err = new Error(
                        &quot;ajax - statusCode &quot; + xhr.statusCode
                    );
                }
                break;
            }
            // debug statusCode / method / url
            if (xhr.err) {
                xhr.statusCode = xhr.statusCode || 500;
                xhr.err.statusCode = xhr.statusCode;
                tmp = (
                    (
                        local.isBrowser
                        ? &quot;browser&quot;
                        : &quot;node&quot;
                    )
                    + &quot; - &quot; + xhr.statusCode + &quot; &quot; + xhr.method + &quot; &quot; + xhr.url
                    + &quot;\n&quot;
                );
                xhr.err.message = tmp + xhr.err.message;
                xhr.err.stack = tmp + xhr.err.stack;
            }
            // update resHeaders
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
            if (xhr.getAllResponseHeaders) {
                xhr.getAllResponseHeaders().replace((
                    /(.*?):\u0020*(.*?)\r\n/g
                ), function (ignore, key, val) {
                    xhr.resHeaders[key.toLowerCase()] = val;
                });
            }
            // debug ajaxResponse
            xhr.resContentLength =...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/* validateLineSortedReset */
local.ajax = function (opt, onError) {
/*
* this function will send an ajax-req
* with given &lt;opt&gt;.url and callback &lt;onError&gt;
* with err and timeout handling
* example usage:
   local.<span class="apidocCodeKeywordSpan">ajax</span>({
       data: &quot;hello world&quot;,
       header: {&quot;x-header-hello&quot;: &quot;world&quot;},
       method: &quot;POST&quot;,
       url: &quot;/index.html&quot;
   }, function (err, xhr) {
       console.log(xhr.statusCode);
       console.log(xhr.responseText);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.ajaxProgressUpdate" id="apidoc.elem.utility2.swgg.ajaxProgressUpdate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>ajaxProgressUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajaxProgressUpdate = function () {
    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ) {
        return;
    }
    // test-run
    globalThis.utility2_modeTest += 1;
}
// visual notification - testRun
local.<span class="apidocCodeKeywordSpan">ajaxProgressUpdate</span>();
// mock console.error
consoleError = console.error;
isCoverage = (
    typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
    &amp;&amp; Object.keys(globalThis.__coverage__).length
);
console.error = function (...argList) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.apiAjax" id="apidoc.elem.utility2.swgg.apiAjax">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>apiAjax
        <span class="apidocSignatureSpan">(that, opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apiAjax = function (that, opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send a swagger-api ajax-req with the operation that
 */
</span>    let tmp;
    local.objectSetDefault(opt, {
        data: &quot;&quot;,
        operation: that,
        paramDict: {},
        url: &quot;&quot;
    });
    if (opt.modeDefault) {
        local.normalizeSwaggerParamDict(opt);
    }
    // try to validate paramDict
    opt.err = local.swaggerValidateDataParameters({
        // normalize paramDict
        data: local.normalizeSwaggerParamDict({
            modeNoDefault: opt.modeNoDefault,
            operation: that,
            paramDict: local.jsonCopy(opt.paramDict)
        }).paramDict,
        dataReadonlyRemove: opt.paramDict,
        prefix: [
            &quot;operation&quot;, that._methodPath
        ],
        parameters: that.parameters,
        swaggerJson: local.swaggerJson
    })[0];
    // init default
    local.objectSetDefault(opt, {
        inForm: (
            that._consumes0 === &quot;multipart/form-data&quot;
            ? new local.FormData()
            : &quot;&quot;
        ),
        inHeader: {},
        inPath: that._path.replace((
            /#.*?$/
        ), &quot;&quot;),
        inQuery: &quot;&quot;,
        headers: {},
        method: that._method,
        responseType: (
            that._consumes0.indexOf(&quot;application/octet-stream&quot;) === 0
            ? &quot;arraybuffer&quot;
            : &quot;&quot;
        )
    });
    // init paramDict
    that.parameters.forEach(function (schemaP) {
        tmp = opt.paramDict[schemaP.name];
        if (local.isNullOrUndefined(tmp)) {
            return;
        }
        // serialize array
        if (Array.isArray(tmp) &amp;&amp; schemaP.in !== &quot;body&quot;) {
            switch (
                schemaP.collectionFormat || schemaP[&quot;x-swgg-collectionFormat&quot;]
            ) {
            case &quot;json&quot;:
                tmp = JSON.stringify(tmp);
                break;
            case &quot;multi&quot;:
                tmp.forEach(function (value) {
                    opt[(
                        schemaP.in === &quot;formData&quot;
                        ? &quot;inForm&quot;
                        : &quot;inQuery&quot;
                    )] += (
                        &quot;&amp;&quot; + encodeURIComponent(schemaP.name) + &quot;=&quot;
                        + encodeURIComponent(
                            local.schemaPItemsType(schemaP) === &quot;string&quot;
                            ? value
                            : JSON.stringify(value)
                        )
                    );
                });
                return;
            case &quot;pipes&quot;:
                tmp = tmp.join(&quot;|&quot;);
                break;
            case &quot;ssv&quot;:
                tmp = tmp.join(&quot; &quot;);
                break;
            case &quot;tsv&quot;:
                tmp = tmp.join(&quot;\t&quot;);
                break;
            // default to csv
            default:
                tmp = tmp.join(&quot;,&quot;);
            }
        } else if (
            typeof tmp !== &quot;string&quot;
            &amp;&amp; !(tmp &amp;&amp; tmp.constructor === local.Blob)
        ) {
            tmp = JSON.stringify(tmp);
        }
        switch (schemaP.in) {
        case &quot;body&quot;:
            opt.inBody = tmp;
            break;
        case &quot;formData&quot;:
            switch (that._consumes0) {
            case &quot;application/xml&quot;:
                // init xml header
                if (!opt.inForm) {
                    opt.inForm += &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot;;
                }
                opt.inForm += (
                    &quot;\n&lt;&quot; + schemaP.name + &quot;&gt;&quot; + &quot;&lt;![CDATA[&quot;
                    + tmp.replace((
                        /\]\]&gt;/g
                    ), &quot;]]&amp;#x3e;&quot;) + &quot;]]&gt;&lt;/&quot; + schemaP.name + &quot;&gt;&quot;
                );...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// update apiDict
that = local.jsonCopy(that);
local.apiDict[key.join(&quot;.&quot;)] = that;
local.apiDict[that._methodPath] = that;
// init ajax
that.ajax = function (swaggerJson, onError) {
    return local.<span class="apidocCodeKeywordSpan">apiAjax</span>(that, swaggerJson, onError);
};
that._ajaxToString = that.ajax.toString().replace(&quot;{&quot;, String(
    &quot;{\n&quot;
    + &quot;/*\n&quot;
    + &quot; * this function will run the api-call &quot;
    + JSON.stringify(that._methodPath) + &quot;\n&quot;
    + &quot; * example usage:&quot; + String(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.apiUpdate" id="apidoc.elem.utility2.swgg.apiUpdate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>apiUpdate
        <span class="apidocSignatureSpan">(swaggerJson)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apiUpdate = function (swaggerJson) {
<span class="apidocCodeCommentSpan">/*
 * this function will update the swagger-api dict of api-calls
 */
</span>    let pathDict;
    let tmp;
    swaggerJson = swaggerJson || {};
    // normalize swaggerJson
    swaggerJson = local.normalizeSwaggerJson(swaggerJson, {
        objectSetDescription: function (dict) {
            if (typeof dict === &quot;object&quot; &amp;&amp; dict &amp;&amp; !dict.$ref) {
                if (Array.isArray(dict[&quot;x-swgg-descriptionLineList&quot;])) {
                    dict.description = (
                        dict[&quot;x-swgg-descriptionLineList&quot;].join(&quot;\n&quot;)
                    );
                }
                if (!(
                    dict === swaggerJson.externalDocs
                    || dict === swaggerJson.info
                )) {
                    dict.description = dict.description || &quot;no description&quot;;
                }
            }
        }
    });
    // init apiDict
    local.apiDict = local.apiDict || {};
    // init swaggerJson
    local.swaggerJson = local.swaggerJson || {
        &quot;basePath&quot;: &quot;/api/v0&quot;,
        &quot;definitions&quot;: {
            &quot;BuiltinFile&quot;: {
                &quot;properties&quot;: {
                    &quot;_id&quot;: {
                        &quot;readOnly&quot;: true,
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;_timeCreated&quot;: {
                        &quot;format&quot;: &quot;date-time&quot;,
                        &quot;readOnly&quot;: true,
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;_timeUpdated&quot;: {
                        &quot;format&quot;: &quot;date-time&quot;,
                        &quot;readOnly&quot;: true,
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileBlob&quot;: {
                        &quot;format&quot;: &quot;byte&quot;,
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileContentType&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileDescription&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileFilename&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileInputName&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;fileSize&quot;: {
                        &quot;minimum&quot;: 0,
                        &quot;type&quot;: &quot;integer&quot;
                    },
                    &quot;fileUrl&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    },
                    &quot;id&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    }
                }
            },
            &quot;BuiltinJsonapiResponse&quot;: {
                &quot;properties&quot;: {
                    &quot;data&quot;: {
                        &quot;items&quot;: {
                            &quot;type&quot;: &quot;object&quot;
                        },
                        &quot;type&quot;: &quot;array&quot;
                    },
                    &quot;errors&quot;: {
                        &quot;items&quot;: {
                            &quot;type&quot;: &quot;object&quot;
                        },
                        &quot;type&quot;: &quot;array&quot;
                    },
                    &quot;meta&quot;: {
                        &quot;type&quot;: &quot;object&quot;
                    }
                }
            },
            &quot;BuiltinUser&quot;: {
                &quot;properties&quot;: {
                    &quot;_id&quot;: {
                        &quot;readOnly&quot;: true,...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * 2. npm install swgg\n\
 *     $ npm install swgg\n\
 * 3. run code below to initialize nodejs swgg-client\n\
 * 4. (optional) edit file swagger.json to suit your needs\n\
 */\n\
let swgg;\n\
swgg = require(&quot;swgg&quot;);\n\
swgg.<span class="apidocCodeKeywordSpan">apiUpdate</span>(require(&quot;./swagger.json&quot;));\n\
console.log(&quot;printing currently loaded apis ...&quot;);\n\
Object.keys(swgg.apiDict).sort().forEach(function (key) {\n\
    console.log(&quot;swgg.apiDict[&quot; + JSON.stringify(key) + &quot;].ajax&quot;);\n\
});\n\
console.log(&quot;initialized nodejs swgg-client&quot;);\n\
&lt;/pre&gt;\n\
&lt;div class=&quot;color777 reset&quot;&gt;[ &lt;span&gt;base url&lt;/span&gt;: {{basePath}} ]&lt;/div&gt;\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.apidocCreate" id="apidoc.elem.utility2.swgg.apidocCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>apidocCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create the apidoc from &lt;opt&gt;.dir
 */
</span>    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given &lt;module&gt;
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(&quot;.&quot;);
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(&quot;.&quot;);
        elem.id = encodeURIComponent(&quot;apidoc.elem.&quot; + prefix + &quot;.&quot; + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + &quot; &lt;span class=\&quot;apidocSignatureSpan\&quot;&gt;&quot;
            + elem.moduleName + &quot;.&lt;/span&gt;&quot; + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
        if (elem.typeof !== &quot;function&quot;) {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || &quot;n/a&quot;
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), &quot;&quot;).replace((
                /,/g
            ), &quot;, &quot;).replace((
                /\s+/g
            ), &quot; &quot;);
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), &quot;&lt;span class=\&quot;apidocCodeCommentSpan\&quot;&gt;$1&lt;/span&gt;&quot;).replace((
            /^function\u0020\(/
        ), key + &quot; = function (&quot;);
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp(&quot;((?:\n.*?){8}\\.)(&quot; + key + &quot;)(\\((?:.*?\n){8})&quot;),
                function (ignore, match1, match2, match3) {
                    elem.example = &quot;...&quot; + trimStart(
                        local.stringHtmlSafe(match1)
                        + &quot;&lt;span class=\&quot;apidocCodeKeywordSpan\&quot;&gt;&quot;
                        + local.stringHtmlSafe(match2)
                        + &quot;&lt;/span&gt;&quot;
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + &quot;\n...&quot;;
                    return &quot;&quot;;
                }
            );
            return elem.example;
        });
        elem.example = elem.example || &quot;n/a&quot;;
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = local.path.resolve(opt.dir, file);
            console.error(&quot;apidocCreate - readExample &quot; + file);
            result = &quot;&quot;;
            result = local.identity(
                &quot;\n\n\n\n\n\n\n\n&quot;
                // bug-workaround - truncate example to manageable size
                + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
                + &quot;\n\n\n\n\n\n\n\n&quot;
            ).replace((
                /\r\n*/g
            ), &quot;\n&quot;);
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = &quot;&quot;;
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (text) {
    /...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.write(local.<span class="apidocCodeKeywordSpan">apidocCreate</span>({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.assert" id="apidoc.elem.utility2.swgg.assert">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.assertJsonEqual" id="apidoc.elem.utility2.swgg.assertJsonEqual">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>assertJsonEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) === JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa === bb, message || [
        aa, bb
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // test http GET handling-behavior
    local.ajax({
        url: &quot;assets.hello.txt&quot;
    }, opt.gotoNext);
    break;
case 2:
    // validate responseText
    local.<span class="apidocCodeKeywordSpan">assertJsonEqual</span>(data.responseText, local.stringHelloEmoji);
    // test http GET 304 cache handling-behavior
    local.ajax({
        headers: {
            &quot;If-Modified-Since&quot;: (
                new Date(Date.now() + 0xffff).toUTCString()
            )
        },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.assertJsonNotEqual" id="apidoc.elem.utility2.swgg.assertJsonNotEqual">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>assertJsonNotEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonNotEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) !== JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa !== bb, [
        aa
    ], message || aa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &quot;&quot;, 0, false, null, undefined
        ].forEach(function (bb, jj) {
            if (ii === jj) {
                // test assertJsonEqual&apos;s handling-behavior
                local.assertJsonEqual(aa, bb);
            } else {
                // test assertJsonNotEqual&apos;s handling-behavior
                local.<span class="apidocCodeKeywordSpan">assertJsonNotEqual</span>(aa, bb);
            }
        });
    });
    onError(undefined, opt);
};

local.testCase_base64Xxx_default = function (opt, onError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.assertOrThrow" id="apidoc.elem.utility2.swgg.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;message&gt; if &lt;passed&gt; is falsy
 */
</span>    let err;
    if (passed) {
        return;
    }
    err = (
        (
            message
            &amp;&amp; typeof message.message === &quot;string&quot;
            &amp;&amp; typeof message.stack === &quot;string&quot;
        )
        // if message is errObj, then leave as is
        ? message
        : new Error(
            typeof message === &quot;string&quot;
            // if message is a string, then leave as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message, undefined, 4)
        )
    );
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(text).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.base64FromBuffer" id="apidoc.elem.utility2.swgg.base64FromBuffer">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>base64FromBuffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64FromBuffer = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to base64
 * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/StringView#The_code
 */
</span>    let ii;
    let mod3;
    let text;
    let uint24;
    let uint6ToB64;
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    }
    buf = buf || [];
    text = &quot;&quot;;
    uint24 = 0;
    uint6ToB64 = function (uint6) {
        return (
            uint6 &lt; 26
            ? uint6 + 65
            : uint6 &lt; 52
            ? uint6 + 71
            : uint6 &lt; 62
            ? uint6 - 4
            : uint6 === 62
            ? 43
            : 47
        );
    };
    ii = 0;
    while (ii &lt; buf.length) {
        mod3 = ii % 3;
        uint24 |= buf[ii] &lt;&lt; (16 &gt;&gt;&gt; mod3 &amp; 24);
        if (mod3 === 2 || buf.length - ii === 1) {
            text += String.fromCharCode(
                uint6ToB64(uint24 &gt;&gt;&gt; 18 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 12 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 6 &amp; 63),
                uint6ToB64(uint24 &amp; 63)
            );
            uint24 = 0;
        }
        ii += 1;
    }
    return text.replace((
        /A(?=A$|$)/gm
    ), &quot;=&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? &quot;abcd1234&quot;
    : Number(
        (1 + Math.random()) * 0x10000000000000
    ).toString(36).slice(1)
);
switch (schemaP.format) {
case &quot;byte&quot;:
    value = local.<span class="apidocCodeKeywordSpan">base64FromBuffer</span>(value);
    break;
case &quot;date&quot;:
case &quot;date-time&quot;:
    value = new Date().toISOString();
    break;
case &quot;email&quot;:
    value = value + &quot;@example.com&quot;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.base64ToBuffer" id="apidoc.elem.utility2.swgg.base64ToBuffer">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>base64ToBuffer
        <span class="apidocSignatureSpan">(b64, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToBuffer = function (b64, mode) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert &lt;b64&gt; to Uint8Array
 * https://gist.github.com/wang-bin/7332335
 */
</span>    let buf;
    let byte;
    let chr;
    let ii;
    let jj;
    let map64;
    let mod4;
    b64 = b64 || &quot;&quot;;
    buf = new Uint8Array(b64.length); // 3/4
    byte = 0;
    jj = 0;
    map64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
    mod4 = 0;
    ii = 0;
    while (ii &lt; b64.length) {
        chr = map64.indexOf(b64[ii]);
        if (chr &gt;= 0) {
            mod4 %= 4;
            if (mod4 === 0) {
                byte = chr;
            } else {
                byte = byte * 64 + chr;
                buf[jj] = 255 &amp; (byte &gt;&gt; ((-2 * (mod4 + 1)) &amp; 6));
                jj += 1;
            }
            mod4 += 1;
        }
        ii += 1;
    }
    // optimization - create resized-view of buf
    buf = buf.subarray(0, jj);
    return local.bufferValidateAndCoerce(buf, mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!data) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    local.serverRespondHeadSet(req, res, null, {
        &quot;Content-Type&quot;: data.fileContentType
    });
    res.end(local.<span class="apidocCodeKeywordSpan">base64ToBuffer</span>(data.fileBlob));
    break;
case &quot;userLogout&quot;:
    opt.gotoNext();
    break;
default:
    opt.gotoNext(null, data, meta);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.base64ToUtf8" id="apidoc.elem.utility2.swgg.base64ToUtf8">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>base64ToUtf8
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToUtf8 = function (b64) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert &lt;b64&gt; to utf8
 */
</span>    return local.base64ToBuffer(b64, &quot;string&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // validate signature
        local.assertOrThrow(local.sjcl.codec.base64url.fromBits(
            new Hmac(local.sjcl.codec.base64url.toBits(
                local.jwtAes256KeyInit(key)
            )).encrypt(token[0] + &quot;.&quot; + token[1])
        ) === token[2]);
        // return decoded data
        token = JSON.parse(local.<span class="apidocCodeKeywordSpan">base64ToUtf8</span>(token[1]));
        // https://tools.ietf.org/html/rfc7519#section-4.1
        // validate jwt-registered-headers
        local.assertOrThrow(!token.exp || token.exp &gt;= timeNow);
        local.assertOrThrow(!token.nbf || token.nbf &lt;= timeNow);
        return token;
    }, local.nop) || {};
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.blobRead" id="apidoc.elem.utility2.swgg.blobRead">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>blobRead
        <span class="apidocSignatureSpan">(blob, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobRead = function (blob, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will read from &lt;blob&gt;
 */
</span>    let isDone;
    let reader;
    if (blob &amp;&amp; blob.constructor &amp;&amp; blob.constructor === local.FormData) {
        blob.read(onError);
        return;
    }
    if (!local.isBrowser) {
        onError(undefined, local.bufferValidateAndCoerce(blob.buf));
        return;
    }
    reader = new FileReader();
    reader.onabort = function (evt) {
        if (isDone) {
            return;
        }
        isDone = true;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
            onError(new Error(&quot;blobRead - &quot; + evt.type));
            break;
        case &quot;load&quot;:
            onError(
                undefined,
                Object.prototype.toString.call(reader.result)
                === &quot;[object ArrayBuffer]&quot;
                // convert ArrayBuffer to Uint8Array
                ? new Uint8Array(reader.result)
                : reader.result
            );
            break;
        }
    };
    reader.onerror = reader.onabort;
    reader.onload = reader.onabort;
    reader.readAsArrayBuffer(blob);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
switch ((xhr.data &amp;&amp; xhr.data.constructor) || true) {
// Blob
// https://developer.mozilla.org/en-US/docs/Web/API/Blob
case local2.Blob:
// FormData
// https://developer.mozilla.org/en-US/docs/Web/API/FormData
case local2.FormData:
    local2.<span class="apidocCodeKeywordSpan">blobRead</span>(xhr.data, function (err, data) {
        if (err) {
            xhr.onEvent(err);
            return;
        }
        // send data
        xhr.send(data);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.browserTest" id="apidoc.elem.utility2.swgg.browserTest">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>browserTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">browserTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will spawn google-puppeteer-process to test &lt;opt&gt;.url
 */
</span>    let browser;
    let fileScreenshot;
    let isDone;
    let onParallel;
    let page;
    let testId;
    let testName;
    let timerTimeout;
    // init utility2_testReport
    globalThis.utility2_testReport = globalThis.utility2_testReport || {
        coverage: globalThis.__coverage__,
        testPlatformList: [
            {
                name: (
                    local.isBrowser
                    ? (
                        &quot;browser - &quot;
                        + location.pathname + &quot; - &quot; + navigator.userAgent
                    )
                    : &quot;node - &quot; + process.platform + &quot; &quot; + process.version
                ) + &quot; - &quot; + new Date().toISOString(),
                testCaseList: []
            }
        ]
    };
    if (opt.modeTestReportCreate) {
        return;
    }
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        // node - init
        case 1:
            onParallel = local.onParallel(opt.gotoNext);
            onParallel.counter += 1;
            isDone = 0;
            testId = Math.random().toString(16);
            testName = new local.url.URL(opt.url).pathname;
            testName = (
                local.env.MODE_BUILD + &quot;.browser.&quot;
                + encodeURIComponent(testName.replace(
                    &quot;/build..&quot;
                    + local.env.CI_BRANCH
                    + &quot;..&quot; + local.env.CI_HOST,
                    &quot;/build&quot;
                ))
            );
            fileScreenshot = (
                local.env.npm_config_dir_build + &quot;/screenshot.&quot;
                + testName
                + &quot;.png&quot;
            );
            opt.url = opt.url.replace(
                &quot;{{timeExit}}&quot;,
                Date.now() + local.timeoutDefault
            );
            // init timerTimeout
            timerTimeout = local.onTimeout(
                opt.gotoNext,
                local.timeoutDefault,
                testName
            );
            // create puppeteer browser
            local.puppeteerLaunch({
                args: [
                    &quot;--headless&quot;,
                    &quot;--incognito&quot;,
                    &quot;--no-sandbox&quot;,
                    &quot;--remote-debugging-port=0&quot;
                ],
                dumpio: !opt.modeSilent,
                executablePath: local.env.CHROME_BIN,
                ignoreDefaultArgs: true
            }).then(opt.gotoNextData);
            break;
        case 2:
            browser = data;
            browser.newPage().then(opt.gotoNextData);
            break;
        case 3:
            page = data;
            page.goto(opt.url).then(opt.gotoNextData);
            break;
        case 4:
            onParallel.counter += 1;
            setTimeout(function () {
                page.screenshot({
                    path: fileScreenshot
                }).then(function () {
                    console.error(
                        &quot;\nbrowserTest - created screenshot file &quot;
                        + fileScreenshot
                        + &quot;\n&quot;
                    );
                    onParallel();
                });
            }, 100);
            page.evaluate(function (testId) {
                window.utility2_testId = testId;
            }, testId);
            page.on(&quot;metrics&quot;, function (metric) {
                if (isDone &gt;= 1 || metric.title !== testId) {
                    return;
                }
                isDone = 1;
                opt.gotoNext();
            });
            break;
        case 5:
            page.evaluate(function () {
                return JSON.stringify(window.utility2_testReport);
            }).then(opt.gotoNextData);
            break;
        case 6:
            data = JSON.parse(data);...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict = {};

local.cliDict[&quot;utility2.browserTest&quot;] = function () {
/*
* &lt;urlList&gt; &lt;mode&gt;
* will browser-test in parallel, comma-separated &lt;urlList&gt; with given &lt;mode&gt;
*/
   local.<span class="apidocCodeKeywordSpan">browserTest</span>({
       url: process.argv[3]
   }, local.onErrorDefault);
};

local.cliDict[&quot;utility2.githubCrudContentDelete&quot;] = function () {
/*
* &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.bufferConcat" id="apidoc.elem.utility2.swgg.bufferConcat">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferConcat
        <span class="apidocSignatureSpan">(bufList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferConcat = function (bufList) {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s Buffer.concat
 */
</span>    let byteLength;
    let ii;
    let isString;
    let jj;
    let result;
    isString = true;
    result = [
        &quot;&quot;
    ];
    byteLength = 0;
    bufList.forEach(function (buf) {
        if (buf !== 0 &amp;&amp; !(buf &amp;&amp; buf.length)) {
            return;
        }
        // optimization - concat string
        if (isString &amp;&amp; typeof buf === &quot;string&quot;) {
            result[0] += buf;
            return;
        }
        isString = null;
        buf = local.bufferValidateAndCoerce(buf);
        byteLength += buf.byteLength;
        result.push(buf);
    });
    // optimization - return string
    if (isString) {
        return result[0];
    }
    result[0] = local.bufferValidateAndCoerce(result[0]);
    byteLength += result[0].byteLength;
    bufList = result;
    result = local.bufferValidateAndCoerce(new Uint8Array(byteLength));
    ii = 0;
    bufList.forEach(function (buf) {
        jj = 0;
        while (jj &lt; buf.byteLength) {
            result[ii] = buf[jj];
            ii += 1;
            jj += 1;
        }
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
// init boundary
ii = 0;
jj = local.bufferIndexOfSubBuffer(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.<span class="apidocCodeKeywordSpan">bufferConcat</span>([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
while (true) {
    jj = local.bufferIndexOfSubBuffer(
        req.bodyRaw,
        boundary,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.bufferIndexOfSubBuffer" id="apidoc.elem.utility2.swgg.bufferIndexOfSubBuffer">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferIndexOfSubBuffer
        <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferIndexOfSubBuffer = function (buf, subBff, fromIndex) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;buf&gt; from &lt;fromIndex&gt; for position of &lt;subBff&gt;
 */
</span>    let ii;
    let jj;
    let kk;
    if (!subBff.length) {
        return 0;
    }
    ii = fromIndex || 0;
    while (ii &lt; buf.length) {
        kk = ii;
        jj = 0;
        while (jj &lt; subBff.length) {
            if (subBff[jj] !== buf[kk]) {
                break;
            }
            kk += 1;
            jj += 1;
        }
        if (jj === subBff.length) {
            return kk - jj;
        }
        ii += 1;
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
req.swgg.bodyParsed = {};
req.swgg.bodyMeta = {};
crlf = new Uint8Array([
    0x0d, 0x0a
]);
// init boundary
ii = 0;
jj = local.<span class="apidocCodeKeywordSpan">bufferIndexOfSubBuffer</span>(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.bufferConcat([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.bufferRandomBytes" id="apidoc.elem.utility2.swgg.bufferRandomBytes">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferRandomBytes
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferRandomBytes = function (length) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a Buffer with given &lt;length&gt;,
 * filled with cryptographically-strong random-values
 */
</span>    return (
        (
            typeof window === &quot;object&quot;
            &amp;&amp; window.crypto
            &amp;&amp; typeof window.crypto.getRandomValues === &quot;function&quot;
        )
        ? window.crypto.getRandomValues(new Uint8Array(length))
        : require(&quot;crypto&quot;).randomBytes(length)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.jwtAes256KeyCreate = function () {
/*
* this function will create a random, aes-256-base64url-jwt-key
*/
   return local.normalizeJwtBase64Url(
       local.base64FromBuffer(local.<span class="apidocCodeKeywordSpan">bufferRandomBytes</span>(32))
   );
};

local.jwtAes256KeyInit = function (key) {
/*
* this function will init aes-256-base64url-jwt-&lt;key&gt;
* https://jwt.io/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.bufferToUtf8" id="apidoc.elem.utility2.swgg.bufferToUtf8">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferToUtf8
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferToUtf8 = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to utf8
 */
</span>    return local.bufferValidateAndCoerce(buf, &quot;string&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let name;
// if req is already parsed, then goto next
if (!req.swgg.operation || !local.isNullOrUndefined(req.swgg.bodyParsed)) {
    next();
    return;
}
headerParse = function () {
    local.<span class="apidocCodeKeywordSpan">bufferToUtf8</span>(req.bodyRaw.slice(ii, ii + 1024)).replace((
        /^content-disposition:\u0020?form-data;(.+?)\r\n(?:content-type:\u0020?(.*?)$)?/im
    ), function (ignore, match1, match2) {
        data = {
            contentType: match2,
            name: &quot;&quot;
        };
        match1.replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.bufferValidateAndCoerce" id="apidoc.elem.utility2.swgg.bufferValidateAndCoerce">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>bufferValidateAndCoerce
        <span class="apidocSignatureSpan">(buf, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferValidateAndCoerce = function (buf, mode) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate and coerce/convert
 * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
 */
</span>    // validate not 0
    if (buf !== 0) {
        buf = buf || &quot;&quot;;
    }
    if (typeof buf === &quot;string&quot; &amp;&amp; mode === &quot;string&quot;) {
        return buf;
    }
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    // validate instanceof Uint8Array
    } else if (Object.prototype.toString.call(buf) !== &quot;[object Uint8Array]&quot;) {
        throw new Error(
            &quot;bufferValidateAndCoerce - value is not instanceof &quot;
            + &quot;ArrayBuffer, String, or Uint8Array&quot;
        );
    }
    // convert Uint8Array to utf8
    if (mode === &quot;string&quot;) {
        return new TextDecoder().decode(buf);
    }
    // coerce Uint8Array to Buffer
    if (globalThis.Buffer &amp;&amp; Buffer.isBuffer &amp;&amp; !Buffer.isBuffer(buf)) {
        Object.setPrototypeOf(buf, Buffer.prototype);
    }
    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           }
           mod4 += 1;
       }
       ii += 1;
   }
   // optimization - create resized-view of buf
   buf = buf.subarray(0, jj);
   return local.<span class="apidocCodeKeywordSpan">bufferValidateAndCoerce</span>(buf, mode);
};

local.base64ToUtf8 = function (b64) {
/*
* this function will convert &lt;b64&gt; to utf8
*/
   return local.base64ToBuffer(b64, &quot;string&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.buildApp" id="apidoc.elem.utility2.swgg.buildApp">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>buildApp
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildApp = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build app with given &lt;opt&gt;
 */
</span>    opt = local.objectSetDefault(opt, {
        assetsList: []
    });
    // build assets
    local.fsRmrfSync(&quot;tmp/build/app&quot;);
    local.onParallelList({
        list: [
            {
                file: &quot;/LICENSE&quot;,
                url: &quot;/LICENSE&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
                url: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;
            }, {
                file: &quot;/assets.app.js&quot;,
                url: &quot;/assets.app.js&quot;
            }, {
                file: &quot;/assets.example.html&quot;,
                url: &quot;/assets.example.html&quot;
            }, {
                file: &quot;/assets.example.js&quot;,
                url: &quot;/assets.example.js&quot;
            }, {
                file: &quot;/assets.swgg.html&quot;,
                url: &quot;/assets.swgg.html&quot;
            }, {
                file: &quot;/assets.swgg.swagger.json&quot;,
                url: &quot;/assets.swgg.swagger.json&quot;
            }, {
                file: &quot;/assets.swgg.swagger.petstore.json&quot;,
                url: &quot;/assets.swgg.swagger.petstore.json&quot;
            }, {
                file: &quot;/assets.swgg.swagger.server.json&quot;,
                url: &quot;/assets.swgg.swagger.server.json&quot;
            }, {
                file: &quot;/assets.test.js&quot;,
                url: &quot;/assets.test.js&quot;
            }, {
                file: &quot;/assets.utility2.html&quot;,
                url: &quot;/assets.utility2.html&quot;
            }, {
                file: &quot;/assets.utility2.base.html&quot;,
                url: &quot;/assets.utility2.base.html&quot;
            }, {
                file: &quot;/assets.utility2.rollup.js&quot;,
                url: &quot;/assets.utility2.rollup.js&quot;
            }, {
                file: &quot;/index.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/index.rollup.html&quot;,
                url: &quot;/index.rollup.html&quot;
            }, {
                file: &quot;/jsonp.utility2.stateInit&quot;,
                url: (
                    &quot;/jsonp.utility2.stateInit&quot;
                    + &quot;?callback=window.utility2.stateInit&quot;
                )
            }
        ].concat(opt.assetsList)
    }, function (option2, onParallel) {
        option2 = option2.elem;
        onParallel.counter += 1;
        local.ajax(option2, function (err, xhr) {
            // handle err
            local.assertOrThrow(!err, err);
            // jslint file
            local.jslintAndPrint(xhr.responseText, option2.file, {
                conditional: true,
                coverage: local.env.npm_config_mode_coverage
            });
            // handle err
            local.assertOrThrow(
                !local.jslint.jslintResult.errMsg,
                local.jslint.jslintResult.errMsg
            );
            local.fsWriteFileWithMkdirpSync(
                &quot;tmp/build/app&quot; + option2.file,
                xhr.response
            );
            onParallel();
        });
    }, function (err) {
        // handle err
        local.assertOrThrow(!err, err);
        // test standalone assets.app.js
        local.fsWriteFileWithMkdirpSync(
            &quot;tmp/buildApp/assets.app.js&quot;,
            local.assetsDict[&quot;/assets.app.js&quot;]
        );
        local.childProcessSpawnWithTimeout(&quot;node&quot;, [
            &quot;assets.app.js&quot;
        ], {
            cwd: &quot;tmp/buildApp&quot;,
            env: {
                PATH: local.env.PATH,
                PORT: (Math.random()...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
   local.<span class="apidocCodeKeywordSpan">buildApp</span>(opt, onError);
};

local._testCase_buildLib_default = function (opt, onError) {
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.buildLib" id="apidoc.elem.utility2.swgg.buildLib">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>buildLib
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildLib = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build lib with given &lt;opt&gt;
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        dataFrom: local.fsReadFileOrEmptyStringSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            &quot;utf8&quot;
        ),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.my_app.template.js&quot;],
            opt
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize top-level comment-description
        (
            /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
        ),
        // customize body after /* validateLineSortedReset */
        (
            /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize local for assets.utility2.rollup.js
    if (
        local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
        &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
    ) {
        opt.dataTo = opt.dataTo.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // save lib
    result = opt.dataTo;
    if (!local.env.npm_config_mode_coverage) {
        local.fs.writeFileSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            result
        );
    }
    opt.customize(opt);
    onError();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildLib</span>({}, onError);
};

local._testCase_buildReadme_default = function (opt, onError) {
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.buildReadme" id="apidoc.elem.utility2.swgg.buildReadme">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>buildReadme
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildReadme = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build readme with given &lt;opt&gt; my-app-lite template
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        // reset toc
        dataFrom: local.fsReadFileOrEmptyStringSync(
            &quot;README.md&quot;,
            &quot;utf8&quot;
        ).replace((
            /\n#\u0020table\u0020of\u0020contents$[\S\s]*?\n\n\n\n/m
        ), &quot;\n# table of contents\n\n\n\n&quot;),
        packageJsonRgx: (
            /\n#\u0020package.json\n```json\n([\S\s]*?)\n```\n/
        )
    });
    // render dataTo
    opt.dataTo = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.readme.template.md&quot;],
        opt
    );
    // init package.json
    opt.dataFrom.replace(opt.packageJsonRgx, function (match0, match1) {
        // remove null from package.json
        opt.packageJson = JSON.parse(match1.replace((
            /\u0020{4}&quot;.*?&quot;:\u0020null,?$/gm
        ), &quot;&quot;));
        opt.packageJson.description = opt.dataFrom.split(&quot;\n&quot;)[1];
        local.tryCatchOnError(function () {
            local.objectSetDefault(opt.packageJson, {
                nameLib: local.fsReadFileOrEmptyStringSync(
                    &quot;./package.json&quot;,
                    &quot;json&quot;
                ).nameLib
            });
        }, local.nop);
        opt.packageJson = local.objectSetDefault(opt.packageJson, {
            nameLib: opt.packageJson.name.replace((
                /\W/g
            ), &quot;_&quot;),
            nameOriginal: opt.packageJson.name
        });
        opt.packageJson = local.objectSetDefault(
            opt.packageJson,
            JSON.parse(local.templateRenderMyApp(opt.packageJsonRgx.exec(
                local.assetsDict[&quot;/assets.readme.template.md&quot;]
            )[1], opt)),
            2
        );
        // avoid npm-installing that
        delete opt.packageJson.devDependencies[opt.packageJson.name];
        // reset scripts
        opt.packageJson.scripts = {
            &quot;build-ci&quot;: &quot;./npm_scripts.sh&quot;,
            env: &quot;env&quot;,
            eval: &quot;./npm_scripts.sh&quot;,
            &quot;heroku-postbuild&quot;: &quot;./npm_scripts.sh&quot;,
            postinstall: &quot;./npm_scripts.sh&quot;,
            start: &quot;./npm_scripts.sh&quot;,
            test: &quot;./npm_scripts.sh&quot;,
            utility2: &quot;./npm_scripts.sh&quot;
        };
        // save package.json
        local.fs.writeFileSync(
            &quot;package.json&quot;,
            local.jsonStringifyOrdered(opt.packageJson, undefined, 4) + &quot;\n&quot;
        );
        // re-render dataTo
        opt.dataTo = local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.readme.template.md&quot;],
            opt
        );
        opt.dataTo = opt.dataTo.replace(
            opt.packageJsonRgx,
            match0.replace(
                match1,
                local.jsonStringifyOrdered(opt.packageJson, undefined, 4)
            )
        );
    });
    // search-and-replace - customize dataTo
    [
        // customize name and description
        (
            /.*?\n.*?\n/
        ),
        // customize cdn-download
        (
            /\n#\u0020cdn\u0020download\n[\S\s]*?\n\n\n\n/
        ),
        // customize live-web-demo
        (
            /\n#\u0020live\u0020web\u0020demo\n[\S\s]*?\n\n\n\n/
        ),
        // customize to-do
        (
            /\n####\u0020todo\n[\S\s]*?\n\n\n\n/
        ),
        // customize example.js - shared js-env code - init-before
        (
            /\nglobalThis\.local\u0020=\u0020local;\n[^`]*?\n\/\/\u0020run\u0020browser\u0020js\-env\u0020code\u0020-\u0020init-
test\n/
        ),
        // customize example.js - html-body
        (
            /\n&lt;!--\u0020custom-html-start\u0020--&gt;\\n\\\n[^`]*?\n&lt;!--\u0020custom-html-end\u0020--&gt;\\n\\\n/
        ),
        // customize build_ci - shBuildCiAfter...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildReadme</span>({}, onError);
};

local._testCase_buildTest_default = function (opt, onError) {
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.buildTest" id="apidoc.elem.utility2.swgg.buildTest">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>buildTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build test with given &lt;opt&gt;
 */
</span>    let result;
    local.objectSetDefault(opt, {
        customize: local.nop,
        dataFrom: local.fsReadFileOrEmptyStringSync(&quot;test.js&quot;, &quot;utf8&quot;),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.test.template.js&quot;],
            opt
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize shared js\-env code - function
        (
            /\n\}\(\)\);\n\n\n\n\/\/\u0020run\u0020shared\u0020js\-env\u0020code\u0020-\u0020function\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize require(&quot;utility2&quot;)
    [
        &quot;./assets.utility2.rollup.js&quot;,
        &quot;./lib.utility2.js&quot;
    ].forEach(function (file) {
        if (local.fs.existsSync(file)) {
            opt.dataTo = opt.dataTo.replace(
                &quot;require(\&quot;utility2\&quot;)&quot;,
                &quot;require(\&quot;&quot; + file + &quot;\&quot;)&quot;
            );
        }
    });
    opt.customize(opt);
    // save test.js
    result = opt.dataTo;
    local.fs.writeFileSync(&quot;test.js&quot;, result);
    onError();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildTest</span>({}, onError);
};

local._testCase_webpage_default = function (opt, onError) {
/*
* this function will test webpage&apos;s default handling-behavior
*/
   local.domStyleValidate();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.childProcessSpawnWithTimeout" id="apidoc.elem.utility2.swgg.childProcessSpawnWithTimeout">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>childProcessSpawnWithTimeout
        <span class="apidocSignatureSpan">(command, args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithTimeout = function (command, args, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run like child_process.spawn,
 * but with auto-timeout after timeout milliseconds
 * example usage:
    let child = local.childProcessSpawnWithTimeout(
        &quot;/bin/sh&quot;,
        [&quot;-c&quot;, &quot;echo hello world&quot;],
        {stdio: [&quot;ignore&quot;, 1, 2], timeout: 5000}
    );
    child.on(&quot;error&quot;, console.error);
    child.on(&quot;exit&quot;, function (exitCode) {
        console.error(&quot;exitCode &quot; + exitCode);
    });
 */
</span>    let child;
    let child_process;
    let timerTimeout;
    child_process = require(&quot;child_process&quot;);
    // spawn child
    child = child_process.spawn(command, args, opt).on(&quot;exit&quot;, function () {
        // cleanup timerTimeout
        try {
            process.kill(timerTimeout.pid);
        } catch (ignore) {}
    });
    // init timerTimeout
    timerTimeout = child_process.spawn(
        // convert timeout to integer seconds with 2 second delay
        &quot;sleep &quot;
        + Math.floor(
            0.001 * (Number(opt &amp;&amp; opt.timeout) || local.timeoutDefault)
            + 2
        )
        + &quot;; kill -9 &quot; + child.pid + &quot; 2&gt;/dev/null&quot;,
        {
            shell: true,
            stdio: &quot;ignore&quot;
        }
    );
    return child;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handle err
local.assertOrThrow(!err, err);
// test standalone assets.app.js
local.fsWriteFileWithMkdirpSync(
    &quot;tmp/buildApp/assets.app.js&quot;,
    local.assetsDict[&quot;/assets.app.js&quot;]
);
local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithTimeout</span>(&quot;node&quot;, [
    &quot;assets.app.js&quot;
], {
    cwd: &quot;tmp/buildApp&quot;,
    env: {
        PATH: local.env.PATH,
        PORT: (Math.random() * 0x10000) | 0x8000,
        npm_config_timeout_exit: 5000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.childProcessSpawnWithUtility2" id="apidoc.elem.utility2.swgg.childProcessSpawnWithUtility2">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>childProcessSpawnWithUtility2
        <span class="apidocSignatureSpan">(script, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithUtility2 = function (script, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run child_process.spawn, with lib.utility2.sh sourced
 */
</span>    require(&quot;child_process&quot;).spawn(
        &quot;. &quot; + (process.env.npm_config_dir_utility2 || __dirname)
        + &quot;/lib.utility2.sh; &quot; + script,
        {
            shell: true,
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        }
    ).on(&quot;exit&quot;, function (exitCode) {
        onError(exitCode &amp;&amp; Object.assign(new Error(), {
            exitCode
        }));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // test __dirname handling-behavior
        [
            process.env, {
                npm_config_dir_utility2: &quot;&quot;
            }
        ]
    ], function (onError) {
        local.local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithUtility2</span>(&quot;undefined&quot;, function (err
) {
            // handle err
            local.assertOrThrow(err, err);
        });
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.cliRun" id="apidoc.elem.utility2.swgg.cliRun">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let text;
        let textDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        textDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            text = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            textDict[text] = textDict[text] || (ii + 2);
            ii = textDict[text];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(text);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(text).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        text = &quot;&quot;;
        text += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        text += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.coalesce" id="apidoc.elem.utility2.swgg.coalesce">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(text);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.corsBackendHostInject" id="apidoc.elem.utility2.swgg.corsBackendHostInject">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>corsBackendHostInject
        <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsBackendHostInject = function (url, backendHost, rgx, location) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;location&gt;.host is a github site,
 * inject &lt;backendHost&gt; into &lt;url&gt; with given &lt;rgx&gt;
 */
</span>    location = (
        location
        || (typeof window === &quot;object&quot; &amp;&amp; window &amp;&amp; window.location)
    );
    if (!(backendHost &amp;&amp; location &amp;&amp; (
        /\bgithub.io$/
    ).test(location.host))) {
        return url;
    }
    // init github-branch
    location.pathname.replace((
        /\/build\.\.(alpha|beta|master)\.\.travis-ci\.org\//
    ), function (ignore, match1) {
        backendHost = backendHost.replace(&quot;-alpha.&quot;, &quot;-&quot; + match1 + &quot;.&quot;);
    });
    return url.replace(rgx || (
        /.*?($)/m
    ), backendHost + &quot;$1&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_corsBackendHostInject_default = function (opt, onError) {
/*
* this function will corsBackendHostInject&apos;s default handling-behavior
*/
   // test null-case handling-behavior
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">corsBackendHostInject</span>(), undefined);
   // test override-all handling-behavior
   local.assertJsonEqual(local.corsBackendHostInject(
       &quot;cc.com&quot;,
       &quot;aa-alpha.bb.com&quot;,
       null,
       {
           host: &quot;github.io&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.corsForwardProxyHostIfNeeded" id="apidoc.elem.utility2.swgg.corsForwardProxyHostIfNeeded">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>corsForwardProxyHostIfNeeded
        <span class="apidocSignatureSpan">(xhr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsForwardProxyHostIfNeeded = function (xhr) {
<span class="apidocCodeCommentSpan">/*
 * this function will return xhr.corsForwardProxyHost, if needed
 */
</span>    return (
        local.isBrowser
        &amp;&amp; local.env.npm_package_nameLib
        &amp;&amp; (
            /^https?:\/\//
        ).test(xhr.url)
        &amp;&amp; xhr.url.indexOf(xhr.location.protocol + &quot;//&quot; + xhr.location.host)
        !== 0
        &amp;&amp; (
            /\.github\.io$/
        ).test(xhr.location.host)
        &amp;&amp; xhr.corsForwardProxyHost !== &quot;disabled&quot;
        &amp;&amp; (xhr.corsForwardProxyHost || &quot;https://h1-proxy1.herokuapp.com&quot;)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.functionOrNop(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.<span class="apidocCodeKeywordSpan">corsForwardProxyHostIfNeeded</span>(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawDecrypt" id="apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawDecrypt">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>cryptoAesXxxCbcRawDecrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
 * example usage:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // base64
    if (opt.mode === &quot;base64&quot;) {
        data = local.base64ToBuffer(data);
    }
    // normalize data
    if (Object.prototype.toString.call(data) !== &quot;[object Uint8Array]&quot;) {
        data = new Uint8Array(data);
    }
    // init iv
    iv = data.subarray(0, 16);
    // optimization - create resized-view of data
    data = data.subarray(16);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            cipher = crypto.createDecipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv
            );
            onError(undefined, Buffer.concat([
                cipher.update(data), cipher.final()
            ]));
        });
        return;
    }
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;decrypt&quot;
    ]).then(function (key) {
        crypto.subtle.decrypt({
            iv,
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            onError(undefined, new Uint8Array(data));
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawDecrypt</span>({
           data,
           key,
           mode
       }, console.log);
   });
*/
   let cipher;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawEncrypt" id="apidoc.elem.utility2.swgg.cryptoAesXxxCbcRawEncrypt">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>cryptoAesXxxCbcRawEncrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawEncrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc encrypt with given &lt;opt&gt;
 * example usage:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // init iv
    iv = new Uint8Array((((data.byteLength) &gt;&gt; 4) &lt;&lt; 4) + 32);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            // init iv
            iv.set(crypto.randomBytes(16));
            cipher = crypto.createCipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv.subarray(0, 16)
            );
            data = cipher.update(data);
            iv.set(data, 16);
            iv.set(cipher.final(), 16 + data.byteLength);
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        });
        return;
    }
    // init iv
    iv.set(crypto.getRandomValues(new Uint8Array(16)));
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;encrypt&quot;
    ]).then(function (key) {
        crypto.subtle.encrypt({
            iv: iv.subarray(0, 16),
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            iv.set(new Uint8Array(data), 16);
            // base64
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
/*
* this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
* example usage:
   data = new Uint8Array([1,2,3]);
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawEncrypt</span>({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dateGetWeekOfMonth" id="apidoc.elem.utility2.swgg.dateGetWeekOfMonth">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dateGetWeekOfMonth
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfMonth = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return sunday-based week-of-month from &lt;date&gt;
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    return Math.ceil((date.getUTCDate() + new Date(
        date.getUTCFullYear(),
        date.getUTCMonth(),
        1
    ).getUTCDay()) / 7) - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dateGetWeekOfYear" id="apidoc.elem.utility2.swgg.dateGetWeekOfYear">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dateGetWeekOfYear
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfYear = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return ISO week-of-year from &lt;date&gt;
 *
 * Based on information at:
 *
 *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR
 *
 * Algorithm is to find nearest thursday, it&apos;s year
 * is the year of the week number. Then get weeks
 * between that date and the first day of that year.
 *
 * Note that dates in one year can be weeks of previous
 * or next year, overlap is up to 3 days.
 *
 * e.g. 2014/12/29 is Monday in week  1 of 2015
 *      2012/1/1   is Sunday in week 52 of 2011
 *
 * https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    // Set to nearest Thursday: current date + 4 - current day number
    // Make Sunday&apos;s day number 7
    date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
    // Calculate full weeks to nearest Thursday
    return Math.ceil((((
        date
        // Get first day of year
        - new Date(Date.UTC(date.getUTCFullYear(), 0, 1))
    ) / 86400000) + 1) / 7);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dateUtcFromLocal" id="apidoc.elem.utility2.swgg.dateUtcFromLocal">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dateUtcFromLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcFromLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert local-&lt;date&gt; to utc-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?$/
    ).test(date), &quot;invalid local-date &quot; + date);
    if (!timezoneOffset) {
        return new Date(date).toISOString();
    }
    return new Date(
        new Date(date + &quot;Z&quot;).getTime() + timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dateUtcToLocal" id="apidoc.elem.utility2.swgg.dateUtcToLocal">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dateUtcToLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcToLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert utc-&lt;date&gt; to local-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?Z$/
    ).test(date), &quot;invalid utc-date &quot; + date);
    timezoneOffset = timezoneOffset || new Date(date).getTimezoneOffset();
    return new Date(
        new Date(date).getTime() - timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dbFieldRandomCreate" id="apidoc.elem.utility2.swgg.dbFieldRandomCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dbFieldRandomCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbFieldRandomCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random dbField from &lt;opt&gt;.schemaP
 */
</span>    let depth;
    let ii;
    let max;
    let min;
    let schemaP;
    let value;
    depth = (
        Number.isFinite(opt.depth)
        ? opt.depth
        : 3
    );
    schemaP = opt.schemaP;
    schemaP = schemaP.schema || schemaP;
    if (schemaP.readOnly) {
        return;
    }
    // init default
    if (opt.modeNotRandom &amp;&amp; !local.isNullOrUndefined(schemaP.default)) {
        return local.jsonCopy(schemaP.default);
    }
    // init enum-value
    if (schemaP.enum) {
        value = (
            opt.modeNotRandom
            ? schemaP.enum[0]
            : local.listGetElementRandom(schemaP.enum)
        );
        return (
            local.schemaPType(schemaP) === &quot;array&quot;
            ? [
                value
            ]
            : value
        );
    }
    // init default
    value = null;
    switch (local.schemaPType(schemaP)) {
    // 5.3. Validation keywords for arrays
    case &quot;array&quot;:
        if (depth &lt;= 0) {
            break;
        }
        value = [];
        ii = 0;
        while (ii &lt; Math.min(
            // 5.3.2. maxItems
            schemaP.maxItems || 2,
            // 5.3.3. minItems
            schemaP.minItems || 2,
            // 5.3.4. uniqueItems
            schemaP.uniqueItems
            ? 2
            : 1
        )) {
            // recurse dbFieldRandomCreate
            value.push(local.dbFieldRandomCreate({
                depth: depth - 1,
                modeNotRandom: opt.modeNotRandom,
                schemaP: local.schemaPItems(schemaP)
            }));
            ii += 1;
        }
        break;
    case &quot;boolean&quot;:
        value = (
            opt.modeNotRandom
            ? false
            : Boolean(Math.random() &gt; 0.5)
        );
        break;
    // 5.1. Validation keywords for numeric instances (number and integer)
    case &quot;integer&quot;:
    case &quot;number&quot;:
        max = schemaP.maximum;
        min = schemaP.minimum;
        if (opt.modeNotRandom) {
            value = (
                !(0 &lt; min || max &lt; 0)
                ? 0
                : min || max
            );
        } else {
            if (!(Number.isFinite(max) &amp;&amp; Number.isFinite(min))) {
                if (!Number.isFinite(max) &amp;&amp; !Number.isFinite(min)) {
                    max = 1000;
                    min = 0;
                } else if (Number.isFinite(max)) {
                    min = max - 1000;
                } else {
                    max = min + 1000;
                }
            }
            // exclusiveMaximum and exclusiveMinimum for float
            value = (
                min
                + (max - min) * Math.max(Math.random(), min * 0.000000000000001)
            );
            if (local.schemaPType(schemaP) === &quot;integer&quot;) {
                value = Math.round(value);
            }
        }
        max = schemaP.maximum;
        min = schemaP.minimum;
        // exclusiveMaximum for integer
        if (schemaP.exclusiveMaximum &amp;&amp; value === max) {
            value -= 1;
        }
        // exclusiveMinimum for integer
        if (schemaP.exclusiveMaximum &amp;&amp; value === min) {
            value += 1;
        }
        // multipleOf
        if (schemaP.multipleOf &gt; 0) {
            value = schemaP.multipleOf * Math.floor(value / schemaP.multipleOf);
            if (value &lt; min || (schemaP.exclusiveMinimum &amp;&amp; value &lt;= min)) {
                value += schemaP.multipleOf;
            }
        }
        break;
    // 5.2. Validation keywords for strings
    case &quot;string&quot;:
        value = (
            opt.modeNotRandom
            ? &quot;abcd1234&quot;
            : Number(
                (1 + Math.random()) * 0x10000000000000
            ).toString(36).slice(1)
        );
        switch (schemaP.format) {
        case &quot;byte&quot;:
            value = local.b...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    schemaP.minItems || 2,
    // 5.3.4. uniqueItems
    schemaP.uniqueItems
    ? 2
    : 1
)) {
    // recurse dbFieldRandomCreate
    value.push(local.<span class="apidocCodeKeywordSpan">dbFieldRandomCreate</span>({
        depth: depth - 1,
        modeNotRandom: opt.modeNotRandom,
        schemaP: local.schemaPItems(schemaP)
    }));
    ii += 1;
}
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dbRowListRandomCreate" id="apidoc.elem.utility2.swgg.dbRowListRandomCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dbRowListRandomCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbRowListRandomCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a dbRowList of &lt;opt&gt;.length random dbRow&apos;s
 */
</span>    let ii;
    ii = 0;
    while (ii &lt; opt.length) {
        opt.dbRowList.push(local.dbRowRandomCreate(opt));
        ii += 1;
    }
    return opt.dbRowList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.dbRowRandomCreate" id="apidoc.elem.utility2.swgg.dbRowRandomCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>dbRowRandomCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dbRowRandomCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random dbRow from opt.properties
 */
</span>    let dbRow;
    let ii;
    let properties;
    dbRow = {};
    opt = local.objectSetDefault(opt, {
        override: local.nop,
        prefix: [
            &quot;dbRow&quot;
        ]
    });
    properties = local.swaggerValidateDataSchema({
        // dereference property
        modeDereference: true,
        prefix: opt.prefix,
        schema: opt.schema,
        swaggerJson: local.swaggerJson
    });
    properties = local.jsonCopy((properties &amp;&amp; properties.properties) || {});
    ii = Object.keys(properties).length;
    while (ii &lt; (opt.schema &amp;&amp; opt.schema.minProperties)) {
        properties[&quot;property&quot; + ii] = {
            type: &quot;string&quot;
        };
        ii += 1;
    }
    Object.keys(properties).forEach(function (key) {
        dbRow[key] = local.dbFieldRandomCreate({
            depth: opt.depth,
            modeNotRandom: opt.modeNotRandom,
            schemaP: local.swaggerValidateDataSchema({
                // dereference property
                modeDereference: true,
                prefix: opt.prefix.concat([
                    key
                ]),
                schema: properties[key],
                swaggerJson: local.swaggerJson
            })
        });
    });
    dbRow = local.jsonCopy(local.objectSetOverride(dbRow, opt.override(opt)));
    // try to validate data
    local.tryCatchOnError(function () {
        local.swaggerValidateDataSchema({
            data: dbRow,
            prefix: opt.prefix,
            schema: opt.schema,
            swaggerJson: local.swaggerJson
        });
    }, local.onErrorDefault);
    return dbRow;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;
// 5.4. Validation keywords for objects
default:
    if (depth &lt;= 0) {
        break;
    }
    // recurse dbRowRandomCreate
    value = local.<span class="apidocCodeKeywordSpan">dbRowRandomCreate</span>({
        depth: depth - 1,
        modeNotRandom: opt.modeNotRandom,
        prefix: [
            &quot;schema&lt;&quot; + JSON.stringify(schemaP) + &quot;&gt;&quot;
        ],
        schema: schemaP
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.domFragmentRender" id="apidoc.elem.utility2.swgg.domFragmentRender">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>domFragmentRender
        <span class="apidocSignatureSpan">(template, dict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domFragmentRender = function (template, dict) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem rendered from &lt;template&gt;
 */
</span>    let tmp;
    tmp = document.createElement(&quot;template&quot;);
    tmp.innerHTML = local.templateRender(template, dict);
    return tmp.content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
// init uiFragment
swaggerJson.uiFragment = document.createDocumentFragment();
// init resourceDict
Object.keys(swaggerJson.resourceDict).sort().forEach(function (key) {
    // templateRender resource
    swaggerJson.uiFragment.appendChild(
        local.<span class="apidocCodeKeywordSpan">domFragmentRender</span>(
            local.templateUiResource,
            swaggerJson.resourceDict[key]
        )
    );
});
Object.keys(swaggerJson.operationDict).sort(function (aa, bb) {
    aa = swaggerJson.operationDict[aa];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.domQuerySelectorAllTagName" id="apidoc.elem.utility2.swgg.domQuerySelectorAllTagName">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>domQuerySelectorAllTagName
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domQuerySelectorAllTagName = function (selector) {
<span class="apidocCodeCommentSpan">/*
 * this function will return all tagName that match &lt;selector&gt;
 */
</span>    let set;
    set = new Set();
    local.querySelectorAll(selector).forEach(function (elem) {
        set.add(elem.tagName);
    });
    return Array.from(set).sort();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.domSelectOptionValue" id="apidoc.elem.utility2.swgg.domSelectOptionValue">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>domSelectOptionValue
        <span class="apidocSignatureSpan">(elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domSelectOptionValue = function (elem) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;elem&gt;.options[&lt;elem&gt;.selectedIndex].value
 */
</span>    elem = elem &amp;&amp; elem.options[elem.selectedIndex];
    return (elem &amp;&amp; elem.value) || &quot;&quot;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.domStyleValidate" id="apidoc.elem.utility2.swgg.domStyleValidate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>domStyleValidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domStyleValidate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will validate &lt;style&gt; tags
 */
</span>    let rgx;
    let tmp;
    rgx = (
        /^0\u0020(?:(body\u0020&gt;\u0020)?(?:\.testReportDiv\u0020.+|\.x-istanbul\u0020.+|\.button|\.colorError|\.readonly|\.textarea
|\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\u0020\{))|^[1-9]\d*?\u0020#/m
    );
    tmp = [];
    local.querySelectorAll(&quot;style&quot;).map(function (elem, ii) {
        elem.innerHTML.replace((
            /\/\*[\S\s]*?\*\/|;|\}/g
        ), &quot;\n&quot;).replace((
            /^([^\n\u0020@].*?)[,{:].*?$/gm
        ), function (match0, match1) {
            try {
                ii = local.querySelectorAll(match1).length;
            } catch (errCaught) {
                console.error(errCaught);
            }
            if (!(ii &gt; 1)) {
                tmp.push(ii + &quot; &quot; + match0);
            }
        });
    });
    tmp.filter(function (elem) {
        return !rgx.test(elem);
    }).sort().reverse().forEach(function (elem, ii, list) {
        console.error(
            &quot;domStyleValidateUnmatched &quot; + (list.length - ii) + &quot;. &quot; + elem
        );
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return local.buildTest({}, onError);
};

local._testCase_webpage_default = function (opt, onError) {
/*
* this function will test webpage&apos;s default handling-behavior
*/
   local.<span class="apidocCodeKeywordSpan">domStyleValidate</span>();
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   local.browserTest({
       fileScreenshot: (
           local.env.npm_config_dir_build
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.emit" id="apidoc.elem.utility2.swgg.emit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>emit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  data = concat(fragments, messageLength);
} else if (this._binaryType === &apos;arraybuffer&apos;) {
  data = toArrayBuffer(concat(fragments, messageLength));
} else {
  data = fragments;
}

this.<span class="apidocCodeKeywordSpan">emit</span>(&apos;message&apos;, data);
      } else {
const buf = concat(fragments, messageLength);

if (!isValidUTF8(buf)) {
  this._loop = false;
  return error(Error, &apos;invalid UTF-8 sequence&apos;, true, 1007);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.errorMessagePrepend" id="apidoc.elem.utility2.swgg.errorMessagePrepend">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>errorMessagePrepend
        <span class="apidocSignatureSpan">(err, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorMessagePrepend = function (err, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will prepend message to &lt;err&gt;.message and &lt;err&gt;.stack
 */
</span>    if (err === local.errDefault) {
        return;
    }
    err.message = message + err.message;
    err.stack = message + err.stack;
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
local.onErrorJsonapi(function (err, data) {
    local.serverRespondHeadSet(req, res, err &amp;&amp; err.statusCode, {
        &quot;Content-Type&quot;: &quot;application/json&quot;
    });
    if (err) {
        // debug statusCode / method / url
        local.<span class="apidocCodeKeywordSpan">errorMessagePrepend</span>(
            err,
            res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url + &quot;\n&quot;
        );
        // print err.stack to stderr
        local.onErrorDefault(err);
    }
    data = err || data;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.eventEmitterCreate" id="apidoc.elem.utility2.swgg.eventEmitterCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>eventEmitterCreate
        <span class="apidocSignatureSpan">(that = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventEmitterCreate = function (that = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a simple, node-like event-emitter with &lt;that&gt;,
 * with methods emit, on, once, removeListener
 */
</span>    let dict;
    let emit;
    let on;
    let once;
    let remove;
    emit = function (type, msg) {
    /*
     * this function will emit evt &lt;type&gt; with &lt;msg&gt;
     */
        Array.from(dict[type] || []).forEach(function (listener) {
            listener(msg);
        });
    };
    on = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
     */
        let isDone;
        if (typeof listener === &quot;function&quot;) {
            dict[type] = dict[type] || [];
            dict[type].push(
                opt.once
                ? function listener2(msg) {
                    remove(type, listener2);
                    if (!isDone) {
                        isDone = true;
                        listener(msg);
                    }
                }
                : listener
            );
        }
        return that;
    };
    once = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
     */
        opt.once = true;
        return on(type, listener, opt);
    };
    remove = function (type, listener) {
    /*
     * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
     */
        let ii;
        let list;
        list = dict[type] || [];
        ii = list.length;
        while (ii &gt; 0) {
            ii -= 1;
            if (list[ii] === listener) {
                list.splice(ii, 1);
            }
        }
        return that;
    };
    dict = {};
    that.emit = that.emit || emit;
    that.listenerEmit = that.listenerEmit || emit;
    that.on = that.on || on;
    that.once = that.once || once;
    that.removeListener = that.removeListener || remove;
    that.removeEventListener = that.removeEventListener || remove;
    that.listenerOn = that.listenerOn || on;
    that.listenerOnce = that.listenerOnce || once;
    that.listenerRemove = that.listenerRemove || remove;
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   that.removeEventListener = that.removeEventListener || remove;
   that.listenerOn = that.listenerOn || on;
   that.listenerOnce = that.listenerOnce || once;
   that.listenerRemove = that.listenerRemove || remove;
   return that;
};

local.<span class="apidocCodeKeywordSpan">eventEmitterCreate</span>(local);

local.fsReadFileOrEmptyStringSync = function (file, opt) {
/*
* this function will try to read file or return empty-string, or
* if &lt;opt&gt; === &quot;json&quot;, then try to JSON.parse file or return {}
*/
   try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.events" id="apidoc.elem.utility2.swgg.events">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>events
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.fsReadFileOrEmptyStringSync" id="apidoc.elem.utility2.swgg.fsReadFileOrEmptyStringSync">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>fsReadFileOrEmptyStringSync
        <span class="apidocSignatureSpan">(file, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrEmptyStringSync = function (file, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to read file or return empty-string, or
 * if &lt;opt&gt; === &quot;json&quot;, then try to JSON.parse file or return {}
 */
</span>    try {
        return (
            opt === &quot;json&quot;
            ? JSON.parse(local.fs.readFileSync(file, &quot;utf8&quot;))
            : local.fs.readFileSync(file, opt)
        );
    } catch (ignore) {
        return (
            opt === &quot;json&quot;
            ? {}
            : &quot;&quot;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    local.templateSwaggerUiLogoMediumBase64,
    &quot;base64&quot;
);
local.assetsDict[&quot;/assets.swagger-ui.logo.small.png&quot;] = Buffer.from(
    local.templateSwaggerUiLogoSmallBase64,
    &quot;base64&quot;
);
local.swgg.apiUpdate(local.<span class="apidocCodeKeywordSpan">fsReadFileOrEmptyStringSync</span>(
    local.__dirname + &quot;/assets.swgg.swagger.json&quot;,
    &quot;json&quot;
));
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.fsRmrfSync" id="apidoc.elem.utility2.swgg.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (dir) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;dir&gt;
 */
</span>    let child_process;
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    child_process.spawnSync(&quot;rm&quot;, [
        &quot;-rf&quot;, dir
    ], {
        stdio: [
            &quot;ignore&quot;, 1, 2
        ]
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.swgg.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(file, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (file, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;file&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    // try to write file
    try {
        fs.writeFileSync(file, data);
    } catch (ignore) {
        // mkdir -p
        require(&quot;child_process&quot;).spawnSync(
            &quot;mkdir&quot;,
            [
                &quot;-p&quot;, require(&quot;path&quot;).dirname(file)
            ],
            {
                stdio: [
                    &quot;ignore&quot;, 1, 2
                ]
            }
        );
        // rewrite file
        fs.writeFileSync(file, data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 1. print coverage in text-format to stdout
new local.TextReport(opt).writeReport(local.collector);
// 2. write coverage in html-format to filesystem
new local.HtmlReport(opt).writeReport(local.collector);
local.writer.writeFile(&quot;&quot;, local.nop);
if (!local.isBrowser) {
    // write coverage.json
    local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
        opt.dir + &quot;/coverage.json&quot;,
        JSON.stringify(opt.coverage)
    );
    // write coverage.code-dict.json
    local.fsWriteFileWithMkdirpSync(
        opt.dir + &quot;/coverage.code-dict.json&quot;,
        JSON.stringify(globalThis.__coverageCodeDict__)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.functionOrNop" id="apidoc.elem.utility2.swgg.functionOrNop">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>functionOrNop
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionOrNop = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;fnc&gt; exists,
 * return &lt;fnc&gt;,
 * else return &lt;nop&gt;
 */
</span>    return fnc || local.nop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xhr.addEventListener(&quot;loadstart&quot;, ajaxProgressUpdate);
xhr.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (local.<span class="apidocCodeKeywordSpan">functionOrNop</span>(local2.corsForwardProxyHostIfNeeded)(xhr)) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
// open url - default
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.gotoNext" id="apidoc.elem.utility2.swgg.gotoNext">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>gotoNext
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoNext = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
 * and append current-stack to any err
 */
</span>    opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
        try {
            opt.gotoState += (
                (err &amp;&amp; !opt.modeErrorIgnore)
                ? 1000
                : 1
            );
            if (opt.modeDebug) {
                console.error(&quot;gotoNext - &quot; + JSON.stringify({
                    gotoState: opt.gotoState,
                    errorMessage: err &amp;&amp; err.message
                }));
                if (err &amp;&amp; err.stack) {
                    console.error(err.stack);
                }
            }
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.gotoNext(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.<span class="apidocCodeKeywordSpan">gotoNext</span>(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
};

local.onErrorDefault = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.idDomElementCreate" id="apidoc.elem.utility2.swgg.idDomElementCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>idDomElementCreate
        <span class="apidocSignatureSpan">(seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idDomElementCreate = function (seed) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a deterministic and unique dom-element id
 * from &lt;seed&gt; that is both dom-selector and url friendly
 */
</span>    local.idDomElementDict[seed] = (local.idDomElementDict[seed] || 0) + 1;
    return encodeURIComponent(
        seed + &quot;_&quot; + local.idDomElementDict[seed]
    ).replace((
        /\W/g
    ), &quot;_&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    swaggerJson.resourceDict[tag] || swaggerJson.tagDict[tag],
    {
        description: &quot;no description&quot;,
        name: tag
    }
);
resource = swaggerJson.resourceDict[tag];
resource.id = resource.id || local.<span class="apidocCodeKeywordSpan">idDomElementCreate</span>(
    &quot;swgg_id_&quot; + tag
);
resource.summary = resource.summary || String(
    resource.description
).replace((
    /\bhttps?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s]/g
), &quot;&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.idNameInit" id="apidoc.elem.utility2.swgg.idNameInit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>idNameInit
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idNameInit = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will init &lt;opt&gt;.idBackend, &lt;opt&gt;.idName, and &lt;opt&gt;.queryById
 */
</span>    let idBackend;
    let idName;
    // init idName
    idName = opt.crudType[1] || &quot;id&quot;;
    opt.idName = idName;
    // init idBackend
    idBackend = opt.crudType[2] || opt.idName;
    opt.idBackend = idBackend;
    // invert queryById
    if (opt.modeQueryByIdInvert) {
        idBackend = opt.idName;
        idName = opt.idBackend;
    }
    // init queryById
    opt.idValue = (opt.data &amp;&amp; opt.data[idBackend]) || opt.idValue;
    opt.queryById = {};
    opt.queryById[idName] = opt.idValue;
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
that._crudType = that._crudType || key.slice(2);
that._crudType[0] = that._crudType[0] || that.operationId;
// init _fileUploadNumber
that._fileUploadNumber = Number(
    that._crudType[0] === &quot;fileUploadManyByForm&quot; &amp;&amp; that._crudType[1]
) || 1;
// init _idBackend and _idName
tmp = local.<span class="apidocCodeKeywordSpan">idNameInit</span>({
    crudType: that._crudType
});
that._idBackend = tmp.idBackend;
that._idName = tmp.idName;
// init tags
that.tags = that.tags || [];
that.tags[0] = that.tags[0] || key[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.identity" id="apidoc.elem.utility2.swgg.identity">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.isNullOrUndefined" id="apidoc.elem.utility2.swgg.isNullOrUndefined">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will test if val is null or undefined
 */
</span>    return val === null || val === undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ? &quot;arraybuffer&quot;
        : &quot;&quot;
    )
});
// init paramDict
that.parameters.forEach(function (schemaP) {
    tmp = opt.paramDict[schemaP.name];
    if (local.<span class="apidocCodeKeywordSpan">isNullOrUndefined</span>(tmp)) {
        return;
    }
    // serialize array
    if (Array.isArray(tmp) &amp;&amp; schemaP.in !== &quot;body&quot;) {
        switch (
            schemaP.collectionFormat || schemaP[&quot;x-swgg-collectionFormat&quot;]
        ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.istanbulCoverageMerge" id="apidoc.elem.utility2.swgg.istanbulCoverageMerge">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulCoverageMerge
        <span class="apidocSignatureSpan">(coverage1, coverage2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageMerge = function (coverage1, coverage2) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge coverage2 into coverage1
 */
</span>    let dict1;
    let dict2;
    coverage1 = coverage1 || {};
    coverage2 = coverage2 || {};
    Object.keys(coverage2).forEach(function (file) {
        if (!coverage2[file]) {
            return;
        }
        // if file is undefined in coverage1, then add it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge file from coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (count, ii) {
                        dict1[key][ii] += count;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        case 6:
data = JSON.parse(data);
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.<span class="apidocCodeKeywordSpan">istanbulCoverageMerge</span>(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.testReportMerge(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.counter += 1;
local.fs.writeFile(
    local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
    JSON.stringify(globalThis.utility2_testReport),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.istanbulCoverageReportCreate" id="apidoc.elem.utility2.swgg.istanbulCoverageReportCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulCoverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. print coverage in text-format to stdout
 * 2. write coverage in html-format to filesystem
 * 3. return coverage in html-format as single document
 */
</span>    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    opt = {};
    opt.dir = process.cwd() + &quot;/tmp/build/coverage.html&quot;;
    // merge previous coverage
    if (!local.isBrowser &amp;&amp; process.env.npm_config_mode_coverage_merge) {
        console.log(&quot;merging file &quot; + opt.dir + &quot;/coverage.json to coverage&quot;);
        try {
            local.coverageMerge(opt.coverage, JSON.parse(
                local.fs.readFileSync(opt.dir + &quot;/coverage.json&quot;, &quot;utf8&quot;)
            ));
        } catch (ignore) {}
        try {
            Object.keys(JSON.parse(local.fs.readFileSync(
                opt.dir + &quot;/coverage.code-dict.json&quot;,
                &quot;utf8&quot;
            ))).forEach(function (key) {
                globalThis.__coverageCodeDict__[key] = (
                    globalThis.__coverageCodeDict__[key]
                    || true
                );
            });
        } catch (ignore) {}
    }
    // init writer
    local.coverageReportHtml = &quot;&quot;;
    local.coverageReportHtml += (
        &quot;&lt;div class=\&quot;coverageReportDiv\&quot;&gt;\n&quot;
        + &quot;&lt;h1&gt;coverage-report&lt;/h1&gt;\n&quot;
        + &quot;&lt;div style=\&quot;&quot;
        + &quot;background: #fff; border: 1px solid #999; margin 0; padding: 0;&quot;
        + &quot;\&quot;&gt;\n&quot;
    );
    local.writerData = &quot;&quot;;
    opt.sourceStore = {};
    opt.writer = local.writer;
    // 1. print coverage in text-format to stdout
    new local.TextReport(opt).writeReport(local.collector);
    // 2. write coverage in html-format to filesystem
    new local.HtmlReport(opt).writeReport(local.collector);
    local.writer.writeFile(&quot;&quot;, local.nop);
    if (!local.isBrowser) {
        // write coverage.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.json&quot;,
            JSON.stringify(opt.coverage)
        );
        // write coverage.code-dict.json
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.code-dict.json&quot;,
            JSON.stringify(globalThis.__coverageCodeDict__)
        );
        // write coverage.badge.svg
        opt.pct = local.coverageReportSummary.root.metrics.lines.pct;
        local.fsWriteFileWithMkdirpSync(
            local._istanbul_path.dirname(opt.dir) + &quot;/coverage.badge.svg&quot;,
            // edit coverage badge percent
            // edit coverage badge color
            local.templateCoverageBadgeSvg.replace((
                /100.0/g
            ), opt.pct).replace((
                /0d0/g
            ), (
                Math.round((100 - opt.pct) * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + Math.round(opt.pct * 2.21).toString(16).padStart(2, &quot;0&quot;)
                + &quot;00&quot;
            ))
        );
    }
    console.log(&quot;created coverage file &quot; + opt.dir + &quot;/index.html&quot;);
    // 3. return coverage in html-format as a single document
    local.coverageReportHtml += &quot;&lt;/div&gt;\n&lt;/div&gt;\n&quot;;
    // write coverage.rollup.html
    if (!local.isBrowser) {
        local.fsWriteFileWithMkdirpSync(
            opt.dir + &quot;/coverage.rollup.html&quot;,
            local.coverageReportHtml
        );
    }
    return local.coverageReportHtml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.istanbulInstrumentInPackage" id="apidoc.elem.utility2.swgg.istanbulInstrumentInPackage">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulInstrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument the code
 * only if the macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in the code
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &quot;globalThis.utility2_moduleExports&quot;
);
// init example.js
tmp = process.cwd() + &quot;/example.js&quot;;
// jslint code
local.jslintAndPrint(code, tmp);
// cover code
code = local.<span class="apidocCodeKeywordSpan">istanbulInstrumentInPackage</span>(code, tmp);
// init module.exports
module = new local.Module(tmp);
require.cache[tmp] = module;
// load code into module
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.istanbulInstrumentSync" id="apidoc.elem.utility2.swgg.istanbulInstrumentSync">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>istanbulInstrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. normalize the file
 * 2. save code to __coverageCodeDict__[file] for future html-report
 * 3. return instrumented code
 */
</span>    // 1. normalize the file
    file = local._istanbul_path.resolve(&quot;/&quot;, file);
    // 2. save code to __coverageCodeDict__[file] for future html-report
    globalThis.__coverageCodeDict__[file] = true;
    // 3. return instrumented code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jslintAndPrint" id="apidoc.elem.utility2.swgg.jslintAndPrint">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jslintAndPrint
        <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrint = function (code = &quot;&quot;, file = &quot;undefined&quot;, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint / csslint &lt;code&gt; and print any errors to stderr
 */
</span>    let ii;
    let tmp;
    if (!(opt &amp;&amp; opt.gotoState)) {
        local.jslintResult = {
            gotoState: 0
        };
    }
    opt = Object.assign(local.jslintResult, opt);
    opt.gotoState += 1;
    switch (opt.gotoState) {
    // jslint - init
    case 1:
        // cleanup
        opt.errList = [];
        opt.errMsg = &quot;&quot;;
        // preserve lineno
        if (opt.iiStart) {
            opt.lineOffset |= 0;
            ii = 0;
            while (true) {
                ii = code.indexOf(&quot;\n&quot;, ii);
                if (ii === 0 || ii &gt; opt.iiStart) {
                    break;
                }
                ii += 1;
                opt.lineOffset += 1;
            }
            code = code.slice(opt.iiStart, opt.iiEnd || code.length);
        }
        switch (opt.fileType0) {
        // deembed-js - &apos;\\n\\\n...\\n\\\n&apos;
        case &quot;.\\n\\&quot;:
            // rgx - remove \\n\\
            code = code.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || &quot;&quot;;
            });
            break;
        // deembed-js - &apos;\n...\n&apos;
        case &quot;.sh&quot;:
            // rgx - convert &apos;&quot;&apos;&quot;&apos; to &apos;
            code = code.replace((
                /&apos;&quot;&apos;&quot;&apos;/g
            ), &quot;&apos;&quot;);
            break;
        }
        // init
        opt = Object.assign(opt, {
            &quot;.css&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.html&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.js&quot;: (
                /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.md&quot;: (
                /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.sh&quot;: (
                /(^#\u0020jslint\u0020utility2:true$)/m
            ),
            code0: code,
            fileType: (
                /\.\w+?$|$/m
            ).exec(file)[0]
        });
        // jslint - .json
        if (
            code &amp;&amp; (opt.fileType === &quot;.js&quot; || opt.fileType === &quot;.json&quot;)
            &amp;&amp; !opt.fileType0
        ) {
            try {
                tmp = JSON.parse(code);
                opt.fileType = &quot;.json&quot;;
                if (opt.autofix) {
                    code = JSON.stringify(tmp, null, 4) + &quot;\n&quot;;
                    opt.code0 = code;
                }
                opt.gotoState = Infinity;
                break;
            } catch (errCaught) {
                if (opt.fileType === &quot;.json&quot;) {
                    opt.errList.push({
                        column: 0,
                        evidence: code.slice(0, 100),
                        line: 0,
                        message: errCaught.message
                    });
                    opt.gotoState = Infinity;
                    break;
                }
            }
        }
        try {
            opt.conditionalPassed = opt[opt.fileType].exec(code);
        } catch (ignore) {}
        opt.utility2 = (
            opt.conditionalPassed
            &amp;&amp; opt.conditionalPassed[1]
        ) || opt.autofix;
        if (
            opt.conditional
            &amp;&amp; (!opt.conditionalPassed || opt.coverage)
        ) {
            break;
        }
        opt.gotoState = 10;
        break;
    // jslint - autofix
    case 11:
        code = local.jslintAutofix(code, file, opt);
        local.jslintResult = opt;
        break;
    // jslint - csslint and jslint
    case 12:
        // restore lineOffset
        code = &quot;\n&quot;.rep...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    // read file
    local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
    break;
case 2:
    // jslint
    local.jslint.<span class="apidocCodeKeywordSpan">jslintAndPrint</span>(data, opt.file);
    local.assertOrThrow(
        !local.jslint.jslintResult.errMsg,
        local.jslint.jslintResult.errMsg.replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;)
    );
    // validate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jslintAutofixLocalFunction" id="apidoc.elem.utility2.swgg.jslintAutofixLocalFunction">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jslintAutofixLocalFunction
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAutofixLocalFunction = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint-autofix local-function
 */
</span>    let code2;
    let dictFnc;
    let dictProp;
    let tmp;
    if (local.isBrowser) {
        return code;
    }
    file = file.replace(process.cwd() + &quot;/&quot;, &quot;&quot;);
    switch (file) {
    case &quot;README.md&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.sh&quot;:
    case &quot;lib.apidoc.js&quot;:
    case &quot;lib.github_crud.js&quot;:
    case &quot;lib.istanbul.js&quot;:
    case &quot;lib.jslint.js&quot;:
    case &quot;lib.marked.js&quot;:
    case &quot;lib.puppeteer.js&quot;:
    case &quot;lib.sjcl.js&quot;:
    case &quot;lib.swgg.js&quot;:
    case &quot;npm_scripts.sh&quot;:
    case &quot;test.js&quot;:
        break;
    default:
        return code;
    }
    // autofix - assets.utility2.header.js
    code = code.replace((
        /\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020start\n[\S\s]*?\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020end\n/
    ), &quot;\n&quot; + local.assetsDict[&quot;/assets.utility2.header.js&quot;]);
    // autofix - assets.my_app.template.js
    code = local.stringMerge(
        code,
        local.assetsDict[&quot;/assets.my_app.template.js&quot;].replace((
            /my_app/g
        ), file.split(&quot;.&quot;)[1]),
        file !== &quot;README.md&quot; &amp;&amp; local.identity(
            /\n\/\*\u0020istanbul\u0020instrument\u0020in\u0020package\u0020[\S\s]*?\n\/\*\u0020validateLineSortedReset\u0020\*\/\n/
        )
    );
    // customize local for assets.utility2.rollup.js
    if (
        file === &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;
        &amp;&amp; local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
        &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
    ) {
        code = code.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // init functionAllDict and functionBaseDict
    [
        [
            &quot;utility2&quot;, &quot;swgg&quot;
        ], [
            &quot;utility2&quot;, &quot;apidoc&quot;, &quot;github_crud&quot;, &quot;swgg&quot;
        ]
    ].forEach(function (dictList, ii) {
        tmp = (
            ii
            ? &quot;functionAllDict&quot;
            : &quot;functionBaseDict&quot;
        );
        if (local[tmp]) {
            return;
        }
        local[tmp] = {};
        dictList.forEach(function (dict) {
            dict = local[dict];
            Object.keys(dict).forEach(function (key) {
                if (
                    !(
                        /^[A-Z_]|^testCase_/m
                    ).test(key)
                    &amp;&amp; typeof dict[key] === &quot;function&quot;
                ) {
                    local[tmp][key] = local[tmp][key] || String(dict[key]);
                }
            });
        });
        Object.keys(local[tmp]).forEach(function (key) {
            if (process.binding(&quot;natives&quot;)[key]) {
                local[tmp][key] = undefined;
            }
        });
    });
    // autofix - local-function
    dictFnc = {};
    dictProp = {};
    code = code.replace((
        /^local\.(.*?)\u0020=\u0020(function\u0020\([\S\s]*?\n\});\n+/gm
    ), function (match0, key, match2, match3) {
        // local-function - duplicate
        if (dictFnc[key]) {
            return &quot;&quot;;
        }
        // local-function - normalize
        dictFnc[key] = true;
        match3 = local.functionAllDict[key] || &quot;&quot;;
        // make shell-safe
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c
        if...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jsonCopy" id="apidoc.elem.utility2.swgg.jsonCopy">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jsonCopy
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonCopy = function (obj) {
<span class="apidocCodeCommentSpan">/*
 * this function will deep-copy obj
 */
</span>    return (
        obj === undefined
        ? undefined
        : JSON.parse(JSON.stringify(obj))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
// try to validate paramDict
opt.err = local.swaggerValidateDataParameters({
    // normalize paramDict
    data: local.normalizeSwaggerParamDict({
        modeNoDefault: opt.modeNoDefault,
        operation: that,
        paramDict: local.<span class="apidocCodeKeywordSpan">jsonCopy</span>(opt.paramDict)
    }).paramDict,
    dataReadonlyRemove: opt.paramDict,
    prefix: [
        &quot;operation&quot;, that._methodPath
    ],
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jsonStringifyOrdered" id="apidoc.elem.utility2.swgg.jsonStringifyOrdered">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jsonStringifyOrdered
        <span class="apidocSignatureSpan">(obj, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonStringifyOrdered = function (obj, replacer, space) {
<span class="apidocCodeCommentSpan">/*
 * this function will JSON.stringify &lt;obj&gt;,
 * with object-keys sorted and circular-references removed
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Syntax
 */
</span>    let circularSet;
    let stringify;
    let tmp;
    stringify = function (obj) {
    /*
     * this function will recursively JSON.stringify obj,
     * with object-keys sorted and circular-references removed
     */
        // if obj is not an object or function, then JSON.stringify as normal
        if (!(
            obj
            &amp;&amp; typeof obj === &quot;object&quot;
            &amp;&amp; typeof obj.toJSON !== &quot;function&quot;
        )) {
            return JSON.stringify(obj);
        }
        // ignore circular-reference
        if (circularSet.has(obj)) {
            return;
        }
        circularSet.add(obj);
        // if obj is an array, then recurse items
        if (Array.isArray(obj)) {
            tmp = &quot;[&quot; + obj.map(function (obj) {
                // recurse
                tmp = stringify(obj);
                return (
                    typeof tmp === &quot;string&quot;
                    ? tmp
                    : &quot;null&quot;
                );
            }).join(&quot;,&quot;) + &quot;]&quot;;
            circularSet.delete(obj);
            return tmp;
        }
        // if obj is not an array,
        // then recurse its items with object-keys sorted
        tmp = &quot;{&quot; + Object.keys(obj).sort().map(function (key) {
            // recurse
            tmp = stringify(obj[key]);
            if (typeof tmp === &quot;string&quot;) {
                return JSON.stringify(key) + &quot;:&quot; + tmp;
            }
        }).filter(function (obj) {
            return typeof obj === &quot;string&quot;;
        }).join(&quot;,&quot;) + &quot;}&quot;;
        circularSet.delete(obj);
        return tmp;
    };
    circularSet = new Set();
    return JSON.stringify((
        (typeof obj === &quot;object&quot; &amp;&amp; obj)
        // recurse
        ? JSON.parse(stringify(obj))
        : obj
    ), replacer, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;!-- swgg-script-extra-end --&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.<span class="apidocCodeKeywordSpan">jsonStringifyOrdered</span>(
local.objectSetOverride(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtAes256GcmDecrypt" id="apidoc.elem.utility2.swgg.jwtAes256GcmDecrypt">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256GcmDecrypt
        <span class="apidocSignatureSpan">(token, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256GcmDecrypt = function (token, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will use json-web-encryption to
 * aes-256-gcm-decrypt &lt;token&gt; with given base64url-encoded &lt;key&gt;
 * https://tools.ietf.org/html/rfc7516
 */
</span>    return local.tryCatchOnError(function () {
        token = token.replace((
            /-/g
        ), &quot;+&quot;).replace((
            /_/g
        ), &quot;/&quot;).split(&quot;.&quot;);
        token = local.sjcl.decrypt(
            local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
            JSON.stringify({
                adata: token[4],
                ct: token[3],
                iv: token[2],
                ks: 256,
                mode: &quot;gcm&quot;
            })
        );
        return local.jwtHs256Decode(token, key);
    }, local.nop) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
crud = req.swgg.crud;
user = {};
req.swgg.user = user;
user.jwtEncrypted = (
    req.headers.authorization
    &amp;&amp; req.headers.authorization.replace(&quot;Bearer &quot;, &quot;&quot;)
);
user.jwtDecrypted = local.<span class="apidocCodeKeywordSpan">jwtAes256GcmDecrypt</span>(user.jwtEncrypted);
switch (crud.crudType[0]) {
// hack-coverage - test err handling-behavior
case &quot;crudErrorLogin&quot;:
    opt.gotoNext(local.errDefault);
    return;
case &quot;userLoginByPassword&quot;:
    user.password = req.urlParsed.query.password;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtAes256GcmEncrypt" id="apidoc.elem.utility2.swgg.jwtAes256GcmEncrypt">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256GcmEncrypt
        <span class="apidocSignatureSpan">(data, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256GcmEncrypt = function (data, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will use json-web-encryption to
 * aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
 * https://tools.ietf.org/html/rfc7516
 */
</span>    let adata;
    adata = local.jwtAes256KeyCreate();
    data = local.jwtHs256Encode(data, key);
    data = JSON.parse(local.sjcl.encrypt(
        local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
        data,
        {
            adata: local.sjcl.codec.base64url.toBits(adata),
            ks: 256,
            mode: &quot;gcm&quot;
        }
    ));
    return local.normalizeJwtBase64Url(
        &quot;eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4R0NNIn0..&quot;
        + data.iv + &quot;.&quot; + data.ct + &quot;.&quot; + adata
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init isAuthenticated
user.isAuthenticated = true;
// create JSON Web Token (JWT)
// https://tools.ietf.org/html/rfc7519
user.jwtDecrypted = {};
user.jwtDecrypted.sub = user.data.username;
// update jwtEncrypted in client
user.jwtEncrypted = local.<span class="apidocCodeKeywordSpan">jwtAes256GcmEncrypt</span>(
    user.jwtDecrypted
);
local.serverRespondHeadSet(req, res, null, {
    &quot;swgg-jwt-encrypted&quot;: user.jwtEncrypted
});
// update jwtEncrypted in dbTableUser
local.dbTableUser.crudUpdateOneById({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtAes256KeyCreate" id="apidoc.elem.utility2.swgg.jwtAes256KeyCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256KeyCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256KeyCreate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random, aes-256-base64url-jwt-key
 */
</span>    return local.normalizeJwtBase64Url(
        local.base64FromBuffer(local.bufferRandomBytes(32))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.jwtAes256GcmEncrypt = function (data, key) {
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
* https://tools.ietf.org/html/rfc7516
*/
   let adata;
   adata = local.<span class="apidocCodeKeywordSpan">jwtAes256KeyCreate</span>();
   data = local.jwtHs256Encode(data, key);
   data = JSON.parse(local.sjcl.encrypt(
       local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
       data,
       {
           adata: local.sjcl.codec.base64url.toBits(adata),
           ks: 256,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtAes256KeyInit" id="apidoc.elem.utility2.swgg.jwtAes256KeyInit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtAes256KeyInit
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtAes256KeyInit = function (key) {
<span class="apidocCodeCommentSpan">/*
 * this function will init aes-256-base64url-jwt-&lt;key&gt;
 * https://jwt.io/
 */
</span>    // init npm_config_jwtAes256Key
    local.env.npm_config_jwtAes256Key = (
        local.env.npm_config_jwtAes256Key
        || &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
    );
    return key || local.env.npm_config_jwtAes256Key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return local.tryCatchOnError(function () {
token = token.replace((
    /-/g
), &quot;+&quot;).replace((
    /_/g
), &quot;/&quot;).split(&quot;.&quot;);
token = local.sjcl.decrypt(
    local.sjcl.codec.base64url.toBits(local.<span class="apidocCodeKeywordSpan">jwtAes256KeyInit</span>(key)),
    JSON.stringify({
        adata: token[4],
        ct: token[3],
        iv: token[2],
        ks: 256,
        mode: &quot;gcm&quot;
    })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtHs256Decode" id="apidoc.elem.utility2.swgg.jwtHs256Decode">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtHs256Decode
        <span class="apidocSignatureSpan">(token, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtHs256Decode = function (token, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will decode json-web-token with given base64-encoded &lt;key&gt;
 * https://jwt.io/
 */
</span>    let Hmac;
    let timeNow;
    Hmac = local.sjcl.misc.hmac;
    timeNow = Date.now() / 1000;
    // try to decode token
    return local.tryCatchOnError(function () {
        token = token.split(&quot;.&quot;);
        // validate header
        local.assertOrThrow(
            token[0] === &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;,
            token
        );
        // validate signature
        local.assertOrThrow(local.sjcl.codec.base64url.fromBits(
            new Hmac(local.sjcl.codec.base64url.toBits(
                local.jwtAes256KeyInit(key)
            )).encrypt(token[0] + &quot;.&quot; + token[1])
        ) === token[2]);
        // return decoded data
        token = JSON.parse(local.base64ToUtf8(token[1]));
        // https://tools.ietf.org/html/rfc7519#section-4.1
        // validate jwt-registered-headers
        local.assertOrThrow(!token.exp || token.exp &gt;= timeNow);
        local.assertOrThrow(!token.nbf || token.nbf &lt;= timeNow);
        return token;
    }, local.nop) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               adata: token[4],
               ct: token[3],
               iv: token[2],
               ks: 256,
               mode: &quot;gcm&quot;
           })
       );
       return local.<span class="apidocCodeKeywordSpan">jwtHs256Decode</span>(token, key);
   }, local.nop) || {};
};

local.jwtAes256GcmEncrypt = function (data, key) {
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.jwtHs256Encode" id="apidoc.elem.utility2.swgg.jwtHs256Encode">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>jwtHs256Encode
        <span class="apidocSignatureSpan">(data, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jwtHs256Encode = function (data, key) {
<span class="apidocCodeCommentSpan">/*
 * this function will encode &lt;data&gt; into a json-web-token
 * with given base64-encoded &lt;key&gt;
 * https://jwt.io/
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    data = (
        &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.&quot;
        + local.normalizeJwtBase64Url(
            local.base64FromBuffer(JSON.stringify(data))
        )
    );
    return data + &quot;.&quot; + local.sjcl.codec.base64url.fromBits(
        new Hmac(local.sjcl.codec.base64url.toBits(
            local.jwtAes256KeyInit(key)
        )).encrypt(data)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will use json-web-encryption to
* aes-256-gcm-encrypt &lt;data&gt; with given base64url-encoded &lt;key&gt;
* https://tools.ietf.org/html/rfc7516
*/
   let adata;
   adata = local.jwtAes256KeyCreate();
   data = local.<span class="apidocCodeKeywordSpan">jwtHs256Encode</span>(data, key);
   data = JSON.parse(local.sjcl.encrypt(
       local.sjcl.codec.base64url.toBits(local.jwtAes256KeyInit(key)),
       data,
       {
           adata: local.sjcl.codec.base64url.toBits(adata),
           ks: 256,
           mode: &quot;gcm&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listGetElementRandom" id="apidoc.elem.utility2.swgg.listGetElementRandom">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listGetElementRandom
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listGetElementRandom = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will return random elem from &lt;list&gt;
 */
</span>    return list[Math.floor(Math.random() * list.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return local.jsonCopy(schemaP.default);
}
// init enum-value
if (schemaP.enum) {
    value = (
        opt.modeNotRandom
        ? schemaP.enum[0]
        : local.<span class="apidocCodeKeywordSpan">listGetElementRandom</span>(schemaP.enum)
    );
    return (
        local.schemaPType(schemaP) === &quot;array&quot;
        ? [
            value
        ]
        : value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listShuffle" id="apidoc.elem.utility2.swgg.listShuffle">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listShuffle
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listShuffle = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace shuffle &lt;list&gt; using fisher-yates algorithm
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
</span>    let ii;
    let random;
    let swap;
    ii = list.length;
    while (ii &gt; 1) {
        ii -= 1;
        random = Math.floor(Math.random() * (ii + 1));
        swap = list[ii];
        list[ii] = list[random];
        list[random] = swap;
    }
    return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
opt = {};
// init list
opt.list = &quot;[0,1]&quot;;
// shuffle list 100 times
opt.ii = 0;
while (opt.ii &lt; 100) {
    opt.listShuffled = JSON.stringify(
        local.<span class="apidocCodeKeywordSpan">listShuffle</span>(JSON.parse(opt.list))
    );
    // validate shuffled list
    local.assertJsonEqual(opt.listShuffled.length, opt.list.length);
    opt.changed = opt.changed || opt.listShuffled !== opt.list;
    opt.ii += 1;
}
// validate list changed at least once during the shuffle
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listenerEmit" id="apidoc.elem.utility2.swgg.listenerEmit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerEmit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerEmit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listenerOn" id="apidoc.elem.utility2.swgg.listenerOn">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerOn
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOn = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listenerOnce" id="apidoc.elem.utility2.swgg.listenerOnce">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerOnce
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOnce = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.listenerRemove" id="apidoc.elem.utility2.swgg.listenerRemove">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>listenerRemove
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerRemove = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.localStorageSetItemOrClear" id="apidoc.elem.utility2.swgg.localStorageSetItemOrClear">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>localStorageSetItemOrClear
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localStorageSetItemOrClear = function (key, value) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to set &lt;key&gt;/&lt;value&gt; pair to localStorage,
 * or else call localStorage.clear()
 */
</span>    try {
        localStorage.setItem(key, value);
    } catch (ignore) {
        localStorage.clear();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    local.apiKeyValue = localStorage.getItem(local.apiKeyKey) || &quot;&quot;;
// save apiKeyValue
} else {
    local.apiKeyValue = document.querySelector(
        &quot;#swggApiKeyInput1&quot;
    ).value;
    local.<span class="apidocCodeKeywordSpan">localStorageSetItemOrClear</span>(
        local.apiKeyKey,
        local.apiKeyValue
    );
}
// if keyup-evt is not return-key, then return
if (
    (opt.type === &quot;keyup&quot; &amp;&amp; opt.code !== &quot;Enter&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.marked" id="apidoc.elem.utility2.swgg.marked">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>marked
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareAssetsCached" id="apidoc.elem.utility2.swgg.middlewareAssetsCached">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareAssetsCached
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareAssetsCached = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve cached-assets
 */
</span>    if (!local.assetsDict.hasOwnProperty(req.urlParsed.pathname)) {
        next();
        return;
    }
    // do not cache if headers already sent or url has &apos;?&apos; search indicator
    if (!(res.headersSent || req.url.indexOf(&quot;?&quot;) &gt;= 0)) {
        // init serverResponseHeaderLastModified
        local.serverResponseHeaderLastModified = (
            local.serverResponseHeaderLastModified
            // resolve to 1000 ms
            || new Date(new Date().toUTCString())
        );
        // respond with 304 If-Modified-Since serverResponseHeaderLastModified
        if (
            new Date(req.headers[&quot;if-modified-since&quot;])
            &gt;= local.serverResponseHeaderLastModified
        ) {
            res.statusCode = 304;
            res.end();
            return;
        }
        res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        res.setHeader(
            &quot;Last-Modified&quot;,
            local.serverResponseHeaderLastModified.toUTCString()
        );
    }
    res.end(local.assetsDict[req.urlParsed.pathname]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareBodyParse" id="apidoc.elem.utility2.swgg.middlewareBodyParse">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareBodyParse
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareBodyParse = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to parse &lt;req&gt;.bodyRaw
 */
</span>    let boundary;
    let crlf;
    let data;
    let headerParse;
    let ii;
    let jj;
    let name;
    // if req is already parsed, then goto next
    if (!req.swgg.operation || !local.isNullOrUndefined(req.swgg.bodyParsed)) {
        next();
        return;
    }
    headerParse = function () {
        local.bufferToUtf8(req.bodyRaw.slice(ii, ii + 1024)).replace((
            /^content-disposition:\u0020?form-data;(.+?)\r\n(?:content-type:\u0020?(.*?)$)?/im
        ), function (ignore, match1, match2) {
            data = {
                contentType: match2,
                name: &quot;&quot;
            };
            match1.replace((
                /(\w+)=&quot;([^&quot;]+)/g
            ), function (ignore, match1, match2) {
                data[match1.toLowerCase()] = match2;
            });
            name = data.name;
            req.swgg.bodyMeta[name] = data;
        });
    };
    switch (req.swgg.operation._consumes0) {
    // parse application/x-www-form-urlencoded, e.g.
    // aa=hello%20world&amp;bb=bye%20world
    case &quot;application/x-www-form-urlencoded&quot;:
        req.swgg.bodyParsed = local.bufferToUtf8(req.bodyRaw);
        req.swgg.bodyParsed = local.urlParse(
            &quot;?&quot; + req.swgg.bodyParsed,
            true
        ).query;
        break;
    case &quot;application/xml&quot;:
        req.swgg.bodyParsed = {};
        local.bufferToUtf8(req.bodyRaw).replace((
            /&lt;(.+?)&gt;&lt;!\[CDATA\[([\S\s]+?)\]\]&gt;/g
        ), function (name, match1, value) {
            name = match1;
            name = decodeURIComponent(name);
            req.swgg.bodyParsed[name] = (
                local.schemaPType(
                    req.swgg.operation._schemaPDict[name]
                ) === &quot;string&quot;
                ? value
                : JSON.parse(value)
            );
        });
        break;
    /*
     * parse multipart/form-data, e.g.
     * --Boundary\r\n
     * Content-Disposition: form-data; name=&quot;key&quot;\r\n
     * \r\n
     * value\r\n
     * --Boundary\r\n
     * Content-Disposition: form-data; name=&quot;input1&quot;; filename=&quot;file1.png&quot;\r\n
     * Content-Type: image/jpeg\r\n
     * \r\n
     * &lt;data1&gt;\r\n
     * --Boundary\r\n
     * Content-Disposition: form-data; name=&quot;input2&quot;; filename=&quot;file2.png&quot;\r\n
     * Content-Type: image/jpeg\r\n
     * \r\n
     * &lt;data2&gt;\r\n
     * --Boundary--\r\n
     * https://tools.ietf.org/html/rfc7578
     */
    case &quot;multipart/form-data&quot;:
        req.swgg.bodyParsed = {};
        req.swgg.bodyMeta = {};
        crlf = new Uint8Array([
            0x0d, 0x0a
        ]);
        // init boundary
        ii = 0;
        jj = local.bufferIndexOfSubBuffer(req.bodyRaw, crlf, ii);
        if (jj &lt;= 0) {
            break;
        }
        boundary = local.bufferConcat([
            crlf, req.bodyRaw.slice(ii, jj)
        ]);
        ii = jj + 2;
        while (true) {
            jj = local.bufferIndexOfSubBuffer(
                req.bodyRaw,
                boundary,
                ii
            );
            if (jj &lt; 0) {
                break;
            }
            headerParse();
            ii = local.bufferIndexOfSubBuffer(
                req.bodyRaw,
                [
                    0x0d, 0x0a, 0x0d, 0x0a
                ],
                ii + 2
            ) + 4;
            data = req.bodyRaw.slice(ii, jj);
            req.swgg.bodyParsed[name] = data;
            ii = jj + boundary.length + 2;
        }
        break;
    default:
        req.swgg.bodyParsed = local.bufferToUtf8(req.bodyRaw);
        // try to JSON.parse the string
        local.tryCatchOnError(function () {
            req.swgg.bodyParsed = JSON.parse(req.swgg.bodyParsed);
        }, local.nop);
    }
    next(null, req, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareBodyRead" id="apidoc.elem.utility2.swgg.middlewareBodyRead">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareBodyRead
        <span class="apidocSignatureSpan">(req, ignore, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareBodyRead = function (req, ignore, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * read and save &lt;req&gt; body to &lt;req&gt;.bodyRaw
 */
</span>    // if req is already read, then goto next
    if (!req.readable) {
        next();
        return;
    }
    let bufList;
    bufList = [];
    req.on(&quot;data&quot;, function (buf) {
        bufList.push(buf);
    }).on(&quot;end&quot;, function () {
        req.bodyRaw = (
            local.isBrowser
            ? bufList[0]
            : Buffer.concat(bufList)
        );
        next();
    // on event-error, pass error to onError
    }).on(&quot;error&quot;, next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will run the test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
   case &quot;/test.body&quot;:
       // test req-body-read handling-behavior
       local.<span class="apidocCodeKeywordSpan">middlewareBodyRead</span>(req, res, function () {
           // test multiple req-body-read handling-behavior
           local.middlewareBodyRead(req, res, function () {
               res.write(req.bodyRaw);
               res.end();
           });
       });
       break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareCrudBuiltin" id="apidoc.elem.utility2.swgg.middlewareCrudBuiltin">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareCrudBuiltin
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareCrudBuiltin = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * run the builtin crud-operations backed by db-lite
 */
</span>    let crud;
    let onParallel;
    let opt;
    let tmp;
    let user;
    opt = {};
    local.gotoNext(opt, function (err, data, meta) {
        switch (opt.gotoState) {
        case 1:
            crud = req.swgg.crud;
            user = req.swgg.user;
            switch (crud.crudType[0]) {
            case &quot;crudCountManyByQuery&quot;:
                crud.dbTable.crudCountManyByQuery(
                    crud.queryWhere,
                    opt.gotoNext
                );
                break;
            case &quot;crudSetManyById&quot;:
                crud.dbTable.crudSetManyById(crud.body, opt.gotoNext);
                break;
            case &quot;crudSetOneById&quot;:
                // replace idName with idBackend in body
                delete crud.body.id;
                delete crud.body[crud.idName];
                crud.body[crud.idBackend] = crud.data[crud.idName];
                crud.dbTable.crudSetOneById(crud.body, opt.gotoNext);
                break;
            case &quot;crudUpdateOneById&quot;:
                // replace idName with idBackend in body
                delete crud.body.id;
                delete crud.body[crud.idName];
                crud.body[crud.idBackend] = crud.data[crud.idName];
                crud.dbTable.crudUpdateOneById(crud.body, opt.gotoNext);
                break;
            // hack-coverage - test err handling-behavior
            case &quot;crudErrorDelete&quot;:
            case &quot;crudErrorGet&quot;:
            case &quot;crudErrorHead&quot;:
            case &quot;crudErrorOptions&quot;:
            case &quot;crudErrorPatch&quot;:
            case &quot;crudErrorPost&quot;:
            case &quot;crudErrorPut&quot;:
                opt.gotoNext(local.errDefault);
                break;
            case &quot;crudGetManyByQuery&quot;:
                onParallel = local.onParallel(opt.gotoNext);
                onParallel.counter += 1;
                crud.dbTable.crudGetManyByQuery({
                    fieldList: crud.queryFields,
                    limit: crud.queryLimit,
                    query: crud.queryWhere,
                    skip: crud.querySkip,
                    sort: crud.querySort
                }, function (err, data) {
                    crud.queryData = data;
                    onParallel(err);
                });
                onParallel.counter += 1;
                crud.dbTable.crudCountAll(function (err, data) {
                    crud.paginationCountTotal = data;
                    onParallel(err);
                });
                break;
            case &quot;crudGetOneById&quot;:
                crud.dbTable.crudGetOneById(crud.queryById, opt.gotoNext);
                break;
            case &quot;crudGetOneByQuery&quot;:
                crud.dbTable.crudGetOneByQuery({
                    query: crud.queryWhere
                }, opt.gotoNext);
                break;
            case &quot;crudNullDelete&quot;:
            case &quot;crudNullGet&quot;:
            case &quot;crudNullHead&quot;:
            case &quot;crudNullOptions&quot;:
            case &quot;crudNullPatch&quot;:
            case &quot;crudNullPost&quot;:
            case &quot;crudNullPut&quot;:
                opt.gotoNext();
                break;
            case &quot;crudRemoveManyByQuery&quot;:
                crud.dbTable.crudRemoveManyByQuery(
                    crud.queryWhere,
                    opt.gotoNext
                );
                break;
            case &quot;crudRemoveOneById&quot;:
                crud.dbTable.crudRemoveOneById(crud.queryById, opt.gotoNext);
                break;
            case &quot;fileGetOneById&quot;:
                local.dbTableFile = local.db.dbTableCreateOne({
                    name: &quot;File&quot;
                });
                crud.dbTable.crudGetOneById(crud.queryById, opt.g...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareCrudEnd" id="apidoc.elem.utility2.swgg.middlewareCrudEnd">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareCrudEnd
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareCrudEnd = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to end builtin crud-operations
 */
</span>    if (req.swgg.crud.endArgList) {
        local.serverRespondJsonapi.apply(null, req.swgg.crud.endArgList);
        return;
    }
    next(null, req, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareError" id="apidoc.elem.utility2.swgg.middlewareError">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareError
        <span class="apidocSignatureSpan">(err, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareError = function (err, req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to handle errors
 */
</span>    // default - 404 Not Found
    if (!err) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    // http://jsonapi.org/format/#errors
    if (local.swgg &amp;&amp; typeof local.swgg.serverRespondJsonapi === &quot;function&quot;) {
        local.swgg.serverRespondJsonapi(req, res, err);
    }
    // statusCode [400, 600)
    local.serverRespondDefault(req, res, (
        (err.statusCode &gt;= 400 &amp;&amp; err.statusCode &lt; 600)
        ? err.statusCode
        : 500
    ), err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
globalThis.utility2_onReadyBefore.counter += 1;
local.serverLocalReqHandler = function (req, res) {
    let that;
    that = {};
    local.gotoNext(that, function (err) {
        if (err || that.gotoState &gt;= local.middlewareList.length) {
            local.<span class="apidocCodeKeywordSpan">middlewareError</span>(err, req, res);
            return;
        }
        // recurse with next middleware in middlewareList
        local.middlewareList[that.gotoState](req, res, that.gotoNext);
    });
    that.gotoState = -1;
    that.gotoNext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareFileServer" id="apidoc.elem.utility2.swgg.middlewareFileServer">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareFileServer
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareFileServer = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve files
 */
</span>    let file;
    if (req.method !== &quot;GET&quot; || local.isBrowser) {
        next();
        return;
    }
    // security - disable parent directory lookup
    file = local.path.resolve(&quot;/&quot;, req.urlParsed.pathname).slice(1);
    // replace trailing &apos;/&apos; with &apos;/index.html&apos;
    file = file.replace((
        /\/$/
    ), &quot;/index.html&quot;);
    local.fs.readFile(file, function (err, data) {
        // default to next
        if (err) {
            next();
            return;
        }
        // respond with data
        local.serverRespondHeadSet(req, res, undefined, {
            &quot;Content-Type&quot;: local.contentTypeDict[(
                /\.[^.]*?$|$/m
            ).exec(file)[0]]
        });
        res.end(data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &quot;/test.timeout&quot;:
        setTimeout(function () {
            res.end();
        }, 2000);
        break;
    // serve file
    default:
        local.<span class="apidocCodeKeywordSpan">middlewareFileServer</span>(req, res, next);
    }
});
}());



// run node js-env code - init-after
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareForwardProxy" id="apidoc.elem.utility2.swgg.middlewareForwardProxy">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareForwardProxy
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareForwardProxy = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to forward-proxy &lt;req&gt;
 * to its destination-host
 */
</span>    let isDone;
    let onError;
    let opt;
    let timerTimeout;
    // handle preflight-cors
    if (req.method === &quot;OPTIONS&quot; &amp;&amp; (
        /forward-proxy-url/
    ).test(req.headers[&quot;access-control-request-headers&quot;])) {
        local.serverRespondCors(req, res);
        res.end();
        return;
    }
    if (!req.headers[&quot;forward-proxy-url&quot;]) {
        next();
        return;
    }
    local.serverRespondCors(req, res);
    // init onError
    onError = function (err) {
        if (isDone) {
            return;
        }
        isDone = true;
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // debug middlewareForwardProxy
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(opt.timeStart).toISOString(),
            type: &quot;middlewareForwardProxyResponse&quot;,
            method: opt.method,
            url: opt.url,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - opt.timeStart,
            // extra
            headers: opt.headers
        }));
        if (!err) {
            return;
        }
        // cleanup clientReq and clientRes
        local.streamCleanup(opt.clientReq);
        local.streamCleanup(opt.clientReq);
        next(err);
    };
    // init opt
    opt = local.urlParse(req.headers[&quot;forward-proxy-url&quot;]);
    opt.method = req.method;
    opt.url = req.headers[&quot;forward-proxy-url&quot;];
    // init timerTimeout
    timerTimeout = local.onTimeout(
        onError,
        local.timeoutDefault,
        &quot;forward-proxy &quot; + opt.method + &quot; &quot; + opt.url
    );
    // parse headers
    opt.headers = {};
    local.tryCatchOnError(function () {
        opt.headers = JSON.parse(req.headers[&quot;forward-proxy-headers&quot;]);
    }, local.nop);
    // debug opt
    local._debugForwardProxy = opt;
    opt.clientReq = (
        opt.protocol === &quot;https:&quot;
        ? local.https
        : local.http
    ).request(opt, function (clientReq) {
        opt.clientReq = clientReq.on(&quot;error&quot;, onError);
        res.statusCode = opt.clientReq.statusCode;
        // pipe clientReq to res
        opt.clientReq.pipe(res);
    }).on(&quot;error&quot;, onError);
    opt.timeStart = Date.now();
    // handle evt
    req.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError).on(&quot;error&quot;, onError);
    // pipe req to clientReq
    req.pipe(opt.clientReq);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareInit" id="apidoc.elem.utility2.swgg.middlewareInit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to init &lt;req&gt; and &lt;res&gt;
 */
</span>    // debug req and res
    local._debugServerReqRes4 = local._debugServerReqRes3;
    local._debugServerReqRes3 = local._debugServerReqRes2;
    local._debugServerReqRes2 = local._debugServerReqRes1;
    local._debugServerReqRes1 = {
        req,
        res
    };
    // init timerTimeout
    local.serverRespondTimeoutDefault(req, res, local.timeoutDefault);
    // init req.urlParsed
    req.urlParsed = local.urlParse(req.url);
    // init res-header content-type
    local.serverRespondHeadSet(req, res, undefined, {
        &quot;Content-Type&quot;: local.contentTypeDict[(
            /\.[^.]*?$|$/m
        ).exec(req.urlParsed.pathname)[0]]
    });
    // set main-page content-type to text/html
    if (req.urlParsed.pathname === &quot;/&quot;) {
        local.serverRespondHeadSet(req, res, undefined, {
            &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
        });
    }
    // default to next
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareJsonpStateInit" id="apidoc.elem.utility2.swgg.middlewareJsonpStateInit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareJsonpStateInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareJsonpStateInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * serve browser-state wrapped in given jsonp-callback
 */
</span>    let state;
    if (!(req.stateInit || (
        req.urlParsed
        &amp;&amp; req.urlParsed.pathname === &quot;/jsonp.utility2.stateInit&quot;
    ))) {
        next();
        return;
    }
    state = {
        utility2: {
            assetsDict: {
                &quot;/assets.example.html&quot;:
                local.assetsDict[&quot;/assets.example.html&quot;],
                &quot;/assets.example.js&quot;: local.assetsDict[&quot;/assets.example.js&quot;],
                &quot;/assets.swgg.swagger.json&quot;:
                local.assetsDict[&quot;/assets.swgg.swagger.json&quot;],
                &quot;/assets.test.js&quot;: local.assetsDict[&quot;/assets.test.js&quot;],
                &quot;/assets.utility2.base.html&quot;:
                local.assetsDict[&quot;/assets.utility2.base.rollup.html&quot;],
                &quot;/index.rollup.html&quot;: local.assetsDict[&quot;/index.rollup.html&quot;]
            },
            env: {
                NODE_ENV: local.env.NODE_ENV,
                npm_config_mode_backend: local.env.npm_config_mode_backend,
                npm_package_description: local.env.npm_package_description,
                npm_package_homepage: local.env.npm_package_homepage,
                npm_package_name: local.env.npm_package_name,
                npm_package_nameLib: local.env.npm_package_nameLib,
                npm_package_version: local.env.npm_package_version
            }
        }
    };
    if (req.stateInit) {
        return state;
    }
    res.end(
        req.urlParsed.query.callback + &quot;(&quot; + JSON.stringify(state) + &quot;);&quot;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    code += local.assetsDict[tmp];
    break;
case &quot;local.stateInit&quot;:
    // handle large string-replace
    code = local.assetsDict[&quot;/assets.utility2.rollup.content.js&quot;].split(
        &quot;/* utility2.rollup.js content */&quot;
    );
    tmp = local.<span class="apidocCodeKeywordSpan">middlewareJsonpStateInit</span>({
        stateInit: true
    });
    // add extra physical files to assetsDict
    local.fs.readdirSync(&quot;.&quot;).forEach(function (file) {
        file = &quot;/&quot; + file;
        if (
            local.assetsDict[file]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareRouter" id="apidoc.elem.utility2.swgg.middlewareRouter">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareRouter
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareRouter = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * map the req&apos;s method-path to swagger&apos;s tags[0]-crudType
 */
</span>    let tmp;
    // init swgg object
    local.objectSetDefault(req, {
        swgg: {
            crud: {
                crudType: []
            },
            user: {}
        }
    }, 3);
    // if req.url is not prefixed with swaggerJsonBasePath,
    // then default to next
    if (req.urlParsed.pathname.indexOf(local.swaggerJsonBasePath) !== 0) {
        next();
        return;
    }
    // init methodPath
    req.swgg.methodPath = (
        req.method + &quot; &quot;
        + req.urlParsed.pathname.replace(local.swaggerJsonBasePath, &quot;&quot;)
    );
    // init operation
    while (req.swgg.methodPath !== tmp) {
        req.swgg.operation = (
            local.apiDict[req.swgg.methodPath]
            // handle /foo/{id}/bar case
            || local.apiDict[req.swgg.methodPath.replace((
                /\/[^\/]+\/([^\/]*?)$/
            ), &quot;/{}/$1&quot;)]
        );
        // if operation exists, then break
        if (req.swgg.operation) {
            req.swgg.operation = local.jsonCopy(req.swgg.operation);
            // init crud.crudType
            req.swgg.crud.crudType = req.swgg.operation._crudType;
            break;
        }
        tmp = req.swgg.methodPath;
        // handle /foo/{id} case
        req.swgg.methodPath = req.swgg.methodPath.replace((
            /\/[^\/]+?(\/*?)$/
        ), &quot;/$1{}&quot;);
    }
    next(null, req, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareUserLogin" id="apidoc.elem.utility2.swgg.middlewareUserLogin">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareUserLogin
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareUserLogin = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to handle user login
 */
</span>    let crud;
    let opt;
    let user;
    opt = {};
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            local.dbTableUser = local.db.dbTableCreateOne({
                name: &quot;User&quot;
            });
            crud = req.swgg.crud;
            user = {};
            req.swgg.user = user;
            user.jwtEncrypted = (
                req.headers.authorization
                &amp;&amp; req.headers.authorization.replace(&quot;Bearer &quot;, &quot;&quot;)
            );
            user.jwtDecrypted = local.jwtAes256GcmDecrypt(user.jwtEncrypted);
            switch (crud.crudType[0]) {
            // hack-coverage - test err handling-behavior
            case &quot;crudErrorLogin&quot;:
                opt.gotoNext(local.errDefault);
                return;
            case &quot;userLoginByPassword&quot;:
                user.password = req.urlParsed.query.password;
                user.username = req.urlParsed.query.username;
                if (user.password &amp;&amp; user.username) {
                    local.dbTableUser.crudGetOneById({
                        username: user.username
                    }, opt.gotoNext);
                    return;
                }
                break;
            default:
                if (user.jwtDecrypted.sub) {
                    // init username
                    user.username = user.jwtDecrypted.sub;
                    local.dbTableUser.crudGetOneById({
                        username: user.username
                    }, opt.gotoNext);
                    return;
                }
            }
            opt.gotoState = Infinity;
            opt.gotoNext();
            break;
        case 2:
            switch (crud.crudType[0]) {
            case &quot;userLoginByPassword&quot;:
                user.data = data;
                if (!local.sjclHashScryptValidate(
                    user.password,
                    user.data &amp;&amp; user.data.password
                )) {
                    opt.gotoState = Infinity;
                    opt.gotoNext();
                    return;
                }
                // init isAuthenticated
                user.isAuthenticated = true;
                // create JSON Web Token (JWT)
                // https://tools.ietf.org/html/rfc7519
                user.jwtDecrypted = {};
                user.jwtDecrypted.sub = user.data.username;
                // update jwtEncrypted in client
                user.jwtEncrypted = local.jwtAes256GcmEncrypt(
                    user.jwtDecrypted
                );
                local.serverRespondHeadSet(req, res, null, {
                    &quot;swgg-jwt-encrypted&quot;: user.jwtEncrypted
                });
                // update jwtEncrypted in dbTableUser
                local.dbTableUser.crudUpdateOneById({
                    jwtEncrypted: user.jwtEncrypted,
                    username: user.jwtDecrypted.sub
                }, opt.gotoNext);
                return;
            default:
                data = data || {};
                user.data = data;
                if (data.jwtEncrypted) {
                    // init isAuthenticated
                    user.isAuthenticated = true;
                    // update jwtEncrypted in client
                    if (data.jwtEncrypted !== user.jwtEncrypted) {
                        user.jwtEncrypted = data.jwtEncrypted;
                        user.jwtDecrypted = local.jwtAes256GcmDecrypt(
                            user.jwtEncrypted
                        );
                        local.serverRespondHeadSet(req, res, null, {
                            &quot;swgg-jwt-encrypted&quot;: user.jwtEncrypted
                        });
                    }
                }
            }
            opt.gotoNext();
            break;
        default:
            next(err);
        }
    });
    op...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.middlewareValidate" id="apidoc.elem.utility2.swgg.middlewareValidate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>middlewareValidate
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareValidate = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to validate the swagger-&lt;req&gt;
 */
</span>    let crud;
    let opt;
    let tmp;
    opt = {};
    local.gotoNext(opt, function (err) {
        switch (opt.gotoState) {
        case 1:
            if (!req.swgg.operation) {
                opt.gotoState = Infinity;
                opt.gotoNext();
                return;
            }
            // init paramDict
            req.swgg.paramDict = {};
            // parse path param
            tmp = req.urlParsed.pathname.replace(
                local.swaggerJsonBasePath,
                &quot;&quot;
            ).split(&quot;/&quot;);
            req.swgg.operation._path.split(&quot;/&quot;).forEach(function (key, ii) {
                if ((
                    /^\{\S*?\}$/
                ).test(key)) {
                    req.swgg.paramDict[key.slice(1, -1)] = (
                        decodeURIComponent(tmp[ii])
                    );
                }
            });
            req.swgg.operation.parameters.forEach(function (schemaP) {
                switch (schemaP.in) {
                // parse body param
                case &quot;body&quot;:
                    req.swgg.paramDict[schemaP.name] = (
                        req.swgg.bodyParsed
                        || undefined
                    );
                    break;
                // parse formData param
                case &quot;formData&quot;:
                    switch (req.swgg.operation._consumes0) {
                    case &quot;application/x-www-form-urlencoded&quot;:
                    case &quot;application/xml&quot;:
                        req.swgg.paramDict[schemaP.name] = (
                            req.swgg.bodyParsed[schemaP.name]
                        );
                        break;
                    }
                    break;
                // parse header param
                case &quot;header&quot;:
                    req.swgg.paramDict[schemaP.name] = (
                        req.headers[schemaP.name.toLowerCase()]
                    );
                    break;
                // parse query param
                case &quot;query&quot;:
                    req.swgg.paramDict[schemaP.name] = (
                        req.urlParsed.query[schemaP.name]
                    );
                    break;
                }
                // parse array-multi
                tmp = req.swgg.paramDict[schemaP.name];
                if (
                    tmp
                    &amp;&amp; local.schemaPType(schemaP) === &quot;array&quot;
                    &amp;&amp; schemaP.collectionFormat === &quot;multi&quot;
                ) {
                    req.swgg.paramDict[schemaP.name] = (
                        encodeURIComponent(schemaP.name)
                        + &quot;=&quot; + (
                            Array.isArray(tmp)
                            ? tmp
                            : [
                                tmp
                            ]
                        ).join(&quot;&amp;&quot; + encodeURIComponent(schemaP.name) + &quot;=&quot;)
                    );
                }
                // init default
                if (
                    local.isNullOrUndefined(req.swgg.paramDict[schemaP.name])
                    &amp;&amp; schemaP.default !== undefined
                ) {
                    req.swgg.paramDict[schemaP.name] = local.jsonCopy(
                        schemaP.default
                    );
                }
            });
            // normalize paramDict
            local.normalizeSwaggerParamDict(req.swgg);
            // validate paramDict
            err = local.swaggerValidateDataParameters({
                data: req.swgg.paramDict,
                prefix: [
                    &quot;operation&quot;, req.swgg.methodPath
                ],
                parameters: req.swgg.operation.parameters,
                swaggerJson: local.swaggerJson
            })[0];
            op...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.moduleDirname" id="apidoc.elem.utility2.swgg.moduleDirname">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>moduleDirname
        <span class="apidocSignatureSpan">(module, pathList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moduleDirname = function (module, pathList) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
 */
</span>    let result;
    // search process.cwd()
    if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
        return require(&quot;path&quot;).resolve(process.cwd(), module || &quot;&quot;);
    }
    // search pathList
    Array.from([
        pathList,
        require(&quot;module&quot;).globalPaths,
        [
            process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
        ]
    ]).flat().some(function (path) {
        try {
            result = require(&quot;path&quot;).resolve(
                process.cwd(),
                path + &quot;/&quot; + module
            );
            result = require(&quot;fs&quot;).statSync(result).isDirectory() &amp;&amp; result;
            return result;
        } catch (ignore) {
            result = &quot;&quot;;
        }
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return match0.replace((
            /(.{128}(?:\b|\w+))/g
        ), &quot;$1\n&quot;).trimEnd();
    });
    return text;
};
// init opt
opt.dir = local.<span class="apidocCodeKeywordSpan">moduleDirname</span>(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectSetDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.nop" id="apidoc.elem.utility2.swgg.nop">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// run shared js-env code - function
(function () {
let __dirname;
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(__dirname, require);
globalThis.__coverageCodeDict__ = local.coalesce(
    globalThis.__coverageCodeDict__,
    {}
);
// mock builtins
__dirname = &quot;&quot;;
process = local.process || {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.normalizeJwt" id="apidoc.elem.utility2.swgg.normalizeJwt">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeJwt
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwt = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will normalize the jwt-data with registered-headers
 * https://tools.ietf.org/html/rfc7519#section-4.1
 */
</span>    let timeNow;
    timeNow = Date.now() / 1000;
    return local.objectSetDefault(data, {
        exp: timeNow + 5 * 60,
        iat: timeNow,
        jti: Math.random().toString(16).slice(2),
        nbf: timeNow
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.testCase_jwtAes256GcmXxx_default = function (opt, onError) {
/*
* this function will test jwtAes256GcmXxx&apos;s default handling-behavior
*/
   opt = {};
   opt.key = local.jwtAes256KeyCreate();
   // use canonical example at https://jwt.io/
   opt.data = JSON.parse(local.jsonStringifyOrdered(local.<span class="apidocCodeKeywordSpan">normalizeJwt</span>({
       sub: &quot;1234567890&quot;,
       name: &quot;John Doe&quot;,
       admin: true
   })));
   // encrypt token
   opt.token = local.jwtAes256GcmEncrypt(opt.data, opt.key);
   // validate encrypted-token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.normalizeJwtBase64Url" id="apidoc.elem.utility2.swgg.normalizeJwtBase64Url">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeJwtBase64Url
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwtBase64Url = function (b64) {
<span class="apidocCodeCommentSpan">/*
 * this function will normlize &lt;b64&gt; to base64url format
 */
</span>    return b64.replace((
        /\=/g
    ), &quot;&quot;).replace((
        /\+/g
    ), &quot;-&quot;).replace((
        /\//g
    ), &quot;_&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        data,
        {
            adata: local.sjcl.codec.base64url.toBits(adata),
            ks: 256,
            mode: &quot;gcm&quot;
        }
    ));
    return local.<span class="apidocCodeKeywordSpan">normalizeJwtBase64Url</span>(
        &quot;eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4R0NNIn0..&quot;
        + data.iv + &quot;.&quot; + data.ct + &quot;.&quot; + adata
    );
};

local.jwtAes256KeyCreate = function () {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.normalizeSwaggerJson" id="apidoc.elem.utility2.swgg.normalizeSwaggerJson">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeSwaggerJson
        <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeSwaggerJson = function (swaggerJson, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will normalize swaggerJson and filter $npm_package_swggTags0
 */
</span>    let pathDict;
    let tmp;
    opt = local.objectSetDefault(opt, {
        objectSetDescription: function (dict) {
            if (
                dict
                &amp;&amp; dict.description
                &amp;&amp; Array.isArray(dict[&quot;x-swgg-descriptionLineList&quot;])
            ) {
                delete dict.description;
            }
        }
    });
    local.objectSetDefault(swaggerJson, {
        paths: {},
        tags: []
    });
    // fix err - semanticPaths2
    pathDict = {};
    Object.keys(swaggerJson.paths).forEach(function (path) {
        tmp = path.replace((
            /\{.*?\}/g
        ), &quot;{}&quot;);
        pathDict[tmp] = pathDict[tmp] || {};
        pathDict[tmp][path] = true;
    });
    Object.keys(pathDict).forEach(function (key) {
        Object.keys(pathDict[key]).sort().forEach(function (path, ii) {
            // fix err.semanticUniquePath
            if (ii &amp;&amp; swaggerJson[&quot;x-swgg-fixErrorSemanticUniquePath&quot;]) {
                swaggerJson.paths[path + &quot;#&quot; + ii] = swaggerJson.paths[path];
                delete swaggerJson.paths[path];
            }
        });
    });
    Object.keys(swaggerJson.paths).forEach(function (path) {
        Object.keys(swaggerJson.paths[path]).forEach(function (method) {
            tmp = swaggerJson.paths[path][method];
            // auto-create operationId from path
            if (
                swaggerJson[&quot;x-swgg-operationIdFromPath&quot;]
                || tmp[&quot;x-swgg-operationIdFromPath&quot;]
                || !tmp.operationId
            ) {
                tmp.operationId = local.operationIdFromAjax({
                    method,
                    url: path
                });
            }
            // normalize parameter.required
            local.coalesce(tmp.parameters, []).forEach(function (schemaP) {
                if (schemaP.required === false) {
                    delete schemaP.required;
                }
            });
        });
    });
    // override tag.description with x-swgg-tags0-override
    if (swaggerJson[&quot;x-swgg-tags0-override&quot;]) {
        swaggerJson.tags.forEach(function (tag) {
            tmp = local.objectSetDefault(
                swaggerJson[&quot;x-swgg-tags0-override&quot;][tag.name],
                {
                    description: tag.description,
                    &quot;x-swgg-descriptionLineList&quot;: (
                        tag[&quot;x-swgg-descriptionLineList&quot;]
                    )
                }
            );
            tag.description = tmp.description;
            tag[&quot;x-swgg-descriptionLineList&quot;] = (
                tmp[&quot;x-swgg-descriptionLineList&quot;]
            );
            // objectSetDescription
            opt.objectSetDescription(tmp);
            opt.objectSetDescription(tag);
        });
    }
    // apply opt.objectSetDescription
    ([
        swaggerJson.externalDocs, swaggerJson.info
    ]).forEach(opt.objectSetDescription);
    ([
        swaggerJson.definitions, swaggerJson.parameters, swaggerJson.responses
    ]).forEach(function (dict) {
        Object.keys(dict || {}).forEach(function (key) {
            tmp = dict[key];
            if (dict === swaggerJson.definitions) {
                tmp = tmp.properties || {};
                Object.keys(tmp).forEach(function (key) {
                    opt.objectSetDescription(tmp[key]);
                });
                return;
            }
            opt.objectSetDescription(tmp);
        });
    });
    Object.keys(swaggerJson.paths).forEach(function (path) {
        Object.keys(swaggerJson.paths[path]).forEach(function (method) {
            tmp = swaggerJson.paths[path][method];
            opt.objectSetDescription(tmp);
            local.coalesce(
                tmp.parameters,
                []
            ).forEach(opt.objectSetDescriptio...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* this function will update the swagger-api dict of api-calls
*/
   let pathDict;
   let tmp;
   swaggerJson = swaggerJson || {};
   // normalize swaggerJson
   swaggerJson = local.<span class="apidocCodeKeywordSpan">normalizeSwaggerJson</span>(swaggerJson, {
       objectSetDescription: function (dict) {
           if (typeof dict === &quot;object&quot; &amp;&amp; dict &amp;&amp; !dict.$ref) {
               if (Array.isArray(dict[&quot;x-swgg-descriptionLineList&quot;])) {
                   dict.description = (
                       dict[&quot;x-swgg-descriptionLineList&quot;].join(&quot;\n&quot;)
                   );
               }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.normalizeSwaggerParamDict" id="apidoc.elem.utility2.swgg.normalizeSwaggerParamDict">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>normalizeSwaggerParamDict
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeSwaggerParamDict = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will parse the &lt;opt&gt; according to &lt;opt&gt;.operation.parameters
 */
</span>    let tmp;
    opt.operation.parameters.forEach(function (schemaP) {
        tmp = opt.paramDict[schemaP.name];
        // init default
        if (
            !opt.modeNoDefault
            &amp;&amp; (opt.modeDefault || schemaP.required)
            &amp;&amp; local.isNullOrUndefined(tmp)
        ) {
            tmp = local.jsonCopy(schemaP.default);
        }
        if (opt.modeDefault &amp;&amp; local.isNullOrUndefined(tmp)) {
            tmp = local.dbFieldRandomCreate({
                modeNotRandom: true,
                schemaP
            });
        }
        // parse array
        if (local.schemaPType(schemaP) === &quot;array&quot; &amp;&amp; schemaP.in !== &quot;body&quot;) {
            if (typeof tmp === &quot;string&quot;) {
                switch (
                    schemaP.collectionFormat
                    || schemaP[&quot;x-swgg-collectionFormat&quot;]
                ) {
                case &quot;json&quot;:
                    local.tryCatchOnError(function () {
                        tmp = JSON.parse(tmp);
                    }, local.nop);
                    opt.paramDict[schemaP.name] = tmp;
                    return;
                case &quot;multi&quot;:
                    tmp = local.urlParse(&quot;?&quot; + tmp, true).query[schemaP.name];
                    if (!Array.isArray(tmp)) {
                        tmp = [
                            tmp
                        ];
                    }
                    break;
                case &quot;pipes&quot;:
                    tmp = tmp.split(&quot;|&quot;);
                    break;
                case &quot;ssv&quot;:
                    tmp = tmp.split(&quot; &quot;);
                    break;
                case &quot;tsv&quot;:
                    tmp = tmp.split(&quot;\t&quot;);
                    break;
                // default to csv
                default:
                    tmp = tmp.split(&quot;,&quot;);
                }
                if (local.schemaPItemsType(schemaP) !== &quot;string&quot;) {
                    // try to JSON.parse the string
                    local.tryCatchOnError(function () {
                        tmp = tmp.map(function (element) {
                            return JSON.parse(element);
                        });
                    }, local.nop);
                }
            }
        // JSON.parse paramDict
        } else if (
            local.schemaPType(schemaP) !== &quot;file&quot;
            &amp;&amp; local.schemaPType(schemaP) !== &quot;string&quot;
            &amp;&amp; (
                typeof tmp === &quot;string&quot;
                || Object.prototype.toString.call(tmp) === &quot;[object Uint8Array]&quot;
            )
        ) {
            // try to JSON.parse the string
            local.tryCatchOnError(function () {
                tmp = JSON.parse(local.bufferToUtf8(tmp));
            }, local.nop);
        }
        opt.paramDict[schemaP.name] = tmp;
    });
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.objectSetDefault(opt, {
    data: &quot;&quot;,
    operation: that,
    paramDict: {},
    url: &quot;&quot;
});
if (opt.modeDefault) {
    local.<span class="apidocCodeKeywordSpan">normalizeSwaggerParamDict</span>(opt);
}
// try to validate paramDict
opt.err = local.swaggerValidateDataParameters({
    // normalize paramDict
    data: local.normalizeSwaggerParamDict({
        modeNoDefault: opt.modeNoDefault,
        operation: that,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.numberToRomanNumerals" id="apidoc.elem.utility2.swgg.numberToRomanNumerals">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>numberToRomanNumerals
        <span class="apidocSignatureSpan">(num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToRomanNumerals = function (num) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert num to a roman-numeral
 * https://stackoverflow.com/questions/9083037/convert-a-number-into-a-roman-numeral-in-javascript
 */
</span>    let digits;
    let ii;
    let key;
    let roman;
    digits = String(num).split(&quot;&quot;);
    key = [
        &quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;,
        &quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;,
        &quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;
    ];
    roman = &quot;&quot;;
    ii = 3;
    while (ii) {
        ii -= 1;
        roman = (key[Number(digits.pop()) + (ii * 10)] || &quot;&quot;) + roman;
    }
    return new Array(Number(digits.join(&quot;&quot;) + 1)).join(&quot;M&quot;) + roman;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &quot;XCVIII&quot;,
        &quot;XCIX&quot;,
        &quot;C&quot;
    ];
    opt.ii = 0;
    while (opt.ii &lt; 10) {
        local.assertJsonEqual(
            local.<span class="apidocCodeKeywordSpan">numberToRomanNumerals</span>(opt.ii),
            opt.list[opt.ii]
        );
        opt.ii += 1;
    }
    onError(undefined, opt);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.objectAssignDefault" id="apidoc.elem.utility2.swgg.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (target, source) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;target&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;source&gt;
 */
</span>    target = target || {};
    Object.keys(source || {}).forEach(function (key) {
        if (
            target[key] === null
            || target[key] === undefined
            || target[key] === &quot;&quot;
        ) {
            target[key] = target[key] || source[key];
        }
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (key[0] !== &quot;_&quot;) {
        xhr[key] = opt[key];
    }
});
// init timeout
timeout = xhr.timeout || local2.timeoutDefault || 30000;
// init default
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(xhr, {
    corsForwardProxyHost: local2.corsForwardProxyHost,
    headers: {},
    location: (local.isBrowser &amp;&amp; location) || {},
    method: &quot;GET&quot;,
    responseType: &quot;&quot;
});
// init headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.objectSetDefault" id="apidoc.elem.utility2.swgg.objectSetDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>objectSetDefault
        <span class="apidocSignatureSpan">(dict, defaults, depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectSetDefault = function (dict, defaults, depth) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set defaults for undefined-items in dict
 */
</span>    dict = dict || {};
    defaults = defaults || {};
    Object.keys(defaults).forEach(function (key) {
        let defaults2;
        let dict2;
        dict2 = dict[key];
        // handle misbehaving getter
        try {
            defaults2 = defaults[key];
        } catch (ignore) {}
        if (defaults2 === undefined) {
            return;
        }
        // init dict[key] to default value defaults[key]
        switch (dict2) {
        case &quot;&quot;:
        case null:
        case undefined:
            dict[key] = defaults2;
            return;
        }
        // if dict2 and defaults2 are both non-undefined and non-array objects,
        // then recurse with dict2 and defaults2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.objectSetDefault(dict2, defaults2, depth - 1);
        }
    });
    return dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // defaults2 is a non-undefined and non-array object
            &amp;&amp; typeof defaults2 === &quot;object&quot; &amp;&amp; defaults2
            &amp;&amp; !Array.isArray(defaults2)
        ) {
            // recurse
            local.<span class="apidocCodeKeywordSpan">objectSetDefault</span>(dict2, defaults2, depth - 1);
        }
    });
    return dict;
};

local.stringHtmlSafe = function (text) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.objectSetOverride" id="apidoc.elem.utility2.swgg.objectSetOverride">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>objectSetOverride
        <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectSetOverride = function (dict, overrides, depth, env) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set overrides for items in dict
 */
</span>    dict = dict || {};
    env = env || (typeof process === &quot;object&quot; &amp;&amp; process.env) || {};
    overrides = overrides || {};
    Object.keys(overrides).forEach(function (key) {
        let dict2;
        let overrides2;
        dict2 = dict[key];
        overrides2 = overrides[key];
        if (overrides2 === undefined) {
            return;
        }
        // if both dict2 and overrides2 are non-undefined and non-array objects,
        // then recurse with dict2 and overrides2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // overrides2 is a non-undefined and non-array object
            &amp;&amp; typeof overrides2 === &quot;object&quot; &amp;&amp; overrides2
            &amp;&amp; !Array.isArray(overrides2)
        ) {
            local.objectSetOverride(dict2, overrides2, depth - 1, env);
            return;
        }
        // else set dict[key] with overrides[key]
        dict[key] = (
            dict === env
            // if dict is env, then overrides falsy-value with empty-string
            ? overrides2 || &quot;&quot;
            : overrides2
        );
    });
    return dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.jsonStringifyOrdered(
local.<span class="apidocCodeKeywordSpan">objectSetOverride</span>(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.on" id="apidoc.elem.utility2.swgg.on">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>on
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         */
let bufList;
bufList = [];
xhr.resHeaders = resStream.headers || xhr.resHeaders;
xhr.resStream = resStream;
xhr.statusCode = resStream.statusCode;
resStream.dataLength = 0;
resStream.<span class="apidocCodeKeywordSpan">on</span>(&quot;data&quot;, function (buf) {
    bufList.push(buf);
});
resStream.on(&quot;end&quot;, function () {
    xhr.response = (
        local.isBrowser
        ? bufList[0]
        : Buffer.concat(bufList)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onErrorDefault" id="apidoc.elem.utility2.swgg.onErrorDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorDefault
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorDefault = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then print it to stderr
 */
</span>    if (err) {
        console.error(err);
    }
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.onParallel(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.<span class="apidocCodeKeywordSpan">onErrorDefault</span>(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
        return true;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onErrorJsonapi" id="apidoc.elem.utility2.swgg.onErrorJsonapi">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorJsonapi
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorJsonapi = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will normalize err and data to jsonapi format,
 * and pass them to onError
 * http://jsonapi.org/format/#errors
 * http://jsonapi.org/format/#document-structure-resource-objects
 */
</span>    return function (err, data, meta) {
        data = [
            err, data
        ].map(function (data, ii) {
            // if no err occurred, then return
            if (
                (ii === 0 &amp;&amp; !data)
                // if data is already normalized, then return it
                || (data &amp;&amp; data.meta &amp;&amp; data.meta.isJsonapiResponse)
            ) {
                return data;
            }
            // normalize data-list
            if (!Array.isArray(data)) {
                data = [
                    data
                ];
            }
            // normalize errList to contain non-null objects
            if (!ii) {
                data = data.errList || data;
                // normalize errList to be non-empty
                if (!data.length) {
                    data.push(null);
                }
                data = data.map(function (element) {
                    if (!(typeof element === &quot;object&quot; &amp;&amp; element)) {
                        element = {
                            message: String(element)
                        };
                    }
                    // normalize errObj to plain json-object
                    return {
                        message: element.message,
                        name: element.name,
                        stack: element.stack,
                        statusCode: Number(element.statusCode) || 500
                    };
                });
                err = local.jsonCopy(data[0]);
                err.errors = data;
                return err;
            }
            return {
                data
            };
        });
        // init data.meta
        data.forEach(function (data, ii) {
            if (!data) {
                return;
            }
            data.meta = local.jsonCopy(meta || {});
            data.meta.isJsonapiResponse = true;
            if (ii) {
                data.meta.dataLength = data.data.length;
            } else {
                data.meta.errorsLength = data.errors.length;
            }
            data.meta.statusCode = (
                Number(data.meta.statusCode)
                || Number(data.statusCode)
                || 0
            );
        });
        onError(data[0], data[1]);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.serverRespondJsonapi = function (req, res, err, data, meta) {
/*
* this function will respond in jsonapi format
* http://jsonapi.org/format/#errors
* http://jsonapi.org/format/#document-structure-resource-objects
*/
   local.<span class="apidocCodeKeywordSpan">onErrorJsonapi</span>(function (err, data) {
       local.serverRespondHeadSet(req, res, err &amp;&amp; err.statusCode, {
           &quot;Content-Type&quot;: &quot;application/json&quot;
       });
       if (err) {
           // debug statusCode / method / url
           local.errorMessagePrepend(
               err,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onErrorThrow" id="apidoc.elem.utility2.swgg.onErrorThrow">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorThrow
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorThrow = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then throw it
 */
</span>    if (err) {
        throw err;
    }
    return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_onErrorThrow_err = function (opt, onError) {
/*
 * this function will test onErrorThrow&apos;s err handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">onErrorThrow</span>(local.errDefault);
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onErrorWithStack" id="apidoc.elem.utility2.swgg.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack.replace((
        /(.*?)\n.*?$/m
    ), &quot;$1&quot;);
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errDefault
            &amp;&amp; String(err.stack).indexOf(stack.split(&quot;\n&quot;)[2]) &lt; 0
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onFileModifiedRestart" id="apidoc.elem.utility2.swgg.onFileModifiedRestart">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onFileModifiedRestart
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFileModifiedRestart = function (file) {
<span class="apidocCodeCommentSpan">/*
 * this function will watch the file, and if modified, then restart the process
 */
</span>    if (
        local.env.npm_config_mode_auto_restart
        &amp;&amp; local.fs.existsSync(file)
        &amp;&amp; local.fs.statSync(file).isFile()
    ) {
        local.fs.watchFile(file, {
            interval: 1000,
            persistent: false
        }, function (stat2, stat1) {
            if (stat2.mtime &gt; stat1.mtime) {
                console.error(&quot;file modified - &quot; + file);
                setTimeout(function () {
                    process.exit(77);
                }, 1000);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[
    __dirname + &quot;/lib.jslint.js&quot;,
    __filename,
    &quot;undefined&quot;
].forEach(function (file) {
    local.fs.exists(file, function (exists) {
        if (exists) {
            local.<span class="apidocCodeKeywordSpan">onFileModifiedRestart</span>(file);
        }
    });
});
local.fs.readdirSync(process.cwd()).forEach(function (file) {
    file = process.cwd() + &quot;/&quot; + file;
    // if the file is modified, then restart the process
    local.onFileModifiedRestart(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onParallel" id="apidoc.elem.utility2.swgg.onParallel">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if counter === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement counter
        onParallel.counter -= 1;
        // validate counter
        if (!(onParallel.counter &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.counter = &quot; + onParallel.counter
            );
        // ensure onError is run only once
        } else if (onParallel.counter &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure counter &lt;= 0
            onParallel.counter = -Math.abs(onParallel.counter);
        }
        // call onError when isDone
        if (onParallel.counter &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init counter
    onParallel.counter = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.counter -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onParallelList" id="apidoc.elem.utility2.swgg.onParallelList">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onParallelList
        <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallelList = function (opt, onEach, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. async-run onEach in parallel,
 *    with given &lt;opt&gt;.rateLimit and &lt;opt&gt;.retryLimit
 * 2. call &lt;onError&gt; when onParallel.ii + 1 === &lt;opt&gt;.list.length
 */
</span>    let isListEnd;
    let onEach2;
    let onParallel;
    opt.list = opt.list || [];
    onEach2 = function () {
        while (true) {
            if (!(onParallel.ii + 1 &lt; opt.list.length)) {
                isListEnd = true;
                return;
            }
            if (!(onParallel.counter &lt; opt.rateLimit + 1)) {
                return;
            }
            onParallel.ii += 1;
            onEach({
                elem: opt.list[onParallel.ii],
                ii: onParallel.ii,
                list: opt.list,
                retry: 0
            }, onParallel);
        }
    };
    onParallel = local.onParallel(onError, onEach2, function (err, data) {
        if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
            local.onErrorDefault(err);
            data.retry += 1;
            setTimeout(function () {
                onParallel.counter -= 1;
                onEach(data, onParallel);
            }, 1000);
            return true;
        }
        // restart if opt.list has grown
        if (isListEnd &amp;&amp; (onParallel.ii + 1 &lt; opt.list.length)) {
            isListEnd = undefined;
            onEach2();
        }
    });
    onParallel.ii = -1;
    opt.rateLimit = Number(opt.rateLimit) || 6;
    opt.rateLimit = Math.max(opt.rateLimit, 1);
    opt.retryLimit = Number(opt.retryLimit) || 2;
    onParallel.counter += 1;
    onEach2();
    onParallel();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        method: &quot;DELETE&quot;,
        sha: data.sha,
        url: opt.url
    }, opt.gotoNext);
    return;
}
// delete tree
local.<span class="apidocCodeKeywordSpan">onParallelList</span>({
    list: data
}, function (option2, onParallel) {
    onParallel.counter += 1;
    // recurse
    local.githubCrudContentDelete({
        httpReq: opt.httpReq,
        message: opt.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.onTimeout" id="apidoc.elem.utility2.swgg.onTimeout">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>onTimeout
        <span class="apidocSignatureSpan">(onError, timeout, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onTimeout = function (onError, timeout, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will create &lt;timeout&gt;-handler,
 * that appends current-stack to any err encountered
 */
</span>    onError = local.onErrorWithStack(onError);
    // create timerTimeout
    return setTimeout(function () {
        onError(new Error(&quot;onTimeout - &quot; + timeout + &quot; ms - &quot; + message));
    // coerce to finite integer
    }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + &quot;.png&quot;
);
opt.url = opt.url.replace(
    &quot;{{timeExit}}&quot;,
    Date.now() + local.timeoutDefault
);
// init timerTimeout
timerTimeout = local.<span class="apidocCodeKeywordSpan">onTimeout</span>(
    opt.gotoNext,
    local.timeoutDefault,
    testName
);
// create puppeteer browser
local.puppeteerLaunch({
    args: [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.once" id="apidoc.elem.utility2.swgg.once">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>once
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
if (cb) this.<span class="apidocCodeKeywordSpan">once</span>(&apos;close&apos;, cb);

//
// Terminate all associated clients.
//
if (this.clients) {
  for (const client of this.clients) client.terminate();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.operationIdFromAjax" id="apidoc.elem.utility2.swgg.operationIdFromAjax">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>operationIdFromAjax
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operationIdFromAjax = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a sortable operationId
 * from given ajax-&lt;opt&gt;
 */
</span>    let urlParsed;
    urlParsed = local.urlParseWithBraket(opt.url);
    return encodeURIComponent(
        urlParsed.pathname + urlParsed.hash + &quot; &quot; + opt.method.toUpperCase()
    ).replace((
        /[^\w\-.]/g
    ), &quot;_&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tmp = swaggerJson.paths[path][method];
// auto-create operationId from path
if (
    swaggerJson[&quot;x-swgg-operationIdFromPath&quot;]
    || tmp[&quot;x-swgg-operationIdFromPath&quot;]
    || !tmp.operationId
) {
    tmp.operationId = local.<span class="apidocCodeKeywordSpan">operationIdFromAjax</span>({
        method,
        url: path
    });
}
// normalize parameter.required
local.coalesce(tmp.parameters, []).forEach(function (schemaP) {
    if (schemaP.required === false) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.profile" id="apidoc.elem.utility2.swgg.profile">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>profile
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profile = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will profile async &lt;fnc&gt; in milliseconds
 * with callback &lt;onError&gt;
 */
</span>    let timeStart;
    timeStart = Date.now();
    // run async fnc
    fnc(function (err) {
        // call onError with difference in milliseconds
        // between Date.now() and timeStart
        onError(err, Date.now() - timeStart);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
// validate timeElapsed
local.assertOrThrow(
    0 &lt;= opt.timeElapsed &amp;&amp; opt.timeElapsed &lt; 1000,
    opt.timeElapsed
);
// test profile&apos;s async handling-behavior
local.<span class="apidocCodeKeywordSpan">profile</span>(function (onError) {
    setTimeout(onError);
}, function (err, timeElapsed) {
    // handle err
    local.assertOrThrow(!err, err);
    opt.timeElapsed = timeElapsed;
    // validate timeElapsed
    local.assertOrThrow((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.profileSync" id="apidoc.elem.utility2.swgg.profileSync">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>profileSync
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">profileSync = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will profile sync &lt;fnc&gt; in milliseconds
 */
</span>    let timeStart;
    timeStart = Date.now();
    // run sync fnc
    fnc();
    // return difference in milliseconds between Date.now() and timeStart
    return Date.now() - timeStart;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.testCase_profileXxx_default = function (opt, onError) {
/*
* this function will test profileXxx&apos;s default handling-behavior
*/
   opt = {};
   // test profileSync&apos;s handling-behavior
   opt.timeElapsed = local.<span class="apidocCodeKeywordSpan">profileSync</span>(function () {
       return;
   });
   // validate timeElapsed
   local.assertOrThrow(
       0 &lt;= opt.timeElapsed &amp;&amp; opt.timeElapsed &lt; 1000,
       opt.timeElapsed
   );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.puppeteerLaunch" id="apidoc.elem.utility2.swgg.puppeteerLaunch">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>puppeteerLaunch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppeteerLaunch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// init timerTimeout
timerTimeout = local.onTimeout(
    opt.gotoNext,
    local.timeoutDefault,
    testName
);
// create puppeteer browser
local.<span class="apidocCodeKeywordSpan">puppeteerLaunch</span>({
    args: [
        &quot;--headless&quot;,
        &quot;--incognito&quot;,
        &quot;--no-sandbox&quot;,
        &quot;--remote-debugging-port=0&quot;
    ],
    dumpio: !opt.modeSilent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.querySelector" id="apidoc.elem.utility2.swgg.querySelector">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>querySelector
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelector = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.querySelector(selectors)
    ) || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelector = function (selectors) {
/*
 * this function will return first dom-elem that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelector === &quot;function&quot;
        &amp;&amp; document.<span class="apidocCodeKeywordSpan">querySelector</span>(selectors)
    ) || {};
};
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.querySelectorAll" id="apidoc.elem.utility2.swgg.querySelectorAll">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>querySelectorAll
        <span class="apidocSignatureSpan">(selectors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">querySelectorAll = function (selectors) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
</span>    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.querySelectorAll(selectors))
    ) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.querySelectorAll = function (selectors) {
/*
 * this function will return dom-elem-list that match &lt;selectors&gt;
 */
    return (
        typeof document === &quot;object&quot; &amp;&amp; document
        &amp;&amp; typeof document.querySelectorAll === &quot;function&quot;
        &amp;&amp; Array.from(document.<span class="apidocCodeKeywordSpan">querySelectorAll</span>(selectors))
    ) || [];
};
// require builtin
if (!local.isBrowser) {
    local.assert = require(&quot;assert&quot;);
    local.buffer = require(&quot;buffer&quot;);
    local.child_process = require(&quot;child_process&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.removeEventListener" id="apidoc.elem.utility2.swgg.removeEventListener">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>removeEventListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEventListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha
=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=!1;this.K={progress:{},seeded:{}};this.u=this.ga=0;this
.I=1;this.J=2;this.ca=0x10000;this.T=[0,48,64,96,128,192,0x100,384,512,768,1024];this.da=3E4;this.ba=80};
sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady
(&quot;generator isn&apos;t seeded&quot;);if(d&amp;this.J){d=!(d&amp;this.I);e=[];var f=0,g;this.Z=e[0]=(new Date).valueOf()+this
.da;for(g=0;16&gt;g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g&lt;this.c.length&amp;&amp;(e=e.concat(this.c[g].finalize()),
f+=this.m[g],this.m[g]=0,d||!(this.P&amp;1&lt;&lt;g));g++);this.P&gt;=1&lt;&lt;this.c.length&amp;&amp;(this.c.push(new sjcl.hash
.sha256),this.m.push(0));this.f-=f;f&gt;this.o&amp;&amp;(this.o=
f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4&gt;d&amp;&amp;(this.h[d]=
this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d&lt;a;d+=4)0===(d+1)%this.ca&amp;&amp;y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this
);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&amp;&amp;&quot;Setting paranoia=0 will ruin your security; use
it only for testing&quot;!==b)throw new sjcl.exception.invalid(&quot;Setting paranoia=0 will ruin your security; use it only for
 testing&quot;);this.M=a},addEntropy:function(a,
b,c){c=c||&quot;user&quot;;var d,e,f=(new Date).valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&amp;&amp;(d=this
.U[c]=this.ha++);void 0===g&amp;&amp;(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case &quot;number&quot
;:void 0===b&amp;&amp;(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case &quot;object&quot;:c=Object.prototype.toString
.call(a);if(&quot;[object Uint32Array]&quot;===c){e=[];for(c=0;c&lt;a.length;c++)e.push(a[c]);a=e}else for(&quot;[object Array]&
quot;!==c&amp;&amp;(k=1),c=0;c&lt;a.length&amp;&amp;!k;c++)&quot;number&quot;!==typeof a[c]&amp;&amp;
(k=1);if(!k){if(void 0===b)for(c=b=0;c&lt;a.length;c++)for(e=a[c];0&lt;e;)b++,e=e&gt;&gt;&gt;1;this.c[g].update([d,this.N++,2,b,
f,a.length].concat(a))}break;case &quot;string&quot;:void 0===b&amp;&amp;(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length
]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug(&quot;random: addEntropy only supports number, array
of numbers or string&quot;);this.m[g]+=b;this.f+=b;h===this.u&amp;&amp;(this.isReady()!==this.u&amp;&amp;A(&quot;seeded&quot;,Math
.max(this.o,this.f)),A(&quot;progress&quot;,this.getProgress()))},
isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&amp;&amp;this.o&gt;=a?this.m[0]&gt;this.ba&amp;&amp;(new Date).valueOf
()&gt;this.Z?this.J|this.I:this.I:this.f&gt;=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o&
gt;=a?1:this.f&gt;a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:
B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window
.addEventListener)window.addEventListener(&quot;load&quot;,
this.a.loadTimeCollector,!1),window.addEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),window.addEventListener(&quot
;keypress&quot;,this.a.keyboardCollector,!1),window.addEventListener(&quot;devicemotion&quot;,this.a.accelerometerCollector,!1),
window.addEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent(&quot;
onload&quot;,this.a.loadTimeCollector),document.attachEvent(&quot;onmousemove&quot;,this.a.mouseCollector),document.attachEvent(&
quot;keypress&quot;,this.a.keyboardCollector);else throw new sjcl.exception.bug(&quot;can&apos;t attach event&quot;);
this.D=!0}},stopCollectors:function(){this.D&amp;&amp;(window.removeEventListener?(window.<span class="apidocCodeKeywordSpan">removeEventListener
</span>(&quot;load&quot;,this.a.loadTimeCollector,!1),window.removeEventListener(&quot;mousemove&quot;,this.a.mouseCollector,!1),
window.removeEventListener(&quot;keypress&quot;,this.a.keyboardCollector,!1),window.removeEventListener(&quot;devicemotion&quot;,
this.a.accelerometerCollector,!1),window.removeEventListener(&quot;touchmove&quot;,this.a.touchCollector,!1)):document.detachEvent
&amp;&amp;(document.detachEvent(&quot;onload&quot;,this.a.loadTimeCollector),document.detachEvent(&quot;onmousemove&quot;,
this.a.mouseCollector),document.detachEvent(&quot;keypress&quot;,this.a.keyboardCollector)),this.D=!1)},addEventListener:function
(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&amp;&amp
;e[d]===b&amp;&amp;f.push(d);for(c=0;c&lt;f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b
=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&amp;&amp;0!=c&amp;&amp;this.addEntropy([b,c],2,&
quot;mouse&quot;);C(this,0)},qa:function(a){a=
a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,&quot;touch&quot;);C(this,0)},ma:function
(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity
.z;if(window.orientation){var b=window.orientation;&quot;number&quot;===typeof b&amp;&amp;this.addEntropy(b,1,&quot;accelerometer
&quot;)}a&amp;&amp;this.addEntropy(a,2,&quot;accelerometer&quot;);C(this,0)}};
function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&amp;&amp;e.push(d[c]);for(c=0;c&lt;e.length;c++)e[c
](b)}function C(a,b){&quot;undefined&quot;!==typeof window&amp;&amp;window.performance&amp;&amp;&quot;function&quot;===typeof window
.performance.now?a.addEntropy(window.performance.now(),b,&quot;loadtime&quot;):a.addEntropy((new Date).valueOf(),b,&quot;loadtime
&quot;)}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4&gt;b&amp;&amp;(a.h[b]=a.h[b
]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}
function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
a:try{var D,E,F,G;if(G=&quot;undefined&quot;!==typeof module&amp;&amp;module.exports){var H;try{H=require(&quot;crypto&quot;)}catch
(a){H=null}G=E=H}if(G&amp;&amp;E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy
(D,1024,&quot;crypto[&apos;randomBytes&apos;]&quot;);else if(&quot;undefined&quot;!==typeof window&amp;&amp;&quot;undefined&quot
;!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&amp;&amp;window.crypto.getRandomValues)window.crypto.getRandomValues
(F);else if(window.msCrypto&amp;&amp;window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
else break a;sjcl.random.addEntropy(F,1024,&quot;crypto[&apos;getRandomValues&apos;]&quot;)}}catch(a){&quot;undefined&quot;!==typeof
 window&amp;&amp;window.console&amp;&amp;(console.log(&quot;There was an error collecting entropy from the browser:&quot;),console
.log(a))}
sjcl.json={defaults:{v:1,iter:1E4,ks:128,ts:64,mode:&quot;ccm&quot;,adata:&quot;&quot;,cipher:&quot;aes&quot;},ja:function(a,b,c
,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;&quot;string&quot;===
typeof f.salt&amp;&amp;(f.salt=sjcl.codec.base64.toBits(f.salt));&quot;string&quot;===typeof f.iv&amp;&amp;(f.iv=sjcl.codec.base64
.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||&quot;string&quot;===typeof a&amp;&amp;100&gt;=f.iter||64!==f.ts&amp
;&amp;96!==f.ts&amp;&amp;128!==f.ts||128!==f.ks&amp;&amp;192!==f.ks&amp;&amp;0x100!==f.ks||2&gt;f.iv.length||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.removeListener" id="apidoc.elem.utility2.swgg.removeListener">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i &lt; listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.<span class="apidocCodeKeywordSpan">removeListener</span>(method, listeners[i]);
      }
    }
  }
};

exports_websockets_ws_lib_event_target = EventTarget;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.replStart" id="apidoc.elem.utility2.swgg.replStart">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>replStart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replStart = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will start repl-debugger
 */
</span>    let that;
    if (globalThis.utility2_repl1) {
        return;
    }
    // start repl
    that = require(&quot;repl&quot;).start({
        useGlobal: true
    });
    globalThis.utility2_repl1 = that;
    // save eval-function
    that.evalDefault = that.eval;
    // hook custom-eval-function
    that.eval = function (script, context, file, onError) {
        script.replace((
            /^(\S+)\u0020(.*?)\n/
        ), function (ignore, match1, match2) {
            switch (match1) {
            // syntax-sugar - run shell-command
            case &quot;$&quot;:
                switch (match2) {
                // syntax-sugar - run git diff
                case &quot;git diff&quot;:
                    match2 = &quot;git diff --color | cat&quot;;
                    break;
                // syntax-sugar - run git log
                case &quot;git log&quot;:
                    match2 = &quot;git log -n 4 | cat&quot;;
                    break;
                // syntax-sugar - run ll
                case &quot;ll&quot;:
                    match2 = &quot;ls -Fal&quot;;
                    break;
                }
                // source lib.utility2.sh
                if (
                    process.platform !== &quot;win32&quot;
                    &amp;&amp; process.env.npm_config_dir_utility2 &amp;&amp; (match2 !== &quot;:&quot;)
                ) {
                    match2 = (
                        &quot;. &quot; + process.env.npm_config_dir_utility2
                        + &quot;/lib.utility2.sh;&quot; + match2
                    );
                }
                // run shell-command
                require(&quot;child_process&quot;).spawn(match2, {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                // print exitCode
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&quot;exitCode &quot; + exitCode);
                    that.evalDefault(&quot;\n&quot;, context, file, onError);
                });
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - map text with charCodeAt
            case &quot;charCode&quot;:
                console.error(
                    match2.split(&quot;&quot;).map(function (chr) {
                        return (
                            &quot;\\u&quot;
                            + chr.charCodeAt(0).toString(16).padStart(4, 0)
                        );
                    }).join(&quot;&quot;)
                );
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - sort chr
            case &quot;charSort&quot;:
                console.error(JSON.stringify(match2.split(&quot;&quot;).sort().join(&quot;&quot;)));
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - grep current dir
            case &quot;grep&quot;:
                // run shell-command
                require(&quot;child_process&quot;).spawn((
                    &quot;find . -type f | grep -v -E &quot;
/* jslint ignore:start */
+ &apos;&quot;\
/\\.|~\$|(\\b|_)(\\.\\d|\
archive|artifact|\
bower_component|build|\
coverage|\
doc|\
external|\
fixture|\
git_module|\
jquery|\
log|\
min|misc|mock|\
node_module|\
raw|\rollup|\
swp|\
tmp|\
vendor)s{0,1}(\\b|_)\
&quot; &apos;
/* jslint ignore:end */
                    + &quot;| tr \&quot;\\n\&quot; \&quot;\\000\&quot; | xargs -0 grep -HIin -E \&quot;&quot;
                    + match2 + &quot;\&quot;&quot;
                ), {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&quot;exitCode &quot; + exitCode);
                    that.evalDefault(&quot;\n&quot;, context, file, onError);...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.cliDict[&quot;utility2.start&quot;] = function () {
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.<span class="apidocCodeKeywordSpan">replStart</span>();
   local.testRunServer({});
};

local.cliDict[&quot;utility2.swaggerValidateFile&quot;] = function () {
/*
* &lt;file/url&gt;
* will swagger-validate file/url
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.requireReadme" id="apidoc.elem.utility2.swgg.requireReadme">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>requireReadme
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireReadme = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will require and export example.js embedded in README.md
 */
</span>    let code;
    let module;
    let tmp;
    // init module.exports
    module = {};
    if (local.isBrowser) {
        module.exports = local.objectSetDefault(
            globalThis.utility2_rollup || globalThis.local,
            local
        );
        return module.exports;
    }
    // start repl-debugger
    local.replStart();
    // debug dir
    [
        __dirname + &quot;/lib.jslint.js&quot;,
        __filename,
        &quot;undefined&quot;
    ].forEach(function (file) {
        local.fs.exists(file, function (exists) {
            if (exists) {
                local.onFileModifiedRestart(file);
            }
        });
    });
    local.fs.readdirSync(process.cwd()).forEach(function (file) {
        file = process.cwd() + &quot;/&quot; + file;
        // if the file is modified, then restart the process
        local.onFileModifiedRestart(file);
        switch (local.path.basename(file)) {
        // swagger-validate assets.swgg.swagger.json
        case &quot;assets.swgg.swagger.json&quot;:
            local.fs.readFile(file, &quot;utf8&quot;, function (err, data) {
                local.tryCatchOnError(function () {
                    // handle err
                    local.assertOrThrow(!err, err);
                    local.swgg.swaggerValidate(JSON.parse(data));
                }, local.onErrorDefault);
            });
            break;
        }
    });
    // jslint process.cwd()
    if (!local.env.npm_config_mode_library) {
        local.child_process.spawn(&quot;node&quot;, [
            &quot;-e&quot;, (
                &quot;require(&quot;
                + JSON.stringify(__filename)
                + &quot;).jslint.jslintAndPrintDir(&quot;
                + JSON.stringify(process.cwd())
                + &quot;, {autofix:true,conditional:true}, process.exit);&quot;
            )
        ], {
            env: Object.assign({}, local.env, {
                npm_config_mode_library: &quot;1&quot;
            }),
            stdio: [
                &quot;ignore&quot;, &quot;ignore&quot;, 2
            ]
        });
    }
    if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
        // init assets
        local.assetsDict[&quot;/index.html&quot;] = (
            local.fsReadFileOrEmptyStringSync(&quot;index.html&quot;)
            || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
        );
        local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
        local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
            __filename,
            &quot;utf8&quot;
        ).replace((
            /^#!\//
        ), &quot;// &quot;);
        // init exports
        local[local.env.npm_package_nameLib] = local;
        module.exports = local;
        return module.exports;
    }
    // init file $npm_package_main
    globalThis.utility2_moduleExports = require(
        process.cwd() + &quot;/&quot; + local.env.npm_package_main
    );
    globalThis.utility2_moduleExports.globalThis = globalThis;
    // read code from README.md
    code = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.example.template.js&quot;],
        {}
    );
    local.tryCatchOnError(function () {
        tmp = (
            /```\w*?(\n[\W\s]*?example\.js[\n&quot;][\S\s]*?)\n```/
        ).exec(
            local.fs.readFileSync(&quot;README.md&quot;, &quot;utf8&quot;)
        );
        code = tmp.input.slice(0, tmp.index).replace((
            /.+/g
        ), &quot;&quot;) + tmp[1];
    }, local.nop);
    // alias require($npm_package_name) to utility2_moduleExports;
    code = code.replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_name + &quot;.\\)&quot;),
        &quot;globalThis.utility2_moduleExports&quot;
    ).replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_nameOriginal + &quot;.\\)&quot;),
        &quot;globalThis.uti...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
\n\
\n\
\n\
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.<span class="apidocCodeKeywordSpan">requireReadme</span>();\n\
globalThis.local = local;\n\
// init test\n\
local.testRunDefault(local);\n\
}());\n\
\n\
\n\
\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.schemaPItems" id="apidoc.elem.utility2.swgg.schemaPItems">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPItems
        <span class="apidocSignatureSpan">(schemaP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schemaPItems = function (schemaP) {
<span class="apidocCodeCommentSpan">/*
 * this function will return schemaP.items
 */
</span>    return schemaP[&quot;x-swgg-items&quot;] || schemaP.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ? 2
        : 1
    )) {
        // recurse dbFieldRandomCreate
        value.push(local.dbFieldRandomCreate({
            depth: depth - 1,
            modeNotRandom: opt.modeNotRandom,
            schemaP: local.<span class="apidocCodeKeywordSpan">schemaPItems</span>(schemaP)
        }));
        ii += 1;
    }
    break;
case &quot;boolean&quot;:
    value = (
        opt.modeNotRandom
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.schemaPItemsType" id="apidoc.elem.utility2.swgg.schemaPItemsType">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPItemsType
        <span class="apidocSignatureSpan">(schemaP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schemaPItemsType = function (schemaP) {
<span class="apidocCodeCommentSpan">/*
 * this function will return schemaP.items.type
 */
</span>    return local.schemaPType(local.schemaPItems(schemaP) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opt[(
            schemaP.in === &quot;formData&quot;
            ? &quot;inForm&quot;
            : &quot;inQuery&quot;
        )] += (
            &quot;&amp;&quot; + encodeURIComponent(schemaP.name) + &quot;=&quot;
            + encodeURIComponent(
                local.<span class="apidocCodeKeywordSpan">schemaPItemsType</span>(schemaP) === &quot;string&quot;
                ? value
                : JSON.stringify(value)
            )
        );
    });
    return;
case &quot;pipes&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.schemaPType" id="apidoc.elem.utility2.swgg.schemaPType">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>schemaPType
        <span class="apidocSignatureSpan">(schemaP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schemaPType = function (schemaP) {
<span class="apidocCodeCommentSpan">/*
 * this function will return schemaP.type
 */
</span>    return schemaP &amp;&amp; (schemaP[&quot;x-swgg-type&quot;] || schemaP.type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete schemaP.$ref;
});
// init _idName.format and _idName.type
if (that._schemaName &amp;&amp; schemaP.name === that._idName) {
    schemaP.format = swaggerJson.definitions[
        that._schemaName
    ].properties[that._idBackend].format;
    schemaP.type = local.<span class="apidocCodeKeywordSpan">schemaPType</span>(
        swaggerJson.definitions[
            that._schemaName
        ].properties[that._idBackend]
    );
}
// init _schemaPDict
that._schemaPDict[schemaP.name] = schemaP;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.semverCompare" id="apidoc.elem.utility2.swgg.semverCompare">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>semverCompare
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">semverCompare = function (aa, bb) {
<span class="apidocCodeCommentSpan">/*
 * this function will compare semver versions aa ? bb and return
 * -1 if aa &lt; bb
 *  0 if aa = bb
 *  1 if aa &gt; bb
 * https://semver.org/#spec-item-11
 * example usage:
    semverCompare(&quot;2.2.2&quot;, &quot;10.2.2&quot;); // -1
    semverCompare(&quot;1.2.3&quot;, &quot;1.2.3&quot;);  //  0
    semverCompare(&quot;10.2.2&quot;, &quot;2.2.2&quot;); //  1
 */
</span>    let ii;
    let len;
    [
        aa, bb
    ] = [
        aa, bb
    ].map(function (val) {
        val = (
            /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z\-][0-9a-zA-Z\-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA
-Z\-][0-9a-zA-Z\-]*))*))?(?:\+([0-9a-zA-Z\-]+(?:\.[0-9a-zA-Z\-]+)*))?$/
        ).exec(val) || [
            &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;
        ];
        val[4] = val[4] || &quot;&quot;;
        return val.slice(1, 4).concat(val[4].split(&quot;.&quot;));
    });
    ii = -1;
    len = Math.max(aa.length, bb.length);
    while (true) {
        ii += 1;
        if (ii &gt;= len) {
            return 0;
        }
        aa[ii] = aa[ii] || &quot;&quot;;
        bb[ii] = bb[ii] || &quot;&quot;;
        if (ii === 3 &amp;&amp; aa[ii] !== bb[ii]) {
            // 1.2.3 &gt; 1.2.3-alpha
            if (!aa[ii]) {
                return 1;
            }
            // 1.2.3-alpha &lt; 1.2.3
            if (!bb[ii]) {
                return -1;
            }
        }
        if (aa[ii] !== bb[ii]) {
            aa = aa[ii];
            bb = bb[ii];
            return (
                Number(aa) &lt; Number(bb)
                ? -1
                : Number(aa) &gt; Number(bb)
                ? 1
                : aa &lt; bb
                ? -1
                : 1
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
), &quot;.&quot;));
bb = String(process.argv[2] || &quot;0.0.0&quot;).replace((
    /^(\d+?\.\d+?\.)(\d+)(\.*?)$/
), function (ignore, match1, match2, match3) {
    return match1 + (Number(match2) + 1) + match3;
});
packageJson.version = (
    local.<span class="apidocCodeKeywordSpan">semverCompare</span>(aa, bb) === 1
    ? aa
    : bb
);
console.error([
    aa, bb, packageJson.version
]);
// update package.json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondCors" id="apidoc.elem.utility2.swgg.serverRespondCors">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondCors
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondCors = function (req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will enable cors for the req
 * http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
 */
</span>    local.serverRespondHeadSet(req, res, undefined, local.jsonCopy({
        &quot;access-control-allow-headers&quot;:
        req.headers[&quot;access-control-request-headers&quot;],
        &quot;access-control-allow-methods&quot;:
        req.headers[&quot;access-control-request-method&quot;],
        &quot;access-control-allow-origin&quot;: &quot;*&quot;
    }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let onError;
let opt;
let timerTimeout;
// handle preflight-cors
if (req.method === &quot;OPTIONS&quot; &amp;&amp; (
    /forward-proxy-url/
).test(req.headers[&quot;access-control-request-headers&quot;])) {
    local.<span class="apidocCodeKeywordSpan">serverRespondCors</span>(req, res);
    res.end();
    return;
}
if (!req.headers[&quot;forward-proxy-url&quot;]) {
    next();
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondDefault" id="apidoc.elem.utility2.swgg.serverRespondDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondDefault
        <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondDefault = function (req, res, statusCode, err) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with a default message,
 * or &lt;err&gt;.stack for given statusCode
 */
</span>    // init statusCode and contentType
    local.serverRespondHeadSet(
        req,
        res,
        statusCode,
        {
            &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;
        }
    );
    if (err) {
        // debug statusCode / method / url
        local.errorMessagePrepend(
            err,
            res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url
            + &quot;\n&quot;
        );
        // print err.stack to stderr
        local.onErrorDefault(err);
        // end res with err.stack
        res.end(err.stack);
        return;
    }
    // end res with default statusCode message
    res.end(
        statusCode + &quot; &quot; + local.http.STATUS_CODES[statusCode]
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opt.gotoNext(null, data, meta);
    }
    break;
case 3:
    switch (crud.crudType[0]) {
    case &quot;fileGetOneById&quot;:
        if (!data) {
            local.<span class="apidocCodeKeywordSpan">serverRespondDefault</span>(req, res, 404);
            return;
        }
        local.serverRespondHeadSet(req, res, null, {
            &quot;Content-Type&quot;: data.fileContentType
        });
        res.end(local.base64ToBuffer(data.fileBlob));
        break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondEcho" id="apidoc.elem.utility2.swgg.serverRespondEcho">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondEcho
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondEcho = function (req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with debug info
 */
</span>    res.write(
        req.method + &quot; &quot; + req.url
        + &quot; HTTP/&quot; + req.httpVersion + &quot;\r\n&quot;
        + Object.keys(req.headers).map(function (key) {
            return key + &quot;: &quot; + req.headers[key] + &quot;\r\n&quot;;
        }).join(&quot;&quot;) + &quot;\r\n&quot;
    );
    req.pipe(res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;
// test http POST handling-behavior
case &quot;/test.echo&quot;:
    // test res-header handling-behavior
    local.serverRespondHeadSet(req, res, null, {
        &quot;X-Res-Header-Test&quot;: &quot;bb&quot;
    });
    local.<span class="apidocCodeKeywordSpan">serverRespondEcho</span>(req, res);
    break;
// test 500-internal-server-error handling-behavior
case &quot;/test.err-500&quot;:
    // test multiple-callback serverRespondHeadSet handling-behavior
    local.serverRespondHeadSet(req, res, null, {});
    next(local.errDefault);
    // test multiple-callback-error handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondHeadSet" id="apidoc.elem.utility2.swgg.serverRespondHeadSet">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondHeadSet
        <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondHeadSet = function (ignore, res, statusCode, headers) {
<span class="apidocCodeCommentSpan">/*
 * this function will set the &lt;res&gt; object&apos;s &lt;statusCode&gt; and &lt;headers&gt;
 */
</span>    if (res.headersSent) {
        return;
    }
    // init res.statusCode
    if (Number(statusCode)) {
        res.statusCode = Number(statusCode);
    }
    Object.keys(headers).forEach(function (key) {
        if (headers[key]) {
            res.setHeader(key, headers[key]);
        }
    });
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
    local.dbTableFile.crudSetManyById(crud.body, opt.gotoNext);
    break;
case &quot;userLoginByPassword&quot;:
case &quot;userLogout&quot;:
    // respond with 401 Unauthorized
    if (!user.isAuthenticated) {
        local.<span class="apidocCodeKeywordSpan">serverRespondHeadSet</span>(req, res, 401, {});
        req.swgg.crud.endArgList = [
            req, res
        ];
        opt.gotoState = Infinity;
        opt.gotoNext();
        return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondJsonapi" id="apidoc.elem.utility2.swgg.serverRespondJsonapi">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondJsonapi
        <span class="apidocSignatureSpan">(req, res, err, data, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondJsonapi = function (req, res, err, data, meta) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond in jsonapi format
 * http://jsonapi.org/format/#errors
 * http://jsonapi.org/format/#document-structure-resource-objects
 */
</span>    local.onErrorJsonapi(function (err, data) {
        local.serverRespondHeadSet(req, res, err &amp;&amp; err.statusCode, {
            &quot;Content-Type&quot;: &quot;application/json&quot;
        });
        if (err) {
            // debug statusCode / method / url
            local.errorMessagePrepend(
                err,
                res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url + &quot;\n&quot;
            );
            // print err.stack to stderr
            local.onErrorDefault(err);
        }
        data = err || data;
        res.statusCode = data.meta.statusCode || res.statusCode;
        data.meta.statusCode = res.statusCode;
        res.end(JSON.stringify(data));
    })(err, data, meta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// default - 404 Not Found
if (!err) {
    local.serverRespondDefault(req, res, 404);
    return;
}
// http://jsonapi.org/format/#errors
if (local.swgg &amp;&amp; typeof local.swgg.serverRespondJsonapi === &quot;function&quot;) {
    local.swgg.<span class="apidocCodeKeywordSpan">serverRespondJsonapi</span>(req, res, err);
}
// statusCode [400, 600)
local.serverRespondDefault(req, res, (
    (err.statusCode &gt;= 400 &amp;&amp; err.statusCode &lt; 600)
    ? err.statusCode
    : 500
), err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.serverRespondTimeoutDefault" id="apidoc.elem.utility2.swgg.serverRespondTimeoutDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>serverRespondTimeoutDefault
        <span class="apidocSignatureSpan">(req, res, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondTimeoutDefault = function (req, res, timeout) {
<span class="apidocCodeCommentSpan">/*
 * this function will create &lt;timeout&gt;-handler for server-&lt;req&gt;
 */
</span>    let isDone;
    let onError;
    onError = function () {
        if (isDone) {
            return;
        }
        isDone = true;
        // debug res
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(req.timeStart).toISOString(),
            type: &quot;serverResponse&quot;,
            method: req.method,
            url: req.url,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - req.timeStart,
            // extra
            reqContentLength: req.dataLength || 0,
            resContentLength: res.contentLength,
            reqHeaderXForwardedFor: req.headers[&quot;x-forwarded-for&quot;] || &quot;&quot;,
            reqHeaderOrigin: req.headers.origin || &quot;&quot;,
            reqHeaderReferer: req.headers.referer || &quot;&quot;,
            reqHeaderUserAgent: req.headers[&quot;user-agent&quot;]
        }));
        // cleanup timerTimeout
        clearTimeout(req.timerTimeout);
    };
    req.timeStart = Date.now();
    req.onTimeout = req.onTimeout || function (err) {
        local.serverRespondDefault(req, res, 500, err);
        setTimeout(function () {
            // cleanup &lt;req&gt; and &lt;res&gt;
            local.streamCleanup(req);
            local.streamCleanup(res);
        }, 1000);
    };
    // init timerTimeout
    req.timerTimeout = local.onTimeout(
        req.onTimeout,
        timeout || local.timeoutDefault,
        &quot;server &quot; + req.method + &quot; &quot; + req.url
    );
    res.contentLength = 0;
    res.writeContentLength = res.writeContentLength || res.write;
    res.write = function (buf, encoding, callback) {
        buf = local.bufferValidateAndCoerce(buf, typeof buf);
        res.contentLength += buf.length;
        res.writeContentLength(buf, encoding, callback);
    };
    res.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local._debugServerReqRes3 = local._debugServerReqRes2;
local._debugServerReqRes2 = local._debugServerReqRes1;
local._debugServerReqRes1 = {
    req,
    res
};
// init timerTimeout
local.<span class="apidocCodeKeywordSpan">serverRespondTimeoutDefault</span>(req, res, local.timeoutDefault);
// init req.urlParsed
req.urlParsed = local.urlParse(req.url);
// init res-header content-type
local.serverRespondHeadSet(req, res, undefined, {
    &quot;Content-Type&quot;: local.contentTypeDict[(
        /\.[^.]*?$|$/m
    ).exec(req.urlParsed.pathname)[0]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.setTimeoutOnError" id="apidoc.elem.utility2.swgg.setTimeoutOnError">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>setTimeoutOnError
        <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeoutOnError = function (onError, timeout, err, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will after timeout has passed,
 * then call &lt;onError&gt;(&lt;err&gt;, &lt;data&gt;)
 */
</span>    if (typeof onError === &quot;function&quot;) {
        setTimeout(function () {
            onError(err, data);
        }, timeout);
    }
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           element.querySelector(
               &quot;[tabIndex]&quot;
           ).focus();
           // validate input
           local.uiEventListenerDict.onEventInputValidateAndAjax({
               targetOnEvent: element
           });
           local.<span class="apidocCodeKeywordSpan">setTimeoutOnError</span>(onError, 0, null, element);
       }
   );
};

local.uiEventListenerDict.onEventResourceDisplayAction = function (evt) {
/*
* this function will toggle the display of the resource
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHashScryptCreate" id="apidoc.elem.utility2.swgg.sjclHashScryptCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashScryptCreate
        <span class="apidocSignatureSpan">(password, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashScryptCreate = function (password, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a scrypt-hash of the password
 * with given &lt;opt&gt; (default = $s0$10801)
 * e.g.
 * $s0$e0801$epIxT/h6HbbwHaehFnh/bw==$7H0vs
 * XlY8UxxyW/BWx/9GuY7jEvGjT71GFd6O4SZND0=
 * https://github.com/wg/scrypt
 */
</span>    // init opt
    opt = String(opt || &quot;$s0$10801&quot;).split(&quot;$&quot;);
    // init salt
    if (!opt[3]) {
        opt[3] = local.sjcl.codec.base64.fromBits(
            local.sjcl.random.randomWords(4, 0)
        );
    }
    // init hash
    opt[4] = local.sjcl.codec.base64.fromBits(
        local.sjcl.misc.scrypt(
            password || &quot;&quot;,
            local.sjcl.codec.base64.toBits(opt[3]),
            Math.pow(2, parseInt(opt[2].slice(0, 1), 16)),
            parseInt(opt[2].slice(1, 2), 16),
            parseInt(opt[2].slice(3, 4), 16)
        )
    );
    return opt.slice(0, 5).join(&quot;$&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.sjclHashScryptValidate = function (password, hash) {
/*
* this function will validate the password against the scrypt-hash
* https://github.com/wg/scrypt
*/
   return local.<span class="apidocCodeKeywordSpan">sjclHashScryptCreate</span>(password, hash) === hash;
};

local.sjclHashSha1Create = function (data) {
/*
* this function will create a base64-encoded sha1 hash of the string data
*/
   return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha1.hash(data));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHashScryptValidate" id="apidoc.elem.utility2.swgg.sjclHashScryptValidate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashScryptValidate
        <span class="apidocSignatureSpan">(password, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashScryptValidate = function (password, hash) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the password against the scrypt-hash
 * https://github.com/wg/scrypt
 */
</span>    return local.sjclHashScryptCreate(password, hash) === hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opt.gotoState = Infinity;
    opt.gotoNext();
    break;
case 2:
    switch (crud.crudType[0]) {
    case &quot;userLoginByPassword&quot;:
        user.data = data;
        if (!local.<span class="apidocCodeKeywordSpan">sjclHashScryptValidate</span>(
            user.password,
            user.data &amp;&amp; user.data.password
        )) {
            opt.gotoState = Infinity;
            opt.gotoNext();
            return;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHashSha1Create" id="apidoc.elem.utility2.swgg.sjclHashSha1Create">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashSha1Create
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashSha1Create = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha1 hash of the string data
 */
</span>    return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha1.hash(data));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_sjclHashShaXxxCreate_default = function (opt, onError) {
/*
* this function will test sjclHashShaXxxCreate&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">sjclHashSha1Create</span>(&quot;aa&quot;),
       &quot;4MkDWJjdUvxlxBRUzsnE0mEb+zc=&quot;
   );
   local.assertJsonEqual(
       local.sjclHashSha256Create(&quot;aa&quot;),
       &quot;lhtt0+3jy47LqsvWjeBAzXjrLtWIkTDM60xJJo6k1QY=&quot;
   );
   onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHashSha256Create" id="apidoc.elem.utility2.swgg.sjclHashSha256Create">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHashSha256Create
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHashSha256Create = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha256 hash of the string data
 */
</span>    return local.sjcl.codec.base64.fromBits(local.sjcl.hash.sha256.hash(data));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will test sjclHashShaXxxCreate&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.sjclHashSha1Create(&quot;aa&quot;),
        &quot;4MkDWJjdUvxlxBRUzsnE0mEb+zc=&quot;
    );
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">sjclHashSha256Create</span>(&quot;aa&quot;),
        &quot;lhtt0+3jy47LqsvWjeBAzXjrLtWIkTDM60xJJo6k1QY=&quot;
    );
    onError(undefined, opt);
};

local.testCase_sjclHmacShaXxx_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHmacSha1Create" id="apidoc.elem.utility2.swgg.sjclHmacSha1Create">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHmacSha1Create
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHmacSha1Create = function (key, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha1 hmac
 * from the string key and string data
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    return local.sjcl.codec.base64.fromBits(
        (new Hmac(
            local.sjcl.codec.utf8String.toBits(key),
            local.sjcl.hash.sha1
        )).mac(local.sjcl.codec.utf8String.toBits(data))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_sjclHmacShaXxx_default = function (opt, onError) {
/*
* this function will test sjclHmacShaXxx&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">sjclHmacSha1Create</span>(&quot;aa&quot;, &quot;bb&quot;),
       &quot;15pOinCz63A+qZoxnv+mJB6UF1k=&quot;
   );
   local.assertJsonEqual(
       local.sjclHmacSha256Create(&quot;aa&quot;, &quot;bb&quot;),
       &quot;94Xv3VdPHA+ohKyjkM1pb0W5ZVAuMVcmIAAI2AqNRCQ=&quot;
   );
   onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.sjclHmacSha256Create" id="apidoc.elem.utility2.swgg.sjclHmacSha256Create">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>sjclHmacSha256Create
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sjclHmacSha256Create = function (key, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a base64-encoded sha256 hmac
 * from the string key and string data
 */
</span>    let Hmac;
    Hmac = local.sjcl.misc.hmac;
    return local.sjcl.codec.base64.fromBits(
        (new Hmac(
            local.sjcl.codec.utf8String.toBits(key),
            local.sjcl.hash.sha256
        )).mac(local.sjcl.codec.utf8String.toBits(data))
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this function will test sjclHmacShaXxx&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.sjclHmacSha1Create(&quot;aa&quot;, &quot;bb&quot;),
        &quot;15pOinCz63A+qZoxnv+mJB6UF1k=&quot;
    );
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">sjclHmacSha256Create</span>(&quot;aa&quot;, &quot;bb&quot;),
        &quot;94Xv3VdPHA+ohKyjkM1pb0W5ZVAuMVcmIAAI2AqNRCQ=&quot;
    );
    onError(undefined, opt);
};

local.testCase_stringHtmlSafe_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stateInit" id="apidoc.elem.utility2.swgg.stateInit">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stateInit
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stateInit = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will init state &lt;opt&gt;
 */
</span>    local.objectSetOverride(local, opt, 10);
    // init swgg
    local.swgg.apiUpdate(local.swgg.swaggerJson);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   local.fsReadFileOrEmptyStringSync(&quot;assets.swgg.swagger.json&quot;)
   || local.assetsDict[&quot;/assets.swgg.swagger.json&quot;]
   || local.assetsDict[&quot;/assets.swgg.swagger.petstore.json&quot;]
);
// hack-coverage - test testRunServer&apos;s multiple-call handling-behavior
local.testRunServer(local);
// hack-coverage - stateInit
local.<span class="apidocCodeKeywordSpan">stateInit</span>({});
// init test-middleware
local.middlewareList.push(function (req, res, next) {
/*
* this function will run the test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stream" id="apidoc.elem.utility2.swgg.stream">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.streamCleanup" id="apidoc.elem.utility2.swgg.streamCleanup">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>streamCleanup
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamCleanup = function (stream) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to end or destroy the stream
 */
</span>    let err;
    // try to end the stream
    try {
        stream.end();
    } catch (errCaught) {
        err = errCaught;
    }
    // if err, then try to destroy the stream
    if (err) {
        try {
            stream.destroy();
        } catch (ignore) {}
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // extra
        headers: opt.headers
    }));
    if (!err) {
        return;
    }
    // cleanup clientReq and clientRes
    local.<span class="apidocCodeKeywordSpan">streamCleanup</span>(opt.clientReq);
    local.streamCleanup(opt.clientReq);
    next(err);
};
// init opt
opt = local.urlParse(req.headers[&quot;forward-proxy-url&quot;]);
opt.method = req.method;
opt.url = req.headers[&quot;forward-proxy-url&quot;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringHtmlSafe" id="apidoc.elem.utility2.swgg.stringHtmlSafe">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringHtmlSafe
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringHtmlSafe = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will make the text html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
</span>    return text.replace((
        /&amp;/g
    ), &quot;&amp;&quot;).replace((
        /&quot;/g
    ), &quot;&quot;&quot;).replace((
        /&apos;/g
    ), &quot;&apos;&quot;).replace((
        /&lt;/g
    ), &quot;&lt;&quot;).replace((
        /&gt;/g
    ), &quot;&gt;&quot;).replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/ig
    ), &quot;&amp;$1&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
// handle case where module is a function
elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
if (elem.typeof !== &quot;function&quot;) {
    return elem;
}
// init source
elem.source = local.<span class="apidocCodeKeywordSpan">stringHtmlSafe</span>(
    trimStart(toString(module[key])) || &quot;n/a&quot;
).replace((
    /\([\S\s]*?\)/
), function (match0) {
    // init signature
    elem.signature = match0.replace((
        /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringMerge" id="apidoc.elem.utility2.swgg.stringMerge">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringMerge
        <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringMerge = function (str1, str2, rgx) {
<span class="apidocCodeCommentSpan">/*
 * this function will merge &lt;str2&gt; into &lt;str1&gt;,
 * for sections where both match &lt;rgx&gt;
 */
</span>    str2.replace(rgx, function (match2) {
        str1.replace(rgx, function (match1) {
            str1 = str1.replace(match1, function () {
                return match2;
            });
            return &quot;&quot;;
        });
        return &quot;&quot;;
    });
    return str1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
    ),
    // customize body after /* validateLineSortedReset */
    (
        /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
    )
].forEach(function (rgx) {
    opt.dataTo = local.<span class="apidocCodeKeywordSpan">stringMerge</span>(opt.dataTo, opt.dataFrom, rgx);
});
// customize local for assets.utility2.rollup.js
if (
    local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
    &amp;&amp; local.env.npm_package_nameLib !== &quot;swgg&quot;
) {
    opt.dataTo = opt.dataTo.replace(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringQuotedToAscii" id="apidoc.elem.utility2.swgg.stringQuotedToAscii">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringQuotedToAscii
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringQuotedToAscii = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will replace non-ascii-chr to unicode-escaped-ascii-chr
 * in quoted-&lt;str&gt;
 */
</span>    return str.replace((
        /\r/g
    ), &quot;\\r&quot;).replace((
        /\t/g
    ), &quot;\\t&quot;).replace((
        /[^\n\u0020-\u007e]/g
    ), function (chr) {
        return &quot;\\u&quot; + (&quot;0000&quot; + chr.charCodeAt(0).toString(16)).slice(-4);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_stringQuotedToAscii_default = function (opt, onError) {
/*
 * this function will test stringQuotedToAscii&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">stringQuotedToAscii</span>(local.stringHelloEmoji),
        &quot;hello \\ud83d\\ude01\n&quot;
    );
    onError(undefined, opt);
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringRegexpEscape" id="apidoc.elem.utility2.swgg.stringRegexpEscape">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringRegexpEscape
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringRegexpEscape = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will regexp-escape text
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
 */
</span>    return text.replace((
        /[\-\/\\\^$*+?.()|\[\]{}]/g
    ), &quot;\\$&amp;&quot;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
* this function will test stringRegexpEscape&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">stringRegexpEscape</span>(local.stringCharsetAscii),
       (
           &quot;\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007&quot;
           + &quot;\b\t\n\u000b\f\r\u000e\u000f&quot;
           + &quot;\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017&quot;
           + &quot;\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f&quot;
           + &quot; !\&quot;#\\$%&amp;&apos;\\(\\)\\*\\+,\\-\\.\\/0123456789:;&lt;=&gt;\\?@&quot;
           + &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]\\^_`&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringTruncate" id="apidoc.elem.utility2.swgg.stringTruncate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringTruncate
        <span class="apidocSignatureSpan">(text, maxLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTruncate = function (text, maxLength) {
<span class="apidocCodeCommentSpan">/*
 * this function will truncate text to given maxLength
 */
</span>    return (
        text.length &gt; maxLength
        ? text.slice(0, maxLength - 3).trimEnd() + &quot;...&quot;
        : text
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
].forEach(function (ii) {
    opt[&quot;prefix&quot; + ii] = opt.prefix[ii] + opt.prefix.slice(
        ii + 1
    ).map(function (element) {
        return &quot;[&quot; + JSON.stringify(element) + &quot;]&quot;;
    }).join(&quot;&quot;);
});
opt.prefix0 += &quot; = &quot; + local.<span class="apidocCodeKeywordSpan">stringTruncate</span>(
    JSON.stringify(opt.data) || &quot;undefined&quot;,
    100
);
opt.schema2 = local.stringTruncate(
    JSON.stringify(opt.schema) || &quot;undefined&quot;,
    500
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.stringUniqueKey" id="apidoc.elem.utility2.swgg.stringUniqueKey">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>stringUniqueKey
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringUniqueKey = function (text) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a string-key that is unique in given text
 */
</span>    let key;
    // seed the key with the least frequent letters in the english-language
    // https://en.wikipedia.org/wiki/Letter_frequency
    key = &quot;zqxj&quot;;
    do {
        key += Number(
            (1 + Math.random()) * 0x10000000000000
        ).toString(36).slice(1);
    } while (text.indexOf(key) &gt;= 0);
    return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let arg;
let argList;
let doubleBackslash;
let opt;
let quote;
arg = &quot;&quot;;
argList = [];
doubleBackslash = local.<span class="apidocCodeKeywordSpan">stringUniqueKey</span>(text);
// parse doubleBackslash
text = text.replace((
    /\\\\/g
), doubleBackslash);
// parse line-continuation
text = text.replace((
    /\\\n/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerJsonFromAjax" id="apidoc.elem.utility2.swgg.swaggerJsonFromAjax">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromAjax
        <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerJsonFromAjax = function (swaggerJson, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will update swaggerJson
 * with definitions and paths created from given ajax-&lt;opt&gt;
 */
</span>    let data;
    let isArray;
    let operation;
    let pathDict;
    let type;
    let upsertSchemaP;
    let urlParsed;
    upsertSchemaP = function (schemaP) {
        if (!operation.parameters.some(function (element) {
            if (element.in === schemaP.in &amp;&amp; element.name === schemaP.name) {
                [
                    &quot;default&quot;, &quot;items&quot;, &quot;schema&quot;
                ].forEach(function (key) {
                    if (!local.isNullOrUndefined(schemaP[key])) {
                        element[key] = schemaP[key];
                    }
                });
                return true;
            }
        })) {
            operation.parameters.push(schemaP);
        }
    };
    // init swaggerJson
    swaggerJson = local.objectSetDefault(swaggerJson, {
        basePath: &quot;/&quot;,
        definitions: {},
        info: {
            title: &quot;&quot;,
            version: &quot;&quot;
        },
        paths: {},
        swagger: &quot;2.0&quot;
    });
    // init opt
    opt = local.objectSetDefault(opt, {
        headers: {},
        method: &quot;GET&quot;
    });
    // init urlParsed
    urlParsed = local.urlParseWithBraket(opt.url);
    // init operation
    operation = {
        operationId: opt.operationId || local.operationIdFromAjax(opt),
        parameters: [],
        responses: {
            default: {
                description: &quot;default response&quot;
            }
        },
        tags: opt.tags || [
            &quot;undefined&quot;
        ],
        &quot;x-swgg-tags0&quot;: opt[&quot;x-swgg-tags0&quot;]
    };
    if ((
        /^(?:http|https):\/\//
    ).test(opt.url)) {
        operation[&quot;x-swgg-host&quot;] = urlParsed.host;
        operation[&quot;x-swgg-schemes&quot;] = [
            urlParsed.protocol.slice(0, -1)
        ];
    }
    pathDict = {};
    pathDict[urlParsed.pathname + urlParsed.hash] = {};
    pathDict[urlParsed.pathname + urlParsed.hash][
        opt.method.toLowerCase()
    ] = operation;
    local.objectSetDefault(swaggerJson, {
        paths: pathDict
    }, 3);
    // init param in header
    Object.keys(opt.headers).forEach(function (key) {
        upsertSchemaP({
            default: opt.headers[key],
            in: &quot;header&quot;,
            name: key,
            type: &quot;string&quot;
        });
    });
    // init param in path
    urlParsed.pathname.replace((
        /\{[^}]+?\}/g
    ), function (match0) {
        match0 = match0.slice(1, -1);
        upsertSchemaP({
            default: match0,
            in: &quot;path&quot;,
            name: match0,
            required: true,
            type: &quot;string&quot;
        });
    });
    // init param in query
    Object.keys(urlParsed.query).forEach(function (key) {
        upsertSchemaP({
            default: urlParsed.query[key],
            in: &quot;query&quot;,
            name: key,
            type: &quot;string&quot;
        });
    });
    data = opt.data;
    if (!data) {
        return swaggerJson;
    }
    // init param in body - text-data
    upsertSchemaP({
        in: &quot;body&quot;,
        name: &quot;body&quot;,
        schema: {
            type: &quot;string&quot;
        }
    });
    local.tryCatchOnError(function () {
        data = JSON.parse(data);
    }, local.nop);
    if (typeof data !== &quot;object&quot;) {
        return swaggerJson;
    }
    // init param in body - json-data
    isArray = Array.isArray(data);
    type = local.swaggerJsonFromPostBody(swaggerJson, {
        data: (
            isArray
            ? data[0]
            : data
        ),
        depth: 2,
        key: &quot;body&quot;,
        prefix: operation.operationId,
        &quot;x-swgg-tags0&quot;: opt[&quot;x-swgg-tags0&quot;]
    });
    upsertSchemaP({
        in: &quot;body&quot;,
        name: &quot;body&quot;,...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &quot;-X&quot;:
    opt.method = arg;
    return;
}
if (arg === &quot;curl&quot;) {
    if (opt) {
        opt.url = opt.url || argList[ii - 1];
        swaggerJson = local.<span class="apidocCodeKeywordSpan">swaggerJsonFromAjax</span>(swaggerJson, opt);
    }
    opt = {
        headers: {},
        method: &quot;GET&quot;
    };
}
if ((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerJsonFromCurl" id="apidoc.elem.utility2.swgg.swaggerJsonFromCurl">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromCurl
        <span class="apidocSignatureSpan">(swaggerJson, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerJsonFromCurl = function (swaggerJson, text) {
<span class="apidocCodeCommentSpan">/*
 * this function will update swaggerJson
 * with definitions and paths created from given curl-command-text
 */
</span>    let arg;
    let argList;
    let doubleBackslash;
    let opt;
    let quote;
    arg = &quot;&quot;;
    argList = [];
    doubleBackslash = local.stringUniqueKey(text);
    // parse doubleBackslash
    text = text.replace((
        /\\\\/g
    ), doubleBackslash);
    // parse line-continuation
    text = text.replace((
        /\\\n/g
    ), &quot;&quot;);
    // parse quotes
    text.replace((
        /(\s*?)(\S+)/g
    ), function (match0, line, word) {
        line = match0;
        word.replace((
            /^([&quot;&apos;]?).*?(?:\\&quot;)?([&quot;&apos;]?)$/
        ), function (quote1, match1, quote2) {
            quote1 = match1;
            if (quote) {
                arg += line;
            } else {
                arg = word;
                quote = quote1;
            }
            if (!quote || quote === quote2) {
                switch (quote) {
                // parse escapes in single-quotes
                case &quot;&apos;&quot;:
                    arg = arg.replace((
                        /&apos;&quot;&apos;&quot;&apos;/g
                    ), &quot;&apos;&quot;);
                    arg = arg.slice(1, -1);
                    break;
                // parse escapes in double-quotes
                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                case &quot;\&quot;&quot;:
                    arg = arg.replace((
                        /\\([$`&quot;\n])/g
                    ), &quot;$1&quot;);
                    arg = arg.slice(1, -1);
                    break;
                }
                argList.push(arg);
                arg = &quot;&quot;;
                quote = &quot;&quot;;
            }
        });
    });
    // un-parse doubleBackslash
    argList = argList.map(function (arg) {
        return arg.replace(new RegExp(doubleBackslash, &quot;g&quot;), &quot;\\\\&quot;);
    });
    argList.push(&quot;curl&quot;);
    argList.forEach(function (arg, ii) {
        switch (argList[ii - 1]) {
        case &quot;--data&quot;:
        case &quot;--data-ascii&quot;:
        case &quot;--data-binary&quot;:
        case &quot;--data-raw&quot;:
        case &quot;-d&quot;:
            opt.data = arg;
            return;
        case &quot;--header&quot;:
        case &quot;-H&quot;:
            arg = arg.split(&quot;:&quot;);
            arg[1] = arg.slice(1).join(&quot;:&quot;).trim();
            opt.headers[arg[0].toLowerCase()] = arg[1];
            return;
        case &quot;--request&quot;:
        case &quot;-X&quot;:
            opt.method = arg;
            return;
        }
        if (arg === &quot;curl&quot;) {
            if (opt) {
                opt.url = opt.url || argList[ii - 1];
                swaggerJson = local.swaggerJsonFromAjax(swaggerJson, opt);
            }
            opt = {
                headers: {},
                method: &quot;GET&quot;
            };
        }
        if ((
            /^(?:http|https):\/\//
        ).test(arg)) {
            opt.url = arg;
        }
    });
    return swaggerJson;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerJsonFromPostBody" id="apidoc.elem.utility2.swgg.swaggerJsonFromPostBody">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerJsonFromPostBody
        <span class="apidocSignatureSpan">(swaggerJson, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerJsonFromPostBody = function (swaggerJson, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will update swaggerJson
 * with definitions created from the post-body-data
 */
</span>    let definition;
    let isArray;
    let prefix;
    let schemaP;
    let type;
    let value;
    prefix = opt.prefix + &quot;.&quot; + encodeURIComponent(opt.key);
    definition = {
        properties: {},
        &quot;x-swgg-tags0&quot;: opt[&quot;x-swgg-tags0&quot;]
    };
    swaggerJson.definitions[prefix] = definition;
    Object.keys(opt.data).forEach(function (key) {
        value = opt.data[key];
        isArray = Array.isArray(value);
        if (isArray) {
            value = value[0];
        }
        type = (
            local.isNullOrUndefined(value)
            ? &quot;string&quot;
            : typeof value
        );
        schemaP = (
            isArray
            ? {
                default: opt.data[key],
                items: {
                    type
                },
                type: &quot;array&quot;
            }
            : {
                default: value,
                type
            }
        );
        definition.properties[key] = schemaP;
        if (!(type === &quot;object&quot; &amp;&amp; opt.depth &gt; 1)) {
            return;
        }
        // recurse
        type = local.swaggerJsonFromPostBody(swaggerJson, {
            data: value,
            depth: opt.depth - 1,
            key,
            prefix,
            &quot;x-swgg-tags0&quot;: opt[&quot;x-swgg-tags0&quot;]
        });
        if (isArray) {
            schemaP.items = type;
        } else {
            definition.properties[key] = type;
        }
    });
    return {
        $ref: &quot;#/definitions/&quot; + prefix
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    data = JSON.parse(data);
}, local.nop);
if (typeof data !== &quot;object&quot;) {
    return swaggerJson;
}
// init param in body - json-data
isArray = Array.isArray(data);
type = local.<span class="apidocCodeKeywordSpan">swaggerJsonFromPostBody</span>(swaggerJson, {
    data: (
        isArray
        ? data[0]
        : data
    ),
    depth: 2,
    key: &quot;body&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerValidate" id="apidoc.elem.utility2.swgg.swaggerValidate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidate
        <span class="apidocSignatureSpan">(swaggerJson)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerValidate = function (swaggerJson) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the json-object swaggerJson
 */
</span>    let operation;
    let operationIdDict;
    let pathDict;
    let prefix;
    let test;
    let tmp;
    operationIdDict = {};
    swaggerJson = swaggerJson || {};
    local.swaggerValidateDataSchema({
        data: swaggerJson,
        modeSchema: true,
        prefix: [
            &quot;swaggerJson&quot;
        ],
        schema: local.swaggerSchemaJson,
        swaggerJson
    });
    pathDict = {};
    Object.keys(swaggerJson.paths).forEach(function (path) {
        prefix = [
            &quot;swaggerJson&quot;, &quot;paths&quot;, path
        ];
        // validate semanticPaths1
        test = path.indexOf(&quot;?&quot;) &lt; 0;
        local.throwSwaggerError(!test &amp;&amp; {
            errorType: &quot;semanticPaths1&quot;,
            prefix
        });
        tmp = path.replace((
            /\{.*?\}/g
        ), &quot;{}&quot;);
        // validate semanticPaths2
        test = !pathDict[tmp];
        local.throwSwaggerError(!test &amp;&amp; {
            errorType: &quot;semanticPaths2&quot;,
            pathList: [
                pathDict[tmp], path
            ],
            prefix
        });
        pathDict[tmp] = path;
        // validate semanticPaths3
        tmp = {};
        path.replace((
            /\{.*?\}/g
        ), function (match0) {
            test = !tmp[match0];
            local.throwSwaggerError(!test &amp;&amp; {
                errorType: &quot;semanticPaths3&quot;,
                name: match0,
                prefix
            });
            tmp[match0] = true;
        });
        // validate semanticPaths5
        test = path.indexOf(&quot;{}&quot;) &lt; 0;
        local.throwSwaggerError(!test &amp;&amp; {
            errorType: &quot;semanticPaths5&quot;,
            prefix
        });
    });
    // validate swaggerJson.definitions[key].properties[ii].default
    Object.keys(swaggerJson.definitions || {}).forEach(function (schemaName) {
        tmp = local.swaggerValidateDataSchema({
            // dereference definition
            modeDereference: true,
            prefix: [
                &quot;swaggerJson&quot;, &quot;definitions&quot;, schemaName
            ],
            schema: swaggerJson.definitions[schemaName],
            swaggerJson
        });
        Object.keys(tmp.properties || {}).forEach(function (key) {
            local.swaggerValidateDataSchema({
                modeDefault: true,
                prefix: [
                    &quot;swaggerJson&quot;, &quot;definitions&quot;, schemaName, &quot;properties&quot;, key
                ],
                schema: tmp.properties[key],
                swaggerJson
            });
        });
    });
    // validate swaggerJson.parameters[key].default
    Object.keys(swaggerJson.parameters || []).forEach(function (key) {
        local.swaggerValidateDataSchema({
            modeDefault: true,
            prefix: [
                &quot;swaggerJson&quot;, &quot;parameters&quot;, key
            ],
            schema: swaggerJson.parameters[key],
            swaggerJson
        });
    });
    // validate swaggerJson.paths[key][key].parameters[ii].default
    Object.keys(swaggerJson.paths).forEach(function (path) {
        Object.keys(swaggerJson.paths[path]).forEach(function (method) {
            prefix = [
                &quot;swaggerJson&quot;, &quot;paths&quot;, path, method
            ];
            operation = local.swaggerValidateDataSchema({
                // dereference operation
                modeDereference: true,
                prefix,
                schema: swaggerJson.paths[path][method],
                swaggerJson
            });
            // validate semanticOperationIds1
            test = !operationIdDict[operation.operationId];
            local.throwSwaggerError(!test &amp;&amp; {
                data: operation.operationId,
                errorType: &quot;semanticOperationIds1&quot;,
                prefix: prefix.conc...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paths: pathDict
    }, 3);
});
// normalize swaggerJson
local.swaggerJson = JSON.parse(local.jsonStringifyOrdered(swaggerJson));
// try to validate swaggerJson
local.tryCatchOnError(function () {
    local.<span class="apidocCodeKeywordSpan">swaggerValidate</span>(local.swaggerJson);
}, local.onErrorDefault);
// init corsForwardProxyHost
local.corsForwardProxyHost = (
    local.corsForwardProxyHost
    || local.swaggerJson[&quot;x-swgg-corsForwardProxyHost&quot;]
);
// init assets.swgg.swagger.server.json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerValidateDataParameters" id="apidoc.elem.utility2.swgg.swaggerValidateDataParameters">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateDataParameters
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerValidateDataParameters = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the items in &lt;opt&gt;.paramDict
 * against the schemaP&apos;s in &lt;opt&gt;.parameters
 */
</span>    let errList;
    errList = [];
    opt.parameters.forEach(function (schemaP) {
        local.tryCatchOnError(function () {
            local.swaggerValidateDataSchema({
                data: opt.data[schemaP.name],
                dataReadonlyRemove: [
                    opt.dataReadonlyRemove || {},
                    schemaP.name,
                    opt.dataReadonlyRemove
                    &amp;&amp; opt.dataReadonlyRemove[schemaP.name]
                ],
                prefix: opt.prefix.concat([
                    schemaP.name
                ]),
                schema: schemaP,
                swaggerJson: local.swaggerJson
            });
        }, function (errCaught) {
            console.error(errCaught.message);
            errList.push(errCaught);
            errCaught.errList = errList;
        });
    });
    return errList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    paramDict: {},
    url: &quot;&quot;
});
if (opt.modeDefault) {
    local.normalizeSwaggerParamDict(opt);
}
// try to validate paramDict
opt.err = local.<span class="apidocCodeKeywordSpan">swaggerValidateDataParameters</span>({
    // normalize paramDict
    data: local.normalizeSwaggerParamDict({
        modeNoDefault: opt.modeNoDefault,
        operation: that,
        paramDict: local.jsonCopy(opt.paramDict)
    }).paramDict,
    dataReadonlyRemove: opt.paramDict,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerValidateDataSchema" id="apidoc.elem.utility2.swgg.swaggerValidateDataSchema">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateDataSchema
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerValidateDataSchema = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate &lt;opt&gt;.data against the swagger &lt;opt&gt;.schema
 * http://json-schema.org/draft-04/json-schema-validation.html#rfc.section.5
 */
</span>    let $ref;
    let circularSet;
    let data;
    let dataReadonlyRemove2;
    let ii;
    let list;
    let oneOf;
    let schema;
    let test;
    let tmp;
    if (!opt.schema) {
        return;
    }
    data = opt.data;
    opt.dataReadonlyRemove = opt.dataReadonlyRemove || [
        {}, &quot;&quot;, null
    ];
    dataReadonlyRemove2 = opt.dataReadonlyRemove[2] || {};
    schema = opt.schema;
    circularSet = new Set();
    while (true) {
        // dereference schema.schema
        while (schema.schema) {
            schema = schema.schema;
        }
        // dereference schema.oneOf
        oneOf = (data &amp;&amp; schema.oneOf) || [];
        ii = 0;
        while (ii &lt; oneOf.length) {
            tmp = String(oneOf[ii] &amp;&amp; oneOf[ii].$ref).replace(
                &quot;http://json-schema.org/draft-04/schema#&quot;,
                &quot;#&quot;
            );
            switch (
                tmp + &quot; &quot; + (!local.isNullOrUndefined(data.$ref) || data.in)
            ) {
            case &quot;#/definitions/bodyParameter body&quot;:
            case &quot;#/definitions/formDataParameterSubSchema formData&quot;:
            case &quot;#/definitions/headerParameterSubSchema header&quot;:
            case &quot;#/definitions/jsonReference true&quot;:
            case &quot;#/definitions/pathParameterSubSchema path&quot;:
            case &quot;#/definitions/queryParameterSubSchema query&quot;:
                schema = local.swaggerSchemaJson.definitions[tmp.split(&quot;/&quot;)[2]];
                break;
            default:
                switch (tmp) {
                case &quot;#/definitions/bodyParameter&quot;:
                case &quot;#/definitions/jsonReference&quot;:
                    schema = oneOf[ii ^ 1];
                    break;
                }
            }
            if (!schema.oneOf) {
                break;
            }
            ii += 1;
        }
        // dereference schema.$ref
        $ref = schema &amp;&amp; schema.$ref;
        if (!$ref) {
            break;
        }
        test = !circularSet.has($ref);
        local.throwSwaggerError(!test &amp;&amp; {
            data,
            errorType: &quot;schemaDereferenceCircular&quot;,
            prefix: opt.prefix,
            schema
        });
        circularSet.add($ref);
        // validate semanticWalker6
        test = (
            $ref.indexOf(&quot;#/&quot;) === 0
            || $ref.indexOf(&quot;http://json-schema.org/draft-04/schema#/&quot;) === 0
        );
        local.throwSwaggerError(!test &amp;&amp; {
            data: $ref,
            errorType: &quot;semanticWalker6&quot;,
            prefix: opt.prefix.concat([
                &quot;$ref&quot;
            ])
        });
        switch (opt.modeSchema &amp;&amp; $ref) {
        case &quot;http://json-schema.org/draft-04/schema#/definitions/parameter&quot;:
            // validate semanticFormData1
            test = data.in !== &quot;formdata&quot;;
            local.throwSwaggerError(!test &amp;&amp; {
                data: data.in,
                errorType: &quot;semanticFormData1&quot;,
                prefix: opt.prefix.concat([
                    &quot;in&quot;
                ])
            });
            // validate semanticFormData3
            test = data.type !== &quot;file&quot; || data.in === &quot;formData&quot;;
            local.throwSwaggerError(!test &amp;&amp; {
                data,
                errorType: &quot;semanticFormData3&quot;,
                prefix: opt.prefix
            });
            // validate semanticParameters2
            test = data.in === &quot;body&quot; || !local.isNullOrUndefined(data.type);
            local.throwSwaggerError(!test &amp;&amp; {
                data,
                errorType: &quot;semanticParameters2...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.swaggerJsonBasePath = (
    local.swaggerJson.basePath === &quot;/&quot;
    ? &quot;&quot;
    : local.swaggerJson.basePath
);
Object.keys(swaggerJson.definitions).forEach(function (schemaName) {
    swaggerJson.definitions[schemaName] = local.jsonCopy(
        local.<span class="apidocCodeKeywordSpan">swaggerValidateDataSchema</span>({
            // dereference definition
            modeDereference: true,
            prefix: [
                &quot;swaggerJson&quot;, &quot;definitions&quot;, schemaName
            ],
            schema: swaggerJson.definitions[schemaName],
            swaggerJson: local.swaggerJson
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.swaggerValidateFile" id="apidoc.elem.utility2.swgg.swaggerValidateFile">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>swaggerValidateFile
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swaggerValidateFile = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the json-file &lt;opt&gt;.file
 */
</span>    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            if (typeof opt.data === &quot;string&quot;) {
                opt.gotoNext(null, opt.data);
                return;
            }
            // fetch url
            if ((
                /^(?:http|https):\/\//
            ).test(opt.file)) {
                local.ajax({
                    url: opt.file
                }, function (err, xhr) {
                    opt.gotoNext(err, xhr &amp;&amp; xhr.responseText);
                });
                return;
            }
            // read file
            local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
            break;
        case 2:
            // jslint
            local.jslint.jslintAndPrint(data, opt.file);
            local.assertOrThrow(
                !local.jslint.jslintResult.errMsg,
                local.jslint.jslintResult.errMsg.replace((
                    /\u001b\[\d*m/g
                ), &quot;&quot;)
            );
            // validate
            local.swgg.swaggerValidate(JSON.parse(data));
            opt.gotoNext();
            break;
        default:
            console.error(
                err
                ? &quot;\u001b[31mswagger-validate - failed - &quot; + opt.file + &quot;\n&quot;
                + err.message + &quot;\u001b[39m&quot;
                : &quot;swagger-validate - passed - &quot; + opt.file
            );
            onError(err);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.cliDict[&quot;utility2.swaggerValidateFile&quot;] = function () {
/*
 * &lt;file/url&gt;
 * will swagger-validate file/url
 */
    setTimeout(function () {
        local.swgg.<span class="apidocCodeKeywordSpan">swaggerValidateFile</span>({
            file: process.argv[3]
        }, function (err, data) {
            console.error(data);
            process.exit(err);
        });
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.templateRender" id="apidoc.elem.utility2.swgg.templateRender">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &apos;unless&apos; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in the template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.templateRenderMyApp" id="apidoc.elem.utility2.swgg.templateRenderMyApp">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>templateRenderMyApp
        <span class="apidocSignatureSpan">(template, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRenderMyApp = function (template, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will render my-app-lite template with given &lt;opt&gt;.packageJson
 */
</span>    opt.packageJson = local.fsReadFileOrEmptyStringSync(&quot;package.json&quot;, &quot;json&quot;);
    local.objectSetDefault(opt.packageJson, {
        nameLib: opt.packageJson.name.replace((
            /\W/g
        ), &quot;_&quot;),
        repository: {
            url: (
                &quot;https://github.com/kaizhu256/node-&quot;
                + opt.packageJson.name
                + &quot;.git&quot;
            )
        }
    }, 2);
    opt.githubRepo = opt.packageJson.repository.url.replace((
        /\.git$/
    ), &quot;&quot;).split(&quot;/&quot;).slice(-2);
    template = template.replace((
        /kaizhu256(\.github\.io\/|%252F|\/)/g
    ), opt.githubRepo[0] + (&quot;$1&quot;));
    template = template.replace((
        /node-my-app-lite/g
    ), opt.githubRepo[1]);
    template = template.replace((
        /\bh1-my-app\b/g
    ), (
        opt.packageJson.nameHeroku
        || (&quot;h1-&quot; + opt.packageJson.nameLib.replace((
            /_/g
        ), &quot;-&quot;))
    ));
    template = template.replace((
        /my-app-lite/g
    ), opt.packageJson.name);
    template = template.replace((
        /my_app/g
    ), opt.packageJson.nameLib);
    template = template.replace((
        /\{\{packageJson\.(\S+)\}\}/g
    ), function (ignore, match1) {
        return opt.packageJson[match1];
    });
    return template;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let result;
local.objectSetDefault(opt, {
    customize: local.nop,
    dataFrom: local.fsReadFileOrEmptyStringSync(
        &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
        &quot;utf8&quot;
    ),
    dataTo: local.<span class="apidocCodeKeywordSpan">templateRenderMyApp</span>(
        local.assetsDict[&quot;/assets.my_app.template.js&quot;],
        opt
    )
});
// search-and-replace - customize dataTo
[
    // customize top-level comment-description
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testMock" id="apidoc.elem.utility2.swgg.testMock">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testMock
        <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testMock = function (mockList, onTestCase, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will mock the objects in mockList while running the onTestCase
 */
</span>    let onError2;
    onError2 = function (err) {
        // restore mock[0] from mock[2]
        mockList.reverse().forEach(function (mock) {
            Object.keys(mock[2]).forEach(function (key) {
                mock[0][key] = mock[2][key];
            });
        });
        onError(err);
    };
    // suppress console.error and console.log
    if (!(mockList[0] &amp;&amp; mockList[0][0] === console)) {
        mockList.unshift([
            console, {}
        ]);
    }
    local.objectSetDefault(mockList[0][1], {
        error: local.nop,
        log: local.nop
    });
    // mock-objects
    mockList.forEach(function (mock) {
        mock[2] = {};
        // backup mock[0] into mock[2]
        Object.keys(mock[1]).forEach(function (key) {
            mock[2][key] = (
                (
                    typeof process === &quot;object&quot;
                    &amp;&amp; process.env === mock[0]
                    &amp;&amp; mock[0][key] === undefined
                )
                // handle process.env
                ? &quot;&quot;
                : mock[0][key]
            );
        });
        // override mock[0] with mock[1]
        Object.keys(mock[1]).forEach(function (key) {
            mock[0][key] = mock[1][key];
        });
    });
    // try to call onError with mock-objects
    local.tryCatchOnError(function () {
        // run onTestCase
        onTestCase(onError2);
    }, onError2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                };
            }
        });
        mockList.push([
            tmp, mockDict
        ]);
    });
    local.<span class="apidocCodeKeywordSpan">testMock</span>(mockList, function (onError) {
        local.tryCatchOnError(function () {
            exports = require(file);
        }, local.onErrorDefault);
        onError();
    }, local.onErrorThrow);
    return exports;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testReportCreate" id="apidoc.elem.utility2.swgg.testReportCreate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testReportCreate
        <span class="apidocSignatureSpan">(testReport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportCreate = function (testReport) {
<span class="apidocCodeCommentSpan">/*
 * this function will create test-report artifacts
 */
</span>    testReport = local.objectSetDefault(testReport, {
        testPlatformList: []
    });
    // print test-report summary
    console.error(
        &quot;\n&quot; + new Array(56).join(&quot;-&quot;)
        + &quot;\n&quot; + testReport.testPlatformList.filter(function (testPlatform) {
            // if testPlatform has no tests, then filter it out
            return testPlatform.testCaseList.length;
        }).map(function (testPlatform) {
            return (
                &quot;| test-report - &quot; + testPlatform.name + &quot;\n|&quot;
                + String(
                    testPlatform.timeElapsed + &quot; ms     &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsFailed + &quot; failed &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsPassed + &quot; passed &quot;
                ).padStart(16, &quot; &quot;)
                + &quot;     |\n&quot; + new Array(56).join(&quot;-&quot;)
            );
        }).join(&quot;\n&quot;) + &quot;\n&quot;
    );
    // create test-report.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/test-report.html&quot;,
        local.testReportMerge(testReport)
    );
    // create build.badge.svg
    local.fs.writeFileSync(
        &quot;tmp/build/build.badge.svg&quot;,
        local.assetsDict[&quot;/assets.buildBadge.template.svg&quot;].replace((
            /0000-00-00\u002000:00:00\u0020UTC\u0020-\u0020master\u0020-\u0020aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/g
        ), (
            new Date().toISOString().slice(0, 19).replace(&quot;T&quot;, &quot; &quot;)
            + &quot; - &quot; + local.env.CI_BRANCH + &quot; - &quot; + local.env.CI_COMMIT_ID
        ))
    );
    // create test-report.badge.svg
    local.fs.writeFileSync(
        &quot;tmp/build/test-report.badge.svg&quot;,
        local.assetsDict[&quot;/assets.testReportBadge.template.svg&quot;].replace((
            // edit number of tests failed
            /999/g
        ), testReport.testsFailed).replace((
            // edit badge color
            /d00/g
        ), (
            testReport.testsFailed
            ? &quot;d00&quot;
            : &quot;0d0&quot;
        ))
    );
    console.error(
        &quot;created test-report file &quot;
        + process.cwd() + &quot;/tmp/build/test-report.html\n&quot;
    );
    // if any test failed, then exit with non-zero exitCode
    console.error(
        &quot;\n&quot; + local.env.MODE_BUILD
        + &quot; - &quot; + testReport.testsFailed + &quot; failed tests\n&quot;
    );
    // print failed testCase
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testCaseList.forEach(function (testCase) {
            if (testCase.status !== &quot;passed&quot;) {
                console.error(JSON.stringify(testCase, undefined, 4));
            }
        });
    });
    return testReport;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.cliDict[&quot;utility2.testReportCreate&quot;] = function () {
/*
 *
 * will create test-report
 */
    process.exit(local.<span class="apidocCodeKeywordSpan">testReportCreate</span>(local.fsReadFileOrEmptyStringSync(
        local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
        &quot;json&quot;
    )).testsFailed);
};
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testReportMerge" id="apidoc.elem.utility2.swgg.testReportMerge">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testReportMerge
        <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportMerge = function (testReport1, testReport2) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. merge testReport2 into testReport1
 * 2. return testReport1 in html-format
 */
</span>    let errorStackList;
    let testCaseNumber;
    let testReport;
    testReport2 = testReport2 || {};
    // 1. merge testReport2 into testReport1
    [
        testReport1, testReport2
    ].forEach(function (testReport, ii) {
        ii += 1;
        local.objectSetDefault(testReport, {
            date: new Date().toISOString(),
            errorStackList: [],
            testPlatformList: [],
            timeElapsed: 0
        }, 8);
        // security - handle malformed testReport
        local.assertOrThrow(
            typeof testReport === &quot;object&quot; &amp;&amp; testReport,
            ii + &quot; invalid testReport &quot; + typeof testReport
        );
        // validate timeElapsed
        local.assertOrThrow(
            typeof testReport.timeElapsed === &quot;number&quot;,
            ii + &quot; invalid testReport.timeElapsed &quot;
            + typeof testReport.timeElapsed
        );
        // security - handle malformed testReport.testPlatformList
        testReport.testPlatformList.forEach(function (testPlatform) {
            local.objectSetDefault(testPlatform, {
                name: &quot;undefined&quot;,
                testCaseList: [],
                timeElapsed: 0
            }, 8);
            local.assertOrThrow(
                typeof testPlatform.name === &quot;string&quot;,
                ii + &quot; invalid testPlatform.name &quot; + typeof testPlatform.name
            );
            // insert $MODE_BUILD into testPlatform.name
            if (local.env.MODE_BUILD) {
                testPlatform.name = testPlatform.name.replace((
                    /^(browser|node)\b/
                ), local.env.MODE_BUILD + &quot; - $1&quot;);
            }
            // validate timeElapsed
            local.assertOrThrow(
                typeof testPlatform.timeElapsed === &quot;number&quot;,
                (
                    ii + &quot; invalid testPlatform.timeElapsed &quot;
                    + typeof testPlatform.timeElapsed
                )
            );
            // security - handle malformed testPlatform.testCaseList
            testPlatform.testCaseList.forEach(function (testCase) {
                local.objectSetDefault(testCase, {
                    errorStack: &quot;&quot;,
                    name: &quot;undefined&quot;,
                    timeElapsed: 0
                }, 8);
                local.assertOrThrow(
                    typeof testCase.errorStack === &quot;string&quot;,
                    ii + &quot; invalid testCase.errorStack &quot;
                    + typeof testCase.errorStack
                );
                local.assertOrThrow(
                    typeof testCase.name === &quot;string&quot;,
                    ii + &quot; invalid testCase.name &quot; + typeof testCase.name
                );
                // validate timeElapsed
                local.assertOrThrow(
                    typeof testCase.timeElapsed === &quot;number&quot;,
                    (
                        ii + &quot; invalid testCase.timeElapsed &quot;
                        + typeof testCase.timeElapsed
                    )
                );
            });
        });
    });
    // merge testReport2.testPlatformList into testReport1.testPlatformList
    testReport2.testPlatformList.forEach(function (testPlatform2) {
        // add testPlatform2 to testReport1.testPlatformList
        testReport1.testPlatformList.push(testPlatform2);
    });
    testReport = testReport1;
    testReport.testsFailed = 0;
    testReport.testsPassed = 0;
    testReport.testsPending = 0;
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testsFailed = 0;
        testPlatform.testsPassed = 0;
        testPlatform.testsPending = 0;
        testPlatform.testCaseList.forEach(function (testCase) {
            switch (testCase.status) {...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.istanbulCoverageMerge(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.<span class="apidocCodeKeywordSpan">testReportMerge</span>(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.counter += 1;
local.fs.writeFile(
    local.env.npm_config_dir_build + &quot;/test-report.json&quot;,
    JSON.stringify(globalThis.utility2_testReport),
    function (err) {
        console.error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testRunBrowser" id="apidoc.elem.utility2.swgg.testRunBrowser">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunBrowser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunBrowser = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will run browser-tests
 */
</span>    // hide browser-tests
    if (local.querySelector(&quot;#htmlTestReport1&quot;).style.maxHeight !== &quot;0px&quot;) {
        local.uiAnimateSlideUp(local.querySelector(&quot;#htmlTestReport1&quot;));
        local.querySelector(
            &quot;#buttonTestRun1&quot;
        ).textContent = &quot;run browser-tests&quot;;
        return;
    }
    // show browser-tests
    local.uiAnimateSlideDown(local.querySelector(&quot;#htmlTestReport1&quot;));
    local.querySelector(&quot;#buttonTestRun1&quot;).textContent = &quot;hide browser-tests&quot;;
    local.modeTest = 1;
    local.testRunDefault(local);
    // reset output
    local.querySelectorAll(&quot;.onevent-reset-output&quot;).forEach(function (elem) {
        elem.textContent = &quot;&quot;;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };\n\
});\n\
local.objectAssignDefault(local, globalThis.domOnEventDelegateDict);\n\
globalThis.domOnEventDelegateDict = local;\n\
if ((\n\
    /\\bmodeTest=1\\b/\n\
).test(location.search)) {\n\
    local.<span class="apidocCodeKeywordSpan">testRunBrowser</span>();\n\
}\n\
}());\n\
\n\
\n\
\n\
// run node js\-env code - init-test\n\
(function () {\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testRunDefault" id="apidoc.elem.utility2.swgg.testRunDefault">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunDefault
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunDefault = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run tests in testPlatform.testCaseList
 */
</span>    let consoleError;
    let isCoverage;
    let processExit;
    let testPlatform;
    let testReport;
    let timerInterval;
    // run-server
    if (!local.isBrowser) {
        local.testRunServer(opt);
    }
    globalThis.utility2_modeTest = Number(
        globalThis.utility2_modeTest
        || opt.modeTest
        || local.modeTest
        || local.env.npm_config_mode_test
    );
    switch (globalThis.utility2_modeTest) {
    // init
    case 1:
        globalThis.utility2_modeTest += 1;
        // reset db
        globalThis.utility2_onReadyAfter(function () {
            local.testRunDefault(opt);
        });
        return;
    // test-run
    default:
        // test-ignore
        if (
            globalThis.utility2_onReadyBefore.counter
            || !globalThis.utility2_modeTest
            || globalThis.utility2_modeTest &gt; 2
        ) {
            return;
        }
        // test-run
        globalThis.utility2_modeTest += 1;
    }
    // visual notification - testRun
    local.ajaxProgressUpdate();
    // mock console.error
    consoleError = console.error;
    isCoverage = (
        typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
        &amp;&amp; Object.keys(globalThis.__coverage__).length
    );
    console.error = function (...argList) {
    /*
     * this function will ignore serverLog-messages during test-run
     */
        if (!isCoverage &amp;&amp; !(
            /^serverLog\u0020-\u0020\{/
        ).test(argList[0])) {
            consoleError(...argList);
        }
    };
    // mock proces.exit
    if (!local.isBrowser) {
        processExit = process.exit;
        process.exit = local.nop;
    }
    // init modeTestCase
    local.modeTestCase = (
        local.modeTestCase
        || local.env.npm_config_mode_test_case || &quot;&quot;
    );
    // init testReport
    testReport = globalThis.utility2_testReport;
    // init testReport timer
    local.timeElapsedStart(testReport);
    // init testPlatform
    testPlatform = testReport.testPlatformList[0];
    // init testPlatform timer
    local.timeElapsedStart(testPlatform);
    // reset testPlatform.testCaseList
    testPlatform.testCaseList.length = 0;
    // add tests into testPlatform.testCaseList
    Object.keys(opt).forEach(function (key) {
        // add testCase opt[key] to testPlatform.testCaseList
        if (
            typeof opt[key] === &quot;function&quot; &amp;&amp; (
                local.modeTestCase
                ? local.modeTestCase.split(
                    /[,\s]/g
                ).indexOf(key) &gt;= 0
                : key.indexOf(&quot;testCase_&quot;) === 0
            )
        ) {
            testPlatform.testCaseList.push({
                isBrowser: local.isBrowser,
                name: key,
                status: &quot;pending&quot;,
                onTestCase: opt[key]
            });
        }
    });
    local.testReportMerge(testReport);
    local.querySelectorAll(&quot;#htmlTestReport1&quot;).forEach(function (elem) {
        local.uiAnimateSlideDown(elem);
        elem.innerHTML = local.testReportMerge(testReport);
    });
    local.emit(&quot;utility2.testRunStart&quot;, testReport);
    // testRunProgressUpdate every 2000 ms until isDone
    timerInterval = setInterval(function () {
        // update testPlatform.timeElapsed
        local.timeElapsedPoll(testPlatform);
        local.querySelector(
            &quot;#htmlTestReport1&quot;
        ).innerHTML = local.testReportMerge(testReport);
        local.emit(&quot;utility2.testRunProgressUpdate&quot;, testReport);
        // cleanup timerInterval
        if (!testReport.testsPending) {
            clearInterval(timerInterval);
        }
        // list pending testCase every 5000 ms
        if (testPlatform.timeElapsed % 5000 &lt; 2000) {
            consoleError(
                &quot;testRunDefault - &quot;
                + testPlatform.timeEl...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.requireReadme();\n\
globalThis.local = local;\n\
// init test\n\
local.<span class="apidocCodeKeywordSpan">testRunDefault</span>(local);\n\
}());\n\
\n\
\n\
\n\
// run shared js\-env code - function\n\
(function () {\n\
return;\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.testRunServer" id="apidoc.elem.utility2.swgg.testRunServer">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>testRunServer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunServer = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. create server from local.middlewareList
 * 2. start server on local.env.PORT
 * 3. run tests
 */
</span>    // 1. create server from local.middlewareList
    local.middlewareList = local.middlewareList || [
        local.middlewareInit,
        local.middlewareForwardProxy,
        local.middlewareAssetsCached,
        local.middlewareJsonpStateInit,
        local.middlewareFileServer
    ];
    if (local.env.npm_config_mode_library || globalThis.utility2_serverHttp1) {
        return;
    }
    globalThis.utility2_onReadyBefore.counter += 1;
    local.serverLocalReqHandler = function (req, res) {
        let that;
        that = {};
        local.gotoNext(that, function (err) {
            if (err || that.gotoState &gt;= local.middlewareList.length) {
                local.middlewareError(err, req, res);
                return;
            }
            // recurse with next middleware in middlewareList
            local.middlewareList[that.gotoState](req, res, that.gotoNext);
        });
        that.gotoState = -1;
        that.gotoNext();
    };
    globalThis.utility2_serverHttp1 = local.http.createServer(
        local.serverLocalReqHandler
    );
    // 2. start server on local.env.PORT
    console.error(&quot;http-server listening on port &quot; + local.env.PORT);
    globalThis.utility2_onReadyBefore.counter += 1;
    globalThis.utility2_serverHttp1.listen(
        local.env.PORT,
        globalThis.utility2_onReadyBefore
    );
    // 3. run tests
    local.testRunDefault(opt);
    globalThis.utility2_onReadyBefore();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.replStart();
   local.<span class="apidocCodeKeywordSpan">testRunServer</span>({});
};

local.cliDict[&quot;utility2.swaggerValidateFile&quot;] = function () {
/*
* &lt;file/url&gt;
* will swagger-validate file/url
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.throwError" id="apidoc.elem.utility2.swgg.throwError">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>throwError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will throw new err
 */
</span>    throw new Error();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_throwError_default = function (opt, onError) {
/*
 * this function will test throwError&apos;s default handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">throwError</span>();
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.throwSwaggerError" id="apidoc.elem.utility2.swgg.throwSwaggerError">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>throwSwaggerError
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwSwaggerError = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw a swaggerError with given &lt;opt&gt;.errorType
 */
</span>    let err;
    if (!opt) {
        return;
    }
    [
        0, 2
    ].forEach(function (ii) {
        opt[&quot;prefix&quot; + ii] = opt.prefix[ii] + opt.prefix.slice(
            ii + 1
        ).map(function (element) {
            return &quot;[&quot; + JSON.stringify(element) + &quot;]&quot;;
        }).join(&quot;&quot;);
    });
    opt.prefix0 += &quot; = &quot; + local.stringTruncate(
        JSON.stringify(opt.data) || &quot;undefined&quot;,
        100
    );
    opt.schema2 = local.stringTruncate(
        JSON.stringify(opt.schema) || &quot;undefined&quot;,
        500
    );
    opt.type2 = (opt.schema &amp;&amp; local.schemaPType(opt.schema)) || &quot;object&quot;;
    if (opt.schema &amp;&amp; opt.schema.format) {
        opt.type2 += &quot; (&quot; + opt.schema.format + &quot;)&quot;;
    }
    err = new Error(&quot;error.&quot; + opt.errorType + &quot; - &quot; + local.templateRender(
        local.swaggerErrorTypeDict[opt.errorType],
        opt,
        {
            notHtmlSafe: true
        }
    ));
    err.messageShort = local.templateRender(
        local.swaggerErrorTypeDict[opt.errorType].replace(
            &quot;{{prefix0}}&quot;,
            &quot;{{prefix2}}&quot;
        ),
        opt,
        {
            notHtmlSafe: true
        }
    );
    err.opt = opt;
    err.statusCode = 400;
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pathDict = {};
Object.keys(swaggerJson.paths).forEach(function (path) {
    prefix = [
        &quot;swaggerJson&quot;, &quot;paths&quot;, path
    ];
    // validate semanticPaths1
    test = path.indexOf(&quot;?&quot;) &lt; 0;
    local.<span class="apidocCodeKeywordSpan">throwSwaggerError</span>(!test &amp;&amp; {
        errorType: &quot;semanticPaths1&quot;,
        prefix
    });
    tmp = path.replace((
        /\{.*?\}/g
    ), &quot;{}&quot;);
    // validate semanticPaths2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.timeElapsedPoll" id="apidoc.elem.utility2.swgg.timeElapsedPoll">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>timeElapsedPoll
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedPoll = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will poll &lt;opt&gt;.timeElapsed
 */
</span>    opt = local.timeElapsedStart(opt);
    opt.timeElapsed = Date.now() - opt.timeStart;
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &gt; bb.status.replace(&quot;passed&quot;, &quot;z&quot;) + bb.name
        ? 1
        : -1
    );
});
// stop testReport timer
if (!testReport.testsPending) {
    local.<span class="apidocCodeKeywordSpan">timeElapsedPoll</span>(testReport);
}
// 2. return testReport1 in html-format
// json-copy testReport that will be modified for html templating
testReport = local.jsonCopy(testReport1);
// update timeElapsed
local.timeElapsedPoll(testReport);
testReport.testPlatformList.forEach(function (testPlatform) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.timeElapsedStart" id="apidoc.elem.utility2.swgg.timeElapsedStart">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>timeElapsedStart
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedStart = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will start &lt;opt&gt;.timeElapsed
 */
</span>    opt = opt || {};
    opt.timeStart = opt.timeStart || Date.now();
    return opt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
local.modeTestCase = (
    local.modeTestCase
    || local.env.npm_config_mode_test_case || &quot;&quot;
);
// init testReport
testReport = globalThis.utility2_testReport;
// init testReport timer
local.<span class="apidocCodeKeywordSpan">timeElapsedStart</span>(testReport);
// init testPlatform
testPlatform = testReport.testPlatformList[0];
// init testPlatform timer
local.timeElapsedStart(testPlatform);
// reset testPlatform.testCaseList
testPlatform.testCaseList.length = 0;
// add tests into testPlatform.testCaseList
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.tryCatchOnError" id="apidoc.elem.utility2.swgg.tryCatchOnError">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>tryCatchOnError
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryCatchOnError = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run the fnc in a tryCatch block,
 * else call onError with errCaught
 */
</span>    let result;
    // validate onError
    local.assertOrThrow(typeof onError === &quot;function&quot;, typeof onError);
    try {
        // reset errCaught
        local._debugTryCatchError = null;
        result = fnc();
        local._debugTryCatchError = null;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return elem;
};
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.<span class="apidocCodeKeywordSpan">tryCatchOnError</span>(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiAnimateSlideAccordian" id="apidoc.elem.utility2.swgg.uiAnimateSlideAccordian">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideAccordian
        <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideAccordian = function (elem, elemList, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown &lt;elem&gt;, but slideUp elements in &lt;elemList&gt;
 */
</span>    elemList.forEach(function (elem2) {
        if (elem2 !== elem) {
            local.uiAnimateSlideUp(elem2);
        }
    });
    setTimeout(function () {
        local.uiAnimateSlideDown(elem, onError);
    }, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// show parent resource
local.uiAnimateSlideDown(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideAccordian</span>(
    element.querySelector(
        &quot;.operation &gt; form&quot;
    ),
    Array.from(element.closest(
        &quot;.operationList&quot;
    ).querySelectorAll(
        &quot;.operation &gt; form&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiAnimateSlideDown" id="apidoc.elem.utility2.swgg.uiAnimateSlideDown">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideDown
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideDown = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown dom-&lt;elem&gt;
 */
</span>    onError = onError || local.nop;
    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;100%&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        onError();
        return;
    }
    elem.style.borderBottom = &quot;&quot;;
    elem.style.borderTop = &quot;&quot;;
    elem.style.marginBottom = &quot;&quot;;
    elem.style.marginTop = &quot;&quot;;
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + &quot;px&quot;;
    elem.style.paddingBottom = &quot;&quot;;
    elem.style.paddingTop = &quot;&quot;;
    setTimeout(function () {
        elem.style.maxHeight = &quot;100%&quot;;
        onError();
    }, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &quot;.operation&quot;
);
location.hash = &quot;!&quot; + element.id;
element.closest(
    &quot;.resource&quot;
).classList.remove(&quot;expanded&quot;);
// show parent resource
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideDown</span>(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.uiAnimateSlideAccordian(
    element.querySelector(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiAnimateSlideUp" id="apidoc.elem.utility2.swgg.uiAnimateSlideUp">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uiAnimateSlideUp
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideUp = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideUp dom-&lt;elem&gt;
 */
</span>    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;0px&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        local.setTimeoutOnError(onError);
        return;
    }
    elem.style.borderBottom = &quot;0&quot;;
    elem.style.borderTop = &quot;0&quot;;
    elem.style.marginBottom = &quot;0&quot;;
    elem.style.marginTop = &quot;0&quot;;
    elem.style.maxHeight = &quot;0&quot;;
    elem.style.paddingBottom = &quot;0&quot;;
    elem.style.paddingTop = &quot;0&quot;;
    local.setTimeoutOnError(onError, 250);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);
// collapse all operations in the resource
if (evt.currentTarget.classList.contains(&quot;expanded&quot;)) {
    evt.currentTarget.classList.remove(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
        local.<span class="apidocCodeKeywordSpan">uiAnimateSlideUp</span>(element);
    });
// expand all operations in the resource
} else {
    evt.currentTarget.classList.add(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventDelegate" id="apidoc.elem.utility2.swgg.uiEventDelegate">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uiEventDelegate
        <span class="apidocSignatureSpan">(evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiEventDelegate = function (evt) {
    // filter non-input keyup-evt
    evt.targetOnEvent = evt.target.closest(
        &quot;[data-onevent]&quot;
    );
    if (!evt.targetOnEvent) {
        return;
    }
    // rate-limit keyup
    if (evt.type === &quot;keyup&quot;) {
        local.uiEventDelegateKeyupEvent = evt;
        if (local.uiEventDelegateKeyupTimerTimeout !== 2) {
            local.uiEventDelegateKeyupTimerTimeout = (
                local.uiEventDelegateKeyupTimerTimeout
                || setTimeout(function () {
                    local.uiEventDelegateKeyupTimerTimeout = 2;
                    local.uiEventDelegate(local.uiEventDelegateKeyupEvent);
                }, 100)
            );
            return;
        }
        local.uiEventDelegateKeyupTimerTimeout = null;
        if (!evt.target.closest(
            &quot;input, option, select, textarea&quot;
        )) {
            return;
        }
    }
    switch (evt.targetOnEvent.tagName) {
    case &quot;BUTTON&quot;:
    case &quot;FORM&quot;:
        evt.preventDefault();
        break;
    }
    evt.stopPropagation();
    local.uiEventListenerDict[evt.targetOnEvent.dataset.onevent](evt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (evt.type === &quot;keyup&quot;) {
local.uiEventDelegateKeyupEvent = evt;
if (local.uiEventDelegateKeyupTimerTimeout !== 2) {
    local.uiEventDelegateKeyupTimerTimeout = (
        local.uiEventDelegateKeyupTimerTimeout
        || setTimeout(function () {
            local.uiEventDelegateKeyupTimerTimeout = 2;
            local.<span class="apidocCodeKeywordSpan">uiEventDelegate</span>(local.uiEventDelegateKeyupEvent);
        }, 100)
    );
    return;
}
local.uiEventDelegateKeyupTimerTimeout = null;
if (!evt.target.closest(
    &quot;input, option, select, textarea&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiRenderSchemaP" id="apidoc.elem.utility2.swgg.uiRenderSchemaP">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uiRenderSchemaP
        <span class="apidocSignatureSpan">(schemaP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiRenderSchemaP = function (schemaP) {
<span class="apidocCodeCommentSpan">/*
 * this function will render schemaP
 */
</span>    // init schemaP.id
    schemaP.id = local.idDomElementCreate(&quot;swgg_id_&quot; + schemaP.name);
    // init enum
    schemaP.enum2 = (
        schemaP.enum
        || local.coalesce(local.schemaPItems(schemaP), {}).enum
        || (local.schemaPType(schemaP) === &quot;boolean&quot; &amp;&amp; [
            false, true
        ])
    );
    // init input - file
    if (local.schemaPType(schemaP) === &quot;file&quot;) {
        schemaP.isFile = true;
    // init input - textarea
    } else if (schemaP.in === &quot;body&quot;) {
        schemaP.isTextarea = true;
    // init input - select
    } else if (schemaP.enum2) {
        // init enumDefault
        schemaP.enumDefault = [];
        if (schemaP.required &amp;&amp; schemaP.default !== undefined) {
            schemaP.enumDefault = (
                local.schemaPType(schemaP) === &quot;array&quot;
                ? schemaP.default
                : [
                    schemaP.default
                ]
            );
        }
        schemaP.isSelectMultiple = local.schemaPType(schemaP) === &quot;array&quot;;
        schemaP.selectOptionList = schemaP.enum2.map(function (element) {
            // init hasDefault
            schemaP.hasDefault = (
                schemaP.hasDefault
                || schemaP.enumDefault.indexOf(element) &gt;= 0
            );
            return {
                id: local.idDomElementCreate(&quot;swgg_id_&quot; + schemaP.name),
                selected: (
                    schemaP.enumDefault.indexOf(element) &gt;= 0
                    ? &quot;selected&quot;
                    : &quot;&quot;
                ),
                type: (
                    local.schemaPItemsType(schemaP)
                    || local.schemaPType(schemaP)
                ),
                placeholder: (
                    typeof element === &quot;string&quot;
                    ? element
                    : JSON.stringify(element)
                ),
                valueSelectOption: element
            };
        });
        // init &apos;undefined&apos; value
        if (!schemaP.required &amp;&amp; !schemaP.hasDefault) {
            schemaP.selectOptionList.unshift({
                id: local.idDomElementCreate(&quot;swgg_id_&quot; + schemaP.name),
                selected: &quot;selected&quot;,
                type: local.schemaPType(schemaP),
                placeholder: &quot;&lt;none&gt;&quot;,
                valueSelectOption: &quot;$swggUndefined&quot;
            });
        }
        // select at least one value
        schemaP.selectOptionList.some(function (element, ii) {
            if (ii === 0 || element.selected) {
                element.selected = &quot;selected&quot;;
                if (ii !== 0) {
                    schemaP.selectOptionList[0].selected = &quot;&quot;;
                    return true;
                }
            }
        });
    // init input - textarea
    } else if (local.schemaPType(schemaP) === &quot;array&quot; || (
        schemaP.format === &quot;json&quot;
        &amp;&amp; local.schemaPType(schemaP) === &quot;string&quot;
    )) {
        schemaP.isTextarea = true;
    // init input - number
    } else if (schemaP.type === &quot;integer&quot; || schemaP.type === &quot;number&quot;) {
        schemaP.isInputNumber = true;
    // init input - text
    } else {
        schemaP.isInputText = true;
    }
    // init format2 / type2
    Array.from([
        schemaP, schemaP.schema || {}
    ]).some(function (element) {
        local.objectSetDefault(schemaP, {
            format2: local.schemaPItemsType(element) || element.format,
            type2: local.schemaPType(element)
        });
        return schemaP.type2;
    });
    schemaP.type2 = schemaP.type2 || &quot;object&quot;;
    // init schema2
    Array.from([
        schemaP,
        local.schemaPItems(schemaP),
        schemaP.schema,
        schemaP.schema &amp;&amp; local.schemaPItems(schemaP.schema)
    ])...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.urlJoin" id="apidoc.elem.utility2.swgg.urlJoin">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>urlJoin
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlJoin = function (aa, bb) {
<span class="apidocCodeCommentSpan">/*
 * this function will if bb is relative, url-join aa with bb
 */
</span>    // bb is absolute-url
    if ((
        /^\w+?:\/\//
    ).test(bb)) {
        return bb;
    }
    // bb is absolute-url without protocol
    if (bb.slice(0, 2) === &quot;//&quot;) {
        return aa.split(&quot;/&quot;)[0] + bb;
    }
    // bb is absolute-url without host
    if (bb[0] === &quot;/&quot;) {
        return aa.split(&quot;/&quot;).slice(0, 3).join(&quot;/&quot;) + bb;
    }
    // bb is relative-url
    if (aa.split(&quot;/&quot;).length &lt; 4) {
        aa += &quot;/&quot;;
    }
    return aa.replace((
        /[?#].*?$/
    ), &quot;&quot;).replace((
        /[^\/]*?$/
    ), &quot;&quot;) + bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_urlJoin_default = function (opt, onError) {
/*
* this function will test urlJoin&apos;s default handling-behavior
*/
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">urlJoin</span>(&quot;&quot;, &quot;&quot;), &quot;/&quot;);
   local.assertJsonEqual(local.urlJoin(&quot;http://aa/bb&quot;, &quot;zz&quot;), &quot;http://aa/zz&quot;);
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;zz&quot;),
       &quot;http://aa/bb/zz&quot;
   );
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;/zz&quot;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.urlParse" id="apidoc.elem.utility2.swgg.urlParse">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>urlParse
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlParse = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will parse &lt;url&gt; according to below spec, plus a query param
 * https://developer.mozilla.org/en-US/docs/Web/API/URL
 */
</span>    let urlParsed;
    urlParsed = {};
    // try to parse url
    local.tryCatchOnError(function () {
        // resolve host-less url
        if (local.isBrowser) {
            local.serverLocalHost = (
                local.serverLocalHost
                || location.protocol + &quot;//&quot; + location.host
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = (
                    local.serverLocalHost
                    + location.pathname.replace((
                        /\/[^\/]*?$/
                    ), &quot;&quot;) + &quot;/&quot; + url
                );
            }
            urlParsed = new globalThis.URL(url);
            urlParsed.path = (
                &quot;/&quot; + urlParsed.href.split(&quot;/&quot;).slice(3).join(&quot;/&quot;).split(&quot;#&quot;)[0]
            );
        } else {
            local.env.PORT = local.env.PORT || &quot;8081&quot;;
            local.serverLocalHost = (
                local.serverLocalHost
                || (&quot;http://127.0.0.1:&quot; + local.env.PORT)
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = local.serverLocalHost + &quot;/&quot; + url;
            }
            urlParsed = local.url.parse(url);
        }
        // init query
        urlParsed.query = {};
        local.coalesce(urlParsed.search, &quot;&quot;).slice(1).replace((
            /[^&amp;]+/g
        ), function (item) {
            item = item.split(&quot;=&quot;);
            item[0] = decodeURIComponent(item[0]);
            item[1] = decodeURIComponent(item.slice(1).join(&quot;=&quot;));
            // parse repeating query-param as an array
            if (urlParsed.query[item[0]]) {
                if (!Array.isArray(urlParsed.query[item[0]])) {
                    urlParsed.query[item[0]] = [
                        urlParsed.query[item[0]]
                    ];
                }
                urlParsed.query[item[0]].push(item[1]);
            } else {
                urlParsed.query[item[0]] = item[1];
            }
        });
        urlParsed.basename = urlParsed.pathname.replace((
            /^.*\//
        ), &quot;&quot;);
    }, local.nop);
    // https://developer.mozilla.org/en/docs/Web/API/URL#Properties
    return {
        basename: urlParsed.basename || &quot;&quot;,
        hash: urlParsed.hash || &quot;&quot;,
        host: urlParsed.host || &quot;&quot;,
        hostname: urlParsed.hostname || &quot;&quot;,
        href: urlParsed.href || &quot;&quot;,
        path: urlParsed.path || &quot;&quot;,
        pathname: urlParsed.pathname || &quot;&quot;,
        port: urlParsed.port || &quot;&quot;,
        protocol: urlParsed.protocol || &quot;&quot;,
        query: urlParsed.query || {},
        search: urlParsed.search || &quot;&quot;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
}
// init url
opt.url = &quot;&quot;;
opt.url += (
    local.identity(
        that[&quot;x-swgg-schemes&quot;] || local.swaggerJson.schemes || []
    )[0] || local.<span class="apidocCodeKeywordSpan">urlParse</span>(&quot;&quot;).protocol.slice(0, -1)
);
opt.url += &quot;://&quot;;
opt.url += (
    that[&quot;x-swgg-host&quot;]
    || local.swaggerJson.host
    || local.urlParse(&quot;&quot;).host
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.urlParseWithBraket" id="apidoc.elem.utility2.swgg.urlParseWithBraket">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>urlParseWithBraket
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlParseWithBraket = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will urlParse the url with curly-brackets preserved
 */
</span>    let tmp;
    tmp = local.stringUniqueKey(url);
    return JSON.parse(JSON.stringify(
        local.urlParse(url.replace((
            /\{/g
        ), tmp + 1).replace((
            /\}/g
        ), tmp + 2))
    ).replace(
        new RegExp(tmp + 1, &quot;g&quot;),
        &quot;{&quot;
    ).replace(
        new RegExp(tmp + 2, &quot;g&quot;),
        &quot;}&quot;
    ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

local.operationIdFromAjax = function (opt) {
/*
 * this function will create a sortable operationId
 * from given ajax-&lt;opt&gt;
 */
    let urlParsed;
    urlParsed = local.<span class="apidocCodeKeywordSpan">urlParseWithBraket</span>(opt.url);
    return encodeURIComponent(
        urlParsed.pathname + urlParsed.hash + &quot; &quot; + opt.method.toUpperCase()
    ).replace((
        /[^\w\-.]/g
    ), &quot;_&quot;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.userLoginByPassword" id="apidoc.elem.utility2.swgg.userLoginByPassword">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>userLoginByPassword
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">userLoginByPassword = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send a login-by-password req
 */
</span>    local.apiDict[&quot;GET /user/userLoginByPassword&quot;].ajax({
        paramDict: {
            password: opt.password,
            username: opt.username
        }
    }, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.userLogout" id="apidoc.elem.utility2.swgg.userLogout">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>userLogout
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">userLogout = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send a logout req
 */
</span>    local.apiDict[&quot;GET /user/userLogout&quot;].ajax(opt, onError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uuid4Create" id="apidoc.elem.utility2.swgg.uuid4Create">
        function <span class="apidocSignatureSpan">utility2.swgg.</span>uuid4Create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid4Create = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random uuid,
 * with format &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;
 */
</span>    // code derived from http://jsperf.com/uuid4
    let id;
    let ii;
    id = &quot;&quot;;
    ii = 0;
    while (ii &lt; 32) {
        switch (ii) {
        case 8:
        case 20:
            id += &quot;-&quot;;
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
            break;
        case 12:
            id += &quot;-&quot;;
            id += &quot;4&quot;;
            break;
        case 16:
            id += &quot;-&quot;;
            id += local.identity((Math.random() * 4) | 8).toString(16);
            break;
        default:
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
        }
        ii += 1;
    }
    return id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

local.testCase_uuid4Create_default = function (opt, onError) {
/*
 * this function will test uuid4Create&apos;s default handling-behavior
 */
    local.assertOrThrow(
        local.regexpValidateUuid.test(local.<span class="apidocCodeKeywordSpan">uuid4Create</span>()),
        local.uuid4Create()
    );
    onError(undefined, opt);
};

local.testCase_webpage_err = function (opt, onError) {
/*
...</pre></li>
    </ul>
















































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.swgg.uiEventListenerDict" id="apidoc.module.utility2.swgg.uiEventListenerDict">module utility2.swgg.uiEventListenerDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputTextareaChange" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputTextareaChange">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventInputTextareaChange
        <span class="apidocSignatureSpan">(evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventInputTextareaChange = function (evt) {
<span class="apidocCodeCommentSpan">/*
 * this function will show/hide the textarea&apos;s multiline placeholder
 */
</span>    let isTransparent;
    let value;
    isTransparent = evt.targetOnEvent.style.background.indexOf(
        &quot;transparent&quot;
    ) &gt;= 0;
    value = evt.targetOnEvent.value;
    if (value &amp;&amp; isTransparent) {
        evt.targetOnEvent.style.background = &quot;&quot;;
    }
    if (!value &amp;&amp; !isTransparent) {
        evt.targetOnEvent.style.background = &quot;transparent&quot;;
    }
    local.uiEventListenerDict.onEventInputValidateAndAjax({
        targetOnEvent: evt.targetOnEvent
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &quot;.swggUiContainer [data-value-text]&quot;
).forEach(function (element) {
    // render valueText
    element.value = decodeURIComponent(element.dataset.valueText);
    delete element.dataset.valueText;
    // init textarea&apos;s multiline placeholder
    if (element.tagName === &quot;TEXTAREA&quot;) {
        local.uiEventListenerDict.<span class="apidocCodeKeywordSpan">onEventInputTextareaChange</span>({
            targetOnEvent: element
        });
    }
});
// handle evt
[
    &quot;Change&quot;, &quot;Click&quot;, &quot;Keyup&quot;, &quot;Submit&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputValidateAndAjax" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventInputValidateAndAjax">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventInputValidateAndAjax
        <span class="apidocSignatureSpan">( opt, onError )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventInputValidateAndAjax = function ( opt, onError ) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate the input parameters
 * against the schemas in &lt;opt&gt;.parameters
 */
</span>    let errorDict;
    let jsonParse;
    let tmp;
    jsonParse = function (text) {
    /*
     * this function will try to JSON.parse(text)
     */
        return local.tryCatchOnError(function () {
            return JSON.parse(text);
        }, function () {
            return text;
        });
    };
    // hack-jslint
    opt.targetOnEvent = opt.targetOnEvent.closest(
        &quot;.operation&quot;
    );
    opt.api = local.apiDict[opt.targetOnEvent.dataset._methodPath];
    opt.headers = {};
    opt.modeAjax = opt.modeAjax || &quot;validate&quot;;
    opt.modeNoDefault = true;
    opt.paramDict = {};
    opt.url = &quot;&quot;;
    opt.api.parameters.forEach(function (schemaP) {
        tmp = opt.targetOnEvent.querySelector(
            &quot;.schemaP[data-name=&quot; + JSON.stringify(schemaP.name) + &quot;] .input&quot;
        );
        switch (tmp.tagName) {
        case &quot;INPUT&quot;:
            // parse file
            if (local.schemaPType(tmp) === &quot;file&quot;) {
                tmp = tmp.files &amp;&amp; tmp.files[0];
                break;
            }
            tmp = tmp.value;
            if (!tmp) {
                return;
            }
            // parse string
            if (local.schemaPType(schemaP) !== &quot;string&quot;) {
                tmp = jsonParse(tmp);
            }
            break;
        case &quot;SELECT&quot;:
            tmp = Array.from(tmp.options).filter(function (element) {
                return element.selected;
            }).map(function (element) {
                return jsonParse(decodeURIComponent(
                    element.dataset.valueSelectOption
                ));
            });
            if (!tmp.length || tmp[0] === &quot;$swggUndefined&quot;) {
                return;
            }
            if (local.schemaPType(schemaP) !== &quot;array&quot;) {
                tmp = tmp[0];
            }
            break;
        case &quot;TEXTAREA&quot;:
            tmp = tmp.value;
            if (!tmp) {
                return;
            }
            // ignore string (json)
            if (
                schemaP.format === &quot;json&quot;
                &amp;&amp; local.schemaPType(schemaP) === &quot;string&quot;
            ) {
                break;
            }
            if (
                schemaP.schema
                &amp;&amp; local.schemaPType(schemaP.schema) === &quot;string&quot;
                &amp;&amp; typeof tmp === &quot;string&quot;
            ) {
                break;
            }
            // parse schema
            if (schemaP.in === &quot;body&quot;) {
                tmp = jsonParse(tmp);
                break;
            }
            // parse array
            tmp = tmp.split(&quot;\n&quot;).map(function (element) {
                return (
                    local.schemaPItemsType(schemaP) === &quot;string&quot;
                    ? element
                    : jsonParse(element)
                );
            });
            break;
        }
        opt.paramDict[schemaP.name] = tmp;
    });
    opt.api.ajax(opt, onError || local.nop);
    // init errorDict
    errorDict = {};
    local.coalesce(opt.err &amp;&amp; opt.err.errList, []).forEach(function (err) {
        errorDict[err.opt.prefix[2]] = err;
    });
    // shake input on err
    Array.from(opt.targetOnEvent.querySelectorAll(
        &quot;.schemaP[data-name]&quot;
    )).forEach(function (element) {
        tmp = errorDict[element.dataset.name];
        local.uiAnimateShakeIfError(tmp, element.querySelector(
            &quot;.input&quot;
        ));
        element.querySelector(
            &quot;.colorError&quot;
        ).textContent = (
            tmp
            ? tmp.messageShort
            : &quot;&quot;
        );
    });
    // shake submit-button on err
    local.uiAnimateShakeIfError(
        opt.err,
        opt.targ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
value = evt.targetOnEvent.value;
if (value &amp;&amp; isTransparent) {
    evt.targetOnEvent.style.background = &quot;&quot;;
}
if (!value &amp;&amp; !isTransparent) {
    evt.targetOnEvent.style.background = &quot;transparent&quot;;
}
local.uiEventListenerDict.<span class="apidocCodeKeywordSpan">onEventInputValidateAndAjax</span>({
    targetOnEvent: evt.targetOnEvent
});
};

local.uiEventListenerDict.onEventInputValidateAndAjax = function (
opt,
onError
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationAjax" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationAjax">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventOperationAjax
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventOperationAjax = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will submit the operation to the backend
 */
</span>    // ensure opt is stateless
    opt = {
        targetOnEvent: opt.targetOnEvent.closest(&quot;.operation&quot;)
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // force ajax
            opt.modeAjax = &quot;ajax&quot;;
            // validate input
            local.uiEventListenerDict.onEventInputValidateAndAjax(
                opt,
                opt.gotoNext
            );
            // reset res output
            Array.from(opt.targetOnEvent.querySelectorAll(
                &quot;.resBody, .resHeaders, .resStatusCode&quot;
            )).forEach(function (element) {
                element.classList.remove(&quot;hasError&quot;);
                element.textContent = &quot;loading ...&quot;;
            });
            opt.targetOnEvent.querySelector(
                &quot;.resMedia&quot;
            ).innerHTML = &quot;&quot;;
            // scrollTo res
            opt.targetOnEvent.querySelector(
                &quot;.resStatusCode&quot;
            ).focus();
            break;
        default:
            local.onErrorDefault(err);
            data = local.objectSetDefault(data, {
                contentType: &quot;undefined&quot;,
                statusCode: &quot;undefined&quot;
            });
            // init resStatusCode
            opt.targetOnEvent.querySelector(
                &quot;.resStatusCode&quot;
            ).textContent = (
                data.statusCode
            );
            // init resHeaders
            opt.targetOnEvent.querySelector(
                &quot;.resHeaders&quot;
            ).textContent = Object.keys(data.resHeaders).map(function (key) {
                return key + &quot;: &quot; + data.resHeaders[key] + &quot;\r\n&quot;;
            }).join(&quot;&quot;);
            // init resBody
            opt.targetOnEvent.querySelector(
                &quot;.resHeaders&quot;
            ).textContent.replace((
                /^content-type:(.*?)$/im
            ), function (ignore, match1) {
                data.contentType = match1.trim();
            });
            data.mediaType = data.contentType.split(&quot;/&quot;)[0].replace(
                &quot;image&quot;,
                &quot;img&quot;
            );
            switch (data.mediaType) {
            case &quot;audio&quot;:
            case &quot;img&quot;:
            case &quot;video&quot;:
                opt.targetOnEvent.querySelector(
                    &quot;.resBody&quot;
                ).textContent = (
                    data.contentType
                );
                opt.targetOnEvent.querySelector(
                    &quot;.resMedia&quot;
                ).innerHTML = (
                    &quot;&lt;&quot; + data.mediaType
                    + &quot; class=\&quot;domOnEventMediaHotkeysInit\&quot;&quot;
                    + &quot; controls src=\&quot;data:&quot;
                    + data.contentType
                    + &quot;;base64,&quot; + local.base64FromBuffer(data.resBuffer)
                    + &quot;\&quot;&gt;&lt;/&quot; + data.mediaType + &quot;&gt;&quot;
                );
                globalThis.domOnEventMediaHotkeys(&quot;init&quot;);
                break;
            default:
                opt.targetOnEvent.querySelector(
                    &quot;.resBody&quot;
                ).textContent = (
                    data.responseJson
                    ? JSON.stringify(data.responseJson, null, 4)
                    : data.response
                );
            }
            // shake res on err
            Array.from(opt.targetOnEvent.querySelectorAll(
                &quot;.resBody, .resHeaders, .resStatusCode&quot;
            )).forEach(function (element) {
                local.uiAnimateShakeIfError(data.statusCode &gt;= 400, element);
            });
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationDisplayShow" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventOperationDisplayShow">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventOperationDisplayShow
        <span class="apidocSignatureSpan">( evt, onError )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventOperationDisplayShow = function ( evt, onError ) {
<span class="apidocCodeCommentSpan">/*
 * this function will toggle the display of the operation
 */
</span>    let element;
    element = evt.targetOnEvent;
    element = element.querySelector(
        &quot;.operation&quot;
    ) || element.closest(
        &quot;.operation&quot;
    );
    location.hash = &quot;!&quot; + element.id;
    element.closest(
        &quot;.resource&quot;
    ).classList.remove(&quot;expanded&quot;);
    // show parent resource
    local.uiAnimateSlideDown(element.closest(
        &quot;.resource&quot;
    ).querySelector(
        &quot;.operationList&quot;
    ));
    // show the operation, but hide all other operations
    local.uiAnimateSlideAccordian(
        element.querySelector(
            &quot;.operation &gt; form&quot;
        ),
        Array.from(element.closest(
            &quot;.operationList&quot;
        ).querySelectorAll(
            &quot;.operation &gt; form&quot;
        )),
        function () {
            // scrollTo operation
            element.querySelector(
                &quot;[tabIndex]&quot;
            ).blur();
            element.querySelector(
                &quot;[tabIndex]&quot;
            ).focus();
            // validate input
            local.uiEventListenerDict.onEventInputValidateAndAjax({
                targetOnEvent: element
            });
            local.setTimeoutOnError(onError, 0, null, element);
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &quot;.operationList&quot;
    ),
    Array.from(document.querySelectorAll(
        &quot;.swggUiContainer .operationList&quot;
    ))
);
// show at least one operation in the resource
local.uiEventListenerDict.<span class="apidocCodeKeywordSpan">onEventOperationDisplayShow</span>({
    targetOnEvent: evt.currentTarget.querySelector(
        &quot;.operation .uiAnimateSlide[style*=\&quot;max-height: 100%\&quot;]&quot;
    ) || evt.currentTarget.querySelector(
        &quot;.operation&quot;
    )
});
return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventResourceDisplayAction" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventResourceDisplayAction">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventResourceDisplayAction
        <span class="apidocSignatureSpan">(evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventResourceDisplayAction = function (evt) {
<span class="apidocCodeCommentSpan">/*
 * this function will toggle the display of the resource
 */
</span>    location.hash = &quot;!&quot; + evt.currentTarget.id;
    evt.targetOnEvent.className.split(&quot; &quot;).some(function (className) {
        switch (className) {
        case &quot;td1&quot;:
            // show the resource, but hide all other resources
            local.uiAnimateSlideAccordian(
                evt.currentTarget.querySelector(
                    &quot;.operationList&quot;
                ),
                Array.from(document.querySelectorAll(
                    &quot;.swggUiContainer .operationList&quot;
                ))
            );
            // show at least one operation in the resource
            local.uiEventListenerDict.onEventOperationDisplayShow({
                targetOnEvent: evt.currentTarget.querySelector(
                    &quot;.operation .uiAnimateSlide[style*=\&quot;max-height: 100%\&quot;]&quot;
                ) || evt.currentTarget.querySelector(
                    &quot;.operation&quot;
                )
            });
            return true;
        case &quot;td2&quot;:
            // show the resource, but hide all other resources
            local.uiAnimateSlideAccordian(
                evt.currentTarget.querySelector(
                    &quot;.operationList&quot;
                ),
                Array.from(document.querySelectorAll(
                    &quot;.swggUiContainer .operationList&quot;
                ))
            );
            // collapse all operations in the resource
            if (evt.currentTarget.classList.contains(&quot;expanded&quot;)) {
                evt.currentTarget.classList.remove(&quot;expanded&quot;);
                Array.from(evt.currentTarget.querySelectorAll(
                    &quot;.operation &gt; form&quot;
                )).forEach(function (element) {
                    local.uiAnimateSlideUp(element);
                });
            // expand all operations in the resource
            } else {
                evt.currentTarget.classList.add(&quot;expanded&quot;);
                Array.from(evt.currentTarget.querySelectorAll(
                    &quot;.operation &gt; form&quot;
                )).forEach(function (element) {
                    local.uiAnimateSlideDown(element);
                    // validate input
                    local.uiEventListenerDict.onEventInputValidateAndAjax({
                        targetOnEvent: element
                    });
                });
            }
            return true;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.swgg.uiEventListenerDict.onEventUiReload" id="apidoc.elem.utility2.swgg.uiEventListenerDict.onEventUiReload">
        function <span class="apidocSignatureSpan">utility2.swgg.uiEventListenerDict.</span>onEventUiReload
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEventUiReload = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will reload the ui
 */
</span>    let resource;
    let swaggerJson;
    opt = opt || {};
    swaggerJson = opt;
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            if (
                opt
                &amp;&amp; opt.targetOnEvent
                &amp;&amp; opt.targetOnEvent.classList
                &amp;&amp; !opt.targetOnEvent.classList.contains(
                    &quot;eventDelegate&quot;
                    + opt.type[0].toUpperCase()
                    + opt.type.slice(1)
                )
            ) {
                return;
            }
            opt.inputUrl = document.querySelector(
                &quot;.swggUiContainer &gt; .thead &gt; .td2&quot;
            );
            // clear all apiKeyValue&apos;s from localStorage
            if (
                opt.targetOnEvent
                &amp;&amp; opt.targetOnEvent.id === &quot;buttonSwggApiKeyClear1&quot;
            ) {
                local.apiKeyValue = &quot;&quot;;
                Object.keys(localStorage).forEach(function (key) {
                    if (key.indexOf(&quot;utility2_swgg_apiKeyKey_&quot;) === 0) {
                        localStorage.removeItem(key);
                    }
                });
            // restore apiKeyValue
            } else if (opt.swggInit) {
                local.apiKeyKey = (
                    &quot;utility2_swgg_apiKeyKey_&quot; + encodeURIComponent(
                        local.urlParse(opt.inputUrl.value.replace((
                            /^\//
                        ), &quot;&quot;)).href
                    )
                );
                local.apiKeyValue = localStorage.getItem(local.apiKeyKey) || &quot;&quot;;
            // save apiKeyValue
            } else {
                local.apiKeyValue = document.querySelector(
                    &quot;#swggApiKeyInput1&quot;
                ).value;
                local.localStorageSetItemOrClear(
                    local.apiKeyKey,
                    local.apiKeyValue
                );
            }
            // if keyup-evt is not return-key, then return
            if (
                (opt.type === &quot;keyup&quot; &amp;&amp; opt.code !== &quot;Enter&quot;)
                // do not reload ui during test
                || globalThis.utility2_modeTest &gt;= 4
            ) {
                opt.gotoState = Infinity;
                opt.gotoNext();
                return;
            }
            // reset ui
            document.querySelector(
                &quot;#swggUiReloadErrorDiv1&quot;
            ).textContent = &quot;&quot;;
            document.querySelectorAll(
                &quot;.swggUiContainer &gt; .reset&quot;
            ).forEach(function (element) {
                element.remove();
            });
            // normalize swaggerJsonUrl
            opt.inputUrl.value = local.urlParse(
                opt.inputUrl.value.replace((
                    /^\//
                ), &quot;&quot;)
            ).href;
            document.querySelector(
                &quot;#swggAjaxProgressDiv1 span&quot;
            ).innerHTML = (
                &quot;loading swagger.json&quot;
            );
            opt.gotoNext();
            break;
        case 2:
            // fetch swagger.json file
            local.ajax({
                url: opt.inputUrl.value
            }, opt.gotoNext);
            break;
        case 3:
            // JSON.parse swagger.json string
            local.tryCatchOnError(function () {
                opt.gotoNext(null, JSON.parse(data.responseText));
            }, opt.gotoNext);
            break;
        case 4:
            // reset state
            local.apiDict = null;
            local.swaggerJson = null;
            // apiUpdate swagger.json object
            local.apiUpdate(data);
            swaggerJson = local.jsonCopy(local.swaggerJson);
            local.uiState = swaggerJson;
            // init ajaxProgressText...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /\\bmodeSwaggerJsonUrl=([^&amp;]+)|$/gm\n\
).exec(location.search)[1] || &quot;assets.swgg.swagger.json&quot;);\n\
&lt;/script&gt;\n\
&lt;script src=&quot;assets.utility2.rollup.js&quot;&gt;&lt;/script&gt;\n\
&lt;script&gt;\n\
/* jslint utility2:true */\n\
window.local = window.local || window.swgg;\n\
window.swgg.uiEventListenerDict.<span class="apidocCodeKeywordSpan">onEventUiReload</span>({\n\
    swggInit: true\n\
});\n\
&lt;/script&gt;\n\
&lt;!-- swgg-script-extra-begin --&gt;\n\
&lt;!-- swgg-script-extra-end --&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
