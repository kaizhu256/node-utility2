/* this rollup was created with utility2
 * https://github.com/kaizhu256/node-utility2
 */


/*
assets.app.js

this zero-dependency package will provide high-level functions to to build, test, and deploy webapps

instruction
    1. save this script as assets.app.js
    2. run shell-cmd:
        $ PORT=8081 node assets.app.js
    3. open browser to http://127.0.0.1:8081 and play with web-demo
    4. edit this script to suit your needs
*/
/* utility2.rollup.js begin */
/* istanbul ignore all */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


/* jslint utility2:true */
(function () {
    "use strict";
    // init utility2_app
    globalThis.utility2_app = (
        globalThis.utility2_app_old
        || globalThis.globalLocal
    );
    globalThis.utility2_app.local = globalThis.utility2_app;
    globalThis.utility2_app_old = null;
}());



/* script-begin /assets.utility2.rollup.js */
/* this rollup was created with utility2
 * https://github.com/kaizhu256/node-utility2
 */



/* script-begin /assets.utility2.rollup.start.js */
/* utility2.rollup.js begin */
/* istanbul ignore all */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


/* jslint utility2:true */
(function () {
    "use strict";
    // init utility2_rollup
    globalThis.utility2_rollup = (
        globalThis.utility2_rollup_old
        || globalThis.globalLocal
    );
    globalThis.utility2_rollup.local = globalThis.utility2_rollup;
    globalThis.utility2_rollup_old = null;
}());
/* script-end /assets.utility2.rollup.start.js */



/* script-begin /assets.utility2.lib.apidoc.js */
// usr/bin/env node
/*
 * lib.apidoc.js (2020.6.9)
 * https://github.com/kaizhu256/node-apidoc-lite
 * this zero-dependency package will auto-generate documentation for your npm-package with zero-config
 *
 */


/* istanbul instrument in package apidoc */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_apidoc = local;
}
// init lib main
local.apidoc = local;


/* validateLineSortedReset */
local.cliRun = function ({
    rgxComment
}) {
/*
 * this function will run cli
 */
    let {
        _default,
        _eval,
        _help,
        _interactive,
        _version,
        cliDict,
        replStart
    } = Object.assign({}, local, local.cliDict);
    _eval = _eval || function () {
    /*
     * <code>
     * will eval <code>
     */
        Object.assign(globalThis, local);
        require("vm").runInThisContext(process.argv[3]);
    };
    _help = _help || function () {
    /*
     *
     * will print help
     */
        let cmdList;
        let file;
        let packageJson;
        let str;
        let strDict;
        cmdList = [
            {
                argList: "<arg2>  ...",
                description: "usage:",
                cmd: [
                    "<arg1>"
                ]
            }, {
                argList: "'console.log(\"hello world\")'",
                description: "example:",
                cmd: [
                    "--eval"
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), "");
        packageJson = require("./package.json");
        // validate comment
        rgxComment = rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020<[^>]*?>|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(cliDict).sort().forEach(function (key, ii) {
            if (key[0] === "_" && key !== "_default") {
                return;
            }
            str = String(cliDict[key]);
            if (key === "_default") {
                key = "";
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (cmdList[ii]) {
                cmdList[ii].cmd.push(key);
                return;
            }
            cmdList[ii] = rgxComment.exec(str);
            if (!cmdList[ii]) {
                throw new Error(
                    "cliRun - cannot parse comment in cmd " +
                    key + ":\nnew RegExp(" +
                    JSON.stringify(rgxComment.source) +
                    ").exec(" + JSON.stringify(str).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") + ");"
                );
            }
            cmdList[ii] = {
                argList: String(cmdList[ii][1] || "").trim(),
                cmd: [
                    key
                ],
                description: cmdList[ii][2]
            };
        });
        str = "";
        str += packageJson.name + " (" + packageJson.version + ")\n\n";
        str += cmdList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.cmd = elem.cmd.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(" ");
                elem.description = (
                    "# CMD " +
                    (elem.cmd[0] || "<none>") + "\n# " +
                    elem.description
                );
            }
            return (
                elem.description + "\n  " + file +
                "  " + elem.cmd.sort().join("|") + "  " +
                elem.argList.join("  ")
            );
        }).join("\n\n");
        console.log(str);
    };
    _interactive = _interactive || function () {
    /*
     *
     * will start interactive-mode
     */
        Object.assign(globalThis, local);
        replStart = replStart || require("repl").start;
        replStart({
            useGlobal: true
        });
    };
    _version = _version || function () {
    /*
     *
     * will print version
     */
        console.log(require(__dirname + "/package.json").version);
    };
    _default = _default || _help;
    Object.assign(cliDict, {
        "--eval": _eval,
        "--help": _help,
        "--interactive": _interactive,
        "--version": _version,
        "-e": _eval,
        "-h": _help,
        "-i": _interactive,
        "-v": _version,
        _default,
        _eval,
        _help,
        _interactive,
        _version
    });
    // run help-cmd if no arguments are given
    if (process.argv.length <= 2) {
        _help();
        return;
    }
    // run defined-cmd if it exists
    if (cliDict[process.argv[2]]) {
        cliDict[process.argv[2]]();
        return;
    }
    // run default-cmd
    _default();
};

local.moduleDirname = function (module, pathList) {
/*
 * this function will search <pathList> for <module>'s __dirname
 */
    let result;
    // search "."
    if (!module || module === "." || module.indexOf("/") >= 0) {
        return require("path").resolve(module || "");
    }
    // search pathList
    [].concat(
        pathList,
        require("module").globalPaths,
        [
            process.env.HOME + "/node_modules", "/usr/local/lib/node_modules"
        ]
    ).some(function (path) {
        try {
            result = require("path").resolve(path + "/" + module);
            result = require("fs").statSync(result).isDirectory() && result;
            return result;
        } catch (ignore) {
            result = "";
        }
    });
    return result;
};

local.stringHtmlSafe = function (str) {
/*
 * this function will make <str> html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
    return str.replace((
        /&/gu
    ), "&amp;").replace((
        /"/gu
    ), "&quot;").replace((
        /'/gu
    ), "&apos;").replace((
        /</gu
    ), "&lt;").replace((
        />/gu
    ), "&gt;").replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
    ), "&$1");
};

/* jslint ignore:start */
local.templateApidocHtml = '\
<div class="apidocDiv">\n\
<style>\n\
/*csslint\n\
*/\n\
.apidocDiv {\n\
    background: #fff;\n\
    font-family: Arial, Helvetica, sans-serif;\n\
}\n\
.apidocDiv a[href] {\n\
    color: #33f;\n\
    font-weight: bold;\n\
    text-decoration: none;\n\
}\n\
.apidocDiv a[href]:hover {\n\
    text-decoration: underline;\n\
}\n\
.apidocCodeCommentSpan {\n\
    background: #bbf;\n\
    color: #000;\n\
    display: block;\n\
}\n\
.apidocCodeKeywordSpan {\n\
    color: #d00;\n\
    font-weight: bold;\n\
}\n\
.apidocCodePre {\n\
    background: #eef;\n\
    border: 1px solid;\n\
    color: #777;\n\
    overflow-wrap: break-word;\n\
    padding: 5px;\n\
    white-space: pre-wrap;\n\
}\n\
.apidocFooterDiv {\n\
    margin-top: 20px;\n\
    text-align: center;\n\
}\n\
.apidocModuleLi {\n\
    margin-top: 10px;\n\
}\n\
.apidocSectionDiv {\n\
    border-top: 1px solid;\n\
    margin-top: 20px;\n\
}\n\
.apidocSignatureSpan {\n\
    color: #777;\n\
    font-weight: bold;\n\
}\n\
</style>\n\
<h1>api documentation for\n\
    <a\n\
        {{#if env.npm_package_homepage}}\n\
        href="{{env.npm_package_homepage}}"\n\
        {{/if env.npm_package_homepage}}\n\
    >{{env.npm_package_name}} ({{env.npm_package_version}})</a>\n\
</h1>\n\
<h4>{{env.npm_package_description}}</h4>\n\
<div class="apidocSectionDiv"><a\n\
    href="#apidoc.tableOfContents"\n\
    id="apidoc.tableOfContents"\n\
><h1>table of contents</h1></a><ol>\n\
    {{#each moduleList}}\n\
    <li class="apidocModuleLi"><a href="#{{id}}">module {{name}}</a><ol>\n\
        {{#each elemList}}\n\
        <li>\n\
            {{#if source}}\n\
            <a class="apidocElementLiA" href="#{{id}}">\n\
            {{name}}\n\
            <span class="apidocSignatureSpan">{{signature}}</span>\n\
            </a>\n\
            {{#unless source}}\n\
            <span class="apidocSignatureSpan">{{name}}</span>\n\
            {{/if source}}\n\
        </li>\n\
        {{/each elemList}}\n\
    </ol></li>\n\
    {{/each moduleList}}\n\
</ol></div>\n\
{{#each moduleList}}\n\
<div class="apidocSectionDiv">\n\
<h1><a href="#{{id}}" id="{{id}}">module {{name}}</a></h1>\n\
    {{#each elemList}}\n\
    {{#if source}}\n\
    <h2>\n\
        <a href="#{{id}}" id="{{id}}">\n\
        {{name}}\n\
        <span class="apidocSignatureSpan">{{signature}}</span>\n\
        </a>\n\
    </h2>\n\
    <ul>\n\
    <li>description and source-code<pre class="apidocCodePre">{{source truncate 4096}}</pre></li>\n\
    <li>example use<pre class="apidocCodePre">{{example}}</pre></li>\n\
    </ul>\n\
    {{/if source}}\n\
    {{/each elemList}}\n\
</div>\n\
{{/each moduleList}}\n\
<div class="apidocFooterDiv">\n\
    [ this document was created with\n\
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>\n\
    ]\n\
</div>\n\
</div>\n\
';
/* jslint ignore:end */

local.templateRender = function (template, dict, opt = {}, ii = 0) {
/*
 * this function will render <template> with given <dict>
 */
    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    getVal = function (key) {
        argList = key.split(" ");
        val = dict;
        if (argList[0] === "#this/") {
            return val;
        }
        if (argList[0] === "#ii/") {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(".").forEach(function (key) {
            val = val && val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case "each":
        case "eachTrimEndComma":
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join("")
                : ""
            );
            // remove trailing-comma from last elem
            if (helper === "eachTrimEndComma") {
                val = val.trimEnd().replace((
                    /,$/
                ), "");
            }
            return val;
        case "if":
            partial = partial.split("{{#unless " + key + "}}");
            partial = (
                getVal(key)
                ? partial[0]
                // handle "unless" case
                : partial.slice(1).join("{{#unless " + key + "}}")
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case "unless":
            return (
                getVal(key)
                ? ""
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || "";
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                "\\{\\{#(" + match[1] + ") (" + match[2]
                + ")\\}\\}([\\S\\s]*?)\\{\\{/" + match[1] + " " + match[2]
                + "\\}\\}"
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case "*":
                case "+":
                case "-":
                case "/":
                    skip = ii + 1;
                    val = String(
                        fmt === "*"
                        ? Number(val) * Number(list[skip])
                        : fmt === "+"
                        ? Number(val) + Number(list[skip])
                        : fmt === "-"
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;
                case "alphanumeric":
                    val = val.replace((
                        /\W/g
                    ), "_");
                    break;
                case "decodeURIComponent":
                    val = decodeURIComponent(val);
                    break;
                case "encodeURIComponent":
                    val = encodeURIComponent(val);
                    break;
                case "jsonStringify":
                    val = JSON.stringify(val);
                    break;
                case "jsonStringify4":
                    val = JSON.stringify(val, undefined, 4);
                    break;
                case "markdownSafe":
                    val = val.replace((
                        /`/g
                    ), "'"); // `
                    break;
                case "markdownToHtml":
                    markdownToHtml = true;
                    break;
                case "notHtmlSafe":
                    notHtmlSafe = true;
                    break;
                case "padEnd":
                case "padStart":
                case "replace":
                case "slice":
                    skip = ii + 2;
                    val = String(val)[fmt](
                        list[skip - 1],
                        list[skip].replace("\"\"", "").replace("\"_\"", " ")
                    );
                    break;
                case "truncate":
                    skip = ii + 1;
                    if (val.length > list[skip]) {
                        val = val.slice(
                            0,
                            Math.max(list[skip] - 3, 0)
                        ).trimEnd() + "...";
                    }
                    break;
                // default to String.prototype[fmt]()
                default:
                    if (ii <= skip) {
                        break;
                    }
                    val = val[fmt]();
                }
            });
            val = String(val);
            // default to htmlSafe
            if (!notHtmlSafe) {
                val = val.replace((
                    /&/gu
                ), "&amp;").replace((
                    /"/gu
                ), "&quot;").replace((
                    /'/gu
                ), "&apos;").replace((
                    /</gu
                ), "&lt;").replace((
                    />/gu
                ), "&gt;").replace((
                    /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
                ), "&$1");
            }
            markdownToHtml = (
                markdownToHtml
                && (typeof local.marked === "function" && local.marked)
            );
            if (markdownToHtml) {
                val = markdownToHtml(val).replace((
                    /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
                ), "&$1");
            }
            return val;
        } catch (errCaught) {
            errCaught.message = (
                "templateRender could not render expression "
                + JSON.stringify(match0) + "\n"
            ) + errCaught.message;
            local.assertOrThrow(undefined, errCaught);
        }
    });
};

local.tryCatchOnError = function (fnc, onError) {
/*
 * this function will run <fnc> in tryCatch block,
 * else call onError with errCaught
 */
    let result;
    // validate onError
    local.assertOrThrow(typeof onError === "function", typeof onError);
    try {
        // reset errCaught
        delete local._debugTryCatchError;
        result = fnc();
        delete local._debugTryCatchError;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
};
}());


// run shared js-env code - function
(function () {
local.apidocCreate = function (opt) {
/*
 * this function will create the apidoc from <opt>.dir
 */
    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    if (opt.modeNoop) {
        return "";
    }
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given <module>
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(".");
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(".");
        elem.id = encodeURIComponent("apidoc.elem." + prefix + "." + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + " <span class=\"apidocSignatureSpan\">"
            + elem.moduleName + ".</span>" + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(">.<", "><");
        if (elem.typeof !== "function") {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || "n/a"
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), "").replace((
                /,/g
            ), ", ").replace((
                /\s+/g
            ), " ");
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), "<span class=\"apidocCodeCommentSpan\">$1</span>").replace((
            /^function\u0020\(/
        ), key + " = function (");
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp("((?:\n.*?){8}\\.)(" + key + ")(\\((?:.*?\n){8})"),
                function (ignore, match1, match2, match3) {
                    elem.example = "..." + trimStart(
                        local.stringHtmlSafe(match1)
                        + "<span class=\"apidocCodeKeywordSpan\">"
                        + local.stringHtmlSafe(match2)
                        + "</span>"
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + "\n...";
                    return "";
                }
            );
            return elem.example;
        });
        elem.example = elem.example || "n/a";
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = require("path").resolve(opt.dir, file);
            console.error("apidocCreate - readExample " + file);
            result = "";
            result = local.identity(
                "\n\n\n\n\n\n\n\n"
                // bug-workaround - truncate example to manageable size
                + require("fs").readFileSync(file, "utf8").slice(0, 262144)
                + "\n\n\n\n\n\n\n\n"
            ).replace((
                /\r\n*/g
            ), "\n");
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = "";
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (str) {
    /*
     * this function will normalize whitespace before <str>
     */
        let whitespace;
        whitespace = "";
        str.trim().replace((
            /^\u0020*/gm
        ), function (match0) {
            if (!whitespace || match0.length < whitespace.length) {
                whitespace = match0;
            }
            return "";
        });
        str = str.replace(new RegExp("^" + whitespace, "gm"), "");
        // enforce 128 character column limit
        str = str.replace((
            /^.{128}[^\\\n]+/gm
        ), function (match0) {
            return match0.replace((
                /(.{128}(?:\b|\w+))/g
            ), "$1\n").trimEnd();
        });
        return str;
    };
    // init opt
    opt.dir = local.moduleDirname(
        opt.dir,
        opt.modulePathList || require("module").paths
    );
    local.objectAssignDefault(opt, {
        env: {
            npm_package_description: ""
        },
        packageJson: JSON.parse(readExample("package.json")),
        require: function (file) {
            return local.tryCatchOnError(function () {
                return require(file);
            }, console.error);
        }
    });
    Object.keys(opt.packageJson).forEach(function (key) {
        tmp = opt.packageJson[key];
        // strip email from npmdoc documentation
        // https://github.com/npmdoc/node-npmdoc-hpp/issues/1
        if (tmp) {
            if (tmp.email) {
                delete tmp.email;
            }
            if (Array.isArray(tmp)) {
                tmp.forEach(function (elem) {
                    if (elem && elem.email) {
                        delete elem.email;
                    }
                });
            }
        }
        if (key[0] === "_" || key === "readme") {
            delete opt.packageJson[key];
        } else if (typeof tmp === "string") {
            opt.env["npm_package_" + key] = tmp;
        }
    });
    local.objectAssignDefault(opt, {
        blacklistDict: {
            globalThis
        },
        circularSet: new Set([
            globalThis
        ]),
        exampleDict: {},
        exampleList: [],
        html: "",
        libFileList: [],
        moduleDict: {},
        moduleExtraDict: {},
        packageJson: {
            bin: {}
        },
        template: local.templateApidocHtml,
        whitelistDict: {}
    }, 2);
    // init exampleList
    ([
        1, 2, 3, 4
    ]).forEach(function (depth) {
        opt.exampleList = opt.exampleList.concat(
            // find . -maxdepth 1 -mindepth 1 -name "*.js" -type f
            // https://stackoverflow.com/questions/4509624/how-to-limit-depth-for-recursive-file-list
            require("child_process").execSync(
                "find \"" + opt.dir
                + "\" -maxdepth " + depth + " -mindepth " + depth
                + " -type f | sed -e \"s|" + opt.dir
                + "/||\" | grep -iv "
/* jslint ignore:start */
+ '"\
/\\.\\|\\(\\b\\|_\\)\\(\
bower_component\\|\
coverage\\|\
git\\|\
min\\|\
node_module\\|\
rollup\\|\
tmp\\|\
vendor\\)s\\{0,1\\}\\(\\b\\|_\\)\
" '
/* jslint ignore:end */
                + " | sort | head -n 256"
            ).toString().split("\n")
        );
    });
    opt.exampleList = opt.exampleList.filter(function (file) {
        if (file && !opt.exampleDict[file]) {
            opt.exampleDict[file] = true;
            return true;
        }
    }).slice(0, 256).map(readExample);
    // init moduleMain
    local.tryCatchOnError(function () {
        console.error("apidocCreate - requiring " + opt.dir + " ...");
        moduleMain = {};
        moduleMain = (
            opt.moduleDict[opt.env.npm_package_name]
            || opt.require(opt.dir)
            || opt.require(
                opt.dir + "/"
                + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
            ) || {}
        );
        opt.circularSet.add(moduleMain);
        console.error("apidocCreate - ... required " + opt.dir);
    }, console.error);
    tmp = {};
    // handle case where module is a function
    if (typeof moduleMain === "function") {
        (function () {
            let str;
            str = toString(moduleMain);
            tmp = function () {
                return;
            };
            // coverage-hack
            tmp();
            Object.defineProperties(tmp, {
                toString: {
                    get: function () {
                        return function () {
                            return str;
                        };
                    }
                }
            });
        }());
    }
    // normalize moduleMain
    moduleMain = local.objectAssignDefault(tmp, moduleMain);
    opt.moduleDict[opt.env.npm_package_name] = moduleMain;
    // init circularSet - builtins
    [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "crypto",
        "dgram",
        "dns",
        "domain",
        "events",
        "fs",
        "http",
        "https",
        "net",
        "os",
        "path",
        "querystring",
        "readline",
        "repl",
        "stream",
        "string_decoder",
        "timers",
        "tls",
        "tty",
        "url",
        "util",
        "vm",
        "zlib"
    ].forEach(function (key) {
        local.tryCatchOnError(function () {
            opt.circularSet.add(require(key));
        }, local.noop);
    });
    // init circularSet - blacklistDict
    Object.keys(opt.blacklistDict).forEach(function (key) {
        opt.circularSet.add(opt.blacklistDict[key]);
    });
    // init circularSet - moduleDict
    Object.keys(opt.moduleDict).forEach(function (key) {
        opt.circularSet.add(opt.moduleDict[key]);
    });
    // init circularSet - prototype
    opt.circularSet.forEach(function (elem) {
        opt.circularSet.add(elem && elem.prototype);
    });
    // init moduleDict child
    local.apidocModuleDictAdd(opt, opt.moduleDict);
    // init moduleExtraDict
    opt.moduleExtraDict[opt.env.npm_package_name] = (
        opt.moduleExtraDict[opt.env.npm_package_name] || {}
    );
    module = opt.moduleExtraDict[opt.env.npm_package_name];
    ([
        1, 2, 3, 4
    ]).forEach(function (depth) {
        opt.libFileList = opt.libFileList.concat(
            // find . -maxdepth 1 -mindepth 1 -name "*.js" -type f
            // https://stackoverflow.com/questions/4509624/how-to-limit-depth-for-recursive-file-list
            require("child_process").execSync(
                "find \"" + opt.dir
                + "\" -maxdepth " + depth + " -mindepth " + depth
                + " -name \"*.js\" -type f | sed -e \"s|" + opt.dir
                + "/||\" | grep -iv "
/* jslint ignore:start */
+ '"\
/\\.\\|\\(\\b\\|_\\)\\(\
archive\\|artifact\\|asset\\|\
bower_component\\|build\\|\
coverage\\|\
doc\\|dist\\|\
example\\|external\\|\
fixture\\|\
git\\|\
log\\|\
min\\|mock\\|\
node_module\\|\
rollup\\|\
spec\\|\
test\\|tmp\\|\
vendor\\)s\\{0,1\\}\\(\\b\\|_\\)\
" '
/* jslint ignore:end */
                + " | sort | head -n 256"
            ).toString().split("\n")
        );
    });
    opt.ii = 256;
    opt.libFileList.every(function (file) {
        local.tryCatchOnError(function () {
            tmp = {};
            tmp.name = require("path").basename(file).replace(
                "lib.",
                ""
            ).replace((
                /\.[^.]*?$/
            ), "").replace((
                /\W/g
            ), "_");
            Array.from([
                tmp.name,
                tmp.name.slice(0, 1).toUpperCase() + tmp.name.slice(1)
            ]).some(function (name) {
                tmp.isFiltered = name && (
                    !opt.packageJson.main
                    || String("./" + file).indexOf(opt.packageJson.main) < 0
                ) && !module[name];
                return !tmp.isFiltered;
            });
            if (!tmp.isFiltered) {
                return;
            }
            console.error("apidocCreate - libFile " + file);
            tmp.module = opt.require(opt.dir + "/" + file);
            // filter circular-reference
            if (!(tmp.module && opt.circularSet.has(tmp.module))) {
                return;
            }
            opt.ii -= 1;
            module[tmp.name] = tmp.module;
        }, console.error);
        return opt.ii;
    });
    local.apidocModuleDictAdd(opt, opt.moduleExtraDict);
    Object.keys(opt.moduleDict).forEach(function (key) {
        if (key.indexOf(opt.env.npm_package_name + ".") !== 0) {
            return;
        }
        tmp = key.split(".").slice(1).join(".");
        moduleMain[tmp] = moduleMain[tmp] || opt.moduleDict[key];
    });
    // init moduleList
    opt.moduleList = Object.keys(opt.moduleDict).sort().map(function (prefix) {
        module = opt.moduleDict[prefix];
        // handle case where module is a function
        if (typeof module === "function") {
            local.tryCatchOnError(function () {
                module[prefix.split(".").slice(-1)[0]] = (
                    module[prefix.split(".").slice(-1)[0]] || module
                );
            }, console.error);
        }
        return {
            elemList: Object.keys(module).filter(function (key) {
                return local.tryCatchOnError(function () {
                    return (
                        key
                        && (
                            /^\w[\w\-.]*?$/
                        ).test(key)
                        && key.indexOf("testCase_") !== 0
                        && (
                            module[key] !== opt.blacklistDict[key]
                            || opt.whitelistDict[key]
                        )
                    );
                }, console.error);
            }).map(function (key) {
                return elemCreate(module, prefix, key);
            }).sort(function (aa, bb) {
                return (
                    aa.name > bb.name
                    ? 1
                    : -1
                );
            }),
            id: encodeURIComponent("apidoc.module." + prefix),
            name: prefix
        };
    });
    // render apidoc
    opt.result = local.templateRender(opt.template, opt, {
        notHtmlSafe: true
    }).trim().replace((
        /\u0020+$/gm
    ), "") + "\n";
    return opt.result;
};

local.apidocModuleDictAdd = function (opt, moduleDict) {
/*
 * this function will add the modules in <moduleDict> to <opt>.moduleDict
 */
    let isModule;
    let objectKeys;
    let tmp;
    objectKeys = function (dict) {
    /*
     * this function will return a list of the dict's keys, with valid getters
     */
        return Object.keys(dict).sort().filter(function (key) {
            return local.tryCatchOnError(function () {
                return dict[key] || true;
            }, local.noop);
        });
    };
    [
        "child", "prototype", "grandchild", "prototype"
    ].forEach(function (elem) {
        objectKeys(moduleDict).forEach(function (prefix) {
            if (!(
                /^\w[\w\-.]*?$/
            ).test(prefix)) {
                return;
            }
            objectKeys(moduleDict[prefix]).forEach(function (key) {
                if (!(
                    /^\w[\w\-.]*?$/
                ).test(key) || !moduleDict[prefix][key]) {
                    return;
                }
                tmp = (
                    elem === "prototype"
                    ? {
                        module: moduleDict[prefix][key].prototype,
                        name: prefix + "." + key + ".prototype"
                    }
                    : {
                        module: moduleDict[prefix][key],
                        name: prefix + "." + key
                    }
                );
                if (
                    !tmp.module
                    || !(
                        typeof tmp.module === "function"
                        || typeof tmp.module === "object"
                    )
                    || Array.isArray(tmp.module)
                    || opt.moduleDict[tmp.name]
                    || opt.circularSet.has(tmp.module)
                ) {
                    return;
                }
                isModule = Array.from([
                    tmp.module,
                    tmp.module.prototype
                ]).some(function (dict) {
                    return objectKeys(dict || {}).some(function (key) {
                        return typeof dict[key] === "function";
                    });
                });
                if (!isModule) {
                    return;
                }
                opt.circularSet.add(tmp.module);
                opt.moduleDict[tmp.name] = tmp.module;
            });
        });
    });
};
}());


// run node js-env code - init-after
/* istanbul ignore next */
(function () {
if (!local.isEnvNode) {
    return;
}


local.cliDict = {};

local.cliDict._default = function () {
/*
 * <moduleDirectory>
 * will create apidoc from <moduleDirectory>
 */
    // jslint files
    process.stdout.write(local.apidocCreate({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main && !globalThis.utility2_rollup) {
    local.cliRun({});
}
}());
}());
/* script-end /assets.utility2.lib.apidoc.js */



/* script-begin /assets.utility2.lib.istanbul.js */
// usr/bin/env node
/*
 * lib.istanbul.js (2020.11.12)
 * https://github.com/kaizhu256/node-istanbul-lite
 * this zero-dependency package will provide browser-compatible version of istanbul coverage-tool (v0.4.5), with working web-demo
 *
 */


/* istanbul instrument in package istanbul */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_istanbul = local;
}
// init lib main
local.istanbul = local;


/* validateLineSortedReset */
local.cliRun = function ({
    rgxComment
}) {
/*
 * this function will run cli
 */
    let {
        _default,
        _eval,
        _help,
        _interactive,
        _version,
        cliDict,
        replStart
    } = Object.assign({}, local, local.cliDict);
    _eval = _eval || function () {
    /*
     * <code>
     * will eval <code>
     */
        Object.assign(globalThis, local);
        require("vm").runInThisContext(process.argv[3]);
    };
    _help = _help || function () {
    /*
     *
     * will print help
     */
        let cmdList;
        let file;
        let packageJson;
        let str;
        let strDict;
        cmdList = [
            {
                argList: "<arg2>  ...",
                description: "usage:",
                cmd: [
                    "<arg1>"
                ]
            }, {
                argList: "'console.log(\"hello world\")'",
                description: "example:",
                cmd: [
                    "--eval"
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), "");
        packageJson = require("./package.json");
        // validate comment
        rgxComment = rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020<[^>]*?>|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(cliDict).sort().forEach(function (key, ii) {
            if (key[0] === "_" && key !== "_default") {
                return;
            }
            str = String(cliDict[key]);
            if (key === "_default") {
                key = "";
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (cmdList[ii]) {
                cmdList[ii].cmd.push(key);
                return;
            }
            cmdList[ii] = rgxComment.exec(str);
            if (!cmdList[ii]) {
                throw new Error(
                    "cliRun - cannot parse comment in cmd " +
                    key + ":\nnew RegExp(" +
                    JSON.stringify(rgxComment.source) +
                    ").exec(" + JSON.stringify(str).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") + ");"
                );
            }
            cmdList[ii] = {
                argList: String(cmdList[ii][1] || "").trim(),
                cmd: [
                    key
                ],
                description: cmdList[ii][2]
            };
        });
        str = "";
        str += packageJson.name + " (" + packageJson.version + ")\n\n";
        str += cmdList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.cmd = elem.cmd.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(" ");
                elem.description = (
                    "# CMD " +
                    (elem.cmd[0] || "<none>") + "\n# " +
                    elem.description
                );
            }
            return (
                elem.description + "\n  " + file +
                "  " + elem.cmd.sort().join("|") + "  " +
                elem.argList.join("  ")
            );
        }).join("\n\n");
        console.log(str);
    };
    _interactive = _interactive || function () {
    /*
     *
     * will start interactive-mode
     */
        Object.assign(globalThis, local);
        replStart = replStart || require("repl").start;
        replStart({
            useGlobal: true
        });
    };
    _version = _version || function () {
    /*
     *
     * will print version
     */
        console.log(require(__dirname + "/package.json").version);
    };
    _default = _default || _help;
    Object.assign(cliDict, {
        "--eval": _eval,
        "--help": _help,
        "--interactive": _interactive,
        "--version": _version,
        "-e": _eval,
        "-h": _help,
        "-i": _interactive,
        "-v": _version,
        _default,
        _eval,
        _help,
        _interactive,
        _version
    });
    // run help-cmd if no arguments are given
    if (process.argv.length <= 2) {
        _help();
        return;
    }
    // run defined-cmd if it exists
    if (cliDict[process.argv[2]]) {
        cliDict[process.argv[2]]();
        return;
    }
    // run default-cmd
    _default();
};

local.fsReadFileOrDefaultSync = function (pathname, type, dflt) {
/*
 * this function will sync-read <pathname> with given <type> and <dflt>
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return dflt;
    }
    // try to read pathname
    try {
        return (
            type === "json"
            ? JSON.parse(fs.readFileSync(pathname, "utf8"))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};

local.fsWriteFileWithMkdirpSync = function (pathname, data) {
/*
 * this function will sync write <data> to <pathname> with "mkdir -p"
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return;
    }
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require("path").dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
    }
    console.error("fsWriteFileWithMkdirpSync - wrote - " + pathname);
    return true;
};

local.svgBadgeCreate = function ({
    fill,
    str1,
    str2
}) {
/*
 * this function will create svg-badge
 */
    let xx1;
    let xx2;
    str1 = String(str1);
    str2 = String(str2);
    xx1 = 6 * str1.length + 20;
    xx2 = 6 * str2.length + 20;
    return (
        "<svg height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\" xmlns=\"http://www.w3.org/2000/svg\">\n" +
        "<rect fill=\"#555\" height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\"/>\n" +
        "<rect fill=\"" + fill + "\" height=\"20\" width=\"" +
        xx2 + "\" x=\"" + xx1 + "\"/>\n" +
        "<g\n" +
        "fill=\"#fff\"\n" +
        "font-family=\"DejaVu Sans,Verdana,Geneva,sans-serif\"\n" +
        "font-size=\"11\"\n" +
        "text-anchor=\"middle\"\n" +
        ">\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        0.5 * xx1 + "\" y=\"15\">" + str1 + "</text>\n" +
        "<text x=\"" + 0.5 * xx1 + "\" y=\"14\">" + str1 + "</text>\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        (xx1 + 0.5 * xx2) + "\" y=\"15\">" + str2 + "</text>\n" +
        "<text x=\"" + (xx1 + 0.5 * xx2) + "\" y=\"14\">" + str2 + "</text>\n" +
        "</g>\n" +
        "</svg>\n"
    );
};

local.templateRender = function (template, dict, opt = {}, ii = 0) {
/*
 * this function will render <template> with given <dict>
 */
    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    getVal = function (key) {
        argList = key.split(" ");
        val = dict;
        if (argList[0] === "#this/") {
            return val;
        }
        if (argList[0] === "#ii/") {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(".").forEach(function (key) {
            val = val && val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case "each":
        case "eachTrimEndComma":
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join("")
                : ""
            );
            // remove trailing-comma from last elem
            if (helper === "eachTrimEndComma") {
                val = val.trimEnd().replace((
                    /,$/
                ), "");
            }
            return val;
        case "if":
            partial = partial.split("{{#unless " + key + "}}");
            partial = (
                getVal(key)
                ? partial[0]
                // handle "unless" case
                : partial.slice(1).join("{{#unless " + key + "}}")
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case "unless":
            return (
                getVal(key)
                ? ""
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || "";
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                "\\{\\{#(" + match[1] + ") (" + match[2]
                + ")\\}\\}([\\S\\s]*?)\\{\\{/" + match[1] + " " + match[2]
                + "\\}\\}"
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case "*":
                case "+":
                case "-":
                case "/":
                    skip = ii + 1;
                    val = String(
                        fmt === "*"
                        ? Number(val) * Number(list[skip])
                        : fmt === "+"
                        ? Number(val) + Number(list[skip])
                        : fmt === "-"
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;
                case "alphanumeric":
                    val = val.replace((
                        /\W/g
                    ), "_");
                    break;
                case "decodeURIComponent":
                    val = decodeURIComponent(val);
                    break;
                case "encodeURIComponent":
                    val = encodeURIComponent(val);
                    break;
                case "jsonStringify":
                    val = JSON.stringify(val);
                    break;
                case "jsonStringify4":
                    val = JSON.stringify(val, undefined, 4);
                    break;
                case "markdownSafe":
                    val = val.replace((
                        /`/g
                    ), "'"); // `
                    break;
                case "markdownToHtml":
                    markdownToHtml = true;
                    break;
                case "notHtmlSafe":
                    notHtmlSafe = true;
                    break;
                case "padEnd":
                case "padStart":
                case "replace":
                case "slice":
                    skip = ii + 2;
                    val = String(val)[fmt](
                        list[skip - 1],
                        list[skip].replace("\"\"", "").replace("\"_\"", " ")
                    );
                    break;
                case "truncate":
                    skip = ii + 1;
                    if (val.length > list[skip]) {
                        val = val.slice(
                            0,
                            Math.max(list[skip] - 3, 0)
                        ).trimEnd() + "...";
                    }
                    break;
                // default to String.prototype[fmt]()
                default:
                    if (ii <= skip) {
                        break;
                    }
                    val = val[fmt]();
                }
            });
            val = String(val);
            // default to htmlSafe
            if (!notHtmlSafe) {
                val = val.replace((
                    /&/gu
                ), "&amp;").replace((
                    /"/gu
                ), "&quot;").replace((
                    /'/gu
                ), "&apos;").replace((
                    /</gu
                ), "&lt;").replace((
                    />/gu
                ), "&gt;").replace((
                    /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
                ), "&$1");
            }
            markdownToHtml = (
                markdownToHtml
                && (typeof local.marked === "function" && local.marked)
            );
            if (markdownToHtml) {
                val = markdownToHtml(val).replace((
                    /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
                ), "&$1");
            }
            return val;
        } catch (errCaught) {
            errCaught.message = (
                "templateRender could not render expression "
                + JSON.stringify(match0) + "\n"
            ) + errCaught.message;
            local.assertOrThrow(undefined, errCaught);
        }
    });
};
}());


// run shared js-env code - function
(function () {
let escodegen;
let esprima;
let estraverse;
let esutils;
let process;
// mock builtins
escodegen = {};
esprima = {};
estraverse = {};
esutils = {};
process = (
    !local.isEnvNode
    ? {
        env: {},
        stdout: {}
    }
    : globalThis.process
);
local.noop(escodegen, esprima, estraverse, esutils);


/*
repo https://github.com/acornjs/acorn/tree/6.4.1
committed 2020-03-09T10:38:41Z
*/


/*
file https://github.com/acornjs/acorn/blob/6.4.1/acorn/dist/acorn.js
*/
// hack-istanbul - inline-require
/* istanbul ignore next */
/* jslint ignore:start */
(function () { let exports, module; exports = module = esprima;
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, function (exports) { 'use strict';

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `bin/generate-identifier-regex.js`.
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range. They were
  // generated by bin/generate-identifier-regex.js

  // eslint-disable-next-line comma-spacing
  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

  // eslint-disable-next-line comma-spacing
  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords$1 = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  // Checks if an object has a property.

  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 9.
    ecmaVersion: 9,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callbackthat will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callbackthat will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  // Switch to a getter for 7.0.0.
  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") { return true }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) { return true } // '['
    if (context) { return false }

    if (nextCh === 123) { return true } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40) // '('
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$1.parseBlock = function(createNewLexicalScope, node) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (!this.eat(types.braceR)) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$1.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };

  // Parses module export declaration.

  pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };

  // Parses import declaration.

  pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // Verify that a node is an lval  something that can be assigned
  // to.
  // bindingType can be either:
  // 'var' indicating that the lval creates a 'var' binding
  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  // A recursive descent parser operates by defining functions for all

  var pp$3 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash 
  // either with each other or with an init property  and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
          // Backwards-compat kludge. Can be removed in version 6.0
          else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldShorthandAssign = refDestructuringErrors.shorthandAssign;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };

  // Parse call, dot, and `[]`-subscript expressions.

  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || element.type === "ArrowFunctionExpression") { return element }
      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (node$1.callee.type === "Import") {
        if (node$1.arguments.length !== 1) {
          this.raise(node$1.start, "import() requires exactly one argument");
        }

        var importArg = node$1.arguments[0];
        if (importArg && importArg.type === "SpreadElement") {
          this.raise(importArg.start, "... is not allowed in import()");
        }
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super Arguments
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion > 10) {
        return this.parseDynamicImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function() {
    var node = this.startNode();
    this.next();
    if (this.type !== types.parenL) {
      this.unexpected();
    }
    return this.finishNode(node, "Import")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call  at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty$1 = [];

  pp$3.parseNew = function() {
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target" || containsEsc)
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
      this.raise(node.callee.start, "Cannot use new with import(...)");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      node.body = this.parseBlock(false);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();

    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
    this.strict = oldStrict;
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  // Parses yield expression inside generator.

  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };

  // Start an AST node, attaching a start offset.

  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };

  // Finish node at given position

  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Token-specific context update code

  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current () {
    return this.at(this.pos)
  };

  RegExpValidationState.prototype.lookahead = function lookahead () {
    return this.at(this.nextIndex(this.pos))
  };

  RegExpValidationState.prototype.advance = function advance () {
    this.pos = this.nextIndex(this.pos);
  };

  RegExpValidationState.prototype.eat = function eat (ch) {
    if (this.current() === ch) {
      this.advance();
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A /* * */) ||
      state.eat(0x2B /* + */) ||
      state.eat(0x3F /* ? */) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24 /* $ */ ||
      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
      ch === 0x2E /* . */ ||
      ch === 0x3F /* ? */ ||
      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24 /* $ */ &&
      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
      ch !== 0x2E /* . */ &&
      ch !== 0x3F /* ? */ &&
      ch !== 0x5B /* [ */ &&
      ch !== 0x5E /* ^ */ &&
      ch !== 0x7C /* | */
    ) {
      state.advance();
      return true
    }
    return false
  };

  // GroupSpecifier[U] ::
  //   [empty]
  //   `?` GroupName[?U]
  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  // GroupName[U] ::
  //   `<` RegExpIdentifierName[?U] `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  // RegExpIdentifierName[U] ::
  //   RegExpIdentifierStart[?U]
  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  // RegExpIdentifierStart[U] ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
  }

  // RegExpIdentifierPart[U] ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
    var start = state.pos;

    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        state.switchU &&
        state.eat(0x7B /* { */) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D /* } */) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50 /* P */ || ch === 0x70 /* p */)
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B /* { */) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D /* } */)
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64 /* d */ ||
      ch === 0x44 /* D */ ||
      ch === 0x73 /* s */ ||
      ch === 0x53 /* S */ ||
      ch === 0x77 /* w */ ||
      ch === 0x57 /* W */
    )
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* [ */)) {
        return true
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D /* [ */) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }

    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true
    }

    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */)
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */)
    }
    return ch - 0x30 /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };

  // ## Tokenizer

  var pp$9 = Parser.prototype;

  // Move to the next token

  pp$9.next = function() {
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: // ' '
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: // '*'
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46: // '.'
      return this.readToken_dot()

    // Punctuation tokens.
    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)
    case 63: ++this.pos; return this.finishToken(types.question)

    case 96: // '`'
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return this.readNumber(false)

    // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return this.readToken_slash()

    case 37: case 42: // '%*'
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: // '|&'
      return this.readToken_pipe_amp(code)

    case 94: // '^'
      return this.readToken_caret()

    case 43: case 45: // '+-'
      return this.readToken_plus_min(code)

    case 60: case 62: // '<>'
      return this.readToken_lt_gt(code)

    case 61: case 33: // '=!'
      return this.readToken_eq_excl(code)

    case 126: // '~'
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp$9.readInt = function(radix, len) {
    var start = this.pos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);
      if (code >= 97) { val = code - 97 + 10; } // a
      else if (code >= 65) { val = code - 65 + 10; } // A
      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
      else { val = Infinity; }
      if (val >= radix) { break }
      ++this.pos;
      total = total * radix + val;
    }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };

  // Read an integer, octal integer, or floating-point number.

  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var str$1 = this.input.slice(start, this.pos);
      var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (next === 46 && !octal) { // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } // '+-'
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var str = this.input.slice(start, this.pos);
    var val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val)
  };

  // Read a string value, interpreting backslash-escapes.

  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { // '{'
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }
      // falls through

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" // 'n' -> '\n'
    case 114: return "\r" // 'r' -> '\r'
    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
    case 117: return codePointToString$1(this.readCodePoint()) // 'u'
    case 116: return "\t" // 't' -> '\t'
    case 98: return "\b" // 'b' -> '\b'
    case 118: return "\u000b" // 'v' -> '\u000b'
    case 102: return "\f" // 'f' -> '\f'
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
    case 10: // ' \n'
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return ""
      }
      return String.fromCharCode(ch)
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "6.4.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options)
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });
}));
// hack-istanbul - inline-require
}());


/*
repo https://github.com/estools/estraverse/tree/4.2.0
committed 2016-03-10T21:51:59Z
*/


/*
file https://github.com/estools/estraverse/blob/4.2.0/estraverse.js
*/
// hack-istanbul - inline-require
/* istanbul ignore next */
(function () { let exports; exports = estraverse;
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = objectKeys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    // hack-istanbul - inline-require
    exports.version = {};
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */
// hack-istanbul - inline-require
}());


/*
repo https://github.com/estools/esutils/tree/2.0.3
committed 2019-07-31T01:06:44Z
*/


/*
file https://github.com/estools/esutils/blob/2.0.3/lib/code.js
*/
// hack-istanbul - inline-require
/* istanbul ignore next */
(function () { let module; module = {};
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
// hack-istanbul - inline-require
esutils = { code: module.exports }; }());


/*
repo https://github.com/estools/escodegen/tree/v1.12.0
committed 2019-08-13T02:08:40Z
*/


/*
file https://github.com/estools/escodegen/blob/v1.12.0/escodegen.js
*/
// hack-istanbul - inline-require
/* istanbul ignore next */
(function () { let exports; exports = escodegen;
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        // hack-istanbul - inline-require
        // estraverse,
        // esutils,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    // hack-istanbul - inline-require
    // estraverse = require('estraverse');
    // esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Await: 13,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (Array.isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value, prefix = '';
        if (func.async) {
            prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
            // avoid space before method name
            prefix += generateStarSuffix(func) ? '*' : '';
        }
        return prefix;
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + space + (stmt.await ? 'await' + space : '') + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));

        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class'];
            if (stmt.id) {
                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    ')'
                ];

                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDefaultDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            result = join(result, 'default');
            if (isStatement(stmt.declaration)) {
                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }
            return result;
        },

        ExportNamedDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExportAllDeclaration: function (stmt, flags) {
            // export * FromClause ;
            return [
                'export' + space,
                '*' + space,
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ];
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (Array.isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                stmt.id ? generateIdentifier(stmt.id) : '',
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }
    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, currentPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push(' ');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        MetaProperty: function (expr, precedence, flags) {
            var result;
            result = [];
            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
            result.push('.');
            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.all ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
        },

        ArrayExpression: function (expr, precedence, flags, isPattern) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = isPattern ? false : expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        RestElement: function(expr, precedence, flags) {
            return '...' + this.generatePattern(expr.argument);
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                if (expr.value.type === "AssignmentPattern") {
                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
                }
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        AssignmentPattern: function(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Super: function (expr, precedence, flags) {
            return 'super';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            var id = expr.id || expr.local;
            if (id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            var imported = expr.imported;
            var result = [ imported.name ];
            var local = expr.local;
            if (local && local.name !== imported.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
            }
            return result;
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var local = expr.local;
            var result = [ local.name ];
            var exported = expr.exported;
            if (exported && exported.name !== local.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            if (expr.regex) {
              return '/' + expr.regex.pattern + '/' + expr.regex.flags;
            }
            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        },

        ImportExpression: function(expr, precedence, flag) {
            return parenthesize([
                'import(',
                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
                ')'
            ], Precedence.Call, precedence);
        },
    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                // hack-istanbul - inline-require
                SourceNode = {};
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    // hack-istanbul - inline-require
    exports.version = {};
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */
// hack-istanbul - inline-require
}());


/*
repo https://github.com/gotwarlost/istanbul/tree/v0.4.5
committed 2016-08-21T19:53:22Z
*/


/*
file https://github.com/gotwarlost/istanbul/blob/v0.4.5/lib/instrumenter.js
*/
// hack-istanbul - inline-require
/* istanbul ignore next */
(function () { let module, window; module = undefined; window = local;
/*
 Copyright (c) 2012, Yahoo! Inc.  All rights reserved.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

/*global esprima, escodegen, window */
(function (isNode) {
    "use strict";
    var SYNTAX,
        nodeType,
        ESP = isNode ? require('esprima') : esprima,
        ESPGEN = isNode ? require('escodegen') : escodegen,  //TODO - package as dependency
        crypto = isNode ? require('crypto') : null,
        LEADER_WRAP = '(function () { ',
        TRAILER_WRAP = '\n}());',
        COMMENT_RE = /^\s*istanbul\s+ignore\s+(if|else|next)(?=\W|$)/,
        astgen,
        preconditions,
        cond,
        isArray = Array.isArray;

    /* istanbul ignore if: untestable */
    if (!isArray) {
        isArray = function (thing) { return thing &&  Object.prototype.toString.call(thing) === '[object Array]'; };
    }

    if (!isNode) {
        preconditions = {
            'Could not find esprima': ESP,
            'Could not find escodegen': ESPGEN,
            'JSON object not in scope': JSON,
            'Array does not implement push': [].push,
            'Array does not implement unshift': [].unshift
        };
        /* istanbul ignore next: untestable */
        for (cond in preconditions) {
            if (preconditions.hasOwnProperty(cond)) {
                if (!preconditions[cond]) { throw new Error(cond); }
            }
        }
    }

    function generateTrackerVar(filename, omitSuffix) {
        var hash, suffix;
        if (crypto !== null) {
            hash = crypto.createHash('md5');
            hash.update(filename);
            suffix = hash.digest('base64');
            //trim trailing equal signs, turn identifier unsafe chars to safe ones + => _ and / => $
            suffix = suffix.replace(new RegExp('=', 'g'), '')
                .replace(new RegExp('\\+', 'g'), '_')
                .replace(new RegExp('/', 'g'), '$');
        } else {
            window.__cov_seq = window.__cov_seq || 0;
            window.__cov_seq += 1;
            suffix = window.__cov_seq;
        }
        // hack-istanbul - random coverage-identifier
        return '__cov_' + Math.random().toString(16).slice(2);
    }

    function pushAll(ary, thing) {
        if (!isArray(thing)) {
            thing = [ thing ];
        }
        Array.prototype.push.apply(ary, thing);
    }

    SYNTAX = {
        // keep in sync with estraverse's VisitorKeys
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MetaProperty: ['meta', 'property'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    for (nodeType in SYNTAX) {
        /* istanbul ignore else: has own property */
        if (SYNTAX.hasOwnProperty(nodeType)) {
            SYNTAX[nodeType] = { name: nodeType, children: SYNTAX[nodeType] };
        }
    }

    astgen = {
        variable: function (name) { return { type: SYNTAX.Identifier.name, name: name }; },
        stringLiteral: function (str) { return { type: SYNTAX.Literal.name, value: String(str) }; },
        numericLiteral: function (num) { return { type: SYNTAX.Literal.name, value: Number(num) }; },
        statement: function (contents) { return { type: SYNTAX.ExpressionStatement.name, expression: contents }; },
        dot: function (obj, field) { return { type: SYNTAX.MemberExpression.name, computed: false, object: obj, property: field }; },
        subscript: function (obj, sub) { return { type: SYNTAX.MemberExpression.name, computed: true, object: obj, property: sub }; },
        postIncrement: function (obj) { return { type: SYNTAX.UpdateExpression.name, operator: '++', prefix: false, argument: obj }; },
        sequence: function (one, two) { return { type: SYNTAX.SequenceExpression.name, expressions: [one, two] }; },
        returnStatement: function (expr) { return { type: SYNTAX.ReturnStatement.name, argument: expr }; }
    };

    function Walker(walkMap, preprocessor, scope, debug) {
        this.walkMap = walkMap;
        this.preprocessor = preprocessor;
        this.scope = scope;
        this.debug = debug;
        if (this.debug) {
            this.level = 0;
            this.seq = true;
        }
    }

    function defaultWalker(node, walker) {

        var type = node.type,
            preprocessor,
            postprocessor,
            children = SYNTAX[type],
            // don't run generated nodes thru custom walks otherwise we will attempt to instrument the instrumentation code :)
            applyCustomWalker = !!node.loc || node.type === SYNTAX.Program.name,
            walkerFn = applyCustomWalker ? walker.walkMap[type] : null,
            i,
            j,
            walkFnIndex,
            childType,
            childNode,
            ret,
            childArray,
            childElement,
            pathElement,
            assignNode,
            isLast;

        if (!SYNTAX[type]) {
            console.error(node);
            console.error('Unsupported node type:' + type);
            return;
        }
        children = SYNTAX[type].children;
        /* istanbul ignore if: guard */
        if (node.walking) { throw new Error('Infinite regress: Custom walkers may NOT call walker.apply(node)'); }
        node.walking = true;

        ret = walker.apply(node, walker.preprocessor);

        preprocessor = ret.preprocessor;
        if (preprocessor) {
            delete ret.preprocessor;
            ret = walker.apply(node, preprocessor);
        }

        if (isArray(walkerFn)) {
            for (walkFnIndex = 0; walkFnIndex < walkerFn.length; walkFnIndex += 1) {
                isLast = walkFnIndex === walkerFn.length - 1;
                ret = walker.apply(ret, walkerFn[walkFnIndex]);
                /*istanbul ignore next: paranoid check */
                if (ret.type !== type && !isLast) {
                    throw new Error('Only the last walker is allowed to change the node type: [type was: ' + type + ' ]');
                }
            }
        } else {
            if (walkerFn) {
                ret = walker.apply(node, walkerFn);
            }
        }

        if (node.skipSelf) {
            return;
        }

        for (i = 0; i < children.length; i += 1) {
            childType = children[i];
            childNode = node[childType];
            if (childNode && !childNode.skipWalk) {
                pathElement = { node: node, property: childType };
                if (isArray(childNode)) {
                    childArray = [];
                    for (j = 0; j < childNode.length; j += 1) {
                        childElement = childNode[j];
                        pathElement.index = j;
                        if (childElement) {
                          assignNode = walker.apply(childElement, null, pathElement);
                          if (isArray(assignNode.prepend)) {
                              pushAll(childArray, assignNode.prepend);
                              delete assignNode.prepend;
                          }
                        } else {
                            assignNode = undefined;
                        }
                        pushAll(childArray, assignNode);
                    }
                    node[childType] = childArray;
                } else {
                    assignNode = walker.apply(childNode, null, pathElement);
                    /*istanbul ignore if: paranoid check */
                    if (isArray(assignNode.prepend)) {
                        throw new Error('Internal error: attempt to prepend statements in disallowed (non-array) context');
                        /* if this should be allowed, this is how to solve it
                        tmpNode = { type: 'BlockStatement', body: [] };
                        pushAll(tmpNode.body, assignNode.prepend);
                        pushAll(tmpNode.body, assignNode);
                        node[childType] = tmpNode;
                        delete assignNode.prepend;
                        */
                    } else {
                        node[childType] = assignNode;
                    }
                }
            }
        }

        postprocessor = ret.postprocessor;
        if (postprocessor) {
            delete ret.postprocessor;
            ret = walker.apply(ret, postprocessor);
        }

        delete node.walking;

        return ret;
    }

    Walker.prototype = {
        startWalk: function (node) {
            this.path = [];
            this.apply(node);
        },

        apply: function (node, walkFn, pathElement) {
            var ret, i, seq, prefix;

            walkFn = walkFn || defaultWalker;
            if (this.debug) {
                this.seq += 1;
                this.level += 1;
                seq = this.seq;
                prefix = '';
                for (i = 0; i < this.level; i += 1) { prefix += '    '; }
                console.log(prefix + 'Enter (' + seq + '):' + node.type);
            }
            if (pathElement) { this.path.push(pathElement); }
            ret = walkFn.call(this.scope, node, this);
            if (pathElement) { this.path.pop(); }
            if (this.debug) {
                this.level -= 1;
                console.log(prefix + 'Return (' + seq + '):' + node.type);
            }
            return ret || node;
        },

        startLineForNode: function (node) {
            return node && node.loc && node.loc.start ? node.loc.start.line : /* istanbul ignore next: guard */ null;
        },

        ancestor: function (n) {
            return this.path.length > n - 1 ? this.path[this.path.length - n] : /* istanbul ignore next: guard */ null;
        },

        parent: function () {
            return this.ancestor(1);
        },

        isLabeled: function () {
            var el = this.parent();
            return el && el.node.type === SYNTAX.LabeledStatement.name;
        }
    };

    /**
     * mechanism to instrument code for coverage. It uses the `esprima` and
     * `escodegen` libraries for JS parsing and code generation respectively.
     *
     * Works on `node` as well as the browser.
     *
     * Usage on nodejs
     * ---------------
     *
     *      var instrumenter = new require('istanbul').Instrumenter(),
     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');
     *
     * Usage in a browser
     * ------------------
     *
     * Load `esprima.js`, `escodegen.js` and `instrumenter.js` (this file) using `script` tags or other means.
     *
     * Create an instrumenter object as:
     *
     *      var instrumenter = new Instrumenter(),
     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');
     *
     * Aside from demonstration purposes, it is unclear why you would want to instrument code in a browser.
     *
     * @class Instrumenter
     * @constructor
     * @param {Object} options Optional. Configuration options.
     * @param {String} [options.coverageVariable] the global variable name to use for
     *      tracking coverage. Defaults to `__coverage__`
     * @param {Boolean} [options.embedSource] whether to embed the source code of every
     *      file as an array in the file coverage object for that file. Defaults to `false`
     * @param {Boolean} [options.preserveComments] whether comments should be preserved in the output. Defaults to `false`
     * @param {Boolean} [options.noCompact] emit readable code when set. Defaults to `false`
     * @param {Boolean} [options.esModules] whether the code to instrument contains uses es
     *      imports or exports.
     * @param {Boolean} [options.noAutoWrap] do not automatically wrap the source in
     *      an anonymous function before covering it. By default, code is wrapped in
     *      an anonymous function before it is parsed. This is done because
     *      some nodejs libraries have `return` statements outside of
     *      a function which is technically invalid Javascript and causes the parser to fail.
     *      This construct, however, works correctly in node since module loading
     *      is done in the context of an anonymous function.
     *
     * Note that the semantics of the code *returned* by the instrumenter does not change in any way.
     * The function wrapper is "unwrapped" before the instrumented code is generated.
     * @param {Object} [options.codeGenerationOptions] an object that is directly passed to the `escodegen`
     *      library as configuration for code generation. The `noCompact` setting is not honored when this
     *      option is specified
     * @param {Boolean} [options.debug] assist in debugging. Currently, the only effect of
     *      setting this option is a pretty-print of the coverage variable. Defaults to `false`
     * @param {Boolean} [options.walkDebug] assist in debugging of the AST walker used by this class.
     *
     */
    function Instrumenter(options) {
        this.opts = options || {
            debug: false,
            walkDebug: false,
            coverageVariable: '__coverage__',
            codeGenerationOptions: undefined,
            noAutoWrap: false,
            noCompact: false,
            embedSource: false,
            preserveComments: false,
            esModules: false
        };

        if (this.opts.esModules && !this.opts.noAutoWrap) {
            this.opts.noAutoWrap = true;
            if (this.opts.debug) {
                console.log('Setting noAutoWrap to true as required by esModules');
            }
        }

        this.walker = new Walker({
            ArrowFunctionExpression: [ this.arrowBlockConverter ],
            ExpressionStatement: this.coverStatement,
            ExportNamedDeclaration: this.coverExport,
            BreakStatement: this.coverStatement,
            ContinueStatement: this.coverStatement,
            DebuggerStatement: this.coverStatement,
            ReturnStatement: this.coverStatement,
            ThrowStatement: this.coverStatement,
            TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
            VariableDeclaration: this.coverStatement,
            IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
            ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
            ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
            ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
            WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
            SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
            SwitchCase: [ this.switchCaseInjector ],
            WithStatement: [ this.withBlockConverter, this.coverStatement ],
            FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
            FunctionExpression: this.coverFunction,
            LabeledStatement: this.coverStatement,
            ConditionalExpression: this.conditionalBranchInjector,
            LogicalExpression: this.logicalExpressionBranchInjector,
            ObjectExpression: this.maybeAddType,
            MetaProperty: this.coverMetaProperty,
        }, this.extractCurrentHint, this, this.opts.walkDebug);

        //unit testing purposes only
        if (this.opts.backdoor && this.opts.backdoor.omitTrackerSuffix) {
            this.omitTrackerSuffix = true;
        }
    }

    Instrumenter.prototype = {
        /**
         * synchronous instrumentation method. Throws when illegal code is passed to it
         * @method instrumentSync
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         */
        instrumentSync: function (code, filename) {
            var program;

            //protect from users accidentally passing in a Buffer object instead
            if (typeof code !== 'string') { throw new Error('Code must be string'); }
            if (code.charAt(0) === '#') { //shebang, 'comment' it out, won't affect syntax tree locations for things we care about
                code = '//' + code;
            }
            if (!this.opts.noAutoWrap) {
                code = LEADER_WRAP + code + TRAILER_WRAP;
            }
            try {
                // hack-istanbul - inline acorn-opt
                let opt = {
                    locations: true,
                    onComment: [],
                    onToken: this.opts.preserveComments,
                    ranges: true,
                    sourceType: this.opts.esModules ? 'module' : 'script'
                };
                program = ESP.parse(code, opt);
                program.comments = opt.onComment
            } catch (e) {
                console.log('Failed to parse file: ' + filename);
                throw e;
            }
            if (this.opts.preserveComments) {
                program = ESPGEN.attachComments(program, program.comments, program.tokens);
            }
            if (!this.opts.noAutoWrap) {
                program = {
                    type: SYNTAX.Program.name,
                    body: program.body[0].expression.callee.body.body,
                    comments: program.comments
                };
            }
            return this.instrumentASTSync(program, filename, code);
        },
        filterHints: function (comments) {
            var ret = [],
                i,
                comment,
                groups;
            if (!(comments && isArray(comments))) {
                return ret;
            }
            for (i = 0; i < comments.length; i += 1) {
                comment = comments[i];
                /* istanbul ignore else: paranoid check */
                if (comment && comment.value && comment.range && isArray(comment.range)) {
                    groups = String(comment.value).match(COMMENT_RE);
                    if (groups) {
                        ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });
                    }
                }
            }
            return ret;
        },
        extractCurrentHint: function (node) {
            if (!node.range) { return; }
            var i = this.currentState.lastHintPosition + 1,
                hints = this.currentState.hints,
                nodeStart = node.range[0],
                hint;
            this.currentState.currentHint = null;
            // hack-istanbul - allow top-level istanbul-ignore-next
            if (node.type === "Program") { return; }
            while (i < hints.length) {
                hint = hints[i];
                if (hint.end < nodeStart) {
                    this.currentState.currentHint = hint;
                    this.currentState.lastHintPosition = i;
                    i += 1;
                } else {
                    break;
                }
            }
        },
        /**
         * synchronous instrumentation method that instruments an AST instead.
         * @method instrumentASTSync
         * @param {String} program the AST to be instrumented
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         *  @param {String} originalCode the original code corresponding to the AST,
         *  used for embedding the source into the coverage object
         */
        instrumentASTSync: function (program, filename, originalCode) {
            var usingStrict = false,
                codegenOptions,
                generated,
                preamble,
                lineCount,
                i;
            filename = filename || String(new Date().getTime()) + '.js';
            this.sourceMap = null;
            this.coverState = {
                path: filename,
                s: {},
                b: {},
                f: {},
                fnMap: {},
                statementMap: {},
                branchMap: {}
            };
            this.currentState = {
                trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
                func: 0,
                branch: 0,
                variable: 0,
                statement: 0,
                hints: this.filterHints(program.comments),
                currentHint: null,
                lastHintPosition: -1,
                ignoring: 0
            };
            if (program.body && program.body.length > 0 && this.isUseStrictExpression(program.body[0])) {
                //nuke it
                program.body.shift();
                //and add it back at code generation time
                usingStrict = true;
            }
            this.walker.startWalk(program);
            codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
            codegenOptions.comment = this.opts.preserveComments;
            //console.log(JSON.stringify(program, undefined, 2));

            generated = ESPGEN.generate(program, codegenOptions);
            preamble = this.getPreamble(originalCode || '', usingStrict);

            if (generated.map && generated.code) {
                lineCount = preamble.split(/\r\n|\r|\n/).length;
                // offset all the generated line numbers by the number of lines in the preamble
                for (i = 0; i < generated.map._mappings._array.length; i += 1) {
                    generated.map._mappings._array[i].generatedLine += lineCount;
                }
                this.sourceMap = generated.map;
                generated = generated.code;
            }

            return preamble + '\n' + generated + '\n';
        },
        /**
         * Callback based instrumentation. Note that this still executes synchronously in the same process tick
         * and calls back immediately. It only provides the options for callback style error handling as
         * opposed to a `try-catch` style and nothing more. Implemented as a wrapper over `instrumentSync`
         *
         * @method instrument
         * @param {String} code the code to be instrumented as a String
         * @param {String} filename Optional. The name of the file from which
         *  the code was read. A temporary filename is generated when not specified.
         *  Not specifying a filename is only useful for unit tests and demonstrations
         *  of this library.
         * @param {Function(err, instrumentedCode)} callback - the callback function
         */
        instrument: function (code, filename, callback) {

            if (!callback && typeof filename === 'function') {
                callback = filename;
                filename = null;
            }
            try {
                callback(null, this.instrumentSync(code, filename));
            } catch (ex) {
                callback(ex);
            }
        },
        /**
         * returns the file coverage object for the code that was instrumented
         * just before calling this method. Note that this represents a
         * "zero-coverage" object which is not even representative of the code
         * being loaded in node or a browser (which would increase the statement
         * counts for mainline code).
         * @method lastFileCoverage
         * @return {Object} a "zero-coverage" file coverage object for the code last instrumented
         * by this instrumenter
         */
        lastFileCoverage: function () {
            return this.coverState;
        },
        /**
         * returns the source map object for the code that was instrumented
         * just before calling this method.
         * @method lastSourceMap
         * @return {Object} a source map object for the code last instrumented
         * by this instrumenter
         */
        lastSourceMap: function () {
            return this.sourceMap;
        },
        fixColumnPositions: function (coverState) {
            var offset = LEADER_WRAP.length,
                fixer = function (loc) {
                    if (loc.start.line === 1) {
                        loc.start.column -= offset;
                    }
                    if (loc.end.line === 1) {
                        loc.end.column -= offset;
                    }
                },
                k,
                obj,
                i,
                locations;

            obj = coverState.statementMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
            }
            obj = coverState.fnMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
            }
            obj = coverState.branchMap;
            for (k in obj) {
                /* istanbul ignore else: has own property */
                if (obj.hasOwnProperty(k)) {
                    locations = obj[k].locations;
                    for (i = 0; i < locations.length; i += 1) {
                        fixer(locations[i]);
                    }
                }
            }
        },

        getPreamble: function (sourceCode, emitUseStrict) {
            var varName = this.opts.coverageVariable || '__coverage__',
                file = this.coverState.path.replace(/\\/g, '\\\\'),
                tracker = this.currentState.trackerVar,
                coverState,
                strictLine = emitUseStrict ? '"use strict";' : '',
                // return replacements using the function to ensure that the replacement is
                // treated like a dumb string and not as a string with RE replacement patterns
                replacer = function (s) {
                    return function () { return s; };
                },
                code;
            if (!this.opts.noAutoWrap) {
                this.fixColumnPositions(this.coverState);
            }
            if (this.opts.embedSource) {
                this.coverState.code = sourceCode.split(/(?:\r?\n)|\r/);
            }
            coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
            code = [
                "%STRICT%",
                "var %VAR% = (Function('return this'))();",
                "if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }",
                "%VAR% = %VAR%.%GLOBAL%;",
                "if (!(%VAR%['%FILE%'])) {",
                "   %VAR%['%FILE%'] = %OBJECT%;",
                "}",
                "%VAR% = %VAR%['%FILE%'];"
            ].join("\n")
                .replace(/%STRICT%/g, replacer(strictLine))
                .replace(/%VAR%/g, replacer(tracker))
                .replace(/%GLOBAL%/g, replacer(varName))
                .replace(/%FILE%/g, replacer(file))
                .replace(/%OBJECT%/g, replacer(coverState));
            return code;
        },

        startIgnore: function () {
            this.currentState.ignoring += 1;
        },

        endIgnore: function () {
            this.currentState.ignoring -= 1;
        },

        convertToBlock: function (node) {
            if (!node) {
                return { type: 'BlockStatement', body: [] };
            } else if (node.type === 'BlockStatement') {
                return node;
            } else {
                return { type: 'BlockStatement', body: [ node ] };
            }
        },

        arrowBlockConverter: function (node) {
            var retStatement;
            if (node.expression) { // turn expression nodes into a block with a return statement
                retStatement = astgen.returnStatement(node.body);
                // ensure the generated return statement is covered
                retStatement.loc = node.body.loc;
                node.body = this.convertToBlock(retStatement);
                node.expression = false;
            }
        },

        paranoidHandlerCheck: function (node) {
            // if someone is using an older esprima on the browser
            // convert handlers array to single handler attribute
            // containing its first element
            /* istanbul ignore next */
            if (!node.handler && node.handlers) {
                node.handler = node.handlers[0];
            }
        },

        ifBlockConverter: function (node) {
            node.consequent = this.convertToBlock(node.consequent);
            node.alternate = this.convertToBlock(node.alternate);
        },

        loopBlockConverter: function (node) {
            node.body = this.convertToBlock(node.body);
        },

        withBlockConverter: function (node) {
            node.body = this.convertToBlock(node.body);
        },

        statementName: function (location, initValue) {
            var sName,
                ignoring = !!this.currentState.ignoring;

            location.skip = ignoring || undefined;
            initValue = initValue || 0;
            this.currentState.statement += 1;
            sName = this.currentState.statement;
            this.coverState.statementMap[sName] = location;
            this.coverState.s[sName] = initValue;
            return sName;
        },

        skipInit: function (node /*, walker */) {
            if (node.init) {
                node.init.skipWalk = true;
            }
        },

        skipLeft: function (node /*, walker */) {
            node.left.skipWalk = true;
        },

        isUseStrictExpression: function (node) {
            return node && node.type === SYNTAX.ExpressionStatement.name &&
                node.expression  && node.expression.type === SYNTAX.Literal.name &&
                node.expression.value === 'use strict';
        },

        maybeSkipNode: function (node, type) {
            var alreadyIgnoring = !!this.currentState.ignoring,
                hint = this.currentState.currentHint,
                ignoreThis = !alreadyIgnoring && hint && hint.type === type;

            if (ignoreThis) {
                this.startIgnore();
                node.postprocessor = this.endIgnore;
                return true;
            }
            return false;
        },

        coverMetaProperty: function(node /* , walker */) {
           node.skipSelf = true;
        },

        coverStatement: function (node, walker) {
            var sName,
                incrStatementCount,
                parent,
                grandParent;

            this.maybeSkipNode(node, 'next');

            if (this.isUseStrictExpression(node)) {
                grandParent = walker.ancestor(2);
                /* istanbul ignore else: difficult to test */
                if (grandParent) {
                    if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||
                        grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &&
                        walker.parent().node.body[0] === node) {
                        return;
                    }
                }
            }

            if (node.type === SYNTAX.FunctionDeclaration.name) {
                // Called for the side-effect of setting the function's statement count to 1.
                this.statementName(node.loc, 1);
            } else {
                // We let `coverExport` handle ExportNamedDeclarations.
                parent = walker.parent();
                if (parent && parent.node.type === SYNTAX.ExportNamedDeclaration.name) {
                    return;
                }

                sName = this.statementName(node.loc);

                incrStatementCount = astgen.statement(
                    astgen.postIncrement(
                        astgen.subscript(
                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),
                            astgen.stringLiteral(sName)
                        )
                    )
                );

                this.splice(incrStatementCount, node, walker);
            }
        },

        coverExport: function (node, walker) {
            var sName, incrStatementCount;

            if ( !node.declaration || !node.declaration.declarations ) { return; }

            this.maybeSkipNode(node, 'next');

            sName = this.statementName(node.declaration.loc);
            incrStatementCount = astgen.statement(
                astgen.postIncrement(
                    astgen.subscript(
                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),
                        astgen.stringLiteral(sName)
                    )
                )
            );

            this.splice(incrStatementCount, node, walker);
        },

        splice: function (statements, node, walker) {
            var targetNode = walker.isLabeled() ? walker.parent().node : node;
            targetNode.prepend = targetNode.prepend || [];
            pushAll(targetNode.prepend, statements);
        },

        functionName: function (node, line, location) {
            this.currentState.func += 1;
            var id = this.currentState.func,
                ignoring = !!this.currentState.ignoring,
                name = node.id ? node.id.name : '(anonymous_' + id + ')',
                clone = function (attr) {
                    var obj = location[attr] || /* istanbul ignore next */ {};
                    return { line: obj.line, column: obj.column };
                };
            this.coverState.fnMap[id] = {
                name: name, line: line,
                loc: {
                    start: clone('start'),
                    end: clone('end')
                },
                skip: ignoring || undefined
            };
            this.coverState.f[id] = 0;
            return id;
        },

        coverFunction: function (node, walker) {
            var id,
                body = node.body,
                blockBody = body.body,
                popped;

            this.maybeSkipNode(node, 'next');

            id = this.functionName(node, walker.startLineForNode(node), {
                start: node.loc.start,
                end: { line: node.body.loc.start.line, column: node.body.loc.start.column }
            });

            if (blockBody.length > 0 && this.isUseStrictExpression(blockBody[0])) {
                popped = blockBody.shift();
            }
            blockBody.unshift(
                astgen.statement(
                    astgen.postIncrement(
                        astgen.subscript(
                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('f')),
                            astgen.stringLiteral(id)
                        )
                    )
                )
            );
            if (popped) {
                blockBody.unshift(popped);
            }
        },

        branchName: function (type, startLine, pathLocations) {
            var bName,
                paths = [],
                locations = [],
                i,
                ignoring = !!this.currentState.ignoring;
            this.currentState.branch += 1;
            bName = this.currentState.branch;
            for (i = 0; i < pathLocations.length; i += 1) {
                pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;
                locations.push(pathLocations[i]);
                paths.push(0);
            }
            this.coverState.b[bName] = paths;
            this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
            return bName;
        },

        branchIncrementExprAst: function (varName, branchIndex, down) {
            var ret = astgen.postIncrement(
                astgen.subscript(
                    astgen.subscript(
                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('b')),
                        astgen.stringLiteral(varName)
                    ),
                    astgen.numericLiteral(branchIndex)
                ),
                down
            );
            return ret;
        },

        locationsForNodes: function (nodes) {
            var ret = [],
                i;
            for (i = 0; i < nodes.length; i += 1) {
                ret.push(nodes[i].loc);
            }
            return ret;
        },

        ifBranchInjector: function (node, walker) {
            var alreadyIgnoring = !!this.currentState.ignoring,
                hint = this.currentState.currentHint,
                ignoreThen = !alreadyIgnoring && hint && hint.type === 'if',
                ignoreElse = !alreadyIgnoring && hint && hint.type === 'else',
                line = node.loc.start.line,
                col = node.loc.start.column,
                makeLoc = function () { return  { line: line, column: col }; },
                bName = this.branchName('if', walker.startLineForNode(node), [
                    { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },
                    { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }
                ]),
                thenBody = node.consequent.body,
                elseBody = node.alternate.body,
                child;
            thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
            elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
            if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
            if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
        },

        branchLocationFor: function (name, index) {
            return this.coverState.branchMap[name].locations[index];
        },

        switchBranchInjector: function (node, walker) {
            var cases = node.cases,
                bName,
                i;

            if (!(cases && cases.length > 0)) {
                return;
            }
            bName = this.branchName('switch', walker.startLineForNode(node), this.locationsForNodes(cases));
            for (i = 0; i < cases.length; i += 1) {
                cases[i].branchLocation = this.branchLocationFor(bName, i);
                cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
            }
        },

        switchCaseInjector: function (node) {
            var location = node.branchLocation;
            delete node.branchLocation;
            if (this.maybeSkipNode(node, 'next')) {
                location.skip = true;
            }
        },

        conditionalBranchInjector: function (node, walker) {
            var bName = this.branchName('cond-expr', walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate ])),
                ast1 = this.branchIncrementExprAst(bName, 0),
                ast2 = this.branchIncrementExprAst(bName, 1);

            node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));
            node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));
            node.consequent = astgen.sequence(ast1, node.consequent);
            node.alternate = astgen.sequence(ast2, node.alternate);
        },

        maybeAddSkip: function (branchLocation) {
            return function (node) {
                var alreadyIgnoring = !!this.currentState.ignoring,
                    hint = this.currentState.currentHint,
                    ignoreThis = !alreadyIgnoring && hint && hint.type === 'next';
                if (ignoreThis) {
                    this.startIgnore();
                    node.postprocessor = this.endIgnore;
                }
                if (ignoreThis || alreadyIgnoring) {
                    branchLocation.skip = true;
                }
            };
        },

        logicalExpressionBranchInjector: function (node, walker) {
            var parent = walker.parent(),
                leaves = [],
                bName,
                tuple,
                i;

            this.maybeSkipNode(node, 'next');

            if (parent && parent.node.type === SYNTAX.LogicalExpression.name) {
                //already covered
                return;
            }

            this.findLeaves(node, leaves);
            bName = this.branchName('binary-expr',
                walker.startLineForNode(node),
                this.locationsForNodes(leaves.map(function (item) { return item.node; }))
            );
            for (i = 0; i < leaves.length; i += 1) {
                tuple = leaves[i];
                tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
                tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));
            }
        },

        findLeaves: function (node, accumulator, parent, property) {
            if (node.type === SYNTAX.LogicalExpression.name) {
                this.findLeaves(node.left, accumulator, node, 'left');
                this.findLeaves(node.right, accumulator, node, 'right');
            } else {
                accumulator.push({ node: node, parent: parent, property: property });
            }
        },
        maybeAddType: function (node /*, walker */) {
            var props = node.properties,
                i,
                child;
            for (i = 0; i < props.length; i += 1) {
                child = props[i];
                if (!child.type) {
                    child.type = SYNTAX.Property.name;
                }
            }
        },
    };

    if (isNode) {
        module.exports = Instrumenter;
    } else {
        window.Instrumenter = Instrumenter;
    }
}(typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof exports !== 'undefined'));
// hack-istanbul - inline-require
}());


/*
file https://github.com/gotwarlost/istanbul/blob/v0.2.16/lib/report/templates/head.txt
*/
local.templateCoverageReport = '\
{{#if isBrowser}}\n\
<div>\n\
{{#unless isBrowser}}\n\
<!doctype html>\n\
<html lang="en" class="x-istanbul">\n\
{{/if isBrowser}}\n\
<head>\n\
    <title>Code coverage report for {{nameOrAllFiles}}</title>\n\
    <meta charset="utf-8">\n\
<style>\n\
/* jslint utility2:true */\n\
/*csslint\n\
    box-model: false,\n\
    important: false,\n\
*/\n\
/* csslint ignore:start */\n\
*,\n\
*:after,\n\
*:before {\n\
    box-sizing: border-box;\n\
}\n\
/* csslint ignore:end */\n\
.x-istanbul {\n\
    font-family: Helvetica Neue, Helvetica, Arial;\n\
    font-size: 10pt;\n\
    margin: 0;\n\
    padding: 0;\n\
}\n\
.x-istanbul pre {\n\
    font-family: Consolas, Menlo, Monaco, monospace;\n\
    font-size: 14px;\n\
    margin: 0;\n\
    padding: 0;\n\
    tab-size: 2;\n\
}\n\
.x-istanbul .cbranch-no {\n\
    background: yellow !important;\n\
    color: #111;\n\
}\n\
.x-istanbul .cbranch-skip {\n\
    background: #ddd !important;\n\
    color: #111;\n\
}\n\
.x-istanbul .com {\n\
    color: #999 !important;\n\
}\n\
.x-istanbul .cover-empty,\n\
.x-istanbul .cover-fill {\n\
    background: white;\n\
    border: 1px solid #999;\n\
    display: inline-block;\n\
    height: 12px;\n\
}\n\
.x-istanbul .cover-empty {\n\
    background: white;\n\
    border-left: none;\n\
}\n\
.x-istanbul .cover-fill {\n\
    background: #ccc;\n\
    border-right: 1px solid #999;\n\
}\n\
.x-istanbul .cover-full {\n\
    border-right: none !important;\n\
}\n\
.x-istanbul .coverage {\n\
    border-collapse: collapse;\n\
    margin: 0;\n\
    padding: 0\n\
}\n\
.x-istanbul .coverage td {\n\
    color: #111;\n\
    margin: 0;\n\
    padding: 0;\n\
    vertical-align: top;\n\
}\n\
.x-istanbul .coverage td .cline-any {\n\
    display: inline-block;\n\
    padding: 0 5px;\n\
    width: 60px;\n\
}\n\
.x-istanbul .coverage td .cline-neutral {\n\
    background: #eee;\n\
}\n\
.x-istanbul .coverage td .cline-no {\n\
    background: #fc8c84;\n\
}\n\
.x-istanbul .coverage td .cline-yes {\n\
    background: #b5d592;\n\
    color: #999;\n\
}\n\
.x-istanbul .coverage .line-count {\n\
    padding-right: 5px;\n\
    text-align: right;\n\
    width: 50px;\n\
}\n\
.x-istanbul .coverage .line-count a {\n\
    text-decoration: none;\n\
}\n\
.x-istanbul .coverage .line-coverage {\n\
    border-left: 1px solid #999;\n\
    border-right: 1px solid #999;\n\
    color: #777 !important;\n\
    text-align: right;\n\
}\n\
.x-istanbul .coverage-summary {\n\
    padding: 20px;\n\
}\n\
.x-istanbul .coverage-summary table {\n\
    border-collapse: collapse;\n\
    margin: auto;\n\
    table-layout: fixed;\n\
    text-align: left;\n\
    width: 100%\n\
}\n\
.x-istanbul .coverage-summary td {\n\
    border: 1px solid #999;\n\
    margin: 0;\n\
    padding: 5px;\n\
    white-space: nowrap;\n\
}\n\
.x-istanbul .coverage-summary th {\n\
    margin: 0;\n\
    padding: 0 0 2px 0;\n\
}\n\
.x-istanbul .cstat-no {\n\
    background: #fc8c84;\n\
    color: #111;\n\
}\n\
.x-istanbul .cstat-skip {\n\
    background: #ddd;\n\
    color: #111;\n\
}\n\
.x-istanbul .cstat-yes {\n\
    color: #111;\n\
}\n\
.x-istanbul .entity,\n\
.x-istanbul .metric {\n\
    font-weight: bold;\n\
}\n\
.x-istanbul .footer,\n\
.x-istanbul .header {\n\
    background: #eee;\n\
    padding: 20px;\n\
}\n\
.x-istanbul .footer {\n\
    border-top: 1px solid #999;\n\
}\n\
.x-istanbul .fstat-no {\n\
    background: #ffc520;\n\
    color: #111 !important;\n\
}\n\
.x-istanbul .fstat-skip {\n\
    background: #ddd;\n\
    color: #111 !important;\n\
}\n\
.x-istanbul .header {\n\
    border-bottom: 1px solid #999;\n\
    top: 0;\n\
    width: 100%;\n\
}\n\
.x-istanbul .high {\n\
    background: #b5d592 !important;\n\
}\n\
.x-istanbul .ignore-none {\n\
    color: #999;\n\
    font-weight: normal;\n\
}\n\
.x-istanbul .low {\n\
    background: #fc8c84 !important;\n\
}\n\
.x-istanbul .medium {\n\
    background: #ffe87c !important;\n\
}\n\
.x-istanbul .meta {\n\
    text-align: center;\n\
}\n\
.x-istanbul .metric {\n\
    background: white;\n\
    border: 1px solid #999;\n\
    display: inline-block;\n\
    padding: .3em;\n\
}\n\
.x-istanbul .missing-if-branch {\n\
    background: black;\n\
    color: yellow;\n\
    display: inline-block;\n\
    margin-right: 10px;\n\
    padding: 0 4px;\n\
    position: relative;\n\
}\n\
.x-istanbul .missing-if-branch .typ,\n\
.x-istanbul .skip-if-branch .typ {\n\
    color: inherit !important;\n\
}\n\
.x-istanbul .prettyprint {\n\
    border: none !important;\n\
    margin: 0 !important;\n\
    padding: 0 !important;\n\
}\n\
.x-istanbul .skip-if-branch {\n\
    background: #ccc;\n\
    color: white;\n\
    display: none;\n\
    margin-right: 10px;\n\
    padding: 0 4px;\n\
    position: relative;\n\
}\n\
/* validateLineSortedReset */\n\
.x-istanbul a {\n\
    color: #00d;\n\
    text-decoration: underline;\n\
}\n\
.x-istanbul pre {\n\
    overflow: visible;\n\
    white-space: pre\n\
}\n\
.x-istanbul .file div {\n\
    margin-bottom: 2px;\n\
    overflow-wrap: break-word;\n\
    white-space: normal;\n\
    width: 100%;\n\
}\n\
.x-istanbul .tableHeader {\n\
    border-collapse: collapse;\n\
    margin: 0 auto 10px auto;\n\
    table-layout: fixed;\n\
    text-align: left;\n\
    width: 100%;\n\
}\n\
.x-istanbul .tableHeader td {\n\
    background: #fff;\n\
    border: 1px solid #999;\n\
    padding: 5px;\n\
}\n\
.x-istanbul .tableHeader th {\n\
    padding: 0 0 2px 0;\n\
}\n\
</style>\n\
</head>\n\
{{#if isBrowser}}\n\
<div class="x-istanbul">\n\
{{#unless isBrowser}}\n\
<body class="x-istanbul">\n\
{{/if isBrowser}}\n\
<script>\n\
// init domOnEventSelectAllWithinPre\n\
(function () {\n\
/*\n\
 * this function will limit select-all within <pre tabIndex="0"> elements\n\
 * https://stackoverflow.com/questions/985272/selecting-text-in-an-element-akin-to-highlighting-with-your-mouse\n\
 */\n\
    "use strict";\n\
    if (window.domOnEventSelectAllWithinPre) {\n\
        return;\n\
    }\n\
    window.domOnEventSelectAllWithinPre = function (evt) {\n\
        var range;\n\
        var selection;\n\
        if (\n\
            evt\n\
            && evt.key === "a"\n\
            && (evt.ctrlKey || evt.metaKey)\n\
            && evt.target.closest(\n\
                "pre"\n\
            )\n\
        ) {\n\
            range = document.createRange();\n\
            range.selectNodeContents(evt.target.closest(\n\
                "pre"\n\
            ));\n\
            selection = window.getSelection();\n\
            selection.removeAllRanges();\n\
            selection.addRange(range);\n\
            evt.preventDefault();\n\
        }\n\
    };\n\
    // handle evt\n\
    document.addEventListener(\n\
        "keydown",\n\
        window.domOnEventSelectAllWithinPre\n\
    );\n\
}());\n\
</script>\n\
<div class="header {{metrics.statements.score}}">\n\
{{#if env.npm_package_homepage}}\n\
    <h2 style="font-weight: bold;">\n\
        <a href="{{env.npm_package_homepage}}">{{env.npm_package_name}} ({{env.npm_package_version}})</a>\n\
    </h2>\n\
{{/if env.npm_package_homepage}}\n\
    <h2>Code coverage report for <span class="entity">{{nameOrAllFiles}}</span></h2>\n\
    <table class="tableHeader">\n\
    <thead>\n\
    <tr>\n\
        <th>Ignored</th>\n\
        <th>Statements</th>\n\
        <th>Branches</th>\n\
        <th>Functions</th>\n\
        <th>Lines</th>\n\
    </tr>\n\
    </thead>\n\
    <tbody>\n\
        <td>\n\
            Statements: {{metrics.statements.skipped}}<br>\n\
            Branches: {{metrics.branches.skipped}}<br>\n\
            Functions: {{metrics.functions.skipped}}\n\
        </td>\n\
        <td>\n\
            {{metrics.statements.pct}}%<br>\n\
            ({{metrics.statements.covered}} / {{metrics.statements.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.branches.pct}}%<br>\n\
            ({{metrics.branches.covered}} / {{metrics.branches.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.functions.pct}}%<br>\n\
            ({{metrics.functions.covered}} / {{metrics.functions.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.lines.pct}}%<br>\n\
            ({{metrics.lines.covered}} / {{metrics.lines.total}})\n\
        </td>\n\
    </tbody>\n\
    </table>\n\
    <div class="path">{{htmlPath notHtmlSafe}}</div>\n\
</div>\n\
<div class="body">\n\
{{#if isFile}}\n\
<pre><table class="coverage"><tr>\n\
        <td class="line-count">{{htmlLineIi notHtmlSafe}}</td>\n\
        <td class="line-coverage">{{htmlLineCnt notHtmlSafe}}</td>\n\
        <td class="text"><pre class="prettyprint lang-js" tabIndex="0">{{htmlLineCode}}</pre></td>\n\
</tr></table></pre>\n\
{{#unless isFile}}\n\
<div class="coverage-summary">\n\
    <table>\n\
    <thead>\n\
    <tr>\n\
        <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>\n\
        <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>\n\
        <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>\n\
        <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>\n\
        <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>\n\
    </tr>\n\
    </thead>\n\
    <tbody>\n\
{{#each children}}\n\
    <tr>\n\
        <td class="file {{metrics.statements.score}}" data-value="{{relativeName}}">\n\
            <a href="{{href}}">{{relativeName}}<br>\n\
            <span class="cover-fill cover-full" style="width: {{metrics.statements.width1}}px;"></span><span class="cover-empty" style="width: {{metrics.statements.width2}}px;"></span></a>\n\
        </td>\n\
        <td>\n\
            {{metrics.statements.pct}}%<br>\n\
            ({{metrics.statements.covered}} / {{metrics.statements.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.branches.pct}}%<br>\n\
            ({{metrics.branches.covered}} / {{metrics.branches.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.functions.pct}}%<br>\n\
            ({{metrics.functions.covered}} / {{metrics.functions.total}})\n\
        </td>\n\
        <td>\n\
            {{metrics.lines.pct}}%<br>\n\
            ({{metrics.lines.covered}} / {{metrics.lines.total}})\n\
        </td>\n\
    </tr>\n\
{{/each children}}\n\
    </tbody>\n\
    </table>\n\
</div>\n\
{{/if isFile}}\n\
</div>\n\
<div class="footer">\n\
<div class="meta">\n\
    Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at ${datetime}\n\
</div>\n\
</div>\n\
{{#if isBrowser}}\n\
</div>\n\
</div>\n\
{{#unless isBrowser}}\n\
</body>\n\
</html>\n\
{{/if isBrowser}}\n\
';
/* jslint ignore:end */


/*
file none
*/


let fileWrite;
let path;
let reportHtmlWrite;
let reportTextWrite;
// mock path
path = {
    dirname: function (file) {
        return file.replace((
            /\/[\w\-.]+?$/
        ), "");
    },
    resolve: function (...argList) {
        return argList[argList.length - 1];
    },
    sep: "/"
};
// require path
try {
    path = require("path");
} catch (ignore) {}
// init function
fileWrite = function (file, data) {
/*
 * this function will write <data> to <file>
 */
    local.fsWriteFileWithMkdirpSync(file, data);
};
reportHtmlWrite = function (node, dirCoverage, coverage) {
/*
 * this function will recursively write coverage-report of <node> in html-format
 * to <dirCoverage>
 */
    let datetime;
    let htmlAll;
    let lineInsertAt;
    let lineWrapAt;
    let recurse;
    // init function
    lineInsertAt = function (lineObj, col, str, insertBefore) {
    /*
     * this function will insert <str> into <lineObj> at <col>
     */
        let ii;
        let offset;
        let offsetObj;
        col = Math.min(col, lineObj.length0);
        // find offset from col
        offset = col;
        ii = 0;
        while (ii < lineObj.offsets.length) {
            offsetObj = lineObj.offsets[ii];
            if (
                offsetObj.col < col
                || (offsetObj.col === col && !insertBefore)
            ) {
                offset += offsetObj.len;
            }
            if (offsetObj.col >= col) {
                break;
            }
            ii += 1;
        }
        if (offsetObj && offsetObj.col === col) {
            offsetObj.len += str.length;
        } else {
            lineObj.offsets.splice(ii, 0, {
                col,
                len: str.length
            });
        }
        // insert str at offset
        lineObj.text = (
            lineObj.text.slice(0, offset) + str + lineObj.text.slice(offset)
        );
    };
    lineWrapAt = function (lineObj, startCol, startText, endCol, endText) {
    /*
     * this function will wrap <lineObj>.slice(<startCol>, <endCol>)
     * inside <startText> and <endText>
     */
        startCol = Math.min(startCol, lineObj.length0);
        // consumeBlanks
        if (startCol <= lineObj.startCol) {
            startCol = 0;
        }
        lineInsertAt(lineObj, startCol, startText);
        lineInsertAt(lineObj, endCol, endText);
    };
    recurse = function (node, level, dir) {
    /*
     * this function will recursively write <htmlData> from <node>
     * to <dir>/<htmlFile>
     */
        let fileCoverage;
        let htmlData;
        let htmlFile;
        let htmlLineCnt;
        let htmlLineCode;
        let htmlLineIi;
        let htmlPath;
        let ii;
        let jj;
        let kk;
        let lineList;
        let parent;
        let tmp;
        // render htmlPath
        tmp = node;
        parent = tmp.parent;
        htmlPath = tmp.relativeName;
        ii = 1;
        while (parent) {
            htmlPath = (
                "index.html\">" + parent.relativeNameOrAllFiles + "</a>"
                + " &#187; " + htmlPath
            );
            jj = 0;
            while (jj < ii) {
                kk = 0;
                while (kk < tmp.relativeName.split(path.sep).length - 1) {
                    htmlPath = "../" + htmlPath;
                    kk += 1;
                }
                tmp = tmp.parent;
                jj += 1;
            }
            htmlPath = "<a href=\"" + htmlPath;
            parent = parent.parent;
            ii += 1;
        }
        // write dir
        if (!node.isFile) {
            htmlFile = dir + "/index.html";
            htmlData = local.templateRender(
                local.templateCoverageReport,
                Object.assign({
                    datetime,
                    env: process.env,
                    htmlPath,
                    isBrowser: !local.isEnvNode
                }, node)
            );
            htmlAll += htmlData + "\n\n";
            fileWrite(htmlFile, htmlData);
            node.children.forEach(function (child) {
                recurse(child, level + 1, dir + "/" + child.relativeName);
            });
            return;
        }
        // write file
        htmlFile = dir + ".html";
        fileCoverage = coverage[node.pathname];
        lineList = [].concat("", fileCoverage.code, "").map(function (text) {
            let endCol;
            let startCol;
            // new InsertionText
            // init startCol
            startCol = -1;
            ii = 0;
            while (ii < text.length) {
                if (!text[ii].match(
                    /[\u0020\f\n\r\t\u000b\u00a0\u2028\u2029]/
                )) {
                    startCol = ii;
                    break;
                }
                ii += 1;
            }
            // init endCol
            endCol = text.length + 1;
            ii = text.length - 1;
            while (ii >= 0) {
                if (!text[ii].match(
                    /[\u0020\f\n\r\t\u000b\u00a0\u2028\u2029]/
                )) {
                    endCol = ii;
                    break;
                }
                ii -= 1;
            }
            return {
                endCol,
                length0: text.length,
                offsets: [],
                startCol,
                text
            };
        });
        //note: order is important, since statements typically result
        //in spanning the whole line and doing branches late
        //causes mismatched tags
        // annotateBranches(fileCoverage, lineList);
        Object.entries(fileCoverage.b).forEach(function ([
            key,
            list
        ]) {
            if (list.reduce(function (aa, bb) {
                return aa + bb;
            }, 0) <= 0) {
                return;
            }
            //only highlight if partial branches are missing
            list.forEach(function (cnt, ii) {
                let endCol;
                let endLine;
                let lineObj;
                let meta;
                let startLine;
                if (cnt !== 0) {
                    return;
                }
                meta = fileCoverage.branchMap[key].locations[ii];
                endCol = meta.end.column + 1;
                endLine = meta.end.line;
                startLine = meta.start.line;
                //skip branches taken
                if (endLine !== startLine) {
                    endLine = startLine;
                    endCol = lineList[startLine].length0;
                }
                lineObj = lineList[startLine];
                if (fileCoverage.branchMap[key].type === "if") {
                    // and "if" is a special case since the else branch
                    // might not be visible, being non-existent
                    lineInsertAt(
                        lineObj,
                        meta.start.column,
                        "\u0001span class=\"" + (
                            meta.skip
                            ? "skip-if-branch"
                            : "missing-if-branch"
                        ) + "\" title=\"" + (
                            ii === 0
                            ? "if path not taken\"\u0002I"
                            : "else path not taken\"\u0002E"
                        ) + "\u0001/span\u0002",
                        true
                    );
                    return;
                }
                lineWrapAt(
                    lineObj,
                    meta.start.column,
                    "\u0001span class=\"branch-" + ii + " " + (
                        meta.skip
                        ? "cbranch-skip"
                        : "cbranch-no"
                    ) + "\" title=\"branch not covered\"\u0002",
                    endCol,
                    "\u0001/span\u0002"
                );
            });
        });
        // annotateFunctions(fileCoverage, lineList);
        Object.entries(fileCoverage.f).forEach(function ([
            key,
            cnt
        ]) {
            let endCol;
            let endLine;
            let lineObj;
            let meta;
            let startLine;
            if (cnt !== 0) {
                return;
            }
            meta = fileCoverage.fnMap[key];
            endCol = meta.loc.end.column + 1;
            endLine = meta.loc.end.line;
            startLine = meta.loc.start.line;
            if (endLine !== startLine) {
                endLine = startLine;
                endCol = lineList[startLine].length0;
            }
            lineObj = lineList[startLine];
            lineWrapAt(
                lineObj,
                meta.loc.start.column,
                "\u0001span class=\"" + (
                    meta.skip
                    ? "fstat-skip"
                    : "fstat-no"
                ) + "\" title=\"function not covered\"\u0002",
                endCol,
                "\u0001/span\u0002"
            );
        });
        // annotateStatements(fileCoverage, lineList);
        Object.entries(fileCoverage.s).forEach(function ([
            key,
            cnt
        ]) {
            let endCol;
            let endLine;
            let lineObj;
            let meta;
            let startLine;
            if (cnt !== 0) {
                return;
            }
            meta = fileCoverage.statementMap[key];
            endCol = meta.end.column + 1;
            startLine = meta.start.line;
            endLine = meta.end.line;
            if (endLine !== startLine) {
                endLine = startLine;
                endCol = lineList[startLine].length0;
            }
            lineObj = lineList[startLine];
            lineWrapAt(
                lineObj,
                meta.start.column,
                "\u0001span class=\"" + (
                    meta.skip
                    ? "cstat-skip"
                    : "cstat-no"
                ) + "\" title=\"statement not covered\"\u0002",
                endCol,
                "\u0001/span\u0002"
            );
        });
        // remove trailing whitespace
        ii = lineList.length - 1;
        while (ii > 1 && !lineList[ii].text.trim()) {
            lineList.pop();
            ii -= 1;
        }
        htmlLineCnt = "";
        htmlLineCode = "\n";
        htmlLineIi = "";
        ii = 1;
        while (ii < lineList.length) {
            // render htmlLineIi
            htmlLineIi += `<a href="#l${ii}" id="l${ii}">${ii}</a>` + "\n";
            tmp = fileCoverage.l[ii];
            htmlLineCnt += (
                tmp === undefined
                ? `<span class="cline-any cline-neutral">&nbsp;</span>`
                : tmp > 0
                ? `<span class="cline-any cline-yes">${tmp}</span>`
                : `<span class="cline-any cline-no">&nbsp;</span>`
            ) + "\n";
            htmlLineCode += lineList[ii].text + "\n";
            ii += 1;
        }
        htmlLineCode = htmlLineCode.replace((
            /&/g
        ), "&amp;").replace((
            /</g
        ), "&lt;").replace((
            />/g
        ), "&gt;").replace((
            /\u0001/g
        ), "<").replace((
            /\u0002/g
        ), ">");
        htmlData = local.templateRender(
            local.templateCoverageReport,
            Object.assign({
                datetime,
                env: process.env,
                htmlLineCnt,
                htmlLineIi,
                htmlPath,
                isBrowser: !local.isEnvNode,
                lineList
            }, node)
        );
        htmlData = htmlData.split("{{htmlLineCode}}");
        htmlData.splice(1, 0, htmlLineCode);
        htmlData = htmlData.join("");
        htmlAll += htmlData + "\n\n";
        fileWrite(htmlFile, htmlData);
    };
    // init datetime
    datetime = new Date().toGMTString();
    // init htmlAll
    htmlAll = (
        `<div class="coverageReportDiv">
<h2>coverage-report</h2>
<div style="background: #fff; border: 1px solid #999; margin 0; padding: 0;">`
    ) + "\n";
    // recursively write html
    recurse(node, 0, dirCoverage);
    htmlAll += "</div>\n</div>\n";
    // write coverage.all.html
    fileWrite(dirCoverage + "/coverage.all.html", htmlAll);
    // return htmlAll
    return htmlAll;
};
reportTextWrite = function (node, dircoverage) {
/*
 * this function will recursively write coverage-report of <node> in text-format
 * to <dircoverage>/coverage.txt
 */
    let nodeNameWidth;
    let recurse;
    let result;
    let stringPad;
    // init function
    recurse = function (node, level) {
        // update nodeNameWidth
        nodeNameWidth = Math.max(
            nodeNameWidth,
            Math.max(level, 0) * 2 + node.relativeNameOrAllFiles.length
        );
        // format metrics
        return [
            node.metrics.statements,
            node.metrics.statements,
            node.metrics.branches,
            node.metrics.functions,
            node.metrics.lines
        ].map(function ({
            pct,
            score
        }, ii) {
            return (
                ii === 0
                ? stringPad(
                    node.relativeNameOrAllFiles,
                    nodeNameWidth,
                    false,
                    Math.max(level, 0) * 2,
                    score
                )
                : stringPad(String(pct), 8, true, 0, score)
            );
        }).join(" |") + " |\n" + node.children.map(function (child) {
            return recurse(child, level + 1);
        }).join("");
    };
    stringPad = function (str, width, right, indent, score) {
    /*
     * this function will pad <str> to given <width>
     */
        let fillStr;
        let fmtStr;
        fmtStr = "";
        fillStr = " ".repeat(width - indent - str.length);
        fmtStr = (
            right
            ? fillStr + str
            : str + fillStr
        );
        // colorize
        switch (process.stdout.isTTY && score) {
        case "high":
            fmtStr = "\u001b[92m" + fmtStr + "\u001b[0m";
            break;
        case "low":
            fmtStr = "\u001b[91m" + fmtStr + "\u001b[0m";
            break;
        case "medium":
            fmtStr = "\u001b[93m" + fmtStr + "\u001b[0m";
            break;
        }
        return " ".repeat(indent) + fmtStr;
    };
    // init nodeNameWidth
    nodeNameWidth = 0;
    recurse(node, -1);
    // write coverage-report
    result = (
        "-".repeat(nodeNameWidth)
        + "-|---------|---------|---------|---------|\n"
    );
    result = (
        result
        + stringPad("File", nodeNameWidth, false, 0, "")
        + " | % Stmts | % Brchs | % Funcs | % Lines |\n"
        + result
        + recurse(node, -1)
        + result
    );
    console.error(result);
    fileWrite(dircoverage + "/coverage.txt", result);
};


// init local
local.coverageMerge = function (coverage1 = {}, coverage2 = {}) {
/*
 * this function will inplace-merge <coverage2> into <coverage1>
 */
    let dict1;
    let dict2;
    Object.keys(coverage2).forEach(function (file) {
        // if coverage1[file] is undefined, then override it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge coverage2 into coverage1
        [
            "b", "f", "s"
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case "b":
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (cnt, ii) {
                        dict1[key][ii] += cnt;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case "f":
            case "s":
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
};

local.coverageReportCreate = function ({
    coverage,
    coverageInclude
}) {
/*
 * this function will
    // 1. merge previous <dirCoverage>/coverage.json into <coverage>
    // 2. convert <coverage> to <summaryDict>
    // 3. convert <summaryDict> to <nodeRoot>
    // 4. convert <nodeRoot> to text-report <dirCoverage>/coverage.txt
    // 5. convert <nodeRoot> to html-report <dirCoverage>/\*
    // 6. return coverage-report in html-format as single document
 */
    let dirCoverage;
    let filePrefix;
    let htmlAll;
    let nodeDict;
    let nodeRoot;
    let summaryDict;
    let tmp;
    // init function
    function nodeChildAdd(node, child) {
    /*
     * this function will add <child> to <node>
     */
        node.children.push(child);
        child.parent = node;
    }
    function nodeCreate(pathname) {
    /*
     * this function will create a tree-node
     */
        return {
            children: [],
            pathname,
            metrics: {
                branches: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                functions: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                lines: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                statements: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                }
            },
            name: pathname
        };
    }
    function nodeNormalize(node, level, filePrefix, parent) {
    /*
     * this function will recursively normalize <node> and its children
     */
        let metric;
        // init name
        if (node.name.indexOf(filePrefix) === 0) {
            node.name = node.name.slice(filePrefix.length);
        }
        if (node.name[0] === path.sep) {
            node.name = node.name.slice(1);
        }
        // init relativeName
        node.relativeName = (
            parent
            ? (
                parent.name !== "__root__/"
                ? node.name.slice(parent.name.length)
                : node.name
            )
            : node.name.slice(filePrefix.length)
        );
        // init nameOrAllFiles
        node.nameOrAllFiles = node.name || "All files";
        // init relativeNameOrAllFiles
        node.relativeNameOrAllFiles = node.relativeName || "All files";
        // init href
        node.href = node.relativeName.split(path.sep).join("/") + (
            node.isFile
            ? ".html"
            : "index.html"
        );
        // recurse
        node.children.forEach(function (child) {
            nodeNormalize(child, level + 1, filePrefix, node);
        });
        // sort children by name
        node.children.sort(function (aa, bb) {
            return (
                aa.name > bb.name
                ? 1
                : -1
            );
        });
        // init metrics
        if (!node.isFile) {
            node.children.forEach(function (child) {
                [
                    "lines", "statements", "branches", "functions"
                ].forEach(function (key) {
                    metric = node.metrics[key];
                    metric.total += child.metrics[key].total;
                    metric.covered += child.metrics[key].covered;
                    metric.skipped += child.metrics[key].skipped;
                });
            });
        }
        // calculate pct and score
        [
            "lines", "statements", "branches", "functions"
        ].forEach(function (key) {
            metric = node.metrics[key];
            metric.pct = (
                metric.total > 0
                ? Math.floor(
                    (1000 * 100 * metric.covered / metric.total + 5)
                    / 10
                ) / 100
                : 100
            );
            metric.width1 = metric.pct | 0;
            metric.width2 = 100 - metric.width1;
            metric.score = (
                metric.pct >= 80
                ? "high"
                : metric.pct >= 50
                ? "medium"
                : "low"
            );
        });
    }
    // 1. merge previous <dirCoverage>/coverage.json into <coverage>
    coverage = coverage || globalThis.__coverage__;
    coverageInclude = coverageInclude || globalThis.__coverageInclude__;
    dirCoverage = path.resolve(".tmp/build/coverage");
    if (local.isEnvNode && process.env.npm_config_mode_coverage_merge) {
        console.error(
            "istanbul - merging file "
            + dirCoverage + "/coverage.json to coverage"
        );
        local.coverageMerge(coverage, local.fsReadFileOrDefaultSync(
            dirCoverage + "/coverage.json",
            "json",
            {}
        ));
        Object.keys(local.fsReadFileOrDefaultSync(
            dirCoverage + "/coverage.include.json",
            "json",
            {}
        )).forEach(function (file) {
            coverageInclude[file] = 1;
        });
    }
    // 2. convert <coverage> to <summaryDict>
    summaryDict = {};
    Object.entries(coverage).forEach(function ([
        file,
        fileCoverage
    ]) {
        let map;
        let metric;
        let skipped;
        let summary;
        if (fileCoverage && coverageInclude.hasOwnProperty(file)) {
            // reset line-cnt
            delete coverage[file].l;
            // init summary
            summary = {
                branches: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                functions: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                lines: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                },
                statements: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: "Unknown"
                }
            };
            // init line-cnt
            fileCoverage.l = {};
            Object.entries(fileCoverage.s).forEach(function ([
                key,
                cnt
            ]) {
                if (cnt === 0 && fileCoverage.statementMap[key].skip) {
                    cnt = 1;
                }
                fileCoverage.l[
                    fileCoverage.statementMap[key].start.line
                ] = Math.max(fileCoverage.l[
                    fileCoverage.statementMap[key].start.line
                ] | 0, cnt);
            });
            // computeSimpleTotals
            [
                [
                    "lines", "l"
                ],
                [
                    "functions", "f", "fnMap"
                ],
                [
                    "statements", "s", "statementMap"
                ]
            ].forEach(function ([
                keyMetric, keyCovered, keyMap
            ]) {
                map = fileCoverage[keyMap];
                metric = {
                    total: 0,
                    covered: 0,
                    skipped: 0
                };
                Object.entries(fileCoverage[keyCovered]).forEach(function ([
                    key,
                    covered
                ]) {
                    skipped = map && map[key].skip;
                    metric.total += 1;
                    metric.covered += Boolean(covered || skipped);
                    metric.skipped += Boolean(!covered && skipped);
                });
                summary[keyMetric] = metric;
            });
            // computeBranchTotals
            metric = {
                total: 0,
                covered: 0,
                skipped: 0
            };
            Object.entries(fileCoverage.b).forEach(function ([
                key,
                branches
            ]) {
                map = fileCoverage.branchMap[key].locations;
                branches.forEach(function (covered, ii) {
                    skipped = map && map[ii] && map[ii].skip;
                    metric.covered += Boolean(covered || skipped);
                    metric.skipped += Boolean(!covered && skipped);
                });
                metric.total += branches.length;
            });
            summary.branches = metric;
            summaryDict[file] = summary;
            // findCommonArrayPrefix
            tmp = file.split(path.sep);
            if (!filePrefix) {
                filePrefix = tmp.slice(0, -1);
                return;
            }
            filePrefix.some(function (elem, ii) {
                if (elem !== tmp[ii]) {
                    filePrefix = filePrefix.slice(0, ii);
                    return true;
                }
            });
        }
    });
    // 3. convert <summaryDict> to <nodeRoot>
    filePrefix = filePrefix || [];
    tmp = filePrefix.join(path.sep) + path.sep;
    nodeRoot = nodeCreate(tmp);
    nodeDict = {};
    nodeDict[tmp] = nodeRoot;
    Object.entries(summaryDict).forEach(function ([
        key,
        metrics
    ]) {
        let node;
        let parent;
        let parentPath;
        node = nodeCreate(key);
        node.isFile = true;
        node.metrics = metrics;
        nodeDict[key] = node;
        parentPath = path.dirname(key) + path.sep;
        if (parentPath === path.sep + path.sep) {
            parentPath = path.sep + "__root__" + path.sep;
        }
        parent = nodeDict[parentPath];
        if (!parent) {
            parent = nodeCreate(parentPath);
            nodeChildAdd(nodeRoot, parent);
            nodeDict[parentPath] = parent;
        }
        nodeChildAdd(parent, node);
    });
    nodeNormalize(nodeRoot, 0, filePrefix.join(path.sep) + path.sep);
    // 4. convert <nodeRoot> to text-report <dirCoverage>/coverage.txt
    reportTextWrite(nodeRoot, dirCoverage);
    // 5. convert <nodeRoot> to html-report <dirCoverage>/\*
    htmlAll = reportHtmlWrite(nodeRoot, dirCoverage, coverage);
    // save coverage to dirCoverage/coverage.json
    fileWrite(
        dirCoverage + "/coverage.json",
        JSON.stringify(coverage, undefined, 4)
    );
    // save coverageInclude to dirCoverage/coverage.include.json
    fileWrite(
        dirCoverage + "/coverage.include.json",
        JSON.stringify(coverageInclude, undefined, 4)
    );
    // write coverage.badge.svg
    tmp = nodeRoot.metrics.lines.pct;
    fileWrite(
        dirCoverage + "/coverage.badge.svg",
        local.svgBadgeCreate({
            fill: (
                "#"
                + Math.round((100 - tmp) * 2.21).toString(16).padStart(2, "0")
                + Math.round(tmp * 2.21).toString(16).padStart(2, "0")
                + "00"
            ),
            str1: "coverage",
            str2: tmp + " %"
        })
    );
    console.error(
        "istanbul - created coverage file " + dirCoverage + "/index.html"
    );
    // 6. return coverage-report in html-format as single document
    return htmlAll;
};

local.instrumentInPackage = function (code, file) {
/*
 * this function will instrument <code>
 * if macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in <code>
 */
    return (
        (
            process.env.npm_config_mode_coverage
            && code.indexOf("/* istanbul ignore all */\n") < 0 && (
                process.env.npm_config_mode_coverage === "all"
                || process.env.npm_config_mode_coverage === "node_modules"
                || code.indexOf(
                    "/* istanbul instrument in package "
                    + process.env.npm_package_nameLib + " */\n"
                ) >= 0
                || code.indexOf(
                    "/* istanbul instrument in package "
                    + process.env.npm_config_mode_coverage + " */\n"
                ) >= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
};

local.instrumentSync = function (code, file) {
/*
 * this function will
    // 1. normalize <file>
    // 2. save <code> to __coverageInclude__[<file>] for future html-report
    // 3. return instrumented-code
 */
    // 1. normalize <file>
    file = path.resolve(file);
    // 2. save <code> to __coverageInclude__[<file>] for future html-report
    // 3. return instrumented-code
    return (
        "globalThis.__coverageInclude__ = globalThis.__coverageInclude__ || {};"
        + "globalThis.__coverageInclude__[" + JSON.stringify(file) + "] = 1;\n"
    ) + new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
};
}());


// run node js-env code - init-after
/* istanbul ignore next */
(function () {
if (!local.isEnvNode) {
    return;
}


local.cliDict = {};
local.cliDict.cover = function () {
/*
 * <script>
 * will run and cover <script>
 */
    let moduleExtensionsJs;
    let tmp;
    try {
        tmp = JSON.parse(require("fs").readFileSync("package.json", "utf8"));
        process.env.npm_package_nameLib = (
            process.env.npm_package_nameLib
            || tmp.nameLib
            || tmp.name.replace((
                /-/g
            ), "_")
        );
    } catch (ignore) {}
    process.env.npm_config_mode_coverage = (
        process.env.npm_config_mode_coverage
        || process.env.npm_package_nameLib
        || "all"
    );
    // add coverage hook to require
    tmp = require("module");
    moduleExtensionsJs = tmp._extensions[".js"];
    tmp._extensions[".js"] = function (module, file) {
        if (typeof file === "string" && (
            file.indexOf(process.cwd() + require("path").sep) === 0 && (
                process.env.npm_config_mode_coverage === "node_modules"
                || file.indexOf(
                    require("path").resolve("node_modules")
                    + require("path").sep
                ) !== 0
            )
        )) {
            module._compile(local.instrumentInPackage(
                require("fs").readFileSync(file, "utf8"),
                file
            ), file);
            return;
        }
        moduleExtensionsJs(module, file);
    };
    // init process.argv
    process.argv.splice(1, 2);
    process.argv[1] = require("path").resolve(process.argv[1]);
    console.error("\nistanbul - covering $ " + process.argv.join(" "));
    // create coverage on exit
    process.on("exit", function () {
        local.coverageReportCreate({});
    });
    // re-init cli
    tmp.runMain();
};

local.cliDict.instrument = function () {
/*
 * <script>
 * will instrument <script> and print result to stdout
 */
    process.argv[3] = require("path").resolve(process.argv[3]);
    process.stdout.write(local.instrumentSync(
        require("fs").readFileSync(process.argv[3], "utf8"),
        process.argv[3]
    ));
};

local.cliDict.report = function () {
/*
 * <coverageJson>
 * will create coverage-report from file <coverageJson>
 */
    process.argv[3] = require("path").resolve(process.argv[3]);
    globalThis.__coverage__ = JSON.parse(
        require("fs").readFileSync(process.argv[3])
    );
    globalThis.__coverageInclude__ = {};
    Object.keys(globalThis.__coverage__).forEach(function (file) {
        globalThis.__coverageInclude__[file] = 1;
    });
    local.coverageReportCreate({});
};

local.cliDict.test = function () {
/*
 * <script>
 * will run and cover <script> if env-var $npm_config_mode_coverage is set
 */
    if (process.env.npm_config_mode_coverage) {
        process.argv[2] = "cover";
        // re-init cli
        local.cliDict[process.argv[2]]();
        return;
    }
    // restart node with __filename removed from process.argv
    process.argv.splice(1, 2);
    process.argv[1] = require("path").resolve(process.argv[1]);
    // re-init cli
    require("module").runMain();
};

// run the cli
if (module === require.main && !globalThis.utility2_rollup) {
    local.cliRun({});
}
}());
}());
/* script-end /assets.utility2.lib.istanbul.js */



/* script-begin /assets.utility2.lib.jslint.js */
// usr/bin/env node
/*
 * lib.jslint.js (2020.11.3)
 * https://github.com/kaizhu256/node-jslint-lite
 * this zero-dependency package will provide browser-compatible versions of jslint (v2020.7.2) and csslint (v2018.2.25), with working web-demo
 *
 */


/* istanbul instrument in package jslint */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_jslint = local;
}
// init lib main
local.jslint = local;


/* validateLineSortedReset */
local.cliRun = function ({
    rgxComment
}) {
/*
 * this function will run cli
 */
    let {
        _default,
        _eval,
        _help,
        _interactive,
        _version,
        cliDict,
        replStart
    } = Object.assign({}, local, local.cliDict);
    _eval = _eval || function () {
    /*
     * <code>
     * will eval <code>
     */
        Object.assign(globalThis, local);
        require("vm").runInThisContext(process.argv[3]);
    };
    _help = _help || function () {
    /*
     *
     * will print help
     */
        let cmdList;
        let file;
        let packageJson;
        let str;
        let strDict;
        cmdList = [
            {
                argList: "<arg2>  ...",
                description: "usage:",
                cmd: [
                    "<arg1>"
                ]
            }, {
                argList: "'console.log(\"hello world\")'",
                description: "example:",
                cmd: [
                    "--eval"
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), "");
        packageJson = require("./package.json");
        // validate comment
        rgxComment = rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020<[^>]*?>|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(cliDict).sort().forEach(function (key, ii) {
            if (key[0] === "_" && key !== "_default") {
                return;
            }
            str = String(cliDict[key]);
            if (key === "_default") {
                key = "";
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (cmdList[ii]) {
                cmdList[ii].cmd.push(key);
                return;
            }
            cmdList[ii] = rgxComment.exec(str);
            if (!cmdList[ii]) {
                throw new Error(
                    "cliRun - cannot parse comment in cmd " +
                    key + ":\nnew RegExp(" +
                    JSON.stringify(rgxComment.source) +
                    ").exec(" + JSON.stringify(str).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") + ");"
                );
            }
            cmdList[ii] = {
                argList: String(cmdList[ii][1] || "").trim(),
                cmd: [
                    key
                ],
                description: cmdList[ii][2]
            };
        });
        str = "";
        str += packageJson.name + " (" + packageJson.version + ")\n\n";
        str += cmdList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.cmd = elem.cmd.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(" ");
                elem.description = (
                    "# CMD " +
                    (elem.cmd[0] || "<none>") + "\n# " +
                    elem.description
                );
            }
            return (
                elem.description + "\n  " + file +
                "  " + elem.cmd.sort().join("|") + "  " +
                elem.argList.join("  ")
            );
        }).join("\n\n");
        console.log(str);
    };
    _interactive = _interactive || function () {
    /*
     *
     * will start interactive-mode
     */
        Object.assign(globalThis, local);
        replStart = replStart || require("repl").start;
        replStart({
            useGlobal: true
        });
    };
    _version = _version || function () {
    /*
     *
     * will print version
     */
        console.log(require(__dirname + "/package.json").version);
    };
    _default = _default || _help;
    Object.assign(cliDict, {
        "--eval": _eval,
        "--help": _help,
        "--interactive": _interactive,
        "--version": _version,
        "-e": _eval,
        "-h": _help,
        "-i": _interactive,
        "-v": _version,
        _default,
        _eval,
        _help,
        _interactive,
        _version
    });
    // run help-cmd if no arguments are given
    if (process.argv.length <= 2) {
        _help();
        return;
    }
    // run defined-cmd if it exists
    if (cliDict[process.argv[2]]) {
        cliDict[process.argv[2]]();
        return;
    }
    // run default-cmd
    _default();
};
}());


// run shared js-env code - function
(function () {
/* jslint ignore:start */
/*
repo https://github.com/CSSLint/csslint/tree/e8aeeda06c928636e21428e09b1af93f66621209
committed 2018-02-25T11:28:16Z
*/


/*
file https://github.com/CSSLint/csslint/blob/e8aeeda06c928636e21428e09b1af93f66621209/dist/csslint.js
*/
/*!
CSSLint v1.0.5
Copyright (c) 2017 Nicole Sullivan and Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/* istanbul ignore next */
var CSSLint = (function(){
  var module = module || {},
      exports = exports || {};

/*!
Parser-Lib
Copyright (c) 2009-2016 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/* Version v1.1.0, Build time: 6-December-2016 10:31:29 */
var parserlib = (function () {
var require;
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/* exported Colors */

var Colors = module.exports = {
    __proto__       :null,
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    //'currentColor' color keyword https://www.w3.org/TR/css3-color/#currentcolor
    currentColor        :"The value of the 'color' property.",
    //CSS2 system colors https://www.w3.org/TR/css3-color/#css2-system
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
},{}],2:[function(require,module,exports){
"use strict";

module.exports = Combinator;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class Combinator
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Combinator(text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //pretty simple
    if (/^\s+$/.test(text)) {
        this.type = "descendant";
    } else if (text === ">") {
        this.type = "child";
    } else if (text === "+") {
        this.type = "adjacent-sibling";
    } else if (text === "~") {
        this.type = "sibling";
    }
}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;
},{"../util/SyntaxUnit":26,"./Parser":6}],3:[function(require,module,exports){
"use strict";

module.exports = Matcher;

var StringReader = require("../util/StringReader");
var SyntaxError = require("../util/SyntaxError");

/**
 * This class implements a combinator library for matcher functions.
 * The combinators are described at:
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators
 */
function Matcher(matchFunc, toString) {
    this.match = function(expression) {
        // Save/restore marks to ensure that failed matches always restore
        // the original location in the expression.
        var result;
        expression.mark();
        result = matchFunc(expression);
        if (result) {
            expression.drop();
        } else {
            expression.restore();
        }
        return result;
    };
    this.toString = typeof toString === "function" ? toString : function() {
        return toString;
    };
}

/** Precedence table of combinators. */
Matcher.prec = {
    MOD:    5,
    SEQ:    4,
    ANDAND: 3,
    OROR:   2,
    ALT:    1
};

/** Simple recursive-descent grammar to build matchers from strings. */
Matcher.parse = function(str) {
    var reader, eat, expr, oror, andand, seq, mod, term, result;
    reader = new StringReader(str);
    eat = function(matcher) {
        var result = reader.readMatch(matcher);
        if (result === null) {
            throw new SyntaxError(
                "Expected "+matcher, reader.getLine(), reader.getCol());
        }
        return result;
    };
    expr = function() {
        // expr = oror (" | " oror)*
        var m = [ oror() ];
        while (reader.readMatch(" | ") !== null) {
            m.push(oror());
        }
        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);
    };
    oror = function() {
        // oror = andand ( " || " andand)*
        var m = [ andand() ];
        while (reader.readMatch(" || ") !== null) {
            m.push(andand());
        }
        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);
    };
    andand = function() {
        // andand = seq ( " && " seq)*
        var m = [ seq() ];
        while (reader.readMatch(" && ") !== null) {
            m.push(seq());
        }
        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);
    };
    seq = function() {
        // seq = mod ( " " mod)*
        var m = [ mod() ];
        while (reader.readMatch(/^ (?![&|\]])/) !== null) {
            m.push(mod());
        }
        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);
    };
    mod = function() {
        // mod = term ( "?" | "*" | "+" | "#" | "{<num>,<num>}" )?
        var m = term();
        if (reader.readMatch("?") !== null) {
            return m.question();
        } else if (reader.readMatch("*") !== null) {
            return m.star();
        } else if (reader.readMatch("+") !== null) {
            return m.plus();
        } else if (reader.readMatch("#") !== null) {
            return m.hash();
        } else if (reader.readMatch(/^\{\s*/) !== null) {
            var min = eat(/^\d+/);
            eat(/^\s*,\s*/);
            var max = eat(/^\d+/);
            eat(/^\s*\}/);
            return m.braces(+min, +max);
        }
        return m;
    };
    term = function() {
        // term = <nt> | literal | "[ " expression " ]"
        if (reader.readMatch("[ ") !== null) {
            var m = expr();
            eat(" ]");
            return m;
        }
        return Matcher.fromType(eat(/^[^ ?*+#{]+/));
    };
    result = expr();
    if (!reader.eof()) {
        throw new SyntaxError(
            "Expected end of string", reader.getLine(), reader.getCol());
    }
    return result;
};

/**
 * Convert a string to a matcher (parsing simple alternations),
 * or do nothing if the argument is already a matcher.
 */
Matcher.cast = function(m) {
    if (m instanceof Matcher) {
        return m;
    }
    return Matcher.parse(m);
};

/**
 * Create a matcher for a single type.
 */
Matcher.fromType = function(type) {
    // Late require of ValidationTypes to break a dependency cycle.
    var ValidationTypes = require("./ValidationTypes");
    return new Matcher(function(expression) {
        return expression.hasNext() && ValidationTypes.isType(expression, type);
    }, type);
};

/**
 * Create a matcher for one or more juxtaposed words, which all must
 * occur, in the given order.
 */
Matcher.seq = function() {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = true;
        for (i = 0; result && i < ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.SEQ;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(" ");
        if (prec > p) {
            s = "[ " + s + " ]";
        }
        return s;
    });
};

/**
 * Create a matcher for one or more alternatives, where exactly one
 * must occur.
 */
Matcher.alt = function() {
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
    if (ms.length === 1) {
        return ms[0];
    }
    return new Matcher(function(expression) {
        var i, result = false;
        for (i = 0; !result && i < ms.length; i++) {
            result = ms[i].match(expression);
        }
        return result;
    }, function(prec) {
        var p = Matcher.prec.ALT;
        var s = ms.map(function(m) {
            return m.toString(p);
        }).join(" | ");
        if (prec > p) {
            s = "[ " + s + " ]";
        }
        return s;
    });
};

/**
 * Create a matcher for two or more options.  This implements the
 * double bar (||) and double ampersand (&&) operators, as well as
 * variants of && where some of the alternatives are optional.
 * This will backtrack through even successful matches to try to
 * maximize the number of items matched.
 */
Matcher.many = function(required) {
    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {
        if (v.expand) {
            // Insert all of the options for the given complex rule as
            // individual options.
            var ValidationTypes = require("./ValidationTypes");
            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);
        } else {
            acc.push(Matcher.cast(v));
        }
        return acc;
    }, []);

    if (required === true) {
        required = ms.map(function() {
            return true;
        });
    }

    var result = new Matcher(function(expression) {
        var seen = [], max = 0, pass = 0;
        var success = function(matchCount) {
            if (pass === 0) {
                max = Math.max(matchCount, max);
                return matchCount === ms.length;
            } else {
                return matchCount === max;
            }
        };
        var tryMatch = function(matchCount) {
            for (var i = 0; i < ms.length; i++) {
                if (seen[i]) {
                    continue;
                }
                expression.mark();
                if (ms[i].match(expression)) {
                    seen[i] = true;
                    // Increase matchCount iff this was a required element
                    // (or if all the elements are optional)
                    if (tryMatch(matchCount + ((required === false || required[i]) ? 1 : 0))) {
                        expression.drop();
                        return true;
                    }
                    // Backtrack: try *not* matching using this rule, and
                    // let's see if it leads to a better overall match.
                    expression.restore();
                    seen[i] = false;
                } else {
                    expression.drop();
                }
            }
            return success(matchCount);
        };
        if (!tryMatch(0)) {
            // Couldn't get a complete match, retrace our steps to make the
            // match with the maximum # of required elements.
            pass++;
            tryMatch(0);
        }

        if (required === false) {
            return max > 0;
        }
        // Use finer-grained specification of which matchers are required.
        for (var i = 0; i < ms.length; i++) {
            if (required[i] && !seen[i]) {
                return false;
            }
        }
        return true;
    }, function(prec) {
        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;
        var s = ms.map(function(m, i) {
            if (required !== false && !required[i]) {
                return m.toString(Matcher.prec.MOD) + "?";
            }
            return m.toString(p);
        }).join(required === false ? " || " : " && ");
        if (prec > p) {
            s = "[ " + s + " ]";
        }
        return s;
    });
    result.options = ms;
    return result;
};

/**
 * Create a matcher for two or more options, where all options are
 * mandatory but they may appear in any order.
 */
Matcher.andand = function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(true);
    return Matcher.many.apply(Matcher, args);
};

/**
 * Create a matcher for two or more options, where options are
 * optional and may appear in any order, but at least one must be
 * present.
 */
Matcher.oror = function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(false);
    return Matcher.many.apply(Matcher, args);
};

/** Instance methods on Matchers. */
Matcher.prototype = {
    constructor: Matcher,
    // These are expected to be overridden in every instance.
    match: function() { throw new Error("unimplemented"); },
    toString: function() { throw new Error("unimplemented"); },
    // This returns a standalone function to do the matching.
    func: function() { return this.match.bind(this); },
    // Basic combinators
    then: function(m) { return Matcher.seq(this, m); },
    or: function(m) { return Matcher.alt(this, m); },
    andand: function(m) { return Matcher.many(true, this, m); },
    oror: function(m) { return Matcher.many(false, this, m); },
    // Component value multipliers
    star: function() { return this.braces(0, Infinity, "*"); },
    plus: function() { return this.braces(1, Infinity, "+"); },
    question: function() { return this.braces(0, 1, "?"); },
    hash: function() {
        return this.braces(1, Infinity, "#", Matcher.cast(","));
    },
    braces: function(min, max, marker, optSep) {
        var m1 = this, m2 = optSep ? optSep.then(this) : this;
        if (!marker) {
            marker = "{" + min + "," + max + "}";
        }
        return new Matcher(function(expression) {
            var result = true, i;
            for (i = 0; i < max; i++) {
                if (i > 0 && optSep) {
                    result = m2.match(expression);
                } else {
                    result = m1.match(expression);
                }
                if (!result) {
                    break;
                }
            }
            return i >= min;
        }, function() {
            return m1.toString(Matcher.prec.MOD) + marker;
        });
    }
};
},{"../util/StringReader":24,"../util/SyntaxError":25,"./ValidationTypes":21}],4:[function(require,module,exports){
"use strict";

module.exports = MediaFeature;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a media feature, such as max-width:500.
 * @namespace parserlib.css
 * @class MediaFeature
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {SyntaxUnit} name The name of the feature.
 * @param {SyntaxUnit} value The value of the feature or null if none.
 */
function MediaFeature(name, value) {

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;
},{"../util/SyntaxUnit":26,"./Parser":6}],5:[function(require,module,exports){
"use strict";

module.exports = MediaQuery;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents an individual media query.
 * @namespace parserlib.css
 * @class MediaQuery
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} modifier The modifier "not" or "only" (or null).
 * @param {String} mediaType The type of media (i.e., "print").
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function MediaQuery(modifier, mediaType, features, line, col) {

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier ("not" or "only")
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., "print")
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;
}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;
},{"../util/SyntaxUnit":26,"./Parser":6}],6:[function(require,module,exports){
"use strict";

module.exports = Parser;

var EventTarget = require("../util/EventTarget");
var SyntaxError = require("../util/SyntaxError");
var SyntaxUnit = require("../util/SyntaxUnit");

var Combinator = require("./Combinator");
var MediaFeature = require("./MediaFeature");
var MediaQuery = require("./MediaQuery");
var PropertyName = require("./PropertyName");
var PropertyValue = require("./PropertyValue");
var PropertyValuePart = require("./PropertyValuePart");
var Selector = require("./Selector");
var SelectorPart = require("./SelectorPart");
var SelectorSubPart = require("./SelectorSubPart");
var TokenStream = require("./TokenStream");
var Tokens = require("./Tokens");
var Validation = require("./Validation");

/**
 * A CSS3 parser.
 * @namespace parserlib.css
 * @class Parser
 * @constructor
 * @param {Object} options (Optional) Various options for the parser:
 *      starHack (true|false) to allow IE6 star hack as valid,
 *      underscoreHack (true|false) to interpret leading underscores
 *      as IE6-7 targeting for known properties, ieFilters (true|false)
 *      to indicate that IE < 8 filters should be accepted and not throw
 *      syntax errors.
 */
function Parser(options) {

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}

//Static constants
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function() {

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            __proto__: null,

            //restore constructor
            constructor: Parser,

            //instance constants - yuck
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,

            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------

            _stylesheet: function() {

                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");

                //try to read character set
                this._charset();

                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM) {
                    this._import();
                    this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
                    this._namespace();
                    this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while (tt > Tokens.EOF) {

                    try {

                        switch (tt) {
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this._supports();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict) {

                                    //fire error event
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });

                                    //skip braces
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                                        count++;    //keep track of nesting depth
                                    }

                                    while (count) {
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }
                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if (!this._ruleset()) {

                                    //error handling for known issues
                                    switch (tt) {
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }
                                }
                        }
                    } catch (ex) {
                        if (ex instanceof SyntaxError && !this.options.strict) {
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF) {
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit) {
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false) {
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit) {
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList   = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }
            },

            _namespace: function(emit) {
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)) {
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }
            },

            _supports: function(emit) {
                /*
                 * supports_rule
                 *  : SUPPORTS_SYM S* supports_condition S* group_rule_body
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    this._supports_condition();
                    this._readWhitespace();

                    tokenStream.mustMatch(Tokens.LBRACE);
                    this._readWhitespace();

                    if (emit !== false) {
                        this.fire({
                            type:   "startsupports",
                            line:   line,
                            col:    col
                        });
                    }

                    while (true) {
                        if (!this._ruleset()) {
                            break;
                        }
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                    this.fire({
                        type:   "endsupports",
                        line:   line,
                        col:    col
                    });
                }
            },

            _supports_condition: function() {
                /*
                 * supports_condition
                 *  : supports_negation | supports_conjunction | supports_disjunction |
                 *    supports_condition_in_parens
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    ident;

                if (tokenStream.match(Tokens.IDENT)) {
                    ident = tokenStream.token().value.toLowerCase();

                    if (ident === "not") {
                        tokenStream.mustMatch(Tokens.S);
                        this._supports_condition_in_parens();
                    } else {
                        tokenStream.unget();
                    }
                } else {
                    this._supports_condition_in_parens();
                    this._readWhitespace();

                    while (tokenStream.peek() === Tokens.IDENT) {
                        ident = tokenStream.LT(1).value.toLowerCase();
                        if (ident === "and" || ident === "or") {
                            tokenStream.mustMatch(Tokens.IDENT);
                            this._readWhitespace();
                            this._supports_condition_in_parens();
                            this._readWhitespace();
                        }
                    }
                }
            },

            _supports_condition_in_parens: function() {
                /*
                 * supports_condition_in_parens
                 *  : ( '(' S* supports_condition S* ')' ) | supports_declaration_condition |
                 *    general_enclosed
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    ident;

                if (tokenStream.match(Tokens.LPAREN)) {
                    this._readWhitespace();
                    if (tokenStream.match(Tokens.IDENT)) {
                        // look ahead for not keyword, if not given, continue with declaration condition.
                        ident = tokenStream.token().value.toLowerCase();
                        if (ident === "not") {
                            this._readWhitespace();
                            this._supports_condition();
                            this._readWhitespace();
                            tokenStream.mustMatch(Tokens.RPAREN);
                        } else {
                            tokenStream.unget();
                            this._supports_declaration_condition(false);
                        }
                    } else {
                        this._supports_condition();
                        this._readWhitespace();
                        tokenStream.mustMatch(Tokens.RPAREN);
                    }
                } else {
                    this._supports_declaration_condition();
                }
            },

            _supports_declaration_condition: function(requireStartParen) {
                /*
                 * supports_declaration_condition
                 *  : '(' S* declaration ')'
                 *  ;
                 */
                var tokenStream = this._tokenStream;

                if (requireStartParen !== false) {
                    tokenStream.mustMatch(Tokens.LPAREN);
                }
                this._readWhitespace();
                this._declaration();
                tokenStream.mustMatch(Tokens.RPAREN);
            },

            _media: function() {
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while (true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM) {
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
                        this._document();
                    } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {
                        this._supports();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
                        this._media();
                    } else if (!this._ruleset()) {
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },


            //CSS3 Media Queries
            _media_query_list: function() {
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
                    mediaList.push(this._media_query());
                }

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },

            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.

             */
            _media_query: function() {
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)) {
                    ident = tokenStream.token().value.toLowerCase();

                    //since there's no custom tokens for these, need to manually check
                    if (ident !== "only" && ident !== "not") {
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT) {
                    type = this._media_type();
                    if (token === null) {
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN) {
                    if (token === null) {
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0) {
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)) {
                        if (tokenStream.token().value.toLowerCase() !== "and") {
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function() {
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function() {
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)) {
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
            },

            //CSS3 Media Queries
            _media_feature: function() {
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },

            //CSS3 Paged Media
            _page: function() {
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)) {
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto") {
                        this._unexpectedToken(tokenStream.token());
                    }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON) {
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });
            },

            //CSS3 Paged Media
            _margin: function() {
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function() {

                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }
            },

            _pseudo_page: function() {
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
            },

            _font_face: function() {
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function() {
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startviewport",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endviewport",
                    line:   line,
                    col:    col
                });
            },

            _document: function() {
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = "";

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "startdocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });

                var ok = true;
                while (ok) {
                    switch (tokenStream.peek()) {
                        case Tokens.PAGE_SYM:
                            this._page();
                            break;
                        case Tokens.FONT_FACE_SYM:
                            this._font_face();
                            break;
                        case Tokens.VIEWPORT_SYM:
                            this._viewport();
                            break;
                        case Tokens.MEDIA_SYM:
                            this._media();
                            break;
                        case Tokens.KEYFRAMES_SYM:
                            this._keyframes();
                            break;
                        case Tokens.DOCUMENT_SYM:
                            this._document();
                            break;
                        default:
                            ok = Boolean(this._ruleset());
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                token = tokenStream.token();
                this._readWhitespace();

                this.fire({
                    type:      "enddocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });
            },

            _document_function: function() {
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function(inFunction) {

                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))) {
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;
            },

            _combinator: function() {

                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function() {

                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function() {

                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    tokenValue = token.value;

                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) === "_" && this.options.underscoreHack) {
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },

            //Augmented with CSS3 Selectors
            _ruleset: function() {
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict) {

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE) {
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }

                    //trigger parser to continue
                    return true;
                }

                //if it got here, all selectors parsed
                if (selectors) {

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });
                }

                return selectors;
            },

            //CSS3 Selectors
            _selectors_group: function() {

                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null) {

                    selectors.push(selector);
                    while (tokenStream.match(Tokens.COMMA)) {
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null) {
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },

            //CSS3 Selectors
            _selector: function() {
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                    return null;
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this._combinator();

                    if (combinator !== null) {
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();

                        //there must be a next selector
                        if (nextSelector === null) {
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {

                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {

                        //if there's not whitespace, we're done
                        if (this._readWhitespace()) {

                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                            //combinator is not required
                            combinator = this._combinator();

                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null) {
                                if (combinator !== null) {
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null) {
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }
                    }
                } while (true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },

            //CSS3 Selectors
            _simple_selector_sequence: function() {
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,

                    //parts of a simple selector
                    elementName = null,
                    modifiers   = [],

                    //complete selector text
                    selectorText= "",

                    //the different parts after the element name to search for
                    components  = [
                        //HASH
                        function() {
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    line,
                    col;


                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName) {
                    elementName = this._universal();
                }

                if (elementName !== null) {
                    selectorText += elementName;
                }

                while (true) {

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S) {
                        break;
                    }

                    //check for each component
                    while (i < len && component === null) {
                        component = components[i++].call(this);
                    }

                    if (component === null) {

                        //we don't have a selector
                        if (selectorText === "") {
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },

            //CSS3 Selectors
            _type_selector: function() {
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName) {
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns) {
                        tokenStream.unget();
                        if (ns.length > 1) {
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns) {
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },

            //CSS3 Selectors
            _class: function() {
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)) {
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _element_name: function() {
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _namespace_prefix: function() {
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {

                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _universal: function() {
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if (ns) {
                    value += ns;
                }

                if (tokenStream.match(Tokens.STAR)) {
                    value += "*";
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _attrib: function() {
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)) {
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns) {
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _pseudo: function() {

                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)) {

                    if (tokenStream.match(Tokens.COLON)) {
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)) {
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION) {
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo) {
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    } else {
                        var startLine = tokenStream.LT(1).startLine,
                            startCol  = tokenStream.LT(0).startCol;
                        throw new SyntaxError("Expected a `FUNCTION` or `IDENT` after colon at line " + startLine + ", col " + startCol + ".", startLine, startCol);
                    }
                }

                return pseudo;
            },

            //CSS3 Selectors
            _functional_pseudo: function() {
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                    value = null;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },

            //CSS3 Selectors
            _expression: function() {
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = "";

                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])) {

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _negation: function() {
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)) {
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },

            //CSS3 Selectors
            _negation_arg: function() {
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function() {
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while (i < len && arg === null) {

                    arg = args[i].call(this);
                    i++;
                }

                //must be a negation arg
                if (arg === null) {
                    this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName") {
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function() {

                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null) {

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();

                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0) {
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();

                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack === "*" ||
                            this.options.underscoreHack && property.hack === "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function() {
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction) {
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values      = [],
                    //valueParts    = [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null) {

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator) {
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                            valueParts = [];
                        }*/

                        value = this._term(inFunction);

                        if (value === null) {
                            break;
                        } else {
                            values.push(value);
                        }
                    } while (true);
                }

                //cleanup
                /*if (valueParts.length) {
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction) {

                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    part        = null,
                    token,
                    line,
                    col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {

                    value = this._ie_function();
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }

                //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();

                //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {

                    value = tokenStream.token().value;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                        // Correct potentially-inaccurate IDENT parsing in
                        // PropertyValuePart constructor.
                        part = PropertyValuePart.fromToken(tokenStream.token());
                    }
                    this._readWhitespace();
                } else {

                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null) {

                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null) {
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }

                        //has to be a function
                        if (value === null) {

                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null) {
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/
                    } else {
                        value = token.value;
                        if (unary === null) {
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }
                }

                return part !== null ? part : value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;
            },

            _function: function() {

                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;

                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {
                        do {

                            if (this._readWhitespace()) {
                                functionText += tokenStream.token().value;
                            }

                            //might be second time in the loop
                            if (tokenStream.LA(0) === Tokens.COMMA) {
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;

                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function() {

                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()) {
                            functionText += tokenStream.token().value;
                        }

                        //might be second time in the loop
                        if (tokenStream.LA(0) === Tokens.COMMA) {
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;

                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function() {
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if (tokenStream.match(Tokens.HASH)) {

                    //need to do some validation here

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)) {
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------

            _keyframes: function() {

                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();
            },

            _keyframe_name: function() {

                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function() {

                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });
            },

            _key_list: function() {

                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    keyList = [];

                //must be least one key
                keyList.push(this._key());

                this._readWhitespace();

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function() {
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)) {
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },

            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------

            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function() {
                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function(checkStart, readMargins) {
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart) {
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while (true) {

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())) {
                            //noop
                        } else if (this._declaration()) {
                            if (!tokenStream.match(Tokens.SEMICOLON)) {
                                break;
                            }
                        } else {
                            break;
                        }

                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();
                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict) {

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON) {
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.RBRACE) {
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }
            },

            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function() {

                var tokenStream = this._tokenStream,
                    ws = "";

                while (tokenStream.match(Tokens.S)) {
                    ws += tokenStream.token().value;
                }

                return ws;
            },


            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function(token) {
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },

            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function() {
                if (this._tokenStream.LA(1) !== Tokens.EOF) {
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },

            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function(property, value) {
                Validation.validate(property, value);
            },

            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------

            parse: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input) {
                //just passthrough
                return this.parse(input);
            },

            parseMediaQuery: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */
            parsePropertyValue: function(input) {

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function(input) {
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function(input) {

                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void}
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function(input) {
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };

    //copy over onto prototype
    for (prop in additions) {
        if (Object.prototype.hasOwnProperty.call(additions, prop)) {
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();


/*
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
*/
},{"../util/EventTarget":23,"../util/SyntaxError":25,"../util/SyntaxUnit":26,"./Combinator":2,"./MediaFeature":4,"./MediaQuery":5,"./PropertyName":8,"./PropertyValue":9,"./PropertyValuePart":11,"./Selector":13,"./SelectorPart":14,"./SelectorSubPart":15,"./TokenStream":17,"./Tokens":18,"./Validation":19}],7:[function(require,module,exports){
"use strict";

/* exported Properties */

var Properties = module.exports = {
    __proto__: null,

    //A
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "all"                           : "initial | inherit | unset",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : "<time>#",
    "animation-direction"           : "<single-animation-direction>#",
    "animation-duration"            : "<time>#",
    "animation-fill-mode"           : "[ none | forwards | backwards | both ]#",
    "animation-iteration-count"     : "[ <number> | infinite ]#",
    "animation-name"                : "[ none | <single-animation-name> ]#",
    "animation-play-state"          : "[ running | paused ]#",
    "animation-timing-function"     : 1,

    //vendor prefixed
    "-moz-animation-delay"               : "<time>#",
    "-moz-animation-direction"           : "[ normal | alternate ]#",
    "-moz-animation-duration"            : "<time>#",
    "-moz-animation-iteration-count"     : "[ <number> | infinite ]#",
    "-moz-animation-name"                : "[ none | <single-animation-name> ]#",
    "-moz-animation-play-state"          : "[ running | paused ]#",

    "-ms-animation-delay"               : "<time>#",
    "-ms-animation-direction"           : "[ normal | alternate ]#",
    "-ms-animation-duration"            : "<time>#",
    "-ms-animation-iteration-count"     : "[ <number> | infinite ]#",
    "-ms-animation-name"                : "[ none | <single-animation-name> ]#",
    "-ms-animation-play-state"          : "[ running | paused ]#",

    "-webkit-animation-delay"               : "<time>#",
    "-webkit-animation-direction"           : "[ normal | alternate ]#",
    "-webkit-animation-duration"            : "<time>#",
    "-webkit-animation-fill-mode"           : "[ none | forwards | backwards | both ]#",
    "-webkit-animation-iteration-count"     : "[ <number> | infinite ]#",
    "-webkit-animation-name"                : "[ none | <single-animation-name> ]#",
    "-webkit-animation-play-state"          : "[ running | paused ]#",

    "-o-animation-delay"               : "<time>#",
    "-o-animation-direction"           : "[ normal | alternate ]#",
    "-o-animation-duration"            : "<time>#",
    "-o-animation-iteration-count"     : "[ <number> | infinite ]#",
    "-o-animation-name"                : "[ none | <single-animation-name> ]#",
    "-o-animation-play-state"          : "[ running | paused ]#",

    "appearance"                    : "none | auto",
    "-moz-appearance"               : "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
    "-ms-appearance"                : "none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal",
    "-webkit-appearance"            : "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical",
    "-o-appearance"                 : "none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal",

    "azimuth"                       : "<azimuth>",

    //B
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : "<attachment>#",
    "background-clip"               : "<box>#",
    "background-color"              : "<color>",
    "background-image"              : "<bg-image>#",
    "background-origin"             : "<box>#",
    "background-position"           : "<bg-position>",
    "background-repeat"             : "<repeat-style>#",
    "background-size"               : "<bg-size>#",
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color>",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate",
    "border-color"                  : "<color>{1,4}",
    "border-image"                  : 1,
    "border-image-outset"           : "[ <length> | <number> ]{1,4}",
    "border-image-repeat"           : "[ stretch | repeat | round ]{1,2}",
    "border-image-slice"            : "<border-image-slice>",
    "border-image-source"           : "<image> | none",
    "border-image-width"            : "[ <length> | <percentage> | <number> | auto ]{1,4}",
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color>",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : "<border-radius>",
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color>",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : "<length>{1,2}",
    "border-style"                  : "<border-style>{1,4}",
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color>",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : "<border-width>{1,4}",
    "bottom"                        : "<margin-width>",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice | clone",
    "-moz-box-direction"            : "normal | reverse",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-o-box-decoration-break"       : "slice | clone",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice | clone",
    "-webkit-box-direction"         : "normal | reverse",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-decoration-break"          : "slice | clone",
    "box-shadow"                    : "<box-shadow>",
    "box-sizing"                    : "content-box | border-box",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",

    //C
    "caption-side"                  : "top | bottom",
    "clear"                         : "none | right | left | both",
    "clip"                          : "<shape> | auto",
    "-webkit-clip-path"             : "<clip-source> | <clip-path> | none",
    "clip-path"                     : "<clip-source> | <clip-path> | none",
    "clip-rule"                     : "nonzero | evenodd",
    "color"                         : "<color>",
    "color-interpolation"           : "auto | sRGB | linearRGB",
    "color-interpolation-filters"   : "auto | sRGB | linearRGB",
    "color-profile"                 : 1,
    "color-rendering"               : "auto | optimizeSpeed | optimizeQuality",
    "column-count"                  : "<integer> | auto",                      //https://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,

    //D
    "direction"                     : "ltr | rtl",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge",
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "<integer>",

    //E
    "elevation"                     : "<angle> | below | level | above | higher | lower",
    "empty-cells"                   : "show | hide",
    "enable-background"             : 1,

    //F
    "fill"                          : "<paint>",
    "fill-opacity"                  : "<opacity-value>",
    "fill-rule"                     : "nonzero | evenodd",
    "filter"                        : "<filter-function-list> | none",
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none",
    "float-offset"                  : 1,
    "flood-color"                   : 1,
    "flood-opacity"                 : "<opacity-value>",
    "font"                          : "<font-shorthand> | caption | icon | menu | message-box | small-caption | status-bar",
    "font-family"                   : "<font-family>",
    "font-feature-settings"         : "<feature-tag-value> | normal",
    "font-kerning"                  : "auto | normal | none",
    "font-size"                     : "<font-size>",
    "font-size-adjust"              : "<number> | none",
    "font-stretch"                  : "<font-stretch>",
    "font-style"                    : "<font-style>",
    "font-variant"                  : "<font-variant> | normal | none",
    "font-variant-alternates"       : "<font-variant-alternates> | normal",
    "font-variant-caps"             : "<font-variant-caps> | normal",
    "font-variant-east-asian"       : "<font-variant-east-asian> | normal",
    "font-variant-ligatures"        : "<font-variant-ligatures> | normal | none",
    "font-variant-numeric"          : "<font-variant-numeric> | normal",
    "font-variant-position"         : "normal | sub | super",
    "font-weight"                   : "<font-weight>",

    //G
    "glyph-orientation-horizontal"  : "<glyph-angle>",
    "glyph-orientation-vertical"    : "auto | <glyph-angle>",
    "grid"                          : 1,
    "grid-area"                     : 1,
    "grid-auto-columns"             : 1,
    "grid-auto-flow"                : 1,
    "grid-auto-position"            : 1,
    "grid-auto-rows"                : 1,
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-start"             : 1,
    "grid-column-end"               : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-start"                : 1,
    "grid-row-end"                  : 1,
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "grid-template"                 : 1,
    "grid-template-areas"           : 1,
    "grid-template-columns"         : 1,
    "grid-template-rows"            : 1,

    //H
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing>",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",

    //I
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : "auto | optimizeSpeed | optimizeQuality",
    "image-resolution"              : 1,
    "ime-mode"                      : "auto | normal | active | inactive | disabled",
    "inline-box-align"              : "last | <integer>",

    //J
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",

    //K
    "kerning"                       : "auto | <length>",

    //L
    "left"                          : "<margin-width>",
    "letter-spacing"                : "<length> | normal",
    "line-height"                   : "<line-height>",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none",
    "list-style-position"           : "inside | outside",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none",

    //M
    "margin"                        : "<margin-width>{1,4}",
    "margin-bottom"                 : "<margin-width>",
    "margin-left"                   : "<margin-width>",
    "margin-right"                  : "<margin-width>",
    "margin-top"                    : "<margin-width>",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marker"                        : 1,
    "marker-end"                    : 1,
    "marker-mid"                    : 1,
    "marker-start"                  : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "mask"                          : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats",
    "move-to"                       : 1,

    //N
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,

    //O
    "object-fit"                    : "fill | contain | cover | none | scale-down",
    "object-position"               : "<position>",
    "opacity"                       : "<opacity-value>",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer>",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style>",
    "outline-width"                 : "<border-width>",
    "overflow"                      : "visible | hidden | scroll | auto",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,

    //P
    "padding"                       : "<padding-width>{1,4}",
    "padding-bottom"                : "<padding-width>",
    "padding-left"                  : "<padding-width>",
    "padding-right"                 : "<padding-width>",
    "padding-top"                   : "<padding-width>",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right",
    "page-break-before"             : "auto | always | avoid | left | right",
    "page-break-inside"             : "auto | avoid",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all",
    "position"                      : "static | relative | absolute | fixed",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,

    //Q
    "quotes"                        : 1,

    //R
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width>",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,

    //S
    "shape-rendering"               : "auto | optimizeSpeed | crispEdges | geometricPrecision",
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out",
    "speak-header"                  : "once | always",
    "speak-numeral"                 : "digits | continuous",
    "speak-punctuation"             : "code | none",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stop-color"                    : 1,
    "stop-opacity"                  : "<opacity-value>",
    "stress"                        : 1,
    "string-set"                    : 1,
    "stroke"                        : "<paint>",
    "stroke-dasharray"              : "none | <dasharray>",
    "stroke-dashoffset"             : "<percentage> | <length>",
    "stroke-linecap"                : "butt | round | square",
    "stroke-linejoin"               : "miter | round | bevel",
    "stroke-miterlimit"             : "<miterlimit>",
    "stroke-opacity"                : "<opacity-value>",
    "stroke-width"                  : "<percentage> | <length>",

    "table-layout"                  : "auto | fixed",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | match-parent | start | end",
    "text-align-last"               : 1,
    "text-anchor"                   : "start | middle | end",
    "text-decoration"               : "<text-decoration-line> || <text-decoration-style> || <text-decoration-color>",
    "text-decoration-color"         : "<text-decoration-color>",
    "text-decoration-line"          : "<text-decoration-line>",
    "text-decoration-style"         : "<text-decoration-style>",
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage>",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width>",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "touch-action"                  : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,

    //U
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext",
    "user-modify"                   : "read-only | read-write | write-only",
    "user-select"                   : "none | text | toggle | element | elements | all",

    //V
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",
    "visibility"                    : "visible | hidden | collapse",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,

    //W
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap",   // https://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer>",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto",
    "will-change"                   : "<will-change>",
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb",

    //Z
    "z-index"                       : "<integer> | auto",
    "zoom"                          : "<number> | <percentage> | normal"
};
},{}],8:[function(require,module,exports){
"use strict";

module.exports = PropertyName;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class PropertyName
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} hack The type of IE hack applied ("*", "_", or null).
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function PropertyName(text, hack, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied ("*", "_", or null).
     * @type String
     * @property hack
     */
    this.hack = hack;
}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function() {
    return (this.hack ? this.hack : "") + this.text;
};
},{"../util/SyntaxUnit":26,"./Parser":6}],9:[function(require,module,exports){
"use strict";

module.exports = PropertyValue;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just everything single part between ":" and ";". If there are multiple values
 * separated by commas, this type represents just one of the values.
 * @param {String[]} parts An array of value parts making up this value.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValue
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValue(parts, line, col) {

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;
}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;
},{"../util/SyntaxUnit":26,"./Parser":6}],10:[function(require,module,exports){
"use strict";

module.exports = PropertyValueIterator;

/**
 * A utility class that allows for easy iteration over the various parts of a
 * property value.
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.
 * @namespace parserlib.css
 * @class PropertyValueIterator
 * @constructor
 */
function PropertyValueIterator(value) {

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;
}

/**
 * Returns the total number of parts in the value.
 * @return {int} The total number of parts in the value.
 * @method count
 */
PropertyValueIterator.prototype.count = function() {
    return this._parts.length;
};

/**
 * Indicates if the iterator is positioned at the first item.
 * @return {Boolean} True if positioned at first item, false if not.
 * @method isFirst
 */
PropertyValueIterator.prototype.isFirst = function() {
    return this._i === 0;
};

/**
 * Indicates if there are more parts of the property value.
 * @return {Boolean} True if there are more parts, false if not.
 * @method hasNext
 */
PropertyValueIterator.prototype.hasNext = function() {
    return this._i < this._parts.length;
};

/**
 * Marks the current spot in the iteration so it can be restored to
 * later on.
 * @return {void}
 * @method mark
 */
PropertyValueIterator.prototype.mark = function() {
    this._marks.push(this._i);
};

/**
 * Returns the next part of the property value or null if there is no next
 * part. Does not move the internal counter forward.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method peek
 */
PropertyValueIterator.prototype.peek = function(count) {
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};

/**
 * Returns the next part of the property value or null if there is no next
 * part.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method next
 */
PropertyValueIterator.prototype.next = function() {
    return this.hasNext() ? this._parts[this._i++] : null;
};

/**
 * Returns the previous part of the property value or null if there is no
 * previous part.
 * @return {parserlib.css.PropertyValuePart} The previous part of the
 * property value or null if there is no previous part.
 * @method previous
 */
PropertyValueIterator.prototype.previous = function() {
    return this._i > 0 ? this._parts[--this._i] : null;
};

/**
 * Restores the last saved bookmark.
 * @return {void}
 * @method restore
 */
PropertyValueIterator.prototype.restore = function() {
    if (this._marks.length) {
        this._i = this._marks.pop();
    }
};

/**
 * Drops the last saved bookmark.
 * @return {void}
 * @method drop
 */
PropertyValueIterator.prototype.drop = function() {
    this._marks.pop();
};
},{}],11:[function(require,module,exports){
"use strict";

module.exports = PropertyValuePart;

var SyntaxUnit = require("../util/SyntaxUnit");

var Colors = require("./Colors");
var Parser = require("./Parser");
var Tokens = require("./Tokens");

/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just one part of the data between ":" and ";".
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValuePart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValuePart(text, line, col, optionalHint) {
    var hint = optionalHint || {};

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch (this.units.toLowerCase()) {

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;

            case "fr":
                this.type = "grid";
                break;

            case "deg":
            case "rad":
            case "grad":
            case "turn":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;

            //default
        }
    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)) {  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {  //number
        this.type = "number";
        this.value = +RegExp.$1;
    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length === 3) {
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);
        } else {
            this.red    = parseInt(temp.substring(0, 2), 16);
            this.green  = parseInt(temp.substring(2, 4), 16);
            this.blue   = parseInt(temp.substring(4, 6), 16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) { //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) { //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) { //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(("([^\\"]|\\.)*")\)/i.test(text)) { //URI
        // generated by TokenStream.readURI, so always double-quoted.
        this.type   = "uri";
        this.uri    = PropertyValuePart.parseString(RegExp.$1);
    } else if (/^([^\(]+)\(/i.test(text)) {
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)) {    //double-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)) {    //single-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (Colors[text.toLowerCase()]) {  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0, 2), 16);
        this.green  = parseInt(temp.substring(2, 4), 16);
        this.blue   = parseInt(temp.substring(4, 6), 16);
    } else if (/^[,\/]$/.test(text)) {
        this.type   = "operator";
        this.value  = text;
    } else if (/^-?[a-z_\u00A0-\uFFFF][a-z0-9\-_\u00A0-\uFFFF]*$/i.test(text)) {
        this.type   = "identifier";
        this.value  = text;
    }

    // There can be ambiguity with escape sequences in identifiers, as
    // well as with "color" parts which are also "identifiers", so record
    // an explicit hint when the token generating this PropertyValuePart
    // was an identifier.
    this.wasIdent = Boolean(hint.ident);
}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;

/**
 * Helper method to parse a CSS string.
 */
PropertyValuePart.parseString = function(str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
            return "";
        }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
};

/**
 * Helper method to serialize a CSS string.
 */
PropertyValuePart.serializeString = function(value) {
    var replacer = function(match, c) {
        if (c === "\"") {
            return "\\" + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
        return "\\" + cp.toString(16) + " ";
    };
    return "\"" + value.replace(/["\r\n\f]/g, replacer) + "\"";
};

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.css.PropertyValuePart} The object representing the token.
 * @static
 * @method fromToken
 */
PropertyValuePart.fromToken = function(token) {
    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {
        // Tokens can have escaped characters that would fool the type
        // identification in the PropertyValuePart constructor, so pass
        // in a hint if this was an identifier.
        ident: token.type === Tokens.IDENT
    });
    return part;
};
},{"../util/SyntaxUnit":26,"./Colors":1,"./Parser":6,"./Tokens":18}],12:[function(require,module,exports){
"use strict";

var Pseudos = module.exports = {
    __proto__:       null,
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo) {
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
};
},{}],13:[function(require,module,exports){
"use strict";

module.exports = Selector;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");
var Specificity = require("./Specificity");

/**
 * Represents an entire single selector, including all parts but not
 * including multiple selectors (those separated by commas).
 * @namespace parserlib.css
 * @class Selector
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Selector(parts, line, col) {

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);
}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;
},{"../util/SyntaxUnit":26,"./Parser":6,"./Specificity":16}],14:[function(require,module,exports){
"use strict";

module.exports = SelectorPart;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a single part of a selector string, meaning a single set of
 * element name and modifiers. This does not include combinators such as
 * spaces, +, >, etc.
 * @namespace parserlib.css
 * @class SelectorPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} elementName The element name in the selector or null
 *      if there is no element name.
 * @param {Array} modifiers Array of individual modifiers for the element.
 *      May be empty if there are none.
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorPart(elementName, modifiers, text, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;
}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;
},{"../util/SyntaxUnit":26,"./Parser":6}],15:[function(require,module,exports){
"use strict";

module.exports = SelectorSubPart;

var SyntaxUnit = require("../util/SyntaxUnit");

var Parser = require("./Parser");

/**
 * Represents a selector modifier string, meaning a class name, element name,
 * element ID, pseudo rule, etc.
 * @namespace parserlib.css
 * @class SelectorSubPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} type The type of selector modifier.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorSubPart(text, type, line, col) {

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];
}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;
},{"../util/SyntaxUnit":26,"./Parser":6}],16:[function(require,module,exports){
"use strict";

module.exports = Specificity;

var Pseudos = require("./Pseudos");
var SelectorPart = require("./SelectorPart");

/**
 * Represents a selector's specificity.
 * @namespace parserlib.css
 * @class Specificity
 * @constructor
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
 * @param {int} b Number of ID selectors
 * @param {int} c Number of classes and pseudo classes
 * @param {int} d Number of element names and pseudo elements
 */
function Specificity(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,

    /**
     * Compare this specificity to another.
     * @param {Specificity} other The other specificity to compare to.
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
     * @method compare
     */
    compare: function(other) {
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++) {
            if (this[comps[i]] < other[comps[i]]) {
                return -1;
            } else if (this[comps[i]] > other[comps[i]]) {
                return 1;
            }
        }

        return 0;
    },

    /**
     * Creates a numeric value for the specificity.
     * @return {int} The numeric value for the specificity.
     * @method valueOf
     */
    valueOf: function() {
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },

    /**
     * Returns a string representation for specificity.
     * @return {String} The string representation of specificity.
     * @method toString
     */
    toString: function() {
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }
};

/**
 * Calculates the specificity of the given selector.
 * @param {parserlib.css.Selector} The selector to calculate specificity for.
 * @return {parserlib.css.Specificity} The specificity of the selector.
 * @static
 * @method calculate
 */
Specificity.calculate = function(selector) {

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part) {

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) !== "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++) {
            modifier = part.modifiers[i];
            switch (modifier.type) {
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)) {
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++) {
                        updateValues(modifier.args[j]);
                    }
            }
        }
    }

    for (i=0, len=selector.parts.length; i < len; i++) {
        part = selector.parts[i];

        if (part instanceof SelectorPart) {
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};
},{"./Pseudos":12,"./SelectorPart":14}],17:[function(require,module,exports){
"use strict";

module.exports = TokenStream;

var TokenStreamBase = require("../util/TokenStreamBase");

var PropertyValuePart = require("./PropertyValuePart");
var Tokens = require("./Tokens");

var h = /^[0-9a-fA-F]$/,
    nonascii = /^[\u00A0-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/,
    whitespace = /\u0009|\u000a|\u000c|\u000d|\u0020/;

//-----------------------------------------------------------------------------
// Helper functions
//-----------------------------------------------------------------------------


function isHexDigit(c) {
    return c !== null && h.test(c);
}

function isDigit(c) {
    return c !== null && /\d/.test(c);
}

function isWhitespace(c) {
    return c !== null && whitespace.test(c);
}

function isNewLine(c) {
    return c !== null && nl.test(c);
}

function isNameStart(c) {
    return c !== null && /[a-z_\u00A0-\uFFFF\\]/i.test(c);
}

function isNameChar(c) {
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c) {
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier) {
    for (var prop in supplier) {
        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
            receiver[prop] = supplier[prop];
        }
    }
    return receiver;
}

//-----------------------------------------------------------------------------
// CSS Token Stream
//-----------------------------------------------------------------------------


/**
 * A token stream that produces CSS tokens.
 * @param {String|Reader} input The source of text to tokenize.
 * @constructor
 * @class TokenStream
 * @namespace parserlib.css
 */
function TokenStream(input) {
    TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {

    /**
     * Overrides the TokenStreamBase method of the same name
     * to produce CSS tokens.
     * @return {Object} A token object representing the next token.
     * @method _getToken
     * @private
     */
    _getToken: function() {

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while (c) {
            switch (c) {

                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":

                    if (reader.peek() === "*") {
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if (reader.peek() === "=") {
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                    if (isNameChar(reader.peek())) {
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                    if (isDigit(reader.peek())) {
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                    if (reader.peek() === "-") {  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())) {
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - IDENT
                 * - CHAR
                 */
                case "\\":
                    if (/[^\r\n\f]/.test(reader.peek())) {
                        token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                    if (reader.peek() === "+") {
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                    /* falls through */
                default:

                    /*
                     * Potential tokens:
                     * - NUMBER
                     * - DIMENSION
                     * - LENGTH
                     * - FREQ
                     * - TIME
                     * - EMS
                     * - EXS
                     * - ANGLE
                     */
                    if (isDigit(c)) {
                        token = this.numberToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)) {
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - IDENT
                     */
                    if (isIdentStart(c)) {
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                       /*
                        * Potential tokens:
                        * - CHAR
                        * - PLUS
                        */
                        token = this.charToken(c, startLine, startCol);
                    }
            }

            //make sure this token is wanted
            //TODO: check channel
            break;
        }

        if (!token && c === null) {
            token = this.createToken(Tokens.EOF, null, startLine, startCol);
        }

        return token;
    },

    //-------------------------------------------------------------------------
    // Methods to create tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token based on available data and the current
     * reader position information. This method is called by other
     * private methods to create tokens and is never called directly.
     * @param {int} tt The token type.
     * @param {String} value The text value of the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @param {Object} options (Optional) Specifies a channel property
     *      to indicate that a different channel should be scanned
     *      and/or a hide property indicating that the token should
     *      be hidden.
     * @return {Object} A token object.
     * @method createToken
     */
    createToken: function(tt, value, startLine, startCol, options) {
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },

    //-------------------------------------------------------------------------
    // Methods to create specific tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token for any at-rule. If the at-rule is unknown, then
     * the token is for a single "@" character.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method atRuleToken
     */
    atRuleToken: function(first, startLine, startCol) {
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            ident;

        /*
         * First, mark where we are. There are only four @ rules,
         * so anything else is really just an invalid token.
         * Basically, if this doesn't match one of the known @
         * rules, just return '@' as an unknown token and allow
         * parsing to continue after that point.
         */
        reader.mark();

        //try to find the at-keyword
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());

        //if it's not valid, use the first character only and reset the reader
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
            if (rule.length > 1) {
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method charToken
     */
    charToken: function(c, startLine, startCol) {
        var tt = Tokens.type(c);
        var opts = {};

        if (tt === -1) {
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method commentToken
     */
    commentToken: function(first, startLine, startCol) {
        var comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },

    /**
     * Produces a comparison token based on the given character
     * and location in the stream. The next character must be
     * read and is already known to be an equals sign.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method comparisonToken
     */
    comparisonToken: function(c, startLine, startCol) {
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },

    /**
     * Produces a hash token based on the specified information. The
     * first character provided is the pound sign (#) and then this
     * method reads a name afterward.
     * @param {String} first The first character (#) in the hash name.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method hashToken
     */
    hashToken: function(first, startLine, startCol) {
        var name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },

    /**
     * Produces a CDO or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text === "<!--") {
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a CDC or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentEndToken
     */
    htmlCommentEndToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text === "-->") {
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces an IDENT or FUNCTION token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the identifier.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method identOrFunctionToken
     */
    identOrFunctionToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT,
            uriFns  = ["url(", "url-prefix(", "domain("],
            uri;

        //if there's a left paren immediately after, it's a URI or function
        if (reader.peek() === "(") {
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) > -1) {
                reader.mark();
                uri = this.readURI(ident);
                if (uri === null) {
                    //didn't find a valid URL or there's no closing paren
                    reader.reset();
                    tt = Tokens.FUNCTION;
                } else {
                    tt = Tokens.URI;
                    ident = uri;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() === ":") {  //might be an IE function

            //IE-specific functions always being with progid:
            if (ident.toLowerCase() === "progid") {
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },

    /**
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method importantToken
     */
    importantToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while (c) {

            //there can be a comment in here
            if (c === "/") {

                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() !== "*") {
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === "") {    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)) {
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)) {
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)) {
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;
                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt === Tokens.CHAR) {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }
    },

    /**
     * Produces a NOT or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method notToken
     */
    notToken: function(first, startLine, startCol) {
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() === ":not(") {
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a number token based on the given character
     * and location in the stream. This may return a token of
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
     * or PERCENTAGE.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)) {
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)) {
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)) {
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)) {
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }
        } else if (c === "%") {
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a string token based on the given character
     * and location in the stream. Since strings may be indicated
     * by single or double quotes, a failure to match starting
     * and ending quotes results in an INVALID token being generated.
     * The first character in the string is passed in and then
     * the rest are read up to and including the final quotation mark.
     * @param {String} first The first character in the string.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method stringToken
     */
    stringToken: function(first, startLine, startCol) {
        var delim   = first,
            string  = first,
            reader  = this._reader,
            tt      = Tokens.STRING,
            c       = reader.read(),
            i;

        while (c) {
            string += c;

            if (c === "\\") {
                c = reader.read();
                if (c === null) {
                    break; // premature EOF after backslash
                } else if (/[^\r\n\f0-9a-f]/i.test(c)) {
                    // single-character escape
                    string += c;
                } else {
                    // read up to six hex digits
                    for (i=0; isHexDigit(c) && i<6; i++) {
                        string += c;
                        c = reader.read();
                    }
                    // swallow trailing newline or space
                    if (c === "\r" && reader.peek() === "\n") {
                        string += c;
                        c = reader.read();
                    }
                    if (isWhitespace(c)) {
                        string += c;
                    } else {
                        // This character is null or not part of the escape;
                        // jump back to the top to process it.
                        continue;
                    }
                }
            } else if (c === delim) {
                break; // delimiter found.
            } else if (isNewLine(reader.peek())) {
                // newline without an escapement: it's an invalid string
                tt = Tokens.INVALID;
                break;
            }
            c = reader.read();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null) {
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol) {
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() === "+") {
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);

            //ensure there's an actual unicode range here
            if (value.length === 2) {
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") === -1) {

                    if (reader.peek() === "-") {
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);

                        //if there's not another value, back up and just take the first
                        if (temp.length === 1) {
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }
                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a S token based on the specified information. Since whitespace
     * may have multiple characters, this consumes all whitespace characters
     * into a single token.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method whitespaceToken
     */
    whitespaceToken: function(first, startLine, startCol) {
        var value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },


    //-------------------------------------------------------------------------
    // Methods to read values from the string stream
    //-------------------------------------------------------------------------

    readUnicodeRangePart: function(allowQuestionMark) {
        var reader  = this._reader,
            part = "",
            c       = reader.peek();

        //first read hex digits
        while (isHexDigit(c) && part.length < 6) {
            reader.read();
            part += c;
            c = reader.peek();
        }

        //then read question marks if allowed
        if (allowQuestionMark) {
            while (c === "?" && part.length < 6) {
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        //there can't be any other characters after this point

        return part;
    },

    readWhitespace: function() {
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while (isWhitespace(c)) {
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first) {
        var reader  = this._reader,
            number  = first,
            hasDot  = (first === "."),
            c       = reader.peek();


        while (c) {
            if (isDigit(c)) {
                number += reader.read();
            } else if (c === ".") {
                if (hasDot) {
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },

    // returns null w/o resetting reader if string is invalid.
    readString: function() {
        var token = this.stringToken(this._reader.read(), 0, 0);
        return token.type === Tokens.INVALID ? null : token.value;
    },

    // returns null w/o resetting reader if URI is invalid.
    readURI: function(first) {
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        //skip whitespace before
        while (c && isWhitespace(c)) {
            reader.read();
            c = reader.peek();
        }

        //it's a string
        if (c === "'" || c === "\"") {
            inner = this.readString();
            if (inner !== null) {
                inner = PropertyValuePart.parseString(inner);
            }
        } else {
            inner = this.readUnquotedURL();
        }

        c = reader.peek();

        //skip whitespace after
        while (c && isWhitespace(c)) {
            reader.read();
            c = reader.peek();
        }

        //if there was no inner value or the next character isn't closing paren, it's not a URI
        if (inner === null || c !== ")") {
            uri = null;
        } else {
            // Ensure argument to URL is always double-quoted
            // (This simplifies later processing in PropertyValuePart.)
            uri += PropertyValuePart.serializeString(inner) + reader.read();
        }

        return uri;
    },
    // This method never fails, although it may return an empty string.
    readUnquotedURL: function(first) {
        var reader  = this._reader,
            url     = first || "",
            c;

        for (c = reader.peek(); c; c = reader.peek()) {
            // Note that the grammar at
            // https://www.w3.org/TR/CSS2/grammar.html#scanner
            // incorrectly includes the backslash character in the
            // `url` production, although it is correctly omitted in
            // the `baduri1` production.
            if (nonascii.test(c) || /^[\-!#$%&*-\[\]-~]$/.test(c)) {
                url += c;
                reader.read();
            } else if (c === "\\") {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                    url += this.readEscape(reader.read(), true);
                } else {
                    break; // bad escape sequence.
                }
            } else {
                break; // bad character
            }
        }

        return url;
    },

    readName: function(first) {
        var reader  = this._reader,
            ident   = first || "",
            c;

        for (c = reader.peek(); c; c = reader.peek()) {
            if (c === "\\") {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                    ident += this.readEscape(reader.read(), true);
                } else {
                    // Bad escape sequence.
                    break;
                }
            } else if (isNameChar(c)) {
                ident += reader.read();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first, unescape) {
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)) {
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while (c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length === 1) {
            if (/^[^\r\n\f0-9a-f]$/.test(c)) {
                reader.read();
                if (unescape) {
                    return c;
                }
            } else {
                // We should never get here (readName won't call readEscape
                // if the escape sequence is bad).
                throw new Error("Bad escape sequence.");
            }
        } else if (c === "\r") {
            reader.read();
            if (reader.peek() === "\n") {
                c += reader.read();
            }
        } else if (/^[ \t\n\f]$/.test(c)) {
            reader.read();
        } else {
            c = "";
        }

        if (unescape) {
            var cp = parseInt(cssEscape.slice(first.length), 16);
            return String.fromCodePoint ? String.fromCodePoint(cp) :
                String.fromCharCode(cp);
        }
        return cssEscape + c;
    },

    readComment: function(first) {
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c === "*") {
            while (c) {
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c === "*" && reader.peek() === "/") {
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }
    }
});
},{"../util/TokenStreamBase":27,"./PropertyValuePart":11,"./Tokens":18}],18:[function(require,module,exports){
"use strict";

var Tokens = module.exports = [

    /*
     * The following token names are defined in CSS3 Grammar: https://www.w3.org/TR/css3-syntax/#lexical
     */

    // HTML-style comments
    { name: "CDO" },
    { name: "CDC" },

    // ignorables
    { name: "S", whitespace: true/*, channel: "ws"*/ },
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },

    // attribute equality
    { name: "INCLUDES", text: "~=" },
    { name: "DASHMATCH", text: "|=" },
    { name: "PREFIXMATCH", text: "^=" },
    { name: "SUFFIXMATCH", text: "$=" },
    { name: "SUBSTRINGMATCH", text: "*=" },

    // identifier types
    { name: "STRING" },
    { name: "IDENT" },
    { name: "HASH" },

    // at-keywords
    { name: "IMPORT_SYM", text: "@import" },
    { name: "PAGE_SYM", text: "@page" },
    { name: "MEDIA_SYM", text: "@media" },
    { name: "FONT_FACE_SYM", text: "@font-face" },
    { name: "CHARSET_SYM", text: "@charset" },
    { name: "NAMESPACE_SYM", text: "@namespace" },
    { name: "SUPPORTS_SYM", text: "@supports" },
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"] },
    { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"] },
    { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},

    // CSS3 animations
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },

    // important symbol
    { name: "IMPORTANT_SYM" },

    // measurements
    { name: "LENGTH" },
    { name: "ANGLE" },
    { name: "TIME" },
    { name: "FREQ" },
    { name: "DIMENSION" },
    { name: "PERCENTAGE" },
    { name: "NUMBER" },

    // functions
    { name: "URI" },
    { name: "FUNCTION" },

    // Unicode ranges
    { name: "UNICODE_RANGE" },

    /*
     * The following token names are defined in CSS3 Selectors: https://www.w3.org/TR/css3-selectors/#selector-syntax
     */

    // invalid string
    { name: "INVALID" },

    // combinators
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">" },
    { name: "COMMA", text: "," },
    { name: "TILDE", text: "~" },

    // modifier
    { name: "NOT" },

    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner" },
    { name: "TOPLEFT_SYM", text: "@top-left" },
    { name: "TOPCENTER_SYM", text: "@top-center" },
    { name: "TOPRIGHT_SYM", text: "@top-right" },
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner" },
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner" },
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left" },
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center" },
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right" },
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner" },
    { name: "LEFTTOP_SYM", text: "@left-top" },
    { name: "LEFTMIDDLE_SYM", text: "@left-middle" },
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom" },
    { name: "RIGHTTOP_SYM", text: "@right-top" },
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle" },
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom" },

    /*
     * The following token names are defined in CSS3 Media Queries: https://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media" },

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */

    // not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    // part of CSS3 grammar but not the Flex code
    { name: "CHAR" },

    // TODO: Needed?
    // Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },
    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function() {
    var nameMap = [],
        typeMap = Object.create(null);

    Tokens.UNKNOWN = -1;
    Tokens.unshift({ name:"EOF" });
    for (var i=0, len = Tokens.length; i < len; i++) {
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text) {
            if (Tokens[i].text instanceof Array) {
                for (var j=0; j < Tokens[i].text.length; j++) {
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt) {
        return nameMap[tt];
    };

    Tokens.type = function(c) {
        return typeMap[c] || -1;
    };
})();
},{}],19:[function(require,module,exports){
"use strict";

/* exported Validation */

var Matcher = require("./Matcher");
var Properties = require("./Properties");
var ValidationTypes = require("./ValidationTypes");
var ValidationError = require("./ValidationError");
var PropertyValueIterator = require("./PropertyValueIterator");

var Validation = module.exports = {

    validate: function(property, value) {

        //normalize name
        var name        = property.toString().toLowerCase(),
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name],
            part;

        if (!spec) {
            if (name.indexOf("-") !== 0) {    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec !== "number") {

            // All properties accept some CSS-wide values.
            // https://drafts.csswg.org/css-values-3/#common-keywords
            if (ValidationTypes.isAny(expression, "inherit | initial | unset")) {
                if (expression.hasNext()) {
                    part = expression.next();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                }
                return;
            }

            // Property-specific validation.
            this.singleProperty(spec, expression);
        }
    },

    singleProperty: function(types, expression) {

        var result      = false,
            value       = expression.value,
            part;

        result = Matcher.parse(types).match(expression);

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + ValidationTypes.describe(types) + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }
};
},{"./Matcher":3,"./Properties":7,"./PropertyValueIterator":10,"./ValidationError":20,"./ValidationTypes":21}],20:[function(require,module,exports){
"use strict";

module.exports = ValidationError;

/**
 * Type to use when a validation error occurs.
 * @class ValidationError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function ValidationError(message, line, col) {

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;
}

//inherit from Error
ValidationError.prototype = new Error();
},{}],21:[function(require,module,exports){
"use strict";

var ValidationTypes = module.exports;

var Matcher = require("./Matcher");

function copy(to, from) {
    Object.keys(from).forEach(function(prop) {
        to[prop] = from[prop];
    });
}
copy(ValidationTypes, {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0, len=args.length; i < len && !found; i++) {
            if (args[i].charAt(0) === "<") {
                found = this.simple[args[i]](part);
            } else if (args[i].slice(-2) === "()") {
                found = (part.type === "function" &&
                         part.name === args[i].slice(0, -2));
            } else if (text === args[i].toLowerCase()) {
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return Boolean(this.simple[type]);
    },

    isComplex: function(type) {
        return Boolean(this.complex[type]);
    },

    describe: function(type) {
        if (this.complex[type] instanceof Matcher) {
            return this.complex[type].toString(0);
        }
        return type;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are any of the given types.
     */
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0, len=args.length; i < len && !found && expression.hasNext(); i++) {
            found = this.isType(expression, args[i]);
        }

        return found;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are one of a group.
     */
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0, len=args.length; i < len && !found; i++) {
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are of a given type.
     */
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) !== "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else if (this.complex[type] instanceof Matcher) {
            result = this.complex[type].match(expression);
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },


    simple: {
        __proto__: null,

        "<absolute-size>":
            "xx-small | x-small | small | medium | large | x-large | xx-large",

        "<animateable-feature>":
            "scroll-position | contents | <animateable-feature-name>",

        "<animateable-feature-name>": function(part) {
            return this["<ident>"](part) &&
                !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);
        },

        "<angle>": function(part) {
            return part.type === "angle";
        },

        "<attachment>": "scroll | fixed | local",

        "<attr>": "attr()",

        // inset() = inset( <shape-arg>{1,4} [round <border-radius>]? )
        // circle() = circle( [<shape-radius>]? [at <position>]? )
        // ellipse() = ellipse( [<shape-radius>{2}]? [at <position>]? )
        // polygon() = polygon( [<fill-rule>,]? [<shape-arg> <shape-arg>]# )
        "<basic-shape>": "inset() | circle() | ellipse() | polygon()",

        "<bg-image>": "<image> | <gradient> | none",

        "<border-style>":
            "none | hidden | dotted | dashed | solid | double | groove | " +
            "ridge | inset | outset",

        "<border-width>": "<length> | thin | medium | thick",

        "<box>": "padding-box | border-box | content-box",

        "<clip-source>": "<uri>",

        "<color>": function(part) {
            return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
        },

        // The SVG <color> spec doesn't include "currentColor" or "transparent" as a color.
        "<color-svg>": function(part) {
            return part.type === "color";
        },

        "<content>": "content()",

        // https://www.w3.org/TR/css3-sizing/#width-height-keywords
        "<content-sizing>":
            "fill-available | -moz-available | -webkit-fill-available | " +
            "max-content | -moz-max-content | -webkit-max-content | " +
            "min-content | -moz-min-content | -webkit-min-content | " +
            "fit-content | -moz-fit-content | -webkit-fit-content",

        "<feature-tag-value>": function(part) {
            return part.type === "function" && /^[A-Z0-9]{4}$/i.test(part);
        },

        // custom() isn't actually in the spec
        "<filter-function>":
            "blur() | brightness() | contrast() | custom() | " +
            "drop-shadow() | grayscale() | hue-rotate() | invert() | " +
            "opacity() | saturate() | sepia()",

        "<flex-basis>": "<width>",

        "<flex-direction>": "row | row-reverse | column | column-reverse",

        "<flex-grow>": "<number>",

        "<flex-shrink>": "<number>",

        "<flex-wrap>": "nowrap | wrap | wrap-reverse",

        "<font-size>":
            "<absolute-size> | <relative-size> | <length> | <percentage>",

        "<font-stretch>":
            "normal | ultra-condensed | extra-condensed | condensed | " +
            "semi-condensed | semi-expanded | expanded | extra-expanded | " +
            "ultra-expanded",

        "<font-style>": "normal | italic | oblique",

        "<font-variant-caps>":
            "small-caps | all-small-caps | petite-caps | all-petite-caps | " +
            "unicase | titling-caps",

        "<font-variant-css21>": "normal | small-caps",

        "<font-weight>":
            "normal | bold | bolder | lighter | " +
            "100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900",

        "<generic-family>":
            "serif | sans-serif | cursive | fantasy | monospace",

        "<geometry-box>": "<shape-box> | fill-box | stroke-box | view-box",

        "<glyph-angle>": function(part) {
            return part.type === "angle" && part.units === "deg";
        },

        "<gradient>": function(part) {
            return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<icccolor>":
            "cielab() | cielch() | cielchab() | " +
            "icc-color() | icc-named-color()",

        //any identifier
        "<ident>": function(part) {
            return part.type === "identifier" || part.wasIdent;
        },

        "<ident-not-generic-family>": function(part) {
            return this["<ident>"](part) && !this["<generic-family>"](part);
        },

        "<image>": "<uri>",

        "<integer>": function(part) {
            return part.type === "integer";
        },

        "<length>": function(part) {
            if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)) {
                return true;
            } else {
                return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
            }
        },

        "<line>": function(part) {
            return part.type === "integer";
        },

        "<line-height>": "<number> | <length> | <percentage> | normal",

        "<margin-width>": "<length> | <percentage> | auto",

        "<miterlimit>": function(part) {
            return this["<number>"](part) && part.value >= 1;
        },

        "<nonnegative-length-or-percentage>": function(part) {
            return (this["<length>"](part) || this["<percentage>"](part)) &&
                (String(part) === "0" || part.type === "function" || (part.value) >= 0);
        },

        "<nonnegative-number-or-percentage>": function(part) {
            return (this["<number>"](part) || this["<percentage>"](part)) &&
                (String(part) === "0" || part.type === "function" || (part.value) >= 0);
        },

        "<number>": function(part) {
            return part.type === "number" || this["<integer>"](part);
        },

        "<opacity-value>": function(part) {
            return this["<number>"](part) && part.value >= 0 && part.value <= 1;
        },

        "<padding-width>": "<nonnegative-length-or-percentage>",

        "<percentage>": function(part) {
            return part.type === "percentage" || String(part) === "0";
        },

        "<relative-size>": "smaller | larger",

        "<shape>": "rect() | inset-rect()",

        "<shape-box>": "<box> | margin-box",

        "<single-animation-direction>":
            "normal | reverse | alternate | alternate-reverse",

        "<single-animation-name>": function(part) {
            return this["<ident>"](part) &&
                /^-?[a-z_][-a-z0-9_]+$/i.test(part) &&
                !/^(none|unset|initial|inherit)$/i.test(part);
        },

        "<string>": function(part) {
            return part.type === "string";
        },

        "<time>": function(part) {
            return part.type === "time";
        },

        "<uri>": function(part) {
            return part.type === "uri";
        },

        "<width>": "<margin-width>"
    },

    complex: {
        __proto__: null,

        "<azimuth>":
            "<angle>" +
            " | " +
            "[ [ left-side | far-left | left | center-left | center | " +
            "center-right | right | far-right | right-side ] || behind ]" +
            " | "+
            "leftwards | rightwards",

        "<bg-position>": "<position>#",

        "<bg-size>":
            "[ <length> | <percentage> | auto ]{1,2} | cover | contain",

        "<border-image-slice>":
        // [<number> | <percentage>]{1,4} && fill?
        // *but* fill can appear between any of the numbers
        Matcher.many([true /* first element is required */],
                     Matcher.cast("<nonnegative-number-or-percentage>"),
                     Matcher.cast("<nonnegative-number-or-percentage>"),
                     Matcher.cast("<nonnegative-number-or-percentage>"),
                     Matcher.cast("<nonnegative-number-or-percentage>"),
                     "fill"),

        "<border-radius>":
            "<nonnegative-length-or-percentage>{1,4} " +
            "[ / <nonnegative-length-or-percentage>{1,4} ]?",

        "<box-shadow>": "none | <shadow>#",

        "<clip-path>": "<basic-shape> || <geometry-box>",

        "<dasharray>":
        // "list of comma and/or white space separated <length>s and
        // <percentage>s".  There is a non-negative constraint.
        Matcher.cast("<nonnegative-length-or-percentage>")
            .braces(1, Infinity, "#", Matcher.cast(",").question()),

        "<family-name>":
            // <string> | <IDENT>+
            "<string> | <ident-not-generic-family> <ident>*",

        "<filter-function-list>": "[ <filter-function> | <uri> ]+",

        // https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
        "<flex>":
            "none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]",

        "<font-family>": "[ <generic-family> | <family-name> ]#",

        "<font-shorthand>":
            "[ <font-style> || <font-variant-css21> || " +
            "<font-weight> || <font-stretch> ]? <font-size> " +
            "[ / <line-height> ]? <font-family>",

        "<font-variant-alternates>":
            // stylistic(<feature-value-name>)
            "stylistic() || " +
            "historical-forms || " +
            // styleset(<feature-value-name> #)
            "styleset() || " +
            // character-variant(<feature-value-name> #)
            "character-variant() || " +
            // swash(<feature-value-name>)
            "swash() || " +
            // ornaments(<feature-value-name>)
            "ornaments() || " +
            // annotation(<feature-value-name>)
            "annotation()",

        "<font-variant-ligatures>":
            // <common-lig-values>
            "[ common-ligatures | no-common-ligatures ] || " +
            // <discretionary-lig-values>
            "[ discretionary-ligatures | no-discretionary-ligatures ] || " +
            // <historical-lig-values>
            "[ historical-ligatures | no-historical-ligatures ] || " +
            // <contextual-alt-values>
            "[ contextual | no-contextual ]",

        "<font-variant-numeric>":
            // <numeric-figure-values>
            "[ lining-nums | oldstyle-nums ] || " +
            // <numeric-spacing-values>
            "[ proportional-nums | tabular-nums ] || " +
            // <numeric-fraction-values>
            "[ diagonal-fractions | stacked-fractions ] || " +
            "ordinal || slashed-zero",

        "<font-variant-east-asian>":
            // <east-asian-variant-values>
            "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || " +
            // <east-asian-width-values>
            "[ full-width | proportional-width ] || " +
            "ruby",

        // Note that <color> here is "as defined in the SVG spec", which
        // is more restrictive that the <color> defined in the CSS spec.
        // none | currentColor | <color> [<icccolor>]? |
        // <funciri> [ none | currentColor | <color> [<icccolor>]? ]?
        "<paint>": "<paint-basic> | <uri> <paint-basic>?",

        // Helper definition for <paint> above.
        "<paint-basic>": "none | currentColor | <color-svg> <icccolor>?",

        "<position>":
            // Because our `alt` combinator is ordered, we need to test these
            // in order from longest possible match to shortest.
            "[ center | [ left | right ] [ <percentage> | <length> ]? ] && " +
            "[ center | [ top | bottom ] [ <percentage> | <length> ]? ]" +
            " | " +
            "[ left | center | right | <percentage> | <length> ] " +
            "[ top | center | bottom | <percentage> | <length> ]" +
            " | " +
            "[ left | center | right | top | bottom | <percentage> | <length> ]",

        "<repeat-style>":
            "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}",

        "<shadow>":
        //inset? && [ <length>{2,4} && <color>? ]
        Matcher.many([true /* length is required */],
                     Matcher.cast("<length>").braces(2, 4), "inset", "<color>"),

        "<text-decoration-color>":
           "<color>",

        "<text-decoration-line>":
            "none | [ underline || overline || line-through || blink ]",

        "<text-decoration-style>":
            "solid | double | dotted | dashed | wavy",

        "<will-change>":
            "auto | <animateable-feature>#",

        "<x-one-radius>":
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            "[ <length> | <percentage> ]{1,2}"
    }
});

Object.keys(ValidationTypes.simple).forEach(function(nt) {
    var rule = ValidationTypes.simple[nt];
    if (typeof rule === "string") {
        ValidationTypes.simple[nt] = function(part) {
            return ValidationTypes.isLiteral(part, rule);
        };
    }
});

Object.keys(ValidationTypes.complex).forEach(function(nt) {
    var rule = ValidationTypes.complex[nt];
    if (typeof rule === "string") {
        ValidationTypes.complex[nt] = Matcher.parse(rule);
    }
});

// Because this is defined relative to other complex validation types,
// we need to define it *after* the rest of the types are initialized.
ValidationTypes.complex["<font-variant>"] =
    Matcher.oror({ expand: "<font-variant-ligatures>" },
                 { expand: "<font-variant-alternates>" },
                 "<font-variant-caps>",
                 { expand: "<font-variant-numeric>" },
                 { expand: "<font-variant-east-asian>" });
},{"./Matcher":3}],22:[function(require,module,exports){
"use strict";

module.exports = {
    Colors            : require("./Colors"),
    Combinator        : require("./Combinator"),
    Parser            : require("./Parser"),
    PropertyName      : require("./PropertyName"),
    PropertyValue     : require("./PropertyValue"),
    PropertyValuePart : require("./PropertyValuePart"),
    Matcher           : require("./Matcher"),
    MediaFeature      : require("./MediaFeature"),
    MediaQuery        : require("./MediaQuery"),
    Selector          : require("./Selector"),
    SelectorPart      : require("./SelectorPart"),
    SelectorSubPart   : require("./SelectorSubPart"),
    Specificity       : require("./Specificity"),
    TokenStream       : require("./TokenStream"),
    Tokens            : require("./Tokens"),
    ValidationError   : require("./ValidationError")
};
},{"./Colors":1,"./Combinator":2,"./Matcher":3,"./MediaFeature":4,"./MediaQuery":5,"./Parser":6,"./PropertyName":8,"./PropertyValue":9,"./PropertyValuePart":11,"./Selector":13,"./SelectorPart":14,"./SelectorSubPart":15,"./Specificity":16,"./TokenStream":17,"./Tokens":18,"./ValidationError":20}],23:[function(require,module,exports){
"use strict";

module.exports = EventTarget;

/**
 * A generic base to inherit from for any object
 * that needs event handling.
 * @class EventTarget
 * @constructor
 */
function EventTarget() {

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}

EventTarget.prototype = {

    //restore constructor
    constructor: EventTarget,

    /**
     * Adds a listener for a given event type.
     * @param {String} type The type of event to add a listener for.
     * @param {Function} listener The function to call when the event occurs.
     * @return {void}
     * @method addListener
     */
    addListener: function(type, listener) {
        if (!this._listeners[type]) {
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },

    /**
     * Fires an event based on the passed-in object.
     * @param {Object|String} event An object with at least a 'type' attribute
     *      or a string indicating the event name.
     * @return {void}
     * @method fire
     */
    fire: function(event) {
        if (typeof event === "string") {
            event = { type: event };
        }
        if (typeof event.target !== "undefined") {
            event.target = this;
        }

        if (typeof event.type === "undefined") {
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]) {

            //create a copy of the array and use that so listeners can't chane
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++) {
                listeners[i].call(this, event);
            }
        }
    },

    /**
     * Removes a listener for a given event type.
     * @param {String} type The type of event to remove a listener from.
     * @param {Function} listener The function to remove from the event.
     * @return {void}
     * @method removeListener
     */
    removeListener: function(type, listener) {
        if (this._listeners[type]) {
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++) {
                if (listeners[i] === listener) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    }
};
},{}],24:[function(require,module,exports){
"use strict";

module.exports = StringReader;

/**
 * Convenient way to read through strings.
 * @namespace parserlib.util
 * @class StringReader
 * @constructor
 * @param {String} text The text to read.
 */
function StringReader(text) {

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r\n?|\n)/g, "\n");


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}

StringReader.prototype = {

    // restore constructor
    constructor: StringReader,

    //-------------------------------------------------------------------------
    // Position info
    //-------------------------------------------------------------------------

    /**
     * Returns the column of the character to be read next.
     * @return {int} The column of the character to be read next.
     * @method getCol
     */
    getCol: function() {
        return this._col;
    },

    /**
     * Returns the row of the character to be read next.
     * @return {int} The row of the character to be read next.
     * @method getLine
     */
    getLine: function() {
        return this._line;
    },

    /**
     * Determines if you're at the end of the input.
     * @return {Boolean} True if there's no more input, false otherwise.
     * @method eof
     */
    eof: function() {
        return this._cursor === this._input.length;
    },

    //-------------------------------------------------------------------------
    // Basic reading
    //-------------------------------------------------------------------------

    /**
     * Reads the next character without advancing the cursor.
     * @param {int} count How many characters to look ahead (default is 1).
     * @return {String} The next character or null if there is no next character.
     * @method peek
     */
    peek: function(count) {
        var c = null;
        count = typeof count === "undefined" ? 1 : count;

        // if we're not at the end of the input...
        if (this._cursor < this._input.length) {

            // get character and increment cursor and column
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },

    /**
     * Reads the next character from the input and adjusts the row and column
     * accordingly.
     * @return {String} The next character or null if there is no next character.
     * @method read
     */
    read: function() {
        var c = null;

        // if we're not at the end of the input...
        if (this._cursor < this._input.length) {

            // if the last character was a newline, increment row count
            // and reset column count
            if (this._input.charAt(this._cursor) === "\n") {
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }

            // get character and increment cursor and column
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },

    //-------------------------------------------------------------------------
    // Misc
    //-------------------------------------------------------------------------

    /**
     * Saves the current location so it can be returned to later.
     * @method mark
     * @return {void}
     */
    mark: function() {
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function() {
        if (this._bookmark) {
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },

    //-------------------------------------------------------------------------
    // Advanced reading
    //-------------------------------------------------------------------------

    /**
     * Reads up to and including the given string. Throws an error if that
     * string is not found.
     * @param {String} pattern The string to read.
     * @return {String} The string when it is found.
     * @throws Error when the string pattern is not found.
     * @method readTo
     */
    readTo: function(pattern) {

        var buffer = "",
            c;

        /*
         * First, buffer must be the same length as the pattern.
         * Then, buffer must end with the pattern or else reach the
         * end of the input.
         */
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
            c = this.read();
            if (c) {
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;
    },

    /**
     * Reads characters while each character causes the given
     * filter function to return true. The function is passed
     * in each character and either returns true to continue
     * reading or false to stop.
     * @param {Function} filter The function to read on each character.
     * @return {String} The string made up of all characters that passed the
     *      filter check.
     * @method readWhile
     */
    readWhile: function(filter) {

        var buffer = "",
            c = this.peek();

        while (c !== null && filter(c)) {
            buffer += this.read();
            c = this.peek();
        }

        return buffer;
    },

    /**
     * Reads characters that match either text or a regular expression and
     * returns those characters. If a match is found, the row and column
     * are adjusted; if no match is found, the reader's state is unchanged.
     * reading or false to stop.
     * @param {String|RegExp} matcher If a string, then the literal string
     *      value is searched for. If a regular expression, then any string
     *      matching the pattern is search for.
     * @return {String} The string made up of all characters that matched or
     *      null if there was no match.
     * @method readMatch
     */
    readMatch: function(matcher) {

        var source = this._input.substring(this._cursor),
            value = null;

        // if it's a string, just do a straight match
        if (typeof matcher === "string") {
            if (source.slice(0, matcher.length) === matcher) {
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp) {
            if (matcher.test(source)) {
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },


    /**
     * Reads a given number of characters. If the end of the input is reached,
     * it reads only the remaining characters and does not throw an error.
     * @param {int} count The number of characters to read.
     * @return {String} The string made up the read characters.
     * @method readCount
     */
    readCount: function(count) {
        var buffer = "";

        while (count--) {
            buffer += this.read();
        }

        return buffer;
    }
};
},{}],25:[function(require,module,exports){
"use strict";

module.exports = SyntaxError;

/**
 * Type to use when a syntax error occurs.
 * @class SyntaxError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function SyntaxError(message, line, col) {
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;
}

//inherit from Error
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
},{}],26:[function(require,module,exports){
"use strict";

module.exports = SyntaxUnit;

/**
 * Base type to represent a single syntactic unit.
 * @class SyntaxUnit
 * @namespace parserlib.util
 * @constructor
 * @param {String} text The text of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SyntaxUnit(text, line, col, type) {


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.util.SyntaxUnit} The object representing the token.
 * @static
 * @method fromToken
 */
SyntaxUnit.fromToken = function(token) {
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {

    //restore constructor
    constructor: SyntaxUnit,

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method valueOf
     */
    valueOf: function() {
        return this.toString();
    },

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method toString
     */
    toString: function() {
        return this.text;
    }
};
},{}],27:[function(require,module,exports){
"use strict";

module.exports = TokenStreamBase;

var StringReader = require("./StringReader");
var SyntaxError = require("./SyntaxError");

/**
 * Generic TokenStream providing base functionality.
 * @class TokenStreamBase
 * @namespace parserlib.util
 * @constructor
 * @param {String|StringReader} input The text to tokenize or a reader from
 *      which to read the input.
 */
function TokenStreamBase(input, tokenData) {

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = new StringReader(input ? input.toString() : "");

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}

/**
 * Accepts an array of token information and outputs
 * an array of token data containing key-value mappings
 * and matching functions that the TokenStream needs.
 * @param {Array} tokens An array of token descriptors.
 * @return {Array} An array of processed token data.
 * @method createTokenData
 * @static
 */
TokenStreamBase.createTokenData = function(tokens) {

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({ name:"EOF" });

    for (; i < len; i++) {
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text) {
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt) {
        return nameMap[tt];
    };

    tokenData.type = function(c) {
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {

    //restore constructor
    constructor: TokenStreamBase,

    //-------------------------------------------------------------------------
    // Matching methods
    //-------------------------------------------------------------------------

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, the token is placed
     * back onto the token stream. You can pass in any number of
     * token types and this will return true if any of the token
     * types is found.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token might be. If an array is passed,
     *      it's assumed that the token can be any of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {Boolean} True if the token type matches, false if not.
     * @method match
     */
    match: function(tokenTypes, channel) {

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while (i < len) {
            if (tt === tokenTypes[i++]) {
                return true;
            }
        }

        //no match found, put the token back
        this.unget();
        return false;
    },

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, an error is thrown.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @return {void}
     * @method mustMatch
     */
    mustMatch: function(tokenTypes) {

        var token;

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)) {
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },

    //-------------------------------------------------------------------------
    // Consuming methods
    //-------------------------------------------------------------------------

    /**
     * Keeps reading from the token stream until either one of the specified
     * token types is found or until the end of the input is reached.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method advance
     */
    advance: function(tokenTypes, channel) {

        while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {
            this.get();
        }

        return this.LA(0);
    },

    /**
     * Consumes the next token from the token stream.
     * @return {int} The token type of the token that was just consumed.
     * @method get
     */
    get: function(channel) {

        var tokenInfo   = this._tokenData,
            i           =0,
            token,
            info;

        //check the lookahead buffer first
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];

            //obey channels logic
            while ((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length) {
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }

            //here be dragons
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length) {
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }

        //call token retriever method
        token = this._getToken();

        //if it should be hidden, don't save a token
        if (token.type > -1 && !tokenInfo[token.type].hide) {

            //apply token channel
            token.channel = tokenInfo[token.type].channel;

            //save for later
            this._token = token;
            this._lt.push(token);

            //save space that will be moved (must be done before array is truncated)
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

            //keep the buffer under 5 items
            if (this._lt.length > 5) {
                this._lt.shift();
            }

            //also keep the shift buffer under 5 items
            if (this._ltIndexCache.length > 5) {
                this._ltIndexCache.shift();
            }

            //update lookahead index
            this._ltIndex = this._lt.length;
        }

        /*
         * Skip to the next token if:
         * 1. The token type is marked as hidden.
         * 2. The token type has a channel specified and it isn't the current channel.
         */
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))) {
            return this.get(channel);
        } else {
            //return just the type
            return token.type;
        }
    },

    /**
     * Looks ahead a certain number of tokens and returns the token type at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {int} The token type of the token in the given position.
     * @method LA
     */
    LA: function(index) {
        var total = index,
            tt;
        if (index > 0) {
            //TODO: Store 5 somewhere
            if (index > 5) {
                throw new Error("Too much lookahead.");
            }

            //get all those tokens
            while (total) {
                tt = this.get();
                total--;
            }

            //unget all those tokens
            while (total < index) {
                this.unget();
                total++;
            }
        } else if (index < 0) {

            if (this._lt[this._ltIndex+index]) {
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }
        } else {
            tt = this._token.type;
        }

        return tt;
    },

    /**
     * Looks ahead a certain number of tokens and returns the token at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {Object} The token of the token in the given position.
     * @method LA
     */
    LT: function(index) {

        //lookahead first to prime the token buffer
        this.LA(index);

        //now find the token, subtract one because _ltIndex is already at the next index
        return this._lt[this._ltIndex+index-1];
    },

    /**
     * Returns the token type for the next token in the stream without
     * consuming it.
     * @return {int} The token type of the next token in the stream.
     * @method peek
     */
    peek: function() {
        return this.LA(1);
    },

    /**
     * Returns the actual token object for the last consumed token.
     * @return {Token} The token object for the last consumed token.
     * @method token
     */
    token: function() {
        return this._token;
    },

    /**
     * Returns the name of the token for the given token type.
     * @param {int} tokenType The type of token to get the name of.
     * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
     *      invalid token type.
     * @method tokenName
     */
    tokenName: function(tokenType) {
        if (tokenType < 0 || tokenType > this._tokenData.length) {
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },

    /**
     * Returns the token type value for the given token name.
     * @param {String} tokenName The name of the token whose value should be returned.
     * @return {int} The token type value for the given token name or -1
     *      for an unknown token.
     * @method tokenName
     */
    tokenType: function(tokenName) {
        return this._tokenData[tokenName] || -1;
    },

    /**
     * Returns the last consumed token to the token stream.
     * @method unget
     */
    unget: function() {
        //if (this._ltIndex > -1) {
        if (this._ltIndexCache.length) {
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }
};
},{"./StringReader":24,"./SyntaxError":25}],28:[function(require,module,exports){
"use strict";

module.exports = {
    StringReader    : require("./StringReader"),
    SyntaxError     : require("./SyntaxError"),
    SyntaxUnit      : require("./SyntaxUnit"),
    EventTarget     : require("./EventTarget"),
    TokenStreamBase : require("./TokenStreamBase")
};
},{"./EventTarget":23,"./StringReader":24,"./SyntaxError":25,"./SyntaxUnit":26,"./TokenStreamBase":27}],"parserlib":[function(require,module,exports){
"use strict";

module.exports = {
    css  : require("./css"),
    util : require("./util")
};
},{"./css":22,"./util":28}]},{},[]);

return require('parserlib');
})();
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      child = new Buffer(parent.length);
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

/**
 * Main CSSLint object.
 * @class CSSLint
 * @static
 * @extends parserlib.util.EventTarget
 */

/* global parserlib, clone, Reporter */
/* exported CSSLint */

var CSSLint = (function() {
    "use strict";

    var rules           = [],
        formatters      = [],
        embeddedRuleset = /\/\*\s*csslint([^\*]*)\*\//,
        api             = new parserlib.util.EventTarget();

    api.version = "1.0.5";

    //-------------------------------------------------------------------------
    // Rule Management
    //-------------------------------------------------------------------------

    /**
     * Adds a new rule to the engine.
     * @param {Object} rule The rule to add.
     * @method addRule
     */
    api.addRule = function(rule) {
        rules.push(rule);
        rules[rule.id] = rule;
    };

    /**
     * Clears all rule from the engine.
     * @method clearRules
     */
    api.clearRules = function() {
        rules = [];
    };

    /**
     * Returns the rule objects.
     * @return An array of rule objects.
     * @method getRules
     */
    api.getRules = function() {
        return [].concat(rules).sort(function(a, b) {
            return a.id > b.id ? 1 : 0;
        });
    };

    /**
     * Returns a ruleset configuration object with all current rules.
     * @return A ruleset object.
     * @method getRuleset
     */
    api.getRuleset = function() {
        var ruleset = {},
            i = 0,
            len = rules.length;

        while (i < len) {
            ruleset[rules[i++].id] = 1;    // by default, everything is a warning
        }

        return ruleset;
    };

    /**
     * Returns a ruleset object based on embedded rules.
     * @param {String} text A string of css containing embedded rules.
     * @param {Object} ruleset A ruleset object to modify.
     * @return {Object} A ruleset object.
     * @method getEmbeddedRuleset
     */
    function applyEmbeddedRuleset(text, ruleset) {
        var valueMap,
            embedded = text && text.match(embeddedRuleset),
            rules = embedded && embedded[1];

        if (rules) {
            valueMap = {
                "true": 2,  // true is error
                "": 1,      // blank is warning
                "false": 0, // false is ignore

                "2": 2,     // explicit error
                "1": 1,     // explicit warning
                "0": 0      // explicit ignore
            };

            rules.toLowerCase().split(",").forEach(function(rule) {
                var pair = rule.split(":"),
                    property = pair[0] || "",
                    value = pair[1] || "";

                ruleset[property.trim()] = valueMap[value.trim()];
            });
        }

        return ruleset;
    }

    //-------------------------------------------------------------------------
    // Formatters
    //-------------------------------------------------------------------------

    /**
     * Adds a new formatter to the engine.
     * @param {Object} formatter The formatter to add.
     * @method addFormatter
     */
    api.addFormatter = function(formatter) {
        // formatters.push(formatter);
        formatters[formatter.id] = formatter;
    };

    /**
     * Retrieves a formatter for use.
     * @param {String} formatId The name of the format to retrieve.
     * @return {Object} The formatter or undefined.
     * @method getFormatter
     */
    api.getFormatter = function(formatId) {
        return formatters[formatId];
    };

    /**
     * Formats the results in a particular format for a single file.
     * @param {Object} result The results returned from CSSLint.verify().
     * @param {String} filename The filename for which the results apply.
     * @param {String} formatId The name of the formatter to use.
     * @param {Object} options (Optional) for special output handling.
     * @return {String} A formatted string for the results.
     * @method format
     */
    api.format = function(results, filename, formatId, options) {
        var formatter = api.getFormatter(formatId),
            result = null;

        if (formatter) {
            result = formatter.startFormat();
            result += formatter.formatResults(results, filename, options || {});
            result += formatter.endFormat();
        }

        return result;
    };

    /**
     * Indicates if the given format is supported.
     * @param {String} formatId The ID of the format to check.
     * @return {Boolean} True if the format exists, false if not.
     * @method hasFormat
     */
    api.hasFormat = function(formatId) {
        return formatters.hasOwnProperty(formatId);
    };

    //-------------------------------------------------------------------------
    // Verification
    //-------------------------------------------------------------------------

    /**
     * Starts the verification process for the given CSS text.
     * @param {String} text The CSS text to verify.
     * @param {Object} ruleset (Optional) List of rules to apply. If null, then
     *      all rules are used. If a rule has a value of 1 then it's a warning,
     *      a value of 2 means it's an error.
     * @return {Object} Results of the verification.
     * @method verify
     */
    api.verify = function(text, ruleset) {

        var i = 0,
            reporter,
            lines,
            allow = {},
            ignore = [],
            report,
            parser = new parserlib.css.Parser({
                starHack: true,
                ieFilters: true,
                underscoreHack: true,
                strict: false
            });

        // normalize line endings
        lines = text.replace(/\n\r?/g, "$split$").split("$split$");

        // find 'allow' comments
        CSSLint.Util.forEach(lines, function (line, lineno) {
            var allowLine = line && line.match(/\/\*[ \t]*csslint[ \t]+allow:[ \t]*([^\*]*)\*\//i),
                allowRules = allowLine && allowLine[1],
                allowRuleset = {};

            if (allowRules) {
                allowRules.toLowerCase().split(",").forEach(function(allowRule) {
                    allowRuleset[allowRule.trim()] = true;
                });
                if (Object.keys(allowRuleset).length > 0) {
                    allow[lineno + 1] = allowRuleset;
                }
            }
        });

        var ignoreStart = null,
            ignoreEnd = null;
        CSSLint.Util.forEach(lines, function (line, lineno) {
            // Keep oldest, "unclosest" ignore:start
            if (ignoreStart === null && line.match(/\/\*[ \t]*csslint[ \t]+ignore:start[ \t]*\*\//i)) {
                ignoreStart = lineno;
            }

            if (line.match(/\/\*[ \t]*csslint[ \t]+ignore:end[ \t]*\*\//i)) {
                ignoreEnd = lineno;
            }

            if (ignoreStart !== null && ignoreEnd !== null) {
                ignore.push([ignoreStart, ignoreEnd]);
                ignoreStart = ignoreEnd = null;
            }
        });

        // Close remaining ignore block, if any
        if (ignoreStart !== null) {
            ignore.push([ignoreStart, lines.length]);
        }

        if (!ruleset) {
            ruleset = api.getRuleset();
        }

        if (embeddedRuleset.test(text)) {
            // defensively copy so that caller's version does not get modified
            ruleset = clone(ruleset);
            ruleset = applyEmbeddedRuleset(text, ruleset);
        }

        reporter = new Reporter(lines, ruleset, allow, ignore);

        ruleset.errors = 2;       // always report parsing errors as errors
        for (i in ruleset) {
            if (ruleset.hasOwnProperty(i) && ruleset[i]) {
                if (rules[i]) {
                    rules[i].init(parser, reporter);
                }
            }
        }


        // capture most horrible error type
        try {
            parser.parse(text);
        } catch (ex) {
            reporter.error("Fatal error, cannot continue: " + ex.message, ex.line, ex.col, {});
        }

        report = {
            messages    : reporter.messages,
            stats       : reporter.stats,
            ruleset     : reporter.ruleset,
            allow       : reporter.allow,
            ignore      : reporter.ignore
        };

        // sort by line numbers, rollups at the bottom
        report.messages.sort(function (a, b) {
            if (a.rollup && !b.rollup) {
                return 1;
            } else if (!a.rollup && b.rollup) {
                return -1;
            } else {
                return a.line - b.line;
            }
        });

        return report;
    };

    //-------------------------------------------------------------------------
    // Publish the API
    //-------------------------------------------------------------------------

    return api;
})();

/**
 * An instance of Report is used to report results of the
 * verification back to the main API.
 * @class Reporter
 * @constructor
 * @param {String[]} lines The text lines of the source.
 * @param {Object} ruleset The set of rules to work with, including if
 *      they are errors or warnings.
 * @param {Object} explicitly allowed lines
 * @param {[][]} ingore list of line ranges to be ignored
 */
function Reporter(lines, ruleset, allow, ignore) {
    "use strict";

    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}

Reporter.prototype = {

    // restore constructor
    constructor: Reporter,

    /**
     * Report an error.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method error
     */
    error: function(message, line, col, rule) {
        "use strict";
        this.messages.push({
            type    : "error",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule || {}
        });
    },

    /**
     * Report an warning.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method warn
     * @deprecated Use report instead.
     */
    warn: function(message, line, col, rule) {
        "use strict";
        this.report(message, line, col, rule);
    },

    /**
     * Report an issue.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method report
     */
    report: function(message, line, col, rule) {
        "use strict";

        // Check if rule violation should be allowed
        if (this.allow.hasOwnProperty(line) && this.allow[line].hasOwnProperty(rule.id)) {
            return;
        }

        var ignore = false;
        CSSLint.Util.forEach(this.ignore, function (range) {
            if (range[0] <= line && line <= range[1]) {
                ignore = true;
            }
        });
        if (ignore) {
            return;
        }

        this.messages.push({
            type    : this.ruleset[rule.id] === 2 ? "error" : "warning",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },

    /**
     * Report some informational text.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method info
     */
    info: function(message, line, col, rule) {
        "use strict";
        this.messages.push({
            type    : "info",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },

    /**
     * Report some rollup error information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupError
     */
    rollupError: function(message, rule) {
        "use strict";
        this.messages.push({
            type    : "error",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },

    /**
     * Report some rollup warning information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupWarn
     */
    rollupWarn: function(message, rule) {
        "use strict";
        this.messages.push({
            type    : "warning",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },

    /**
     * Report a statistic.
     * @param {String} name The name of the stat to store.
     * @param {Variant} value The value of the stat.
     * @method stat
     */
    stat: function(name, value) {
        "use strict";
        this.stats[name] = value;
    }
};

// expose for testing purposes
CSSLint._Reporter = Reporter;

/*
 * Utility functions that make life easier.
 */
CSSLint.Util = {
    /*
     * Adds all properties from supplier onto receiver,
     * overwriting if the same name already exists on
     * receiver.
     * @param {Object} The object to receive the properties.
     * @param {Object} The object to provide the properties.
     * @return {Object} The receiver
     */
    mix: function(receiver, supplier) {
        "use strict";
        var prop;

        for (prop in supplier) {
            if (supplier.hasOwnProperty(prop)) {
                receiver[prop] = supplier[prop];
            }
        }

        return prop;
    },

    /*
     * Polyfill for array indexOf() method.
     * @param {Array} values The array to search.
     * @param {Variant} value The value to search for.
     * @return {int} The index of the value if found, -1 if not.
     */
    indexOf: function(values, value) {
        "use strict";
        if (values.indexOf) {
            return values.indexOf(value);
        } else {
            for (var i=0, len=values.length; i < len; i++) {
                if (values[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    },

    /*
     * Polyfill for array forEach() method.
     * @param {Array} values The array to operate on.
     * @param {Function} func The function to call on each item.
     * @return {void}
     */
    forEach: function(values, func) {
        "use strict";
        if (values.forEach) {
            return values.forEach(func);
        } else {
            for (var i=0, len=values.length; i < len; i++) {
                func(values[i], i, values);
            }
        }
    }
};

/*
 * Rule: Don't use adjoining classes (.foo.bar).
 */

CSSLint.addRule({

    // rule information
    id: "adjoining-classes",
    name: "Disallow adjoining classes",
    desc: "Don't use adjoining classes.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-adjoining-classes",
    browsers: "IE6",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;
        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                classCount,
                i, j, k;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        classCount = 0;
                        for (k=0; k < part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === "class") {
                                classCount++;
                            }
                            if (classCount > 1){
                                reporter.report("Adjoining classes: "+selectors[i].text, part.line, part.col, rule);
                            }
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: Don't use width or height when using padding or border.
 */
CSSLint.addRule({

    // rule information
    id: "box-model",
    name: "Beware of broken box size",
    desc: "Don't use width or height when using padding or border.",
    url: "https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            widthProperties = {
                border: 1,
                "border-left": 1,
                "border-right": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1
            },
            heightProperties = {
                border: 1,
                "border-bottom": 1,
                "border-top": 1,
                padding: 1,
                "padding-bottom": 1,
                "padding-top": 1
            },
            properties,
            boxSizing = false;

        function startRule() {
            properties = {};
            boxSizing = false;
        }

        function endRule() {
            var prop, value;

            if (!boxSizing) {
                if (properties.height) {
                    for (prop in heightProperties) {
                        if (heightProperties.hasOwnProperty(prop) && properties[prop]) {
                            value = properties[prop].value;
                            // special case for padding
                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[0].value === 0)) {
                                reporter.report("Using height with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }

                if (properties.width) {
                    for (prop in widthProperties) {
                        if (widthProperties.hasOwnProperty(prop) && properties[prop]) {
                            value = properties[prop].value;

                            if (!(prop === "padding" && value.parts.length === 2 && value.parts[1].value === 0)) {
                                reporter.report("Using width with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var name = event.property.text.toLowerCase();

            if (heightProperties[name] || widthProperties[name]) {
                if (!/^0\S*$/.test(event.value) && !(name === "border" && event.value.toString() === "none")) {
                    properties[name] = {
                        line: event.property.line,
                        col: event.property.col,
                        value: event.value
                    };
                }
            } else {
                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)) {
                    properties[name] = 1;
                } else if (name === "box-sizing") {
                    boxSizing = true;
                }
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endviewport", endRule);
    }
});

/*
 * Rule: box-sizing doesn't work in IE6 and IE7.
 */

CSSLint.addRule({

    // rule information
    id: "box-sizing",
    name: "Disallow use of box-sizing",
    desc: "The box-sizing properties isn't supported in IE6 and IE7.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-box-sizing",
    browsers: "IE6, IE7",
    tags: ["Compatibility"],

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("property", function(event) {
            var name = event.property.text.toLowerCase();

            if (name === "box-sizing") {
                reporter.report("The box-sizing property isn't supported in IE6 and IE7.", event.line, event.col, rule);
            }
        });
    }
});

/*
 * Rule: Use the bulletproof @font-face syntax to avoid 404's in old IE
 * (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)
 */

CSSLint.addRule({

    // rule information
    id: "bulletproof-font-face",
    name: "Use the bulletproof @font-face syntax",
    desc: "Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",
    url: "https://github.com/CSSLint/csslint/wiki/Bulletproof-font-face",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            fontFaceRule = false,
            firstSrc = true,
            ruleFailed = false,
            line, col;

        // Mark the start of a @font-face declaration so we only test properties inside it
        parser.addListener("startfontface", function() {
            fontFaceRule = true;
        });

        parser.addListener("property", function(event) {
            // If we aren't inside an @font-face declaration then just return
            if (!fontFaceRule) {
                return;
            }

            var propertyName = event.property.toString().toLowerCase(),
                value = event.value.toString();

            // Set the line and col numbers for use in the endfontface listener
            line = event.line;
            col = event.col;

            // This is the property that we care about, we can ignore the rest
            if (propertyName === "src") {
                var regex = /^\s?url\(['"].+\.eot\?.*['"]\)\s*format\(['"]embedded-opentype['"]\).*$/i;

                // We need to handle the advanced syntax with two src properties
                if (!value.match(regex) && firstSrc) {
                    ruleFailed = true;
                    firstSrc = false;
                } else if (value.match(regex) && !firstSrc) {
                    ruleFailed = false;
                }
            }
        });

        // Back to normal rules that we don't need to test
        parser.addListener("endfontface", function() {
            fontFaceRule = false;

            if (ruleFailed) {
                reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.", line, col, rule);
            }
        });
    }
});

/*
 * Rule: Include all compatible vendor prefixes to reach a wider
 * range of users.
 */

CSSLint.addRule({

    // rule information
    id: "compatible-vendor-prefixes",
    name: "Require compatible vendor prefixes",
    desc: "Include all compatible vendor prefixes to reach a wider range of users.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-compatible-vendor-prefixes",
    browsers: "All",

    // initialization
    init: function (parser, reporter) {
        "use strict";
        var rule = this,
            compatiblePrefixes,
            properties,
            prop,
            variations,
            prefixed,
            i,
            len,
            inKeyFrame = false,
            arrayPush = Array.prototype.push,
            applyTo = [];

        // See http://peter.sh/experiments/vendor-prefixed-css-property-overview/ for details
        compatiblePrefixes = {
            "animation"                  : "webkit",
            "animation-delay"            : "webkit",
            "animation-direction"        : "webkit",
            "animation-duration"         : "webkit",
            "animation-fill-mode"        : "webkit",
            "animation-iteration-count"  : "webkit",
            "animation-name"             : "webkit",
            "animation-play-state"       : "webkit",
            "animation-timing-function"  : "webkit",
            "appearance"                 : "webkit moz",
            "border-end"                 : "webkit moz",
            "border-end-color"           : "webkit moz",
            "border-end-style"           : "webkit moz",
            "border-end-width"           : "webkit moz",
            "border-image"               : "webkit moz o",
            "border-radius"              : "webkit",
            "border-start"               : "webkit moz",
            "border-start-color"         : "webkit moz",
            "border-start-style"         : "webkit moz",
            "border-start-width"         : "webkit moz",
            "box-align"                  : "webkit moz",
            "box-direction"              : "webkit moz",
            "box-flex"                   : "webkit moz",
            "box-lines"                  : "webkit",
            "box-ordinal-group"          : "webkit moz",
            "box-orient"                 : "webkit moz",
            "box-pack"                   : "webkit moz",
            "box-sizing"                 : "",
            "box-shadow"                 : "",
            "column-count"               : "webkit moz ms",
            "column-gap"                 : "webkit moz ms",
            "column-rule"                : "webkit moz ms",
            "column-rule-color"          : "webkit moz ms",
            "column-rule-style"          : "webkit moz ms",
            "column-rule-width"          : "webkit moz ms",
            "column-width"               : "webkit moz ms",
            "flex"                       : "webkit ms",
            "flex-basis"                 : "webkit",
            "flex-direction"             : "webkit ms",
            "flex-flow"                  : "webkit",
            "flex-grow"                  : "webkit",
            "flex-shrink"                : "webkit",
            "hyphens"                    : "epub moz",
            "line-break"                 : "webkit ms",
            "margin-end"                 : "webkit moz",
            "margin-start"               : "webkit moz",
            "marquee-speed"              : "webkit wap",
            "marquee-style"              : "webkit wap",
            "padding-end"                : "webkit moz",
            "padding-start"              : "webkit moz",
            "tab-size"                   : "moz o",
            "text-size-adjust"           : "webkit ms",
            "transform"                  : "webkit ms",
            "transform-origin"           : "webkit ms",
            "transition"                 : "",
            "transition-delay"           : "",
            "transition-duration"        : "",
            "transition-property"        : "",
            "transition-timing-function" : "",
            "user-modify"                : "webkit moz",
            "user-select"                : "webkit moz ms",
            "word-break"                 : "epub ms",
            "writing-mode"               : "epub ms"
        };


        for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
                variations = [];
                prefixed = compatiblePrefixes[prop].split(" ");
                for (i = 0, len = prefixed.length; i < len; i++) {
                    variations.push("-" + prefixed[i] + "-" + prop);
                }
                compatiblePrefixes[prop] = variations;
                arrayPush.apply(applyTo, variations);
            }
        }

        parser.addListener("startrule", function () {
            properties = [];
        });

        parser.addListener("startkeyframes", function (event) {
            inKeyFrame = event.prefix || true;
        });

        parser.addListener("endkeyframes", function () {
            inKeyFrame = false;
        });

        parser.addListener("property", function (event) {
            var name = event.property;
            if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {

                // e.g., -moz-transform is okay to be alone in @-moz-keyframes
                if (!inKeyFrame || typeof inKeyFrame !== "string" ||
                        name.text.indexOf("-" + inKeyFrame + "-") !== 0) {
                    properties.push(name);
                }
            }
        });

        parser.addListener("endrule", function () {
            if (!properties.length) {
                return;
            }

            var propertyGroups = {},
                i,
                len,
                name,
                prop,
                variations,
                value,
                full,
                actual,
                item,
                propertiesSpecified;

            for (i = 0, len = properties.length; i < len; i++) {
                name = properties[i];

                for (prop in compatiblePrefixes) {
                    if (compatiblePrefixes.hasOwnProperty(prop)) {
                        variations = compatiblePrefixes[prop];
                        if (CSSLint.Util.indexOf(variations, name.text) > -1) {
                            if (!propertyGroups[prop]) {
                                propertyGroups[prop] = {
                                    full: variations.slice(0),
                                    actual: [],
                                    actualNodes: []
                                };
                            }
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                                propertyGroups[prop].actual.push(name.text);
                                propertyGroups[prop].actualNodes.push(name);
                            }
                        }
                    }
                }
            }

            for (prop in propertyGroups) {
                if (propertyGroups.hasOwnProperty(prop)) {
                    value = propertyGroups[prop];
                    full = value.full;
                    actual = value.actual;

                    if (full.length > actual.length) {
                        for (i = 0, len = full.length; i < len; i++) {
                            item = full[i];
                            if (CSSLint.Util.indexOf(actual, item) === -1) {
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(" and ") : actual.join(", ");
                                reporter.report("The property " + item + " is compatible with " + propertiesSpecified + " and should be included as well.", value.actualNodes[0].line, value.actualNodes[0].col, rule);
                            }
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: Certain properties don't play well with certain display values.
 * - float should not be used with inline-block
 * - height, width, margin-top, margin-bottom, float should not be used with inline
 * - vertical-align should not be used with block
 * - margin, float should not be used with table-*
 */

CSSLint.addRule({

    // rule information
    id: "display-property-grouping",
    name: "Require properties appropriate for display",
    desc: "Certain properties shouldn't be used with certain display property values.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-properties-appropriate-for-display",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        var propertiesToCheck = {
                display: 1,
                "float": "none",
                height: 1,
                width: 1,
                margin: 1,
                "margin-left": 1,
                "margin-right": 1,
                "margin-bottom": 1,
                "margin-top": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1,
                "padding-bottom": 1,
                "padding-top": 1,
                "vertical-align": 1
            },
            properties;

        function reportProperty(name, display, msg) {
            if (properties[name]) {
                if (typeof propertiesToCheck[name] !== "string" || properties[name].value.toLowerCase() !== propertiesToCheck[name]) {
                    reporter.report(msg || name + " can't be used with display: " + display + ".", properties[name].line, properties[name].col, rule);
                }
            }
        }

        function startRule() {
            properties = {};
        }

        function endRule() {

            var display = properties.display ? properties.display.value : null;
            if (display) {
                switch (display) {

                    case "inline":
                        // height, width, margin-top, margin-bottom, float should not be used with inline
                        reportProperty("height", display);
                        reportProperty("width", display);
                        reportProperty("margin", display);
                        reportProperty("margin-top", display);
                        reportProperty("margin-bottom", display);
                        reportProperty("float", display, "display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");
                        break;

                    case "block":
                        // vertical-align should not be used with block
                        reportProperty("vertical-align", display);
                        break;

                    case "inline-block":
                        // float should not be used with inline-block
                        reportProperty("float", display);
                        break;

                    default:
                        // margin, float should not be used with table
                        if (display.indexOf("table-") === 0) {
                            reportProperty("margin", display);
                            reportProperty("margin-left", display);
                            reportProperty("margin-right", display);
                            reportProperty("margin-top", display);
                            reportProperty("margin-bottom", display);
                            reportProperty("float", display);
                        }

                        // otherwise do nothing
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var name = event.property.text.toLowerCase();

            if (propertiesToCheck[name]) {
                properties[name] = {
                    value: event.value.text,
                    line: event.property.line,
                    col: event.property.col
                };
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endviewport", endRule);
    }
});

/*
 * Rule: Disallow duplicate background-images (using url).
 */

CSSLint.addRule({

    // rule information
    id: "duplicate-background-images",
    name: "Disallow duplicate background images",
    desc: "Every background-image should be unique. Use a common class for e.g. sprites.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-background-images",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            stack = {};

        parser.addListener("property", function(event) {
            var name = event.property.text,
                value = event.value,
                i, len;

            if (name.match(/background/i)) {
                for (i=0, len=value.parts.length; i < len; i++) {
                    if (value.parts[i].type === "uri") {
                        if (typeof stack[value.parts[i].uri] === "undefined") {
                            stack[value.parts[i].uri] = event;
                        } else {
                            reporter.report("Background image '" + value.parts[i].uri + "' was used multiple times, first declared at line " + stack[value.parts[i].uri].line + ", col " + stack[value.parts[i].uri].col + ".", event.line, event.col, rule);
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: Duplicate properties must appear one after the other. If an already-defined
 * property appears somewhere else in the rule, then it's likely an error.
 */

CSSLint.addRule({

    // rule information
    id: "duplicate-properties",
    name: "Disallow duplicate properties",
    desc: "Duplicate properties must appear one after the other.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-properties",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            properties,
            lastProperty;

        function startRule() {
            properties = {};
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var property = event.property,
                name = property.text.toLowerCase();

            if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)) {
                reporter.report("Duplicate property '" + event.property + "' found.", event.line, event.col, rule);
            }

            properties[name] = event.value.text;
            lastProperty = name;
        });
    }
});

/*
 * Rule: Style rules without any properties defined should be removed.
 */

CSSLint.addRule({

    // rule information
    id: "empty-rules",
    name: "Disallow empty rules",
    desc: "Rules without any properties specified should be removed.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-empty-rules",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            count = 0;

        parser.addListener("startrule", function() {
            count=0;
        });

        parser.addListener("property", function() {
            count++;
        });

        parser.addListener("endrule", function(event) {
            var selectors = event.selectors;
            if (count === 0) {
                reporter.report("Rule is empty.", selectors[0].line, selectors[0].col, rule);
            }
        });
    }
});

/*
 * Rule: There should be no syntax errors. (Duh.)
 */

CSSLint.addRule({

    // rule information
    id: "errors",
    name: "Parsing Errors",
    desc: "This rule looks for recoverable syntax errors.",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("error", function(event) {
            reporter.error(event.message, event.line, event.col, rule);
        });
    }
});

CSSLint.addRule({

    // rule information
    id: "fallback-colors",
    name: "Require fallback colors",
    desc: "For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-fallback-colors",
    browsers: "IE6,IE7,IE8",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            lastProperty,
            propertiesToCheck = {
                color: 1,
                background: 1,
                "border-color": 1,
                "border-top-color": 1,
                "border-right-color": 1,
                "border-bottom-color": 1,
                "border-left-color": 1,
                border: 1,
                "border-top": 1,
                "border-right": 1,
                "border-bottom": 1,
                "border-left": 1,
                "background-color": 1
            };

        function startRule() {
            lastProperty = null;
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var property = event.property,
                name = property.text.toLowerCase(),
                parts = event.value.parts,
                i = 0,
                colorType = "",
                len = parts.length;

            if (propertiesToCheck[name]) {
                while (i < len) {
                    if (parts[i].type === "color") {
                        if ("alpha" in parts[i] || "hue" in parts[i]) {

                            if (/([^\)]+)\(/.test(parts[i])) {
                                colorType = RegExp.$1.toUpperCase();
                            }

                            if (!lastProperty || (lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== "compat")) {
                                reporter.report("Fallback " + name + " (hex or RGB) should precede " + colorType + " " + name + ".", event.line, event.col, rule);
                            }
                        } else {
                            event.colorType = "compat";
                        }
                    }

                    i++;
                }
            }

            lastProperty = event;
        });
    }
});

/*
 * Rule: You shouldn't use more than 10 floats. If you do, there's probably
 * room for some abstraction.
 */

CSSLint.addRule({

    // rule information
    id: "floats",
    name: "Disallow too many floats",
    desc: "This rule tests if the float property is used too many times",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-too-many-floats",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;
        var count = 0;

        // count how many times "float" is used
        parser.addListener("property", function(event) {
            if (event.property.text.toLowerCase() === "float" &&
                    event.value.text.toLowerCase() !== "none") {
                count++;
            }
        });

        // report the results
        parser.addListener("endstylesheet", function() {
            reporter.stat("floats", count);
            if (count >= 10) {
                reporter.rollupWarn("Too many floats (" + count + "), you're probably using them for layout. Consider using a grid system instead.", rule);
            }
        });
    }
});

/*
 * Rule: Avoid too many @font-face declarations in the same stylesheet.
 */

CSSLint.addRule({

    // rule information
    id: "font-faces",
    name: "Don't use too many web fonts",
    desc: "Too many different web fonts in the same stylesheet.",
    url: "https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-web-fonts",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            count = 0;


        parser.addListener("startfontface", function() {
            count++;
        });

        parser.addListener("endstylesheet", function() {
            if (count > 5) {
                reporter.rollupWarn("Too many @font-face declarations (" + count + ").", rule);
            }
        });
    }
});

/*
 * Rule: You shouldn't need more than 9 font-size declarations.
 */

CSSLint.addRule({

    // rule information
    id: "font-sizes",
    name: "Disallow too many font sizes",
    desc: "Checks the number of font-size declarations.",
    url: "https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-font-size-declarations",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            count = 0;

        // check for use of "font-size"
        parser.addListener("property", function(event) {
            if (event.property.toString() === "font-size") {
                count++;
            }
        });

        // report the results
        parser.addListener("endstylesheet", function() {
            reporter.stat("font-sizes", count);
            if (count >= 10) {
                reporter.rollupWarn("Too many font-size declarations (" + count + "), abstraction needed.", rule);
            }
        });
    }
});

/*
 * Rule: When using a vendor-prefixed gradient, make sure to use them all.
 */

CSSLint.addRule({

    // rule information
    id: "gradients",
    name: "Require all gradient definitions",
    desc: "When using a vendor-prefixed gradient, make sure to use them all.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-all-gradient-definitions",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            gradients;

        parser.addListener("startrule", function() {
            gradients = {
                moz: 0,
                webkit: 0,
                oldWebkit: 0,
                o: 0
            };
        });

        parser.addListener("property", function(event) {

            if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)) {
                gradients[RegExp.$1] = 1;
            } else if (/\-webkit\-gradient/i.test(event.value)) {
                gradients.oldWebkit = 1;
            }
        });

        parser.addListener("endrule", function(event) {
            var missing = [];

            if (!gradients.moz) {
                missing.push("Firefox 3.6+");
            }

            if (!gradients.webkit) {
                missing.push("Webkit (Safari 5+, Chrome)");
            }

            if (!gradients.oldWebkit) {
                missing.push("Old Webkit (Safari 4+, Chrome)");
            }

            if (!gradients.o) {
                missing.push("Opera 11.1+");
            }

            if (missing.length && missing.length < 4) {
                reporter.report("Missing vendor-prefixed CSS gradients for " + missing.join(", ") + ".", event.selectors[0].line, event.selectors[0].col, rule);
            }
        });
    }
});

/*
 * Rule: Don't use IDs for selectors.
 */

CSSLint.addRule({

    // rule information
    id: "ids",
    name: "Disallow IDs in selectors",
    desc: "Selectors should not contain IDs.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;
        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                idCount,
                i, j, k;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];
                idCount = 0;

                for (j=0; j < selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k < part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === "id") {
                                idCount++;
                            }
                        }
                    }
                }

                if (idCount === 1) {
                    reporter.report("Don't use IDs in selectors.", selector.line, selector.col, rule);
                } else if (idCount > 1) {
                    reporter.report(idCount + " IDs in the selector, really?", selector.line, selector.col, rule);
                }
            }
        });
    }
});

/*
 * Rule: IE6-9 supports up to 31 stylesheet import.
 * Reference:
 * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx
 */

CSSLint.addRule({

    // rule information
    id: "import-ie-limit",
    name: "@import limit on IE6-IE9",
    desc: "IE6-9 supports up to 31 @import per stylesheet",
    browsers: "IE6, IE7, IE8, IE9",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            MAX_IMPORT_COUNT = 31,
            count = 0;

        function startPage() {
            count = 0;
        }

        parser.addListener("startpage", startPage);

        parser.addListener("import", function() {
            count++;
        });

        parser.addListener("endstylesheet", function() {
            if (count > MAX_IMPORT_COUNT) {
                reporter.rollupError(
                    "Too many @import rules (" + count + "). IE6-9 supports up to 31 import per stylesheet.",
                    rule
                );
            }
        });
    }
});

/*
 * Rule: Don't use @import, use <link> instead.
 */

CSSLint.addRule({

    // rule information
    id: "import",
    name: "Disallow @import",
    desc: "Don't use @import, use <link> instead.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-%40import",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("import", function(event) {
            reporter.report("@import prevents parallel downloads, use <link> instead.", event.line, event.col, rule);
        });
    }
});

/*
 * Rule: Make sure !important is not overused, this could lead to specificity
 * war. Display a warning on !important declarations, an error if it's
 * used more at least 10 times.
 */

CSSLint.addRule({

    // rule information
    id: "important",
    name: "Disallow !important",
    desc: "Be careful when using !important declaration",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-%21important",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            count = 0;

        // warn that important is used and increment the declaration counter
        parser.addListener("property", function(event) {
            if (event.important === true) {
                count++;
                reporter.report("Use of !important", event.line, event.col, rule);
            }
        });

        // if there are more than 10, show an error
        parser.addListener("endstylesheet", function() {
            reporter.stat("important", count);
            if (count >= 10) {
                reporter.rollupWarn("Too many !important declarations (" + count + "), try to use less than 10 to avoid specificity issues.", rule);
            }
        });
    }
});

/*
 * Rule: Properties should be known (listed in CSS3 specification) or
 * be a vendor-prefixed property.
 */

CSSLint.addRule({

    // rule information
    id: "known-properties",
    name: "Require use of known properties",
    desc: "Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-use-of-known-properties",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("property", function(event) {

            // the check is handled entirely by the parser-lib (https://github.com/nzakas/parser-lib)
            if (event.invalid) {
                reporter.report(event.invalid.message, event.line, event.col, rule);
            }
        });
    }
});

/*
 * Rule: All properties should be in alphabetical order.
 */

CSSLint.addRule({

    // rule information
    id: "order-alphabetical",
    name: "Alphabetical order",
    desc: "Assure properties are in alphabetical order",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            properties;

        var startRule = function () {
            properties = [];
        };

        var endRule = function(event) {
            var currentProperties = properties.join(","),
                expectedProperties = properties.sort().join(",");

            if (currentProperties !== expectedProperties) {
                reporter.report("Rule doesn't have all its properties in alphabetical order.", event.line, event.col, rule);
            }
        };

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var name = event.property.text,
                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, "");

            properties.push(lowerCasePrefixLessName);
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endviewport", endRule);
    }
});

/*
 * Rule: outline: none or outline: 0 should only be used in a :focus rule
 *       and only if there are other properties in the same rule.
 */

CSSLint.addRule({

    // rule information
    id: "outline-none",
    name: "Disallow outline: none",
    desc: "Use of outline: none or outline: 0 should be limited to :focus rules.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-outline%3Anone",
    browsers: "All",
    tags: ["Accessibility"],

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            lastRule;

        function startRule(event) {
            if (event.selectors) {
                lastRule = {
                    line: event.line,
                    col: event.col,
                    selectors: event.selectors,
                    propCount: 0,
                    outline: false
                };
            } else {
                lastRule = null;
            }
        }

        function endRule() {
            if (lastRule) {
                if (lastRule.outline) {
                    if (lastRule.selectors.toString().toLowerCase().indexOf(":focus") === -1) {
                        reporter.report("Outlines should only be modified using :focus.", lastRule.line, lastRule.col, rule);
                    } else if (lastRule.propCount === 1) {
                        reporter.report("Outlines shouldn't be hidden unless other visual changes are made.", lastRule.line, lastRule.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var name = event.property.text.toLowerCase(),
                value = event.value;

            if (lastRule) {
                lastRule.propCount++;
                if (name === "outline" && (value.toString() === "none" || value.toString() === "0")) {
                    lastRule.outline = true;
                }
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endviewport", endRule);
    }
});

/*
 * Rule: Don't use classes or IDs with elements (a.foo or a#foo).
 */

CSSLint.addRule({

    // rule information
    id: "overqualified-elements",
    name: "Disallow overqualified elements",
    desc: "Don't use classes or IDs with elements (a.foo or a#foo).",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-overqualified-elements",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            classes = {};

        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k < part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (part.elementName && modifier.type === "id") {
                                reporter.report("Element (" + part + ") is overqualified, just use " + modifier + " without element name.", part.line, part.col, rule);
                            } else if (modifier.type === "class") {

                                if (!classes[modifier]) {
                                    classes[modifier] = [];
                                }
                                classes[modifier].push({
                                    modifier: modifier,
                                    part: part
                                });
                            }
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function() {

            var prop;
            for (prop in classes) {
                if (classes.hasOwnProperty(prop)) {

                    // one use means that this is overqualified
                    if (classes[prop].length === 1 && classes[prop][0].part.elementName) {
                        reporter.report("Element (" + classes[prop][0].part + ") is overqualified, just use " + classes[prop][0].modifier + " without element name.", classes[prop][0].part.line, classes[prop][0].part.col, rule);
                    }
                }
            }
        });
    }
});

CSSLint.addRule({
  id: "performant-transitions",
  name: "Allow only performant transisitons",
  desc: "Only allow transitions that trigger compositing for performant, 60fps transformations.",
  url: "",
  browsers: "All",

  init: function(parser, reporter){
    "use strict";
    var rule = this;

    var transitionProperties = ["transition-property", "transition", "-webkit-transition", "-o-transition"];
    var allowedTransitions = [/-webkit-transform/g, /-ms-transform/g, /transform/g, /opacity/g];

    parser.addListener("property", function(event) {
      var propertyName    = event.property.toString().toLowerCase(),
          propertyValue           = event.value.toString(),
          line            = event.line,
          col             = event.col;

      var values = propertyValue.split(",");
      if (transitionProperties.indexOf(propertyName) !== -1) {
        var reportValues = values.filter(function(value) {
          var didMatch = [];
          for (var i = 0; i < allowedTransitions.length; i++) {
            if(value.match(allowedTransitions[i])) {
              didMatch.push(i);
            }
          }
          return didMatch.length === 0;
        });
        if(reportValues.length > 0) {
            reporter.report("Unexpected transition property '"+reportValues.join(",").trim()+"'", line, col, rule);
        }
      }
    });
  }
});

/*
 * Rule: Headings (h1-h6) should not be qualified (namespaced).
 */

CSSLint.addRule({

    // rule information
    id: "qualified-headings",
    name: "Disallow qualified headings",
    desc: "Headings should not be qualified (namespaced).",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-qualified-headings",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                i, j;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0) {
                            reporter.report("Heading (" + part.elementName + ") should not be qualified.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: Selectors that look like regular expressions are slow and should be avoided.
 */

CSSLint.addRule({

    // rule information
    id: "regex-selectors",
    name: "Disallow selectors that look like regexs",
    desc: "Selectors that look like regular expressions are slow and should be avoided.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-selectors-that-look-like-regular-expressions",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++) {
                    part = selector.parts[j];
                    if (part.type === parser.SELECTOR_PART_TYPE) {
                        for (k=0; k < part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === "attribute") {
                                if (/([~\|\^\$\*]=)/.test(modifier)) {
                                    reporter.report("Attribute selectors with " + RegExp.$1 + " are slow!", modifier.line, modifier.col, rule);
                                }
                            }
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: Total number of rules should not exceed x.
 */

CSSLint.addRule({

    // rule information
    id: "rules-count",
    name: "Rules Count",
    desc: "Track how many rules there are.",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var count = 0;

        // count each rule
        parser.addListener("startrule", function() {
            count++;
        });

        parser.addListener("endstylesheet", function() {
            reporter.stat("rule-count", count);
        });
    }
});

/*
 * Rule: Warn people with approaching the IE 4095 limit
 */

CSSLint.addRule({

    // rule information
    id: "selector-max-approaching",
    name: "Warn when approaching the 4095 selector limit for IE",
    desc: "Will warn when selector count is >= 3800 selectors.",
    browsers: "IE",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count >= 3800) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.", 0, 0, rule);
            }
        });
    }
});

/*
 * Rule: Warn people past the IE 4095 limit
 */

CSSLint.addRule({

    // rule information
    id: "selector-max",
    name: "Error when past the 4095 selector limit for IE",
    desc: "Will error when selector count is > 4095.",
    browsers: "IE",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this, count = 0;

        parser.addListener("startrule", function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count > 4095) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.", 0, 0, rule);
            }
        });
    }
});

/*
 * Rule: Avoid new-line characters in selectors.
 */

CSSLint.addRule({

    // rule information
    id: "selector-newline",
    name: "Disallow new-line characters in selectors",
    desc: "New-line characters in selectors are usually a forgotten comma and not a descendant combinator.",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        function startRule(event) {
            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,
                selectors = event.selectors;

            for (i = 0, len = selectors.length; i < len; i++) {
                selector = selectors[i];
                for (p = 0, pLen = selector.parts.length; p < pLen; p++) {
                    for (n = p + 1; n < pLen; n++) {
                        part = selector.parts[p];
                        part2 = selector.parts[n];
                        type = part.type;
                        currentLine = part.line;
                        nextLine = part2.line;

                        if (type === "descendant" && nextLine > currentLine) {
                            reporter.report("newline character found in selector (forgot a comma?)", currentLine, selectors[i].parts[0].col, rule);
                        }
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
    }
});

/*
 * Rule: Use shorthand properties where possible.
 *
 */

CSSLint.addRule({

    // rule information
    id: "shorthand",
    name: "Require shorthand properties",
    desc: "Use shorthand properties where possible.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-shorthand-properties",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            prop, i, len,
            propertiesToCheck = {},
            properties,
            mapping = {
                "margin": [
                    "margin-top",
                    "margin-bottom",
                    "margin-left",
                    "margin-right"
                ],
                "padding": [
                    "padding-top",
                    "padding-bottom",
                    "padding-left",
                    "padding-right"
                ]
            };

        // initialize propertiesToCheck
        for (prop in mapping) {
            if (mapping.hasOwnProperty(prop)) {
                for (i=0, len=mapping[prop].length; i < len; i++) {
                    propertiesToCheck[mapping[prop][i]] = prop;
                }
            }
        }

        function startRule() {
            properties = {};
        }

        // event handler for end of rules
        function endRule(event) {

            var prop, i, len, total;

            // check which properties this rule has
            for (prop in mapping) {
                if (mapping.hasOwnProperty(prop)) {
                    total=0;

                    for (i=0, len=mapping[prop].length; i < len; i++) {
                        total += properties[mapping[prop][i]] ? 1 : 0;
                    }

                    if (total === mapping[prop].length) {
                        reporter.report("The properties " + mapping[prop].join(", ") + " can be replaced by " + prop + ".", event.line, event.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);

        // check for use of "font-size"
        parser.addListener("property", function(event) {
            var name = event.property.toString().toLowerCase();

            if (propertiesToCheck[name]) {
                properties[name] = 1;
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
    }
});

/*
 * Rule: Don't use properties with a star prefix.
 *
 */

CSSLint.addRule({

    // rule information
    id: "star-property-hack",
    name: "Disallow properties with a star prefix",
    desc: "Checks for the star property hack (targets IE6/7)",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-star-hack",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        // check if property name starts with "*"
        parser.addListener("property", function(event) {
            var property = event.property;

            if (property.hack === "*") {
                reporter.report("Property with star prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

/*
 * Rule: Don't use text-indent for image replacement if you need to support rtl.
 *
 */

CSSLint.addRule({

    // rule information
    id: "text-indent",
    name: "Disallow negative text-indent",
    desc: "Checks for text indent less than -99px",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-negative-text-indent",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            textIndent,
            direction;


        function startRule() {
            textIndent = false;
            direction = "inherit";
        }

        // event handler for end of rules
        function endRule() {
            if (textIndent && direction !== "ltr") {
                reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.", textIndent.line, textIndent.col, rule);
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);

        // check for use of "font-size"
        parser.addListener("property", function(event) {
            var name = event.property.toString().toLowerCase(),
                value = event.value;

            if (name === "text-indent" && value.parts[0].value < -99) {
                textIndent = event.property;
            } else if (name === "direction" && value.toString() === "ltr") {
                direction = "ltr";
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
    }
});

/*
 * Rule: Don't use properties with a underscore prefix.
 *
 */

CSSLint.addRule({

    // rule information
    id: "underscore-property-hack",
    name: "Disallow properties with an underscore prefix",
    desc: "Checks for the underscore property hack (targets IE6)",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-underscore-hack",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        // check if property name starts with "_"
        parser.addListener("property", function(event) {
            var property = event.property;

            if (property.hack === "_") {
                reporter.report("Property with underscore prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});

/*
 * Rule: Headings (h1-h6) should be defined only once.
 */

CSSLint.addRule({

    // rule information
    id: "unique-headings",
    name: "Headings should only be defined once",
    desc: "Headings should be defined only once.",
    url: "https://github.com/CSSLint/csslint/wiki/Headings-should-only-be-defined-once",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        var headings = {
            h1: 0,
            h2: 0,
            h3: 0,
            h4: 0,
            h5: 0,
            h6: 0
        };

        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                pseudo,
                i, j;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];
                part = selector.parts[selector.parts.length-1];

                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())) {

                    for (j=0; j < part.modifiers.length; j++) {
                        if (part.modifiers[j].type === "pseudo") {
                            pseudo = true;
                            break;
                        }
                    }

                    if (!pseudo) {
                        headings[RegExp.$1]++;
                        if (headings[RegExp.$1] > 1) {
                            reporter.report("Heading (" + part.elementName + ") has already been defined.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });

        parser.addListener("endstylesheet", function() {
            var prop,
                messages = [];

            for (prop in headings) {
                if (headings.hasOwnProperty(prop)) {
                    if (headings[prop] > 1) {
                        messages.push(headings[prop] + " " + prop + "s");
                    }
                }
            }

            if (messages.length) {
                reporter.rollupWarn("You have " + messages.join(", ") + " defined in this stylesheet.", rule);
            }
        });
    }
});

/*
 * Rule: Don't use universal selector because it's slow.
 */

CSSLint.addRule({

    // rule information
    id: "universal-selector",
    name: "Disallow universal selector",
    desc: "The universal selector (*) is known to be slow.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-universal-selector",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        parser.addListener("startrule", function(event) {
            var selectors = event.selectors,
                selector,
                part,
                i;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.elementName === "*") {
                    reporter.report(rule.desc, part.line, part.col, rule);
                }
            }
        });
    }
});

/*
 * Rule: Don't use unqualified attribute selectors because they're just like universal selectors.
 */

CSSLint.addRule({

    // rule information
    id: "unqualified-attributes",
    name: "Disallow unqualified attribute selectors",
    desc: "Unqualified attribute selectors are known to be slow.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-unqualified-attribute-selectors",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";

        var rule = this;

        parser.addListener("startrule", function(event) {

            var selectors = event.selectors,
                selectorContainsClassOrId = false,
                selector,
                part,
                modifier,
                i, k;

            for (i=0; i < selectors.length; i++) {
                selector = selectors[i];

                part = selector.parts[selector.parts.length-1];
                if (part.type === parser.SELECTOR_PART_TYPE) {
                    for (k=0; k < part.modifiers.length; k++) {
                        modifier = part.modifiers[k];

                        if (modifier.type === "class" || modifier.type === "id") {
                            selectorContainsClassOrId = true;
                            break;
                        }
                    }

                    if (!selectorContainsClassOrId) {
                        for (k=0; k < part.modifiers.length; k++) {
                            modifier = part.modifiers[k];
                            if (modifier.type === "attribute" && (!part.elementName || part.elementName === "*")) {
                                reporter.report(rule.desc, part.line, part.col, rule);
                            }
                        }
                    }
                }
            }
        });
    }
});

/*
 * Rule: When using a vendor-prefixed property, make sure to
 * include the standard one.
 */

CSSLint.addRule({

    // rule information
    id: "vendor-prefix",
    name: "Require standard property with vendor prefix",
    desc: "When using a vendor-prefixed property, make sure to include the standard one.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-standard-property-with-vendor-prefix",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this,
            properties,
            num,
            propertiesToCheck = {
                "-webkit-border-radius": "border-radius",
                "-webkit-border-top-left-radius": "border-top-left-radius",
                "-webkit-border-top-right-radius": "border-top-right-radius",
                "-webkit-border-bottom-left-radius": "border-bottom-left-radius",
                "-webkit-border-bottom-right-radius": "border-bottom-right-radius",

                "-o-border-radius": "border-radius",
                "-o-border-top-left-radius": "border-top-left-radius",
                "-o-border-top-right-radius": "border-top-right-radius",
                "-o-border-bottom-left-radius": "border-bottom-left-radius",
                "-o-border-bottom-right-radius": "border-bottom-right-radius",

                "-moz-border-radius": "border-radius",
                "-moz-border-radius-topleft": "border-top-left-radius",
                "-moz-border-radius-topright": "border-top-right-radius",
                "-moz-border-radius-bottomleft": "border-bottom-left-radius",
                "-moz-border-radius-bottomright": "border-bottom-right-radius",

                "-moz-column-count": "column-count",
                "-webkit-column-count": "column-count",

                "-moz-column-gap": "column-gap",
                "-webkit-column-gap": "column-gap",

                "-moz-column-rule": "column-rule",
                "-webkit-column-rule": "column-rule",

                "-moz-column-rule-style": "column-rule-style",
                "-webkit-column-rule-style": "column-rule-style",

                "-moz-column-rule-color": "column-rule-color",
                "-webkit-column-rule-color": "column-rule-color",

                "-moz-column-rule-width": "column-rule-width",
                "-webkit-column-rule-width": "column-rule-width",

                "-moz-column-width": "column-width",
                "-webkit-column-width": "column-width",

                "-webkit-column-span": "column-span",
                "-webkit-columns": "columns",

                "-moz-box-shadow": "box-shadow",
                "-webkit-box-shadow": "box-shadow",

                "-moz-transform": "transform",
                "-webkit-transform": "transform",
                "-o-transform": "transform",
                "-ms-transform": "transform",

                "-moz-transform-origin": "transform-origin",
                "-webkit-transform-origin": "transform-origin",
                "-o-transform-origin": "transform-origin",
                "-ms-transform-origin": "transform-origin",

                "-moz-box-sizing": "box-sizing",
                "-webkit-box-sizing": "box-sizing"
            };

        // event handler for beginning of rules
        function startRule() {
            properties = {};
            num = 1;
        }

        // event handler for end of rules
        function endRule() {
            var prop,
                i,
                len,
                needed,
                actual,
                needsStandard = [];

            for (prop in properties) {
                if (propertiesToCheck[prop]) {
                    needsStandard.push({
                        actual: prop,
                        needed: propertiesToCheck[prop]
                    });
                }
            }

            for (i=0, len=needsStandard.length; i < len; i++) {
                needed = needsStandard[i].needed;
                actual = needsStandard[i].actual;

                if (!properties[needed]) {
                    reporter.report("Missing standard property '" + needed + "' to go along with '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                } else {
                    // make sure standard property is last
                    if (properties[needed][0].pos < properties[actual][0].pos) {
                        reporter.report("Standard property '" + needed + "' should come after vendor-prefixed property '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startviewport", startRule);

        parser.addListener("property", function(event) {
            var name = event.property.text.toLowerCase();

            if (!properties[name]) {
                properties[name] = [];
            }

            properties[name].push({
                name: event.property,
                value: event.value,
                pos: num++
            });
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endviewport", endRule);
    }
});

/*
 * Rule: You don't need to specify units when a value is 0.
 */

CSSLint.addRule({

    // rule information
    id: "zero-units",
    name: "Disallow units for 0 values",
    desc: "You don't need to specify units when a value is 0.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-units-for-zero-values",
    browsers: "All",

    // initialization
    init: function(parser, reporter) {
        "use strict";
        var rule = this;

        // count how many times "float" is used
        parser.addListener("property", function(event) {
            var parts = event.value.parts,
                i = 0,
                len = parts.length;

            while (i < len) {
                if ((parts[i].units || parts[i].type === "percentage") && parts[i].value === 0 && parts[i].type !== "time") {
                    reporter.report("Values of 0 shouldn't have units specified.", parts[i].line, parts[i].col, rule);
                }
                i++;
            }
        });
    }
});

(function() {
    "use strict";

    /**
     * Replace special characters before write to output.
     *
     * Rules:
     *  - single quotes is the escape sequence for double-quotes
     *  - &amp; is the escape sequence for &
     *  - &lt; is the escape sequence for <
     *  - &gt; is the escape sequence for >
     *
     * @param {String} message to escape
     * @return escaped message as {String}
     */
    var xmlEscape = function(str) {
        if (!str || str.constructor !== String) {
            return "";
        }

        return str.replace(/["&><]/g, function(match) {
            switch (match) {
                case "\"":
                    return "&quot;";
                case "&":
                    return "&amp;";
                case "<":
                    return "&lt;";
                case ">":
                    return "&gt;";
            }
        });
    };

    CSSLint.addFormatter({
        // format information
        id: "checkstyle-xml",
        name: "Checkstyle XML format",

        /**
         * Return opening root XML tag.
         * @return {String} to prepend before all results
         */
        startFormat: function() {
            return "<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>";
        },

        /**
         * Return closing root XML tag.
         * @return {String} to append after all results
         */
        endFormat: function() {
            return "</checkstyle>";
        },

        /**
         * Returns message when there is a file read error.
         * @param {String} filename The name of the file that caused the error.
         * @param {String} message The error message
         * @return {String} The error message.
         */
        readError: function(filename, message) {
            return "<file name=\"" + xmlEscape(filename) + "\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"" + xmlEscape(message) + "\"></error></file>";
        },

        /**
         * Given CSS Lint results for a file, return output for this format.
         * @param results {Object} with error and warning messages
         * @param filename {String} relative file path
         * @param options {Object} (UNUSED for now) specifies special handling of output
         * @return {String} output for results
         */
        formatResults: function(results, filename/*, options*/) {
            var messages = results.messages,
                output = [];

            /**
             * Generate a source string for a rule.
             * Checkstyle source strings usually resemble Java class names e.g
             * net.csslint.SomeRuleName
             * @param {Object} rule
             * @return rule source as {String}
             */
            var generateSource = function(rule) {
                if (!rule || !("name" in rule)) {
                    return "";
                }
                return "net.csslint." + rule.name.replace(/\s/g, "");
            };


            if (messages.length > 0) {
                output.push("<file name=\""+filename+"\">");
                CSSLint.Util.forEach(messages, function (message) {
                    // ignore rollups for now
                    if (!message.rollup) {
                        output.push("<error line=\"" + message.line + "\" column=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                          " message=\"" + xmlEscape(message.message) + "\" source=\"" + generateSource(message.rule) +"\"/>");
                    }
                });
                output.push("</file>");
            }

            return output.join("");
        }
    });
}());

CSSLint.addFormatter({
    // format information
    id: "compact",
    name: "Compact, 'porcelain' format",

    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        return "";
    },

    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        return "";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        "use strict";
        var messages = results.messages,
            output = "";
        options = options || {};

        /**
         * Capitalize and return given string.
         * @param str {String} to capitalize
         * @return {String} capitalized
         */
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        if (messages.length === 0) {
            return options.quiet ? "" : filename + ": Lint Free!";
        }

        CSSLint.Util.forEach(messages, function(message) {
            if (message.rollup) {
                output += filename + ": " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
            } else {
                output += filename + ": line " + message.line +
                    ", col " + message.col + ", " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
            }
        });

        return output;
    }
});

CSSLint.addFormatter({
    // format information
    id: "csslint-xml",
    name: "CSSLint XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        return "</csslint>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename/*, options*/) {
        "use strict";
        var messages = results.messages,
            output = [];

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &amp; is the escape sequence for &
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         *
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {
            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

/* globals JSON: true */

CSSLint.addFormatter({
    // format information
    id: "json",
    name: "JSON",

    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        this.json = [];
        return "";
    },

    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        var ret = "";
        if (this.json.length > 0) {
            if (this.json.length === 1) {
                ret = JSON.stringify(this.json[0]);
            } else {
                ret = JSON.stringify(this.json);
            }
        }
        return ret;
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path (Unused)
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        "use strict";
        if (results.messages.length > 0 || !options.quiet) {
            this.json.push({
                filename: filename,
                messages: results.messages,
                stats: results.stats
            });
        }
        return "";
    }
});

CSSLint.addFormatter({
    // format information
    id: "junit-xml",
    name: "JUNIT XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        return "</testsuites>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename/*, options*/) {
        "use strict";

        var messages = results.messages,
            output = [],
            tests = {
                "error": 0,
                "failure": 0
            };

        /**
         * Generate a source string for a rule.
         * JUNIT source strings usually resemble Java class names e.g
         * net.csslint.SomeRuleName
         * @param {Object} rule
         * @return rule source as {String}
         */
        var generateSource = function(rule) {
            if (!rule || !("name" in rule)) {
                return "";
            }
            return "net.csslint." + rule.name.replace(/\s/g, "");
        };

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         *
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {

            if (!str || str.constructor !== String) {
                return "";
            }

            return str.replace(/"/g, "'").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {

            messages.forEach(function (message) {

                // since junit has no warning class
                // all issues as errors
                var type = message.type === "warning" ? "error" : message.type;

                // ignore rollups for now
                if (!message.rollup) {

                    // build the test case separately, once joined
                    // we'll add it to a custom array filtered by type
                    output.push("<testcase time=\"0\" name=\"" + generateSource(message.rule) + "\">");
                    output.push("<" + type + " message=\"" + escapeSpecialCharacters(message.message) + "\"><![CDATA[" + message.line + ":" + message.col + ":" + escapeSpecialCharacters(message.evidence) + "]]></" + type + ">");
                    output.push("</testcase>");

                    tests[type] += 1;
                }
            });

            output.unshift("<testsuite time=\"0\" tests=\"" + messages.length + "\" skipped=\"0\" errors=\"" + tests.error + "\" failures=\"" + tests.failure + "\" package=\"net.csslint\" name=\"" + filename + "\">");
            output.push("</testsuite>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    // format information
    id: "lint-xml",
    name: "Lint XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        return "</lint>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename/*, options*/) {
        "use strict";
        var messages = results.messages,
            output = [];

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &amp; is the escape sequence for &
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         *
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {

            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    var rule = "";
                    if (message.rule && message.rule.id) {
                        rule = "rule=\"" + escapeSpecialCharacters(message.rule.id) + "\" ";
                    }
                    output.push("<issue " + rule + "line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});

CSSLint.addFormatter({
    // format information
    id: "text",
    name: "Plain Text",

    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        "use strict";
        return "";
    },

    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function() {
        "use strict";
        return "";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        "use strict";
        var messages = results.messages,
            output = "";
        options = options || {};

        if (messages.length === 0) {
            return options.quiet ? "" : "\n\ncsslint: No errors in " + filename + ".";
        }

        output = "\n\ncsslint: There ";
        if (messages.length === 1) {
            output += "is 1 problem";
        } else {
            output += "are " + messages.length + " problems";
        }
        output += " in " + filename + ".";

        var pos = filename.lastIndexOf("/"),
            shortFilename = filename;

        if (pos === -1) {
            pos = filename.lastIndexOf("\\");
        }
        if (pos > -1) {
            shortFilename = filename.substring(pos+1);
        }

        CSSLint.Util.forEach(messages, function (message, i) {
            output = output + "\n\n" + shortFilename;
            if (message.rollup) {
                output += "\n" + (i+1) + ": " + message.type;
                output += "\n" + message.message;
            } else {
                output += "\n" + (i+1) + ": " + message.type + " at line " + message.line + ", col " + message.col;
                output += "\n" + message.message;
                output += "\n" + message.evidence;
            }
        });

        return output;
    }
});

return CSSLint;
})();


/*
repo https://github.com/douglascrockford/JSLint/tree/bca8b225a376352899d634442802b241fee8b97b
committed 2020-11-06T17:58:13Z
*/


/*
file https://github.com/douglascrockford/JSLint/blob/bca8b225a376352899d634442802b241fee8b97b/jslint.js
*/
// jslint.js
// 2020-11-06
// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// The Software shall be used for Good, not Evil.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// jslint(source, option_object, global_array) is a function that takes 3
// arguments. The second two arguments are optional.

//      source          A text to analyze, a string or an array of strings.
//      option_object   An object whose keys correspond to option names.
//      global_array    An array of strings containing global variables that
//                      the file is allowed readonly access.

// jslint returns an object containing its results. The object contains a lot
// of valuable information. It can be used to generate reports. The object
// contains:

//      directives: an array of directive comment tokens.
//      edition: the version of JSLint that did the analysis.
//      exports: the names exported from the module.
//      froms: an array of strings representing each of the imports.
//      functions: an array of objects that represent all of the functions
//              declared in the file.
//      global: an object representing the global object. Its .context property
//              is an object containing a property for each global variable.
//      id: "(JSLint)"
//      json: true if the file is a JSON text.
//      lines: an array of strings, the source.
//      module: true if an import or export statement was used.
//      ok: true if no warnings were generated. This is what you want.
//      option: the option argument.
//      property: a property object.
//      stop: true if JSLint was unable to finish. You don't want this.
//      tokens: an array of objects representing the tokens in the file.
//      tree: the token objects arranged in a tree.
//      warnings: an array of warning objects. A warning object can contain:
//          name: "JSLintError"
//          column: A column number in the file.
//          line: A line number in the file.
//          code: A warning code string.
//          message: The warning message string.
//          a: Exhibit A.
//          b: Exhibit B.
//          c: Exhibit C.
//          d: Exhibit D.

// jslint works in several phases. In any of these phases, errors might be
// found. Sometimes JSLint is able to recover from an error and continue
// parsing. In some cases, it cannot and will stop early. If that should happen,
// repair your code and try again.

// Phases:

//      1. If the source is a single string, split it into an array of strings.
//      2. Turn the source into an array of tokens.
//      3. Furcate the tokens into a parse tree.
//      4. Walk the tree, traversing all of the nodes of the tree. It is a
//          recursive traversal. Each node may be processed on the way down
//          (preaction) and on the way up (postaction).
//      5. Check the whitespace between the tokens.

// jslint can also examine JSON text. It decides that a file is JSON text if
// the first token is "[" or "{". Processing of JSON text is much simpler than
// the processing of JavaScript programs. Only the first three phases are
// required.

// WARNING: JSLint will hurt your feelings.

// hack-jslint - property
let line_ignore;
let lines_extra;
/*\property
    a, and, arity, assign, b, bad_assignment_a, bad_directive_a, bad_get,
    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,
    body, browser, c, calls, catch, charCodeAt, closer, closure, code, column,
    concat, constant, context, convert, couch, create, d, dead, default, devel,
    directive, directives, disrupt, dot, duplicate_a, edition, ellipsis, else,
    empty_block, eval, every, expected_a, expected_a_at_b_c,
    expected_a_b, expected_a_b_from_c_d, expected_a_before_b,
    expected_a_next_at_b, expected_digits_after_a, expected_four_digits,
    expected_identifier_a, expected_line_break_a_b, expected_regexp_factor_a,
    expected_space_a_b, expected_statements_a, expected_string_a,
    expected_type_string_a, exports, expression, extra, finally, flag, for,
    forEach, free, freeze, freeze_exports, from, froms, fud, fudge,
    function_in_loop, functions, g, getset, global, i, id, identifier, import,
    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,
    label, label_a, lbp, led, length, level, line, lines, live, long, loop, m,
    margin, match, message, misplaced_a, misplaced_directive_a, missing_browser,
    missing_m, module, naked_block, name, names, nested_comment, new, node,
    not_label_a, nr, nud, number_isNaN, ok, open, opening, option,
    out_of_scope_a, parameters, parent, pop, property, push, quote, raw,
    redefinition_a_b, replace, required_a_optional_b, reserved_a, role, search,
    shebang, signature, single, slice, some, sort, split, startsWith, statement,
    stop, subscript_a, switch, test, this, thru, toString, todo_comment,
    tokens, too_long, too_many_digits, tree, try, type, u, unclosed_comment,
    unclosed_mega, unclosed_string, undeclared_a, unexpected_a,
    unexpected_a_after_b, unexpected_a_before_b, unexpected_at_top_level_a,
    unexpected_char_a, unexpected_comment, unexpected_directive_a,
    unexpected_expression_a, unexpected_label_a, unexpected_parens,
    unexpected_space_a_b, unexpected_statement_a, unexpected_trailing_space,
    unexpected_typeof_a, uninitialized_a, unreachable_a,
    unregistered_property_a, unused_a, use_double, use_open, use_spaces,
    used, value, var_loop, var_switch, variable, warning, warnings,
    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,
    wrap_condition, wrap_immediate, wrap_parameter, wrap_regexp, wrap_unary,
    wrapped, writable, y
*/

function empty() {

// The empty function produces a new empty object that inherits nothing. This is
// much better than '{}' because confusions around accidental method names like
// 'constructor' are completely avoided.

    return Object.create(null);
}

function populate(array, object = empty(), value = true) {

// Augment an object by taking property names from an array of strings.

    array.forEach(function (name) {
        object[name] = value;
    });
    return object;
}

const allowed_option = {
    // hack-jslint - allowed_option extra
    debug: true,
    nomen: true,
    throw_error: true,

// These are the options that are recognized in the option object or that may
// appear in a /*jslint*/ directive. Most options will have a boolean value,
// usually true. Some options will also predefine some number of global
// variables.

    bitwise: true,
    browser: [
        "caches", "CharacterData", "clearInterval", "clearTimeout", "document",
        "DocumentType", "DOMException", "Element", "Event", "event", "fetch",
        "FileReader", "FontFace", "FormData", "history", "IntersectionObserver",
        "localStorage", "location", "MutationObserver", "name", "navigator",
        "screen", "sessionStorage", "setInterval", "setTimeout", "Storage",
        "TextDecoder", "TextEncoder", "URL", "window", "Worker",
        "XMLHttpRequest"
    ],
    couch: [
        "emit", "getRow", "isArray", "log", "provides", "registerType",
        "require", "send", "start", "sum", "toJSON"
    ],
    convert: true,
    devel: [
        "alert", "confirm", "console", "prompt"
    ],
    eval: true,
    for: true,
    fudge: true,
    getset: true,
    long: true,
    node: [
        "Buffer", "clearImmediate", "clearInterval", "clearTimeout",
        "console", "exports", "module", "process", "require",
        "setImmediate", "setInterval", "setTimeout", "TextDecoder",
        "TextEncoder", "URL", "URLSearchParams", "__dirname", "__filename"
    ],
    single: true,
    this: true,
    white: true
};

const anticondition = populate([
    "?", "~", "&", "|", "^", "<<", ">>", ">>>", "+", "-", "*", "/", "%",
    "typeof", "(number)", "(string)"
]);

// These are the bitwise operators.

const bitwiseop = populate([
    "~", "^", "^=", "&", "&=", "|", "|=", "<<", "<<=", ">>", ">>=",
    ">>>", ">>>="
]);

const escapeable = populate([
    "\\", "/", "`", "b", "f", "n", "r", "t"
]);

const opener = {

// The open and close pairs.

    "(": ")",       // paren
    "[": "]",       // bracket
    "{": "}",       // brace
    "${": "}"       // mega
};

// The relational operators.

const relationop = populate([
    "!=", "!==", "==", "===", "<", "<=", ">", ">="
]);

// This is the set of infix operators that require a space on each side.

const spaceop = populate([
    "!=", "!==", "%", "%=", "&", "&=", "&&", "*", "*=", "+=", "-=", "/",
    "/=", "<", "<=", "<<", "<<=", "=", "==", "===", "=>", ">", ">=",
    ">>", ">>=", ">>>", ">>>=", "^", "^=", "|", "|=", "||"
]);

const standard = [

// These are the globals that are provided by the language standard.

    "Array", "ArrayBuffer", "Boolean", "DataView", "Date", "decodeURI",
    "decodeURIComponent", "encodeURI", "encodeURIComponent", "Error",
    "EvalError", "Float32Array", "Float64Array", "Generator",
    "GeneratorFunction", "Int8Array", "Int16Array", "Int32Array", "Intl",
    "JSON", "Map", "Math", "Number", "Object", "parseInt", "parseFloat",
    "Promise", "Proxy", "RangeError", "ReferenceError", "Reflect", "RegExp",
    "Set", "String", "Symbol", "SyntaxError", "System", "TypeError",
    "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array",
    "URIError", "WeakMap", "WeakSet"
];

const bundle = {

// The bundle contains the raw text messages that are generated by jslint. It
// seems that they are all error messages and warnings. There are no "Atta
// boy!" or "You are so awesome!" messages. There is no positive reinforcement
// or encouragement. This relentless negativity can undermine self-esteem and
// wound the inner child. But if you accept it as sound advice rather than as
// personal criticism, it can make your programs better.

    and: "The '&&' subexpression should be wrapped in parens.",
    bad_assignment_a: "Bad assignment to '{a}'.",
    bad_directive_a: "Bad directive '{a}'.",
    bad_get: "A get function takes no parameters.",
    bad_module_name_a: "Bad module name '{a}'.",
    bad_option_a: "Bad option '{a}'.",
    bad_property_a: "Bad property name '{a}'.",
    bad_set: "A set function takes one parameter.",
    duplicate_a: "Duplicate '{a}'.",
    empty_block: "Empty block.",
    expected_a: "Expected '{a}'.",
    expected_a_at_b_c: "Expected '{a}' at column {b}, not column {c}.",
    expected_a_b: "Expected '{a}' and instead saw '{b}'.",
    expected_a_b_from_c_d: (
        "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'."
    ),
    expected_a_before_b: "Expected '{a}' before '{b}'.",
    expected_a_next_at_b: "Expected '{a}' at column {b} on the next line.",
    expected_digits_after_a: "Expected digits after '{a}'.",
    expected_four_digits: "Expected four digits after '\\u'.",
    expected_identifier_a: "Expected an identifier and instead saw '{a}'.",
    expected_line_break_a_b: "Expected a line break between '{a}' and '{b}'.",
    expected_regexp_factor_a: "Expected a regexp factor and instead saw '{a}'.",
    expected_space_a_b: "Expected one space between '{a}' and '{b}'.",
    expected_statements_a: "Expected statements before '{a}'.",
    expected_string_a: "Expected a string and instead saw '{a}'.",
    expected_type_string_a: "Expected a type string and instead saw '{a}'.",
    freeze_exports: (
        "Expected 'Object.freeze('. All export values should be frozen."
    ),
    function_in_loop: "Don't make functions within a loop.",
    infix_in: (
        "Unexpected 'in'. Compare with undefined, "
        + "or use the hasOwnProperty method instead."
    ),
    label_a: "'{a}' is a statement label.",
    misplaced_a: "Place '{a}' at the outermost level.",
    misplaced_directive_a: (
        "Place the '/*{a}*/' directive before the first statement."
    ),
    missing_browser: "/*global*/ requires the Assume a browser option.",
    missing_m: "Expected 'm' flag on a multiline regular expression.",
    naked_block: "Naked block.",
    nested_comment: "Nested comment.",
    not_label_a: "'{a}' is not a label.",
    number_isNaN: "Use Number.isNaN function to compare with NaN.",
    out_of_scope_a: "'{a}' is out of scope.",
    redefinition_a_b: "Redefinition of '{a}' from line {b}.",
    required_a_optional_b: (
        "Required parameter '{a}' after optional parameter '{b}'."
    ),
    reserved_a: "Reserved name '{a}'.",
    subscript_a: "['{a}'] is better written in dot notation.",
    todo_comment: "Unexpected TODO comment.",
    too_long: "Line is longer than 80 characters.",
    too_many_digits: "Too many digits.",
    unclosed_comment: "Unclosed comment.",
    unclosed_mega: "Unclosed mega literal.",
    unclosed_string: "Unclosed string.",
    undeclared_a: "Undeclared '{a}'.",
    unexpected_a: "Unexpected '{a}'.",
    unexpected_a_after_b: "Unexpected '{a}' after '{b}'.",
    unexpected_a_before_b: "Unexpected '{a}' before '{b}'.",
    unexpected_at_top_level_a: "Expected '{a}' to be in a function.",
    unexpected_char_a: "Unexpected character '{a}'.",
    unexpected_comment: "Unexpected comment.",
    unexpected_directive_a: "When using modules, don't use directive '/*{a}'.",
    unexpected_expression_a: (
        "Unexpected expression '{a}' in statement position."
    ),
    unexpected_label_a: "Unexpected label '{a}'.",
    unexpected_parens: "Don't wrap function literals in parens.",
    unexpected_space_a_b: "Unexpected space between '{a}' and '{b}'.",
    unexpected_statement_a: (
        "Unexpected statement '{a}' in expression position."
    ),
    unexpected_trailing_space: "Unexpected trailing space.",
    unexpected_typeof_a: (
        "Unexpected 'typeof'. Use '===' to compare directly with {a}."
    ),
    uninitialized_a: "Uninitialized '{a}'.",
    unreachable_a: "Unreachable '{a}'.",
    unregistered_property_a: "Unregistered property name '{a}'.",
    unused_a: "Unused '{a}'.",
    use_double: "Use double quotes, not single quotes.",
    use_open: (
        "Wrap a ternary expression in parens, "
        + "with a line break after the left paren."
    ),
    use_spaces: "Use spaces, not tabs.",
    var_loop: "Don't declare variables in a loop.",
    var_switch: "Don't declare variables in a switch.",
    weird_condition_a: "Weird condition '{a}'.",
    weird_expression_a: "Weird expression '{a}'.",
    weird_loop: "Weird loop.",
    weird_relation_a: "Weird relation '{a}'.",
    wrap_condition: "Wrap the condition in parens.",
    wrap_immediate: (
        "Wrap an immediate function invocation in parentheses to assist "
        + "the reader in understanding that the expression is the result "
        + "of a function, and not the function itself."
    ),
    wrap_parameter: "Wrap the parameter in parens.",
    wrap_regexp: "Wrap this regexp in parens to avoid confusion.",
    wrap_unary: "Wrap the unary expression in parens."
};

// Regular expression literals:

function tag_regexp(strings) {
    return new RegExp(strings.raw[0].replace(/\s/g, ""));
}

// supplant {variables}
const rx_supplant = /\{([^{}]*)\}/g;
// carriage return, carriage return linefeed, or linefeed
const rx_crlf = tag_regexp `
      \n
    | \r \n?
`;
// identifier
const rx_identifier = tag_regexp ` ^(
    [ a-z A-Z _ $ ]
    [ a-z A-Z 0-9 _ $ ]*
)$`;
const rx_module = tag_regexp ` ^ [ a-z A-Z 0-9 _ $ : . @ \- \/ ]+ $ `;
const rx_bad_property = tag_regexp `
    ^_
  | \$
  | Sync $
  | _ $
`;
// star slash
const rx_star_slash = tag_regexp ` \* \/ `;
// slash star
const rx_slash_star = tag_regexp ` \/ \* `;
// slash star or ending slash
const rx_slash_star_or_slash = tag_regexp ` \/ \* | \/ $ `;
// uncompleted work comment
const rx_todo = tag_regexp ` \b (?:
    todo
  | TO \s? DO
  | HACK
) \b `;
// tab
const rx_tab = /\t/g;
// directive
const rx_directive = tag_regexp ` ^ (
    jslint
  | property
  | global
) \s+ ( .* ) $ `;
const rx_directive_part = tag_regexp ` ^ (
    [ a-z A-Z $ _ ] [ a-z A-Z 0-9 $ _ ]*
) (?:
    : \s* ( true | false )
)? ,? \s* ( .* ) $ `;
// token
const rx_token = tag_regexp ` ^ (
    (\s+)
  | (
      [ a-z A-Z _ $ ]
      [ a-z A-Z 0-9 _ $ ]*
    )
  | [
      ( ) { } \[ \] , : ; ' " ~ \`
  ]
  | \? [ ? . ]?
  | = (?:
        = =?
      | >
    )?
  | \.+
  | \* [ * \/ = ]?
  | \/ [ * \/ ]?
  | \+ [ = + ]?
  | - [ = \- ]?
  | [ \^ % ] =?
  | & [ & = ]?
  | \| [ | = ]?
  | >{1,3} =?
  | < <? =?
  | ! (?:
        !
      | = =?
    )?
  | (
        0 n?
      | [ 1-9 ] [ 0-9 ]* n?
    )
) ( .* ) $ `;
// hack-jslint - bigint
const rx_digits = /^[0-9]*n?/;
const rx_hexs = /^[0-9A-F]*n?/i;
const rx_octals = /^[0-7]*n?/;
const rx_bits = /^[01]*n?/;
// mega
const rx_mega = /[`\\]|\$\{/;
// JSON number
const rx_JSON_number = tag_regexp ` ^
    -?
    (?: 0 | [ 1-9 ] \d* )
    (?: \. \d* )?
    (?: [ e E ] [ \- + ]? \d+ )?
$ `;
// initial cap
const rx_cap = /^[A-Z]/;

function is_letter(string) {
    return (
        (string >= "a" && string <= "z\uffff")
        || (string >= "A" && string <= "Z\uffff")
    );
}

function supplant(string, object) {
    return string.replace(rx_supplant, function (found, filling) {
        const replacement = object[filling];
        return (
            replacement !== undefined
            ? replacement
            : found
        );
    });
}

let anon;               // The guessed name for anonymous functions.
let blockage;           // The current block.
let block_stack;        // The stack of blocks.
let declared_globals;   // The object containing the global declarations.
let directives;         // The directive comments.
let directive_mode;     // true if directives are still allowed.
let early_stop;         // true if JSLint cannot finish.
let exports;            // The exported names and values.
let froms;              // The array collecting all import-from strings.
let fudge;              // true if the natural numbers start with 1.
let functionage;        // The current function.
let functions;          // The array containing all of the functions.
let global;             // The global object; the outermost context.
let json_mode;          // true if parsing JSON.
let lines;              // The array containing source lines.
let mega_mode;          // true if currently parsing a megastring literal.
let module_mode;        // true if import or export was used.
let next_token;         // The next token to be examined in the parse.
let option;             // The options parameter.
let property;           // The object containing the tallied property names.
let shebang;            // true if a #! was seen on the first line.
let stack;              // The stack of functions.
let syntax;             // The object containing the parser.
let token;              // The current token being examined in the parse.
let token_nr;           // The number of the next token.
let tokens;             // The array of tokens.
let tenure;             // The predefined property registry.
let tree;               // The abstract parse tree.
let var_mode;           // "var" if using var; "let" if using let.
let warnings;           // The array collecting all generated warnings.

// Error reportage functions:

function artifact(the_token) {

// Return a string representing an artifact.

    if (the_token === undefined) {
        the_token = next_token;
    }
    return (
        (the_token.id === "(string)" || the_token.id === "(number)")
        ? String(the_token.value)
        : the_token.id
    );
}

function artifact_line(the_token) {

// Return the fudged line number of an artifact.

    if (the_token === undefined) {
        the_token = next_token;
    }
    return the_token.line + fudge;
}

function artifact_column(the_token) {

// Return the fudged column number of an artifact.

    if (the_token === undefined) {
        the_token = next_token;
    }
    return the_token.from + fudge;
}

function warn_at(code, line, column, a, b, c, d) {

// Report an error at some line and column of the program. The warning object
// resembles an exception.

    const warning = {         // ~~
        name: "JSLintError",
        column,
        line,
        code
    };
    if (a !== undefined) {
        warning.a = a;
    }
    if (b !== undefined) {
        warning.b = b;
    }
    if (c !== undefined) {
        warning.c = c;
    }
    if (d !== undefined) {
        warning.d = d;
    }
    warning.message = supplant(bundle[code] || code, warning);
    // hack-jslint - line_ignore
    Object.assign(warning, lines_extra[warning.line]);
    if (warning.ignore) {
        return;
    }
    // hack-jslint - debug warning
    if (option.debug) {
        warning.stack = warning.stack || new Error().stack;
    }
    warnings.push(warning);
    return warning;
}

function stop_at(code, line, column, a, b, c, d) {

// Same as warn_at, except that it stops the analysis.

    throw warn_at(code, line, column, a, b, c, d);
}

function warn(code, the_token, a, b, c, d) {

// Same as warn_at, except the warning will be associated with a specific token.
// If there is already a warning on this token, suppress the new one. It is
// likely that the first warning will be the most meaningful.

    if (the_token === undefined) {
        the_token = next_token;
    }
    if (the_token.warning === undefined) {
        the_token.warning = warn_at(
            code,
            the_token.line,
            the_token.from,
            a || artifact(the_token),
            b,
            c,
            d
        );
        return the_token.warning;
    }
}

function stop(code, the_token, a, b, c, d) {

// Similar to warn and stop_at. If the token already had a warning, that
// warning will be replaced with this new one. It is likely that the stopping
// warning will be the more meaningful.

    if (the_token === undefined) {
        the_token = next_token;
    }
    delete the_token.warning;
    throw warn(code, the_token, a, b, c, d);
}

// Tokenize:

function tokenize(source) {

// tokenize takes a source and produces from it an array of token objects.
// JavaScript is notoriously difficult to tokenize because of the horrible
// interactions between automatic semicolon insertion, regular expression
// literals, and now megastring literals. JSLint benefits from eliminating
// automatic semicolon insertion and nested megastring literals, which allows
// full tokenization to precede parsing.

// If the source is not an array, then it is split into lines at the
// carriage return/linefeed.

    lines = (
        Array.isArray(source)
        ? source
        : source.split(rx_crlf)
    );
    tokens = [];

    let char;                   // a popular character
    let column = 0;             // the column number of the next character
    let first;                  // the first token
    let from;                   // the starting column number of the token
    let line = -1;              // the line number of the next character
    let nr = 0;                 // the next token number
    let previous = global;      // the previous token including comments
    let prior = global;         // the previous token excluding comments
    let mega_from;              // the starting column of megastring
    let mega_line;              // the starting line of megastring
    let regexp_seen;            // regular expression literal seen on this line
    let snippet;                // a piece of string
    let source_line = "";       // the remaining line source string
    let whole_line = "";        // the whole line source string

    if (lines[0].startsWith("#!")) {
        line = 0;
        shebang = true;
    }

    function next_line() {

// Put the next line of source in source_line. If the line contains tabs,
// replace them with spaces and give a warning. Also warn if the line contains
// unsafe characters or is too damn long.

        let at;
        if (
            !option.long
            && whole_line.length > 80
            && !json_mode
            && first
            && !regexp_seen
            // hack-jslint - ignore too_long url
            && !(
                option.modeUtility2
                && (
                    /^\s*?(?:\/\/(?:!!\u0020|\u0020https:\/\/)|(?:\S+?\u0020)?(?:https:\/\/|this\u0020.*?\u0020package\u0020will\u0020))/m
                ).test(whole_line)
            )
        ) {
            warn_at("too_long", line, 80);
        }
        column = 0;
        line += 1;
        regexp_seen = false;
        source_line = lines[line];
        whole_line = source_line || "";
        if (source_line !== undefined) {
            // hack-jslint - source_line
            let line_extra;
            let match;
            line_extra = {};
            line_extra.line = line;
            line_extra.source = source_line;
            lines_extra[line] = line_extra;
            match = (
                source_line.match(
                    /^\/\*\u0020jslint\u0020(ignore:start|ignore:end|utility2:true)\u0020\*\/$/m
                )
                || source_line.slice(-50).match(
                    /\u0020\/\/\u0020jslint\u0020(ignore:line)$/m
                )
            );
            switch (match && match[1]) {
            case "ignore:end":
                line_ignore = undefined;
                break;
            case "ignore:line":
                line_ignore = "line";
                break;
            case "ignore:start":
                line_ignore = true;
                break;
            case "utility2:true":
                option.bitwise = true;
                option.browser = true;
                option.debug = true;
                option.node = true;
                option.nomen = true;
                option.this = true;
                option.modeUtility2 = true;
                [].concat(
                    allowed_option.browser,
                    allowed_option.node,
                    "global",
                    "globalThis"
                ).forEach(function (key) {
                    declared_globals[key] = false;
                });
                break;
            }
            line_extra.ignore = line_ignore;
            switch (line_ignore) {
            case "line":
                line_ignore = undefined;
                break;
            case true:
                source_line = "";
                break;
            }
            at = source_line.search(rx_tab);
            if (at >= 0) {
                if (!option.white) {
                    warn_at("use_spaces", line, at + 1);
                }
                source_line = source_line.replace(rx_tab, " ");
            }
            if (!option.white && source_line.slice(-1) === " ") {
                warn_at(
                    "unexpected_trailing_space",
                    line,
                    source_line.length - 1
                );
            }
        }
        return source_line;
    }

// Most tokens, including the identifiers, operators, and punctuators, can be
// found with a regular expression. Regular expressions cannot correctly match
// regular expression literals, so we will match those the hard way. String
// literals and number literals can be matched by regular expressions, but they
// don't provide good warnings. The functions snip, next_char, back_char,
// some_digits, and escape help in the parsing of literals.

    function snip() {

// Remove the last character from snippet.

        snippet = snippet.slice(0, -1);
    }

    function next_char(match) {

// Get the next character from the source line. Remove it from the source_line,
// and append it to the snippet. Optionally check that the previous character
// matched an expected value.

        if (match !== undefined && char !== match) {
            return stop_at(
                (
                    char === ""
                    ? "expected_a"
                    : "expected_a_b"
                ),
                line,
                column - 1,
                match,
                char
            );
        }
        if (source_line) {
            char = source_line[0];
            source_line = source_line.slice(1);
            snippet += char;
        } else {
            char = "";
            snippet += " ";
        }
        column += 1;
        return char;
    }

    function back_char() {

// Back up one character by moving a character from the end of the snippet to
// the front of the source_line.

        if (snippet) {
            char = snippet.slice(-1);
            source_line = char + source_line;
            column -= 1;
            snip();
        } else {
            char = "";
        }
        return char;
    }

    function some_digits(rx, quiet) {
        const digits = source_line.match(rx)[0];
        const length = digits.length;
        if (!quiet && length === 0) {
            warn_at("expected_digits_after_a", line, column, snippet);
        }
        column += length;
        source_line = source_line.slice(length);
        snippet += digits;
        next_char();
        return length;
    }

    function escape(extra) {
        next_char("\\");
        if (escapeable[char] === true) {
            return next_char();
        }
        if (char === "") {
            return stop_at("unclosed_string", line, column);
        }
        if (char === "u") {
            if (next_char("u") === "{") {
                if (json_mode) {
                    warn_at("unexpected_a", line, column - 1, char);
                }
                if (some_digits(rx_hexs) > 5) {
                    warn_at("too_many_digits", line, column - 1);
                }
                if (next_char() !== "}") {
                    stop_at("expected_a_before_b", line, column, "}", char);
                }
                return next_char();
            }
            back_char();
            if (some_digits(rx_hexs, true) < 4) {
                warn_at("expected_four_digits", line, column - 1);
            }
            return;
        }
        if (extra && extra.indexOf(char) >= 0) {
            return next_char();
        }
        warn_at("unexpected_a_before_b", line, column - 2, "\\", char);
    }

    function make(id, value, identifier) {

// Make the token object and append it to the tokens list.

        const the_token = {
            from,
            id,
            identifier: Boolean(identifier),
            line,
            nr,
            thru: column
        };
        tokens[nr] = the_token;
        nr += 1;

// Directives must appear before the first statement.

        if (id !== "(comment)" && id !== ";") {
            directive_mode = false;
        }

// If the token is to have a value, give it one.

        if (value !== undefined) {
            the_token.value = value;
        }

// If this token is an identifier that touches a preceding number, or
// a "/", comment, or regular expression literal that touches a preceding
// comment or regular expression literal, then give a missing space warning.
// This warning is not suppressed by option.white.

        if (
            previous.line === line
            && previous.thru === from
            && (id === "(comment)" || id === "(regexp)" || id === "/")
            && (previous.id === "(comment)" || previous.id === "(regexp)")
        ) {
            warn(
                "expected_space_a_b",
                the_token,
                artifact(previous),
                artifact(the_token)
            );
        }
        if (previous.id === "." && id === "(number)") {
            warn("expected_a_before_b", previous, "0", ".");
        }
        if (prior.id === "." && the_token.identifier) {
            the_token.dot = true;
        }

// The previous token is used to detect adjacency problems.

        previous = the_token;

// The prior token is a previous token that was not a comment. The prior token
// is used to disambiguate "/", which can mean division or regular expression
// literal.

        if (previous.id !== "(comment)") {
            prior = previous;
        }
        return the_token;
    }

    function parse_directive(the_comment, body) {

// JSLint recognizes three directives that can be encoded in comments. This
// function processes one item, and calls itself recursively to process the
// next one.

        const result = body.match(rx_directive_part);
        if (result) {
            let allowed;
            const name = result[1];
            const value = result[2];
            if (the_comment.directive === "jslint") {
                allowed = allowed_option[name];
                if (
                    typeof allowed === "boolean"
                    || typeof allowed === "object"
                ) {
                    if (
                        value === ""
                        || value === "true"
                        || value === undefined
                    ) {
                        option[name] = true;
                        if (Array.isArray(allowed)) {
                            populate(allowed, declared_globals, false);
                        }
                    } else if (value === "false") {
                        option[name] = false;
                    } else {
                        warn("bad_option_a", the_comment, name + ":" + value);
                    }
                } else {
                    warn("bad_option_a", the_comment, name);
                }
            } else if (the_comment.directive === "property") {
                if (tenure === undefined) {
                    tenure = empty();
                }
                tenure[name] = true;
            } else if (the_comment.directive === "global") {
                if (value) {
                    warn("bad_option_a", the_comment, name + ":" + value);
                }
                declared_globals[name] = false;
                module_mode = the_comment;
            }
            return parse_directive(the_comment, result[3]);
        }
        if (body) {
            return stop("bad_directive_a", the_comment, body);
        }
    }

    function comment(snippet) {

// Make a comment object. Comments are not allowed in JSON text. Comments can
// include directives and notices of incompletion.

        const the_comment = make("(comment)", snippet);
        if (Array.isArray(snippet)) {
            snippet = snippet.join(" ");
        }
        if (!option.devel && rx_todo.test(snippet)) {
            warn("todo_comment", the_comment);
        }
        const result = snippet.match(rx_directive);
        if (result) {
            if (!directive_mode) {
                warn_at("misplaced_directive_a", line, from, result[1]);
            } else {
                the_comment.directive = result[1];
                parse_directive(the_comment, result[2]);
            }
            directives.push(the_comment);
        }
        return the_comment;
    }

    function regexp() {

// Parse a regular expression literal.

        let multi_mode = false;
        let result;
        let value;
        regexp_seen = true;

        function quantifier() {

// Match an optional quantifier.

            if (char === "?" || char === "*" || char === "+") {
                next_char();
            } else if (char === "{") {
                if (some_digits(rx_digits, true) === 0) {
                    warn_at("expected_a_before_b", line, column, "0", ",");
                }
                if (char === ",") {
                    some_digits(rx_digits, true);
                }
                next_char("}");
            } else {
                return;
            }
            if (char === "?") {
                next_char("?");
            }
        }

        function subklass() {

// Match a character in a character class.

            if (char === "\\") {
                escape("BbDdSsWw-[]^");
                return true;
            }
            if (
                char === ""
                || char === "["
                || char === "]"
                || char === "/"
                || char === "^"
                || char === "-"
            ) {
                return false;
            }
            if (char === " ") {
                warn_at("expected_a_b", line, column, "\\u0020", " ");
            } else if (char === "`" && mega_mode) {
                warn_at("unexpected_a", line, column, "`");
            }
            next_char();
            return true;
        }

        function ranges() {

// Match a range of subclasses.

            if (subklass()) {
                if (char === "-") {
                    next_char("-");
                    if (!subklass()) {
                        return stop_at(
                            "unexpected_a",
                            line,
                            column - 1,
                            "-"
                        );
                    }
                }
                return ranges();
            }
        }

        function klass() {

// Match a class.

            next_char("[");
            if (char === "^") {
                next_char("^");
            }
            (function classy() {
                ranges();
                if (char !== "]" && char !== "") {
                    warn_at(
                        "expected_a_before_b",
                        line,
                        column,
                        "\\",
                        char
                    );
                    next_char();
                    return classy();
                }
            }());
            next_char("]");
        }

        function choice() {

            function group() {

// Match a group that starts with left paren.

                next_char("(");
                if (char === "?") {
                    next_char("?");
                    if (char === "=" || char === "!") {
                        next_char();
                    } else {
                        next_char(":");
                    }
                } else if (char === ":") {
                    warn_at("expected_a_before_b", line, column, "?", ":");
                }
                choice();
                next_char(")");
            }

            function factor() {
                if (
                    char === ""
                    || char === "/"
                    || char === "]"
                    || char === ")"
                ) {
                    return false;
                }
                if (char === "(") {
                    group();
                    return true;
                }
                if (char === "[") {
                    klass();
                    return true;
                }
                if (char === "\\") {
                    escape("BbDdSsWw^${}[]():=!.|*+?");
                    return true;
                }
                if (
                    char === "?"
                    || char === "+"
                    || char === "*"
                    || char === "}"
                    || char === "{"
                ) {
                    warn_at(
                        "expected_a_before_b",
                        line,
                        column - 1,
                        "\\",
                        char
                    );
                } else if (char === "`") {
                    if (mega_mode) {
                        warn_at("unexpected_a", line, column - 1, "`");
                    }
                } else if (char === " ") {
                    warn_at(
                        "expected_a_b",
                        line,
                        column - 1,
                        "\\s",
                        " "
                    );
                } else if (char === "$") {
                    if (source_line[0] !== "/") {
                        multi_mode = true;
                    }
                } else if (char === "^") {
                    if (snippet !== "^") {
                        multi_mode = true;
                    }
                }
                next_char();
                return true;
            }

            function sequence(follow) {
                if (factor()) {
                    quantifier();
                    return sequence(true);
                }
                if (!follow) {
                    warn_at("expected_regexp_factor_a", line, column, char);
                }
            }

// Match a choice (a sequence that can be followed by | and another choice).

            sequence();
            if (char === "|") {
                next_char("|");
                return choice();
            }
        }

// Scan the regexp literal. Give a warning if the first character is = because
// /= looks like a division assignment operator.

        snippet = "";
        next_char();
        if (char === "=") {
            warn_at("expected_a_before_b", line, column, "\\", "=");
        }
        choice();

// Make sure there is a closing slash.

        snip();
        value = snippet;
        next_char("/");

// Process dangling flag letters.

        const allowed = {
            g: true,
            i: true,
            m: true,
            u: true,
            y: true
        };
        const flag = empty();
        (function make_flag() {
            if (is_letter(char)) {
                if (allowed[char] !== true) {
                    warn_at("unexpected_a", line, column, char);
                }
                allowed[char] = false;
                flag[char] = true;
                next_char();
                return make_flag();
            }
        }());
        back_char();
        if (char === "/" || char === "*") {
            return stop_at("unexpected_a", line, from, char);
        }
        result = make("(regexp)", char);
        result.flag = flag;
        result.value = value;
        if (multi_mode && !flag.m) {
            warn_at("missing_m", line, column);
        }
        return result;
    }

    function string(quote) {

// Make a string token.

        let the_token;
        snippet = "";
        next_char();

        return (function next() {
            if (char === quote) {
                snip();
                the_token = make("(string)", snippet);
                the_token.quote = quote;
                return the_token;
            }
            if (char === "") {
                return stop_at("unclosed_string", line, column);
            }
            if (char === "\\") {
                escape(quote);
            } else if (char === "`") {
                if (mega_mode) {
                    warn_at("unexpected_a", line, column, "`");
                }
                next_char("`");
            } else {
                next_char();
            }
            return next();
        }());
    }

    function frack() {
        if (char === ".") {
            some_digits(rx_digits);
        }
        if (char === "E" || char === "e") {
            next_char();
            if (char !== "+" && char !== "-") {
                back_char();
            }
            some_digits(rx_digits);
        }
    }

    function number() {
        if (snippet === "0") {
            next_char();
            if (char === ".") {
                frack();
            } else if (char === "b") {
                some_digits(rx_bits);
            } else if (char === "o") {
                some_digits(rx_octals);
            } else if (char === "x") {
                some_digits(rx_hexs);
            }
        } else {
            next_char();
            frack();
        }

// If the next character after a number is a digit or letter, then something
// unexpected is going on.

        if (
            (char >= "0" && char <= "9")
            || (char >= "a" && char <= "z")
            || (char >= "A" && char <= "Z")
        ) {
            return stop_at(
                "unexpected_a_after_b",
                line,
                column - 1,
                snippet.slice(-1),
                snippet.slice(0, -1)
            );
        }
        back_char();
        return make("(number)", snippet);
    }

    function lex() {
        let array;
        let i = 0;
        let j = 0;
        let last;
        let result;
        let the_token;

// This should properly be a tail recursive function, but sadly, conformant
// implementations of ES6 are still rare. This is the ideal code:

//      if (!source_line) {
//          source_line = next_line();
//          from = 0;
//          return (
//              source_line === undefined
//              ? (
//                  mega_mode
//                  ? stop_at("unclosed_mega", mega_line, mega_from)
//                  : make("(end)")
//              )
//              : lex()
//          );
//      }

// Unfortunately, incompetent JavaScript engines will sometimes fail to execute
// it correctly. So for now, we do it the old fashioned way.

        while (!source_line) {
            source_line = next_line();
            from = 0;
            if (source_line === undefined) {
                return (
                    mega_mode
                    ? stop_at("unclosed_mega", mega_line, mega_from)
                    : make("(end)")
                );
            }
        }

        from = column;
        result = source_line.match(rx_token);

// result[1] token
// result[2] whitespace
// result[3] identifier
// result[4] number
// result[5] rest

        if (!result) {
            return stop_at(
                "unexpected_char_a",
                line,
                column,
                source_line[0]
            );
        }

        snippet = result[1];
        column += snippet.length;
        source_line = result[5];

// Whitespace was matched. Call lex again to get more.

        if (result[2]) {
            return lex();
        }

// The token is an identifier.

        if (result[3]) {
            return make(snippet, undefined, true);
        }

// The token is a number.

        if (result[4]) {
            return number(snippet);
        }

// The token is a string.

        if (snippet === "\"") {
            return string(snippet);
        }
        if (snippet === "'") {
            if (!option.single) {
                warn_at("use_double", line, column);
            }
            return string(snippet);
        }

// The token is a megastring. We don't allow any kind of mega nesting.

        if (snippet === "`") {
            if (mega_mode) {
                return stop_at("expected_a_b", line, column, "}", "`");
            }
            snippet = "";
            mega_from = from;
            mega_line = line;
            mega_mode = true;

// Parsing a mega literal is tricky. First make a ` token.

            make("`");
            from += 1;

// Then loop, building up a string, possibly from many lines, until seeing
// the end of file, a closing `, or a ${ indicting an expression within the
// string.

            (function part() {
                const at = source_line.search(rx_mega);

// If neither ` nor ${ is seen, then the whole line joins the snippet.

                if (at < 0) {
                    snippet += source_line + "\n";
                    return (
                        next_line() === undefined
                        ? stop_at("unclosed_mega", mega_line, mega_from)
                        : part()
                    );
                }
                snippet += source_line.slice(0, at);
                column += at;
                source_line = source_line.slice(at);
                if (source_line[0] === "\\") {
                    snippet += source_line.slice(0, 2);
                    source_line = source_line.slice(2);
                    column += 2;
                    return part();
                }

// if either ` or ${ was found, then the preceding joins the snippet to become
// a string token.

                make("(string)", snippet).quote = "`";
                snippet = "";

// If ${, then make tokens that will become part of an expression until
// a } token is made.

                if (source_line[0] === "$") {
                    column += 2;
                    make("${");
                    source_line = source_line.slice(2);
                    (function expr() {
                        const id = lex().id;
                        if (id === "{") {
                            return stop_at(
                                "expected_a_b",
                                line,
                                column,
                                "}",
                                "{"
                            );
                        }
                        if (id !== "}") {
                            return expr();
                        }
                    }());
                    return part();
                }
            }());
            source_line = source_line.slice(1);
            column += 1;
            mega_mode = false;
            return make("`");
        }

// The token is a // comment.

        if (snippet === "//") {
            snippet = source_line;
            source_line = "";
            the_token = comment(snippet);
            if (mega_mode) {
                warn("unexpected_comment", the_token, "`");
            }
            return the_token;
        }

// The token is a /* comment.

        if (snippet === "/*") {
            array = [];
            if (source_line[0] === "/") {
                warn_at("unexpected_a", line, column + i, "/");
            }
            (function next() {
                if (source_line > "") {
                    i = source_line.search(rx_star_slash);
                    if (i >= 0) {
                        return;
                    }
                    j = source_line.search(rx_slash_star);
                    if (j >= 0) {
                        warn_at("nested_comment", line, column + j);
                    }
                }
                array.push(source_line);
                source_line = next_line();
                if (source_line === undefined) {
                    return stop_at("unclosed_comment", line, column);
                }
                return next();
            }());
            snippet = source_line.slice(0, i);
            j = snippet.search(rx_slash_star_or_slash);
            if (j >= 0) {
                warn_at("nested_comment", line, column + j);
            }
            array.push(snippet);
            column += i + 2;
            source_line = source_line.slice(i + 2);
            return comment(array);
        }

// The token is a slash.

        if (snippet === "/") {

// The / can be a division operator or the beginning of a regular expression
// literal. It is not possible to know which without doing a complete parse.
// We want to complete the tokenization before we begin to parse, so we will
// estimate. This estimator can fail in some cases. For example, it cannot
// know if "}" is ending a block or ending an object literal, so it can
// behave incorrectly in that case; it is not meaningful to divide an
// object, so it is likely that we can get away with it. We avoided the worst
// cases by eliminating automatic semicolon insertion.

            if (prior.identifier) {
                if (!prior.dot) {
                    if (prior.id === "return") {
                        return regexp();
                    }
                    if (
                        prior.id === "(begin)"
                        || prior.id === "case"
                        || prior.id === "delete"
                        || prior.id === "in"
                        || prior.id === "instanceof"
                        || prior.id === "new"
                        || prior.id === "typeof"
                        || prior.id === "void"
                        || prior.id === "yield"
                    ) {
                        the_token = regexp();
                        return stop("unexpected_a", the_token);
                    }
                }
            } else {
                last = prior.id[prior.id.length - 1];
                if ("(,=:?[".indexOf(last) >= 0) {
                    return regexp();
                }
                if ("!&|{};~+-*%/^<>".indexOf(last) >= 0) {
                    the_token = regexp();
                    warn("wrap_regexp", the_token);
                    return the_token;
                }
            }
            if (source_line[0] === "=") {
                column += 1;
                source_line = source_line.slice(1);
                snippet = "/=";
                warn_at("unexpected_a", line, column, "/=");
            }
        }
        return make(snippet);
    }

    first = lex();
    json_mode = first.id === "{" || first.id === "[";

// This loop will be replaced with a recursive call to lex when ES6 has been
// finished and widely deployed and adopted.

    while (true) {
        if (lex().id === "(end)") {
            break;
        }
    }
}

// Parsing:

// Parsing weaves the tokens into an abstract syntax tree. During that process,
// a token may be given any of these properties:

//      arity       string
//      label       identifier
//      name        identifier
//      expression  expressions
//      block       statements
//      else        statements (else, default, catch)

// Specialized tokens may have additional properties.

function survey(name) {
    let id = name.id;

// Tally the property name. If it is a string, only tally strings that conform
// to the identifier rules.

    if (id === "(string)") {
        id = name.value;
        if (!rx_identifier.test(id)) {
            return id;
        }
    } else if (id === "`") {
        if (name.value.length === 1) {
            id = name.value[0].value;
            if (!rx_identifier.test(id)) {
                return id;
            }
        }
    } else if (!name.identifier) {
        return stop("expected_identifier_a", name);
    }

// If we have seen this name before, increment its count.

    if (typeof property[id] === "number") {
        property[id] += 1;

// If this is the first time seeing this property name, and if there is a
// tenure list, then it must be on the list. Otherwise, it must conform to
// the rules for good property names.
    } else {
        if (tenure !== undefined) {
            if (tenure[id] !== true) {
                warn("unregistered_property_a", name);
            }
        } else {
            // hack-jslint - nomen
            if (!option.nomen && name.identifier && rx_bad_property.test(id)) {
                warn("bad_property_a", name);
            }
        }
        property[id] = 1;
    }
    return id;
}

function dispense() {

// Deliver the next token, skipping the comments.

    const cadet = tokens[token_nr];
    token_nr += 1;
    // hack-jslint - advance token async/await to next_token by context
    const next_cadet = tokens[token_nr] || {};
    if (next_cadet.identifier && (
        cadet.id === "await"
        || (cadet.id === "async" && next_cadet.id === "function")
    )) {
        cadet.id = next_cadet.id;
        token_nr += 1;
    }
    if (cadet.id === "(comment)") {
        if (json_mode) {
            warn("unexpected_a", cadet);
        }
        return dispense();
    } else {
        return cadet;
    }
}

function lookahead() {

// Look ahead one token without advancing.

    const old_token_nr = token_nr;
    const cadet = dispense(true);
    token_nr = old_token_nr;
    return cadet;
}

function advance(id, match) {

// Produce the next token.

// Attempt to give helpful names to anonymous functions.

    if (token.identifier && token.id !== "function") {
        anon = token.id;
    } else if (token.id === "(string)" && rx_identifier.test(token.value)) {
        anon = token.value;
    }

// Attempt to match next_token with an expected id.

    if (id !== undefined && next_token.id !== id) {
        return (
            match === undefined
            ? stop("expected_a_b", next_token, id, artifact())
            : stop(
                "expected_a_b_from_c_d",
                next_token,
                id,
                artifact(match),
                artifact_line(match),
                artifact(next_token)
            )
        );
    }

// Promote the tokens, skipping comments.

    token = next_token;
    next_token = dispense();
    if (next_token.id === "(end)") {
        token_nr -= 1;
    }
}

// Parsing of JSON is simple:

function json_value() {
    let negative;
    if (next_token.id === "{") {
        return (function json_object() {
            const brace = next_token;
            const object = empty();
            const properties = [];
            brace.expression = properties;
            advance("{");
            if (next_token.id !== "}") {
                (function next() {
                    let name;
                    let value;
                    if (next_token.quote !== "\"") {
                        warn(
                            "unexpected_a",
                            next_token,
                            next_token.quote
                        );
                    }
                    name = next_token;
                    advance("(string)");
                    if (object[token.value] !== undefined) {
                        warn("duplicate_a", token);
                    } else if (token.value === "__proto__") {
                        warn("bad_property_a", token);
                    } else {
                        object[token.value] = token;
                    }
                    advance(":");
                    value = json_value();
                    value.label = name;
                    properties.push(value);
                    if (next_token.id === ",") {
                        advance(",");
                        return next();
                    }
                }());
            }
            advance("}", brace);
            return brace;
        }());
    }
    if (next_token.id === "[") {
        return (function json_array() {
            const bracket = next_token;
            const elements = [];
            bracket.expression = elements;
            advance("[");
            if (next_token.id !== "]") {
                (function next() {
                    elements.push(json_value());
                    if (next_token.id === ",") {
                        advance(",");
                        return next();
                    }
                }());
            }
            advance("]", bracket);
            return bracket;
        }());
    }
    if (
        next_token.id === "true"
        || next_token.id === "false"
        || next_token.id === "null"
    ) {
        advance();
        return token;
    }
    if (next_token.id === "(number)") {
        if (!rx_JSON_number.test(next_token.value)) {
            warn("unexpected_a");
        }
        advance();
        return token;
    }
    if (next_token.id === "(string)") {
        if (next_token.quote !== "\"") {
            warn("unexpected_a", next_token, next_token.quote);
        }
        advance();
        return token;
    }
    if (next_token.id === "-") {
        negative = next_token;
        negative.arity = "unary";
        advance("-");
        advance("(number)");
        if (!rx_JSON_number.test(token.value)) {
            warn("unexpected_a", token);
        }
        negative.expression = token;
        return negative;
    }
    stop("unexpected_a");
}

// Now we parse JavaScript.

function enroll(name, role, readonly) {

// Enroll a name into the current function context. The role can be exception,
// function, label, parameter, or variable. We look for variable redefinition
// because it causes confusion.

    const id = name.id;

// Reserved words may not be enrolled.

    if (syntax[id] !== undefined && id !== "ignore") {
        warn("reserved_a", name);
    } else {

// Has the name been enrolled in this context?

        let earlier = functionage.context[id];
        if (earlier) {
            warn(
                "redefinition_a_b",
                name,
                name.id,
                earlier.line + fudge
            );

// Has the name been enrolled in an outer context?
        } else {
            stack.forEach(function (value) {
                const item = value.context[id];
                if (item !== undefined) {
                    earlier = item;
                }
            });
            if (earlier) {
                if (id === "ignore") {
                    if (earlier.role === "variable") {
                        warn("unexpected_a", name);
                    }
                } else {
                    if (
                        (
                            role !== "exception"
                            || earlier.role !== "exception"
                        )
                        && role !== "parameter"
                        && role !== "function"
                    ) {
                        warn(
                            "redefinition_a_b",
                            name,
                            name.id,
                            earlier.line + fudge
                        );
                    }
                }
            }

// Enroll it.

            functionage.context[id] = name;
            name.dead = true;
            name.parent = functionage;
            name.init = false;
            name.role = role;
            name.used = 0;
            name.writable = !readonly;
        }
    }
}

function expression(rbp, initial) {

// This is the heart of the Pratt parser. I retained Pratt's nomenclature.
// They are elements of the parsing method called Top Down Operator Precedence.

// nud     Null denotation
// led     Left denotation
// lbp     Left binding power
// rbp     Right binding power

// It processes a nud (variable, constant, prefix operator). It will then
// process leds (infix operators) until the bind powers cause it to stop. It
// returns the expression's parse tree.

    let left;
    let the_symbol;

// Statements will have already advanced, so advance now only if the token is
// not the first of a statement,

    if (!initial) {
        advance();
    }
    the_symbol = syntax[token.id];
    if (the_symbol !== undefined && the_symbol.nud !== undefined) {
        left = the_symbol.nud();
    } else if (token.identifier) {
        left = token;
        left.arity = "variable";
    } else {
        return stop("unexpected_a", token);
    }
    (function right() {
        the_symbol = syntax[next_token.id];
        if (
            the_symbol !== undefined
            && the_symbol.led !== undefined
            && rbp < the_symbol.lbp
        ) {
            advance();
            left = the_symbol.led(left);
            return right();
        }
    }());
    return left;
}

function condition() {

// Parse the condition part of a do, if, while.

    const the_paren = next_token;
    let the_value;
    the_paren.free = true;
    advance("(");
    the_value = expression(0);
    advance(")");
    if (the_value.wrapped === true) {
        warn("unexpected_a", the_paren);
    }
    if (anticondition[the_value.id] === true) {
        warn("unexpected_a", the_value);
    }
    return the_value;
}

function is_weird(thing) {
    return (
        thing.id === "(regexp)"
        || thing.id === "{"
        || thing.id === "=>"
        || thing.id === "function"
        || (thing.id === "[" && thing.arity === "unary")
    );
}

function are_similar(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a)) {
        return (
            Array.isArray(b)
            && a.length === b.length
            && a.every(function (value, index) {
                return are_similar(value, b[index]);
            })
        );
    }
    if (Array.isArray(b)) {
        return false;
    }
    if (a.id === "(number)" && b.id === "(number)") {
        return a.value === b.value;
    }
    let a_string;
    let b_string;
    if (a.id === "(string)") {
        a_string = a.value;
    } else if (a.id === "`" && a.constant) {
        a_string = a.value[0];
    }
    if (b.id === "(string)") {
        b_string = b.value;
    } else if (b.id === "`" && b.constant) {
        b_string = b.value[0];
    }
    if (typeof a_string === "string") {
        return a_string === b_string;
    }
    if (is_weird(a) || is_weird(b)) {
        return false;
    }
    if (a.arity === b.arity && a.id === b.id) {
        if (a.id === ".") {
            return (
                are_similar(a.expression, b.expression)
                && are_similar(a.name, b.name)
            );
        }
        if (a.arity === "unary") {
            return are_similar(a.expression, b.expression);
        }
        if (a.arity === "binary") {
            return (
                a.id !== "("
                && are_similar(a.expression[0], b.expression[0])
                && are_similar(a.expression[1], b.expression[1])
            );
        }
        if (a.arity === "ternary") {
            return (
                are_similar(a.expression[0], b.expression[0])
                && are_similar(a.expression[1], b.expression[1])
                && are_similar(a.expression[2], b.expression[2])
            );
        }
        if (a.arity === "function" && a.arity === "regexp") {
            return false;
        }
        return true;
    }
    return false;
}

function semicolon() {

// Try to match a semicolon.

    if (next_token.id === ";") {
        advance(";");
    } else {
        warn_at(
            "expected_a_b",
            token.line,
            token.thru,
            ";",
            artifact(next_token)
        );
    }
    anon = "anonymous";
}

function statement() {

// Parse a statement. Any statement may have a label, but only four statements
// have use for one. A statement can be one of the standard statements, or
// an assignment expression, or an invocation expression.

    let first;
    let the_label;
    let the_statement;
    let the_symbol;
    advance();
    if (token.identifier && next_token.id === ":") {
        the_label = token;
        if (the_label.id === "ignore") {
            warn("unexpected_a", the_label);
        }
        advance(":");
        if (
            next_token.id === "do"
            || next_token.id === "for"
            || next_token.id === "switch"
            || next_token.id === "while"
        ) {
            enroll(the_label, "label", true);
            the_label.init = true;
            the_label.dead = false;
            the_statement = statement();
            the_statement.label = the_label;
            the_statement.statement = true;
            return the_statement;
        }
        advance();
        warn("unexpected_label_a", the_label);
    }

// Parse the statement.

    first = token;
    first.statement = true;
    the_symbol = syntax[first.id];
    if (the_symbol !== undefined && the_symbol.fud !== undefined) {
        the_symbol.disrupt = false;
        the_symbol.statement = true;
        the_statement = the_symbol.fud();
    } else {

// It is an expression statement.

        the_statement = expression(0, true);
        if (the_statement.wrapped && the_statement.id !== "(") {
            warn("unexpected_a", first);
        }
        semicolon();
    }
    if (the_label !== undefined) {
        the_label.dead = true;
    }
    return the_statement;
}

function statements() {

// Parse a list of statements. Give a warning if an unreachable statement
// follows a disruptive statement.

    const array = [];
    (function next(disrupt) {
        if (
            next_token.id !== "}"
            && next_token.id !== "case"
            && next_token.id !== "default"
            && next_token.id !== "else"
            && next_token.id !== "(end)"
        ) {
            let a_statement = statement();
            array.push(a_statement);
            if (disrupt) {
                warn("unreachable_a", a_statement);
            }
            return next(a_statement.disrupt);
        }
    }(false));
    return array;
}

function not_top_level(thing) {

// Some features should not be at the outermost level.

    if (functionage === global) {
        warn("unexpected_at_top_level_a", thing);
    }
}

function top_level_only(the_thing) {

// Some features must be at the most outermost level.

    if (blockage !== global) {
        warn("misplaced_a", the_thing);
    }
}

function block(special) {

// Parse a block, a sequence of statements wrapped in braces.
//  special "body"      The block is a function body.
//          "ignore"    No warning on an empty block.
//          "naked"     No advance.
//          undefined   An ordinary block.

    let stmts;
    let the_block;
    if (special !== "naked") {
        advance("{");
    }
    the_block = token;
    the_block.arity = "statement";
    the_block.body = special === "body";

// Top level function bodies may include the "use strict" pragma.

    if (
        special === "body"
        && stack.length === 1
        && next_token.value === "use strict"
    ) {
        next_token.statement = true;
        advance("(string)");
        advance(";");
    }
    stmts = statements();
    the_block.block = stmts;
    if (stmts.length === 0) {
        if (!option.devel && special !== "ignore") {
            warn("empty_block", the_block);
        }
        the_block.disrupt = false;
    } else {
        the_block.disrupt = stmts[stmts.length - 1].disrupt;
    }
    advance("}");
    return the_block;
}

function mutation_check(the_thing) {

// The only expressions that may be assigned to are
//      e.b
//      e[b]
//      v
//      [destructure]
//      {destructure}

    if (
        the_thing.arity !== "variable"
        && the_thing.id !== "."
        && the_thing.id !== "["
        && the_thing.id !== "{"
    ) {
        warn("bad_assignment_a", the_thing);
        return false;
    }
    return true;
}

function left_check(left, right) {

// Warn if the left is not one of these:
//      e.b
//      e[b]
//      e()
//      ?:
//      identifier

    const id = left.id;
    if (
        !left.identifier
        && (
            left.arity !== "ternary"
            || (
                !left_check(left.expression[1])
                && !left_check(left.expression[2])
            )
        )
        && (
            left.arity !== "binary"
            || (id !== "." && id !== "(" && id !== "[")
        )
    ) {
        warn("unexpected_a", right);
        return false;
    }
    return true;
}

// These functions are used to specify the grammar of our language:

function symbol(id, bp) {

// Make a symbol if it does not already exist in the language's syntax.

    let the_symbol = syntax[id];
    if (the_symbol === undefined) {
        the_symbol = empty();
        the_symbol.id = id;
        the_symbol.lbp = bp || 0;
        syntax[id] = the_symbol;
    }
    return the_symbol;
}

function assignment(id) {

// Make an assignment operator. The one true assignment is different because
// its left side, when it is a variable, is not treated as an expression.
// That case is special because that is when a variable gets initialized. The
// other assignment operators can modify, but they cannot initialize.

    const the_symbol = symbol(id, 20);
    the_symbol.led = function (left) {
        const the_token = token;
        let right;
        the_token.arity = "assignment";
        right = expression(20 - 1);
        if (id === "=" && left.arity === "variable") {
            the_token.names = left;
            the_token.expression = right;
        } else {
            the_token.expression = [left, right];
        }
        if (
            right.arity === "assignment"
            || right.arity === "pre"
            || right.arity === "post"
        ) {
            warn("unexpected_a", right);
        }
        mutation_check(left);
        return the_token;
    };
    return the_symbol;
}

function constant(id, type, value) {

// Make a constant symbol.

    const the_symbol = symbol(id);
    the_symbol.constant = true;
    the_symbol.nud = (
        typeof value === "function"
        ? value
        : function () {
            token.constant = true;
            if (value !== undefined) {
                token.value = value;
            }
            return token;
        }
    );
    the_symbol.type = type;
    the_symbol.value = value;
    return the_symbol;
}

function infix(id, bp, f) {

// Make an infix operator.

    const the_symbol = symbol(id, bp);
    the_symbol.led = function (left) {
        const the_token = token;
        the_token.arity = "binary";
        if (f !== undefined) {
            return f(left);
        }
        the_token.expression = [left, expression(bp)];
        return the_token;
    };
    return the_symbol;
}

function infixr(id, bp) {

// Make a right associative infix operator.

    const the_symbol = symbol(id, bp);
    the_symbol.led = function (left) {
        const the_token = token;
        the_token.arity = "binary";
        the_token.expression = [left, expression(bp - 1)];
        return the_token;
    };
    return the_symbol;
}

function post(id) {

// Make one of the post operators.

    const the_symbol = symbol(id, 150);
    the_symbol.led = function (left) {
        token.expression = left;
        token.arity = "post";
        mutation_check(token.expression);
        return token;
    };
    return the_symbol;
}

function pre(id) {

// Make one of the pre operators.

    const the_symbol = symbol(id);
    the_symbol.nud = function () {
        const the_token = token;
        the_token.arity = "pre";
        the_token.expression = expression(150);
        mutation_check(the_token.expression);
        return the_token;
    };
    return the_symbol;
}

function prefix(id, f) {

// Make a prefix operator.

    const the_symbol = symbol(id);
    the_symbol.nud = function () {
        const the_token = token;
        the_token.arity = "unary";
        if (typeof f === "function") {
            return f();
        }
        the_token.expression = expression(150);
        return the_token;
    };
    return the_symbol;
}

function stmt(id, f) {

// Make a statement.

    const the_symbol = symbol(id);
    the_symbol.fud = function () {
        token.arity = "statement";
        return f();
    };
    return the_symbol;
}

function ternary(id1, id2) {

// Make a ternary operator.

    const the_symbol = symbol(id1, 30);
    the_symbol.led = function (left) {
        const the_token = token;
        const second = expression(20);
        advance(id2);
        token.arity = "ternary";
        the_token.arity = "ternary";
        the_token.expression = [left, second, expression(10)];
        if (next_token.id !== ")") {
            warn("use_open", the_token);
        }
        return the_token;
    };
    return the_symbol;
}

// Begin defining the language.

syntax = empty();

symbol("}");
symbol(")");
symbol("]");
symbol(",");
symbol(";");
symbol(":");
symbol("*/");
symbol("await");
symbol("case");
symbol("catch");
symbol("class");
symbol("default");
symbol("else");
symbol("enum");
symbol("finally");
symbol("implements");
symbol("interface");
symbol("package");
symbol("private");
symbol("protected");
symbol("public");
symbol("static");
symbol("super");
symbol("void");
symbol("yield");

constant("(number)", "number");
constant("(regexp)", "regexp");
constant("(string)", "string");
constant("arguments", "object", function () {
    warn("unexpected_a", token);
    return token;
});
constant("eval", "function", function () {
    if (!option.eval) {
        warn("unexpected_a", token);
    } else if (next_token.id !== "(") {
        warn("expected_a_before_b", next_token, "(", artifact());
    }
    return token;
});
constant("false", "boolean", false);
constant("Function", "function", function () {
    if (!option.eval) {
        warn("unexpected_a", token);
    } else if (next_token.id !== "(") {
        warn("expected_a_before_b", next_token, "(", artifact());
    }
    return token;
});
constant("ignore", "undefined", function () {
    warn("unexpected_a", token);
    return token;
});
constant("Infinity", "number", Infinity);
constant("isFinite", "function", function () {
    warn("expected_a_b", token, "Number.isFinite", "isFinite");
    return token;
});
constant("isNaN", "function", function () {
    warn("number_isNaN", token);
    return token;
});
constant("NaN", "number", NaN);
constant("null", "null", null);
constant("this", "object", function () {
    if (!option.this) {
        warn("unexpected_a", token);
    }
    return token;
});
constant("true", "boolean", true);
constant("undefined", "undefined");

assignment("=");
assignment("+=");
assignment("-=");
assignment("*=");
assignment("/=");
assignment("%=");
assignment("&=");
assignment("|=");
assignment("^=");
assignment("<<=");
assignment(">>=");
assignment(">>>=");

infix("??", 35);
infix("||", 40);
infix("&&", 50);
infix("|", 70);
infix("^", 80);
infix("&", 90);
infix("==", 100);
infix("===", 100);
infix("!=", 100);
infix("!==", 100);
infix("<", 110);
infix(">", 110);
infix("<=", 110);
infix(">=", 110);
infix("in", 110);
infix("instanceof", 110);
infix("<<", 120);
infix(">>", 120);
infix(">>>", 120);
infix("+", 130);
infix("-", 130);
infix("*", 140);
infix("/", 140);
infix("%", 140);
infixr("**", 150);
infix("(", 160, function (left) {
    const the_paren = token;
    let the_argument;
    if (left.id !== "function") {
        left_check(left, the_paren);
    }
    if (functionage.arity === "statement" && left.identifier) {
        functionage.name.calls[left.id] = left;
    }
    the_paren.expression = [left];
    if (next_token.id !== ")") {
        (function next() {
            let ellipsis;
            if (next_token.id === "...") {
                ellipsis = true;
                advance("...");
            }
            the_argument = expression(10);
            if (ellipsis) {
                the_argument.ellipsis = true;
            }
            the_paren.expression.push(the_argument);
            if (next_token.id === ",") {
                advance(",");
                return next();
            }
        }());
    }
    advance(")", the_paren);
    if (the_paren.expression.length === 2) {
        the_paren.free = true;
        if (the_argument.wrapped === true) {
            warn("unexpected_a", the_paren);
        }
        if (the_argument.id === "(") {
            the_argument.wrapped = true;
        }
    } else {
        the_paren.free = false;
    }
    return the_paren;
});
infix(".", 170, function (left) {
    const the_token = token;
    const name = next_token;
    if (
        (
            left.id !== "(string)"
            || (name.id !== "indexOf" && name.id !== "repeat")
        )
        && (
            left.id !== "["
            || (
                name.id !== "concat"
                && name.id !== "forEach"
                && name.id !== "join"
                && name.id !== "map"
            )
        )
        && (left.id !== "+" || name.id !== "slice")
        && (
            left.id !== "(regexp)"
            || (name.id !== "exec" && name.id !== "test")
        )
    ) {
        left_check(left, the_token);
    }
    if (!name.identifier) {
        stop("expected_identifier_a");
    }
    advance();
    survey(name);

// The property name is not an expression.

    the_token.name = name;
    the_token.expression = left;
    return the_token;
});
infix("?.", 170, function (left) {
    const the_token = token;
    const name = next_token;
    if (
        (
            left.id !== "(string)"
            || (name.id !== "indexOf" && name.id !== "repeat")
        )
        && (
            left.id !== "["
            || (
                name.id !== "concat"
                && name.id !== "forEach"
                && name.id !== "join"
                && name.id !== "map"
            )
        )
        && (left.id !== "+" || name.id !== "slice")
        && (
            left.id !== "(regexp)"
            || (name.id !== "exec" && name.id !== "test")
        )
    ) {
        left_check(left, the_token);
    }
    if (!name.identifier) {
        stop("expected_identifier_a");
    }
    advance();
    survey(name);

// The property name is not an expression.

    the_token.name = name;
    the_token.expression = left;
    return the_token;
});
infix("[", 170, function (left) {
    const the_token = token;
    const the_subscript = expression(0);
    if (the_subscript.id === "(string)" || the_subscript.id === "`") {
        const name = survey(the_subscript);
        if (rx_identifier.test(name)) {
            warn("subscript_a", the_subscript, name);
        }
    }
    left_check(left, the_token);
    the_token.expression = [left, the_subscript];
    advance("]");
    return the_token;
});
infix("=>", 170, function (left) {
    return stop("wrap_parameter", left);
});

function do_tick() {
    const the_tick = token;
    the_tick.value = [];
    the_tick.expression = [];
    if (next_token.id !== "`") {
        (function part() {
            advance("(string)");
            the_tick.value.push(token);
            if (next_token.id === "${") {
                advance("${");
                the_tick.expression.push(expression(0));
                advance("}");
                return part();
            }
        }());
    }
    advance("`");
    return the_tick;
}

infix("`", 160, function (left) {
    const the_tick = do_tick();
    left_check(left, the_tick);
    the_tick.expression = [left].concat(the_tick.expression);
    return the_tick;
});

post("++");
post("--");
pre("++");
pre("--");

prefix("+");
prefix("-");
prefix("~");
prefix("!");
prefix("!!");
prefix("[", function () {
    const the_token = token;
    the_token.expression = [];
    if (next_token.id !== "]") {
        (function next() {
            let element;
            let ellipsis = false;
            if (next_token.id === "...") {
                ellipsis = true;
                advance("...");
            }
            element = expression(10);
            if (ellipsis) {
                element.ellipsis = true;
            }
            the_token.expression.push(element);
            if (next_token.id === ",") {
                advance(",");
                return next();
            }
        }());
    }
    advance("]");
    return the_token;
});
prefix("/=", function () {
    stop("expected_a_b", token, "/\\=", "/=");
});
prefix("=>", function () {
    return stop("expected_a_before_b", token, "()", "=>");
});
prefix("new", function () {
    const the_new = token;
    const right = expression(160);
    if (next_token.id !== "(") {
        warn("expected_a_before_b", next_token, "()", artifact(next_token));
    }
    the_new.expression = right;
    return the_new;
});
prefix("typeof");
prefix("void", function () {
    const the_void = token;
    warn("unexpected_a", the_void);
    the_void.expression = expression(0);
    return the_void;
});

function parameter_list() {
    const list = [];
    let optional;
    const signature = ["("];
    if (next_token.id !== ")" && next_token.id !== "(end)") {
        (function parameter() {
            let ellipsis = false;
            let param;
            if (next_token.id === "{") {
                if (optional !== undefined) {
                    warn(
                        "required_a_optional_b",
                        next_token,
                        next_token.id,
                        optional.id
                    );
                }
                param = next_token;
                param.names = [];
                advance("{");
                signature.push("{");
                (function subparameter() {
                    let subparam = next_token;
                    if (!subparam.identifier) {
                        return stop("expected_identifier_a");
                    }
                    survey(subparam);
                    advance();
                    signature.push(subparam.id);
                    if (next_token.id === ":") {
                        advance(":");
                        advance();
                        token.label = subparam;
                        subparam = token;
                        if (!subparam.identifier) {
                            return stop("expected_identifier_a");
                        }
                    }
                    if (next_token.id === "=") {
                        advance("=");
                        subparam.expression = expression();
                        param.open = true;
                    }
                    param.names.push(subparam);
                    if (next_token.id === ",") {
                        advance(",");
                        signature.push(", ");
                        return subparameter();
                    }
                }());
                list.push(param);
                advance("}");
                signature.push("}");
                if (next_token.id === ",") {
                    advance(",");
                    signature.push(", ");
                    return parameter();
                }
            } else if (next_token.id === "[") {
                if (optional !== undefined) {
                    warn(
                        "required_a_optional_b",
                        next_token,
                        next_token.id,
                        optional.id
                    );
                }
                param = next_token;
                param.names = [];
                advance("[");
                signature.push("[]");
                (function subparameter() {
                    const subparam = next_token;
                    if (!subparam.identifier) {
                        return stop("expected_identifier_a");
                    }
                    advance();
                    param.names.push(subparam);
                    if (next_token.id === "=") {
                        advance("=");
                        subparam.expression = expression();
                        param.open = true;
                    }
                    if (next_token.id === ",") {
                        advance(",");
                        return subparameter();
                    }
                }());
                list.push(param);
                advance("]");
                if (next_token.id === ",") {
                    advance(",");
                    signature.push(", ");
                    return parameter();
                }
            } else {
                if (next_token.id === "...") {
                    ellipsis = true;
                    signature.push("...");
                    advance("...");
                    if (optional !== undefined) {
                        warn(
                            "required_a_optional_b",
                            next_token,
                            next_token.id,
                            optional.id
                        );
                    }
                }
                if (!next_token.identifier) {
                    return stop("expected_identifier_a");
                }
                param = next_token;
                list.push(param);
                advance();
                signature.push(param.id);
                if (ellipsis) {
                    param.ellipsis = true;
                } else {
                    if (next_token.id === "=") {
                        optional = param;
                        advance("=");
                        param.expression = expression(0);
                    } else {
                        if (optional !== undefined) {
                            warn(
                                "required_a_optional_b",
                                param,
                                param.id,
                                optional.id
                            );
                        }
                    }
                    if (next_token.id === ",") {
                        advance(",");
                        signature.push(", ");
                        return parameter();
                    }
                }
            }
        }());
    }
    advance(")");
    signature.push(")");
    return [list, signature.join("")];
}

function do_function(the_function) {
    let name;
    if (the_function === undefined) {
        the_function = token;

// A function statement must have a name that will be in the parent's scope.

        if (the_function.arity === "statement") {
            if (!next_token.identifier) {
                return stop("expected_identifier_a", next_token);
            }
            name = next_token;
            enroll(name, "variable", true);
            the_function.name = name;
            name.init = true;
            name.calls = empty();
            advance();
        } else if (name === undefined) {

// A function expression may have an optional name.

            if (next_token.identifier) {
                name = next_token;
                the_function.name = name;
                advance();
            } else {
                the_function.name = anon;
            }
        }
    } else {
        name = the_function.name;
    }
    the_function.level = functionage.level + 1;
    if (mega_mode) {
        warn("unexpected_a", the_function);
    }

// Don't make functions in loops. It is inefficient, and it can lead to scoping
// errors.

    if (functionage.loop > 0) {
        warn("function_in_loop", the_function);
    }

// Give the function properties for storing its names and for observing the
// depth of loops and switches.

    the_function.context = empty();
    the_function.finally = 0;
    the_function.loop = 0;
    the_function.switch = 0;
    the_function.try = 0;

// Push the current function context and establish a new one.

    stack.push(functionage);
    functions.push(the_function);
    functionage = the_function;
    if (the_function.arity !== "statement" && typeof name === "object") {
        enroll(name, "function", true);
        name.dead = false;
        name.init = true;
        name.used = 1;
    }

// Parse the parameter list.

    advance("(");
    token.free = false;
    token.arity = "function";
    [functionage.parameters, functionage.signature] = parameter_list();
    functionage.parameters.forEach(function enroll_parameter(name) {
        if (name.identifier) {
            enroll(name, "parameter", false);
        } else {
            name.names.forEach(enroll_parameter);
        }
    });

// The function's body is a block.

    the_function.block = block("body");
    if (
        the_function.arity === "statement"
        && next_token.line === token.line
    ) {
        return stop("unexpected_a", next_token);
    }
    if (
        next_token.id === "."
        || next_token.id === "?."
        || next_token.id === "["
    ) {
        warn("unexpected_a");
    }

// Restore the previous context.

    functionage = stack.pop();
    return the_function;
}

prefix("function", do_function);

function fart(pl) {
    advance("=>");
    const the_fart = token;
    the_fart.arity = "binary";
    the_fart.name = "=>";
    the_fart.level = functionage.level + 1;
    functions.push(the_fart);
    if (functionage.loop > 0) {
        warn("function_in_loop", the_fart);
    }

// Give the function properties storing its names and for observing the depth
// of loops and switches.

    the_fart.context = empty();
    the_fart.finally = 0;
    the_fart.loop = 0;
    the_fart.switch = 0;
    the_fart.try = 0;

// Push the current function context and establish a new one.

    stack.push(functionage);
    functionage = the_fart;
    the_fart.parameters = pl[0];
    the_fart.signature = pl[1];
    the_fart.parameters.forEach(function (name) {
        enroll(name, "parameter", true);
    });
    if (next_token.id === "{") {
        warn("expected_a_b", the_fart, "function", "=>");
        the_fart.block = block("body");
    } else {
        the_fart.expression = expression(0);
    }
    functionage = stack.pop();
    return the_fart;
}

prefix("(", function () {
    const the_paren = token;
    let the_value;
    const cadet = lookahead().id;

// We can distinguish between a parameter list for => and a wrapped expression
// with one token of lookahead.

    if (
        next_token.id === ")"
        || next_token.id === "..."
        || (next_token.identifier && (cadet === "," || cadet === "="))
    ) {
        the_paren.free = false;
        return fart(parameter_list());
    }
    the_paren.free = true;
    the_value = expression(0);
    if (the_value.wrapped === true) {
        warn("unexpected_a", the_paren);
    }
    the_value.wrapped = true;
    advance(")", the_paren);
    if (next_token.id === "=>") {
        if (the_value.arity !== "variable") {
            if (the_value.id === "{" || the_value.id === "[") {
                warn("expected_a_before_b", the_paren, "function", "(");
                return stop("expected_a_b", next_token, "{", "=>");
            }
            return stop("expected_identifier_a", the_value);
        }
        the_paren.expression = [the_value];
        return fart([the_paren.expression, "(" + the_value.id + ")"]);
    }
    return the_value;
});
prefix("`", do_tick);
prefix("{", function () {
    const the_brace = token;
    const seen = empty();
    the_brace.expression = [];
    if (next_token.id !== "}") {
        (function member() {
            let extra;
            let full;
            let id;
            let name = next_token;
            let value;
            advance();
            if (
                (name.id === "get" || name.id === "set")
                && next_token.identifier
            ) {
                if (!option.getset) {
                    warn("unexpected_a", name);
                }
                extra = name.id;
                full = extra + " " + next_token.id;
                name = next_token;
                advance();
                id = survey(name);
                if (seen[full] === true || seen[id] === true) {
                    warn("duplicate_a", name);
                }
                seen[id] = false;
                seen[full] = true;
            } else {
                id = survey(name);
                if (typeof seen[id] === "boolean") {
                    warn("duplicate_a", name);
                }
                seen[id] = true;
            }
            if (name.identifier) {
                if (next_token.id === "}" || next_token.id === ",") {
                    if (typeof extra === "string") {
                        advance("(");
                    }
                    value = expression(Infinity, true);
                } else if (next_token.id === "(") {
                    value = do_function({
                        arity: "unary",
                        from: name.from,
                        id: "function",
                        line: name.line,
                        name: (
                            typeof extra === "string"
                            ? extra
                            : id
                        ),
                        thru: name.from
                    });
                } else {
                    if (typeof extra === "string") {
                        advance("(");
                    }
                    let the_colon = next_token;
                    advance(":");
                    value = expression(0);
                    if (value.id === name.id && value.id !== "function") {
                        warn("unexpected_a", the_colon, ": " + name.id);
                    }
                }
                value.label = name;
                if (typeof extra === "string") {
                    value.extra = extra;
                }
                the_brace.expression.push(value);
            } else {
                advance(":");
                value = expression(0);
                value.label = name;
                the_brace.expression.push(value);
            }
            if (next_token.id === ",") {
                advance(",");
                return member();
            }
        }());
    }
    advance("}");
    return the_brace;
});

stmt(";", function () {
    warn("unexpected_a", token);
    return token;
});
stmt("{", function () {
    warn("naked_block", token);
    return block("naked");
});
stmt("break", function () {
    const the_break = token;
    let the_label;
    if (
        (functionage.loop < 1 && functionage.switch < 1)
        || functionage.finally > 0
    ) {
        warn("unexpected_a", the_break);
    }
    the_break.disrupt = true;
    if (next_token.identifier && token.line === next_token.line) {
        the_label = functionage.context[next_token.id];
        if (
            the_label === undefined
            || the_label.role !== "label"
            || the_label.dead
        ) {
            warn(
                (the_label !== undefined && the_label.dead)
                ? "out_of_scope_a"
                : "not_label_a"
            );
        } else {
            the_label.used += 1;
        }
        the_break.label = next_token;
        advance();
    }
    advance(";");
    return the_break;
});

function do_var() {
    const the_statement = token;
    const is_const = the_statement.id === "const";
    the_statement.names = [];

// A program may use var or let, but not both.

    if (!is_const) {
        if (var_mode === undefined) {
            var_mode = the_statement.id;
        } else if (the_statement.id !== var_mode) {
            warn(
                "expected_a_b",
                the_statement,
                var_mode,
                the_statement.id
            );
        }
    }

// We don't expect to see variables created in switch statements.

    if (functionage.switch > 0) {
        warn("var_switch", the_statement);
    }
    if (functionage.loop > 0 && the_statement.id === "var") {
        warn("var_loop", the_statement);
    }
    (function next() {
        if (next_token.id === "{" && the_statement.id !== "var") {
            const the_brace = next_token;
            advance("{");
            (function pair() {
                if (!next_token.identifier) {
                    return stop("expected_identifier_a", next_token);
                }
                const name = next_token;
                survey(name);
                advance();
                if (next_token.id === ":") {
                    advance(":");
                    if (!next_token.identifier) {
                        return stop("expected_identifier_a", next_token);
                    }
                    next_token.label = name;
                    the_statement.names.push(next_token);
                    enroll(next_token, "variable", is_const);
                    advance();
                    the_brace.open = true;
                } else {
                    the_statement.names.push(name);
                    enroll(name, "variable", is_const);
                }
                name.dead = false;
                name.init = true;
                if (next_token.id === "=") {
                    advance("=");
                    name.expression = expression();
                    the_brace.open = true;
                }
                if (next_token.id === ",") {
                    advance(",");
                    return pair();
                }
            }());
            advance("}");
            advance("=");
            the_statement.expression = expression(0);
        } else if (next_token.id === "[" && the_statement.id !== "var") {
            const the_bracket = next_token;
            advance("[");
            (function element() {
                let ellipsis;
                if (next_token.id === "...") {
                    ellipsis = true;
                    advance("...");
                }
                if (!next_token.identifier) {
                    return stop("expected_identifier_a", next_token);
                }
                const name = next_token;
                advance();
                the_statement.names.push(name);
                enroll(name, "variable", is_const);
                name.dead = false;
                name.init = true;
                if (ellipsis) {
                    name.ellipsis = true;
                } else {
                    if (next_token.id === "=") {
                        advance("=");
                        name.expression = expression();
                        the_bracket.open = true;
                    }
                    if (next_token.id === ",") {
                        advance(",");
                        return element();
                    }
                }
            }());
            advance("]");
            advance("=");
            the_statement.expression = expression(0);
        } else if (next_token.identifier) {
            const name = next_token;
            advance();
            if (name.id === "ignore") {
                warn("unexpected_a", name);
            }
            enroll(name, "variable", is_const);
            if (next_token.id === "=" || is_const) {
                advance("=");
                name.dead = false;
                name.init = true;
                name.expression = expression(0);
            }
            the_statement.names.push(name);
        } else {
            return stop("expected_identifier_a", next_token);
        }
    }());
    semicolon();
    return the_statement;
}

stmt("const", do_var);
stmt("continue", function () {
    const the_continue = token;
    if (functionage.loop < 1 || functionage.finally > 0) {
        warn("unexpected_a", the_continue);
    }
    not_top_level(the_continue);
    the_continue.disrupt = true;
    warn("unexpected_a", the_continue);
    advance(";");
    return the_continue;
});
stmt("debugger", function () {
    const the_debug = token;
    if (!option.devel) {
        warn("unexpected_a", the_debug);
    }
    semicolon();
    return the_debug;
});
stmt("delete", function () {
    const the_token = token;
    const the_value = expression(0);
    if (
        (the_value.id !== "." && the_value.id !== "[")
        || the_value.arity !== "binary"
    ) {
        stop("expected_a_b", the_value, ".", artifact(the_value));
    }
    the_token.expression = the_value;
    semicolon();
    return the_token;
});
stmt("do", function () {
    const the_do = token;
    not_top_level(the_do);
    functionage.loop += 1;
    the_do.block = block();
    advance("while");
    the_do.expression = condition();
    semicolon();
    if (the_do.block.disrupt === true) {
        warn("weird_loop", the_do);
    }
    functionage.loop -= 1;
    return the_do;
});
stmt("export", function () {
    const the_export = token;
    let the_id;
    let the_name;
    let the_thing;

    function export_id() {
        if (!next_token.identifier) {
            stop("expected_identifier_a");
        }
        the_id = next_token.id;
        the_name = global.context[the_id];
        if (the_name === undefined) {
            warn("unexpected_a");
        } else {
            the_name.used += 1;
            if (exports[the_id] !== undefined) {
                warn("duplicate_a");
            }
            exports[the_id] = the_name;
        }
        advance();
        the_export.expression.push(the_thing);
    }

    the_export.expression = [];
    if (next_token.id === "default") {
        if (exports.default !== undefined) {
            warn("duplicate_a");
        }
        advance("default");
        the_thing = expression(0);
        if (
            the_thing.id !== "("
            || the_thing.expression[0].id !== "."
            || the_thing.expression[0].expression.id !== "Object"
            || the_thing.expression[0].name.id !== "freeze"
        ) {
            warn("freeze_exports", the_thing);
        }
        if (next_token.id === ";") {
            semicolon();
        }
        exports.default = the_thing;
        the_export.expression.push(the_thing);
    } else {
        if (next_token.id === "function") {
            warn("freeze_exports");
            the_thing = statement();
            the_name = the_thing.name;
            the_id = the_name.id;
            the_name.used += 1;
            if (exports[the_id] !== undefined) {
                warn("duplicate_a", the_name);
            }
            exports[the_id] = the_thing;
            the_export.expression.push(the_thing);
            the_thing.statement = false;
            the_thing.arity = "unary";
        } else if (
            next_token.id === "var"
            || next_token.id === "let"
            || next_token.id === "const"
        ) {
            warn("unexpected_a", next_token);
            statement();
        } else if (next_token.id === "{") {
            advance("{");
            (function loop() {
                export_id();
                if (next_token.id === ",") {
                    advance(",");
                    return loop();
                }
            }());
            advance("}");
            semicolon();
        } else {
            stop("unexpected_a");
        }
    }
    module_mode = true;
    return the_export;
});
stmt("for", function () {
    let first;
    const the_for = token;
    if (!option.for) {
        warn("unexpected_a", the_for);
    }
    not_top_level(the_for);
    functionage.loop += 1;
    advance("(");
    token.free = true;
    if (next_token.id === ";") {
        return stop("expected_a_b", the_for, "while (", "for (;");
    }
    if (
        next_token.id === "var"
        || next_token.id === "let"
        || next_token.id === "const"
    ) {
        return stop("unexpected_a");
    }
    first = expression(0);
    if (first.id === "in") {
        if (first.expression[0].arity !== "variable") {
            warn("bad_assignment_a", first.expression[0]);
        }
        the_for.name = first.expression[0];
        the_for.expression = first.expression[1];
        warn("expected_a_b", the_for, "Object.keys", "for in");
    } else {
        the_for.initial = first;
        advance(";");
        the_for.expression = expression(0);
        advance(";");
        the_for.inc = expression(0);
        if (the_for.inc.id === "++") {
            warn("expected_a_b", the_for.inc, "+= 1", "++");
        }
    }
    advance(")");
    the_for.block = block();
    if (the_for.block.disrupt === true) {
        warn("weird_loop", the_for);
    }
    functionage.loop -= 1;
    return the_for;
});
stmt("function", do_function);
stmt("if", function () {
    let the_else;
    const the_if = token;
    the_if.expression = condition();
    the_if.block = block();
    if (next_token.id === "else") {
        advance("else");
        the_else = token;
        the_if.else = (
            next_token.id === "if"
            ? statement()
            : block()
        );
        if (the_if.block.disrupt === true) {
            if (the_if.else.disrupt === true) {
                the_if.disrupt = true;
            } else {
                warn("unexpected_a", the_else);
            }
        }
    }
    return the_if;
});
stmt("import", function () {
    const the_import = token;
    if (next_token.id === "(") {
        the_import.arity = "unary";
        the_import.constant = true;
        the_import.statement = false;
        advance("(");
        const string = expression(0);
        if (string.id !== "(string)") {
            warn("expected_string_a", string);
        }
        froms.push(token.value);
        advance(")");
        advance(".");
        advance("then");
        advance("(");
        the_import.expression = expression(0);
        advance(")");
        semicolon();
        return the_import;
    }
    let name;
    if (typeof module_mode === "object") {
        warn("unexpected_directive_a", module_mode, module_mode.directive);
    }
    module_mode = true;
    if (next_token.identifier) {
        name = next_token;
        advance();
        if (name.id === "ignore") {
            warn("unexpected_a", name);
        }
        enroll(name, "variable", true);
        the_import.name = name;
    } else {
        const names = [];
        advance("{");
        if (next_token.id !== "}") {
            while (true) {
                if (!next_token.identifier) {
                    stop("expected_identifier_a");
                }
                name = next_token;
                advance();
                if (name.id === "ignore") {
                    warn("unexpected_a", name);
                }
                enroll(name, "variable", true);
                names.push(name);
                if (next_token.id !== ",") {
                    break;
                }
                advance(",");
            }
        }
        advance("}");
        the_import.name = names;
    }
    advance("from");
    advance("(string)");
    the_import.import = token;
    if (!rx_module.test(token.value)) {
        warn("bad_module_name_a", token);
    }
    froms.push(token.value);
    semicolon();
    return the_import;
});
stmt("let", do_var);
stmt("return", function () {
    const the_return = token;
    not_top_level(the_return);
    if (functionage.finally > 0) {
        warn("unexpected_a", the_return);
    }
    the_return.disrupt = true;
    if (next_token.id !== ";" && the_return.line === next_token.line) {
        the_return.expression = expression(10);
    }
    advance(";");
    return the_return;
});
stmt("switch", function () {
    let dups = [];
    let last;
    let stmts;
    const the_cases = [];
    let the_disrupt = true;
    const the_switch = token;
    not_top_level(the_switch);
    if (functionage.finally > 0) {
        warn("unexpected_a", the_switch);
    }
    functionage.switch += 1;
    advance("(");
    token.free = true;
    the_switch.expression = expression(0);
    the_switch.block = the_cases;
    advance(")");
    advance("{");
    (function major() {
        const the_case = next_token;
        the_case.arity = "statement";
        the_case.expression = [];
        (function minor() {
            advance("case");
            token.switch = true;
            const exp = expression(0);
            if (dups.some(function (thing) {
                return are_similar(thing, exp);
            })) {
                warn("unexpected_a", exp);
            }
            dups.push(exp);
            the_case.expression.push(exp);
            advance(":");
            if (next_token.id === "case") {
                return minor();
            }
        }());
        stmts = statements();
        if (stmts.length < 1) {
            warn("expected_statements_a");
            return;
        }
        the_case.block = stmts;
        the_cases.push(the_case);
        last = stmts[stmts.length - 1];
        if (last.disrupt) {
            if (last.id === "break" && last.label === undefined) {
                the_disrupt = false;
            }
        } else {
            warn(
                "expected_a_before_b",
                next_token,
                "break;",
                artifact(next_token)
            );
        }
        if (next_token.id === "case") {
            return major();
        }
    }());
    dups = undefined;
    if (next_token.id === "default") {
        const the_default = next_token;
        advance("default");
        token.switch = true;
        advance(":");
        the_switch.else = statements();
        if (the_switch.else.length < 1) {
            warn("unexpected_a", the_default);
            the_disrupt = false;
        } else {
            const the_last = the_switch.else[the_switch.else.length - 1];
            if (the_last.id === "break" && the_last.label === undefined) {
                warn("unexpected_a", the_last);
                the_last.disrupt = false;
            }
            the_disrupt = the_disrupt && the_last.disrupt;
        }
    } else {
        the_disrupt = false;
    }
    advance("}", the_switch);
    functionage.switch -= 1;
    the_switch.disrupt = the_disrupt;
    // hack-jslint - validate sorted-case-statements
    let aa;
    let bb;
    let ii;
    ii = 0;
    while (ii < the_cases.length) {
        aa = bb;
        bb = the_cases[ii].expression[0];
        if (!(
            ii === 0
            || (
                aa.id === "(number)" && bb.id === "(number)"
                && Number(aa.value) < Number(bb.value)
            )
            || lines[aa.line] < lines[bb.line]
        )) {
            warn_at(
                "Unsorted case-statements.",
                the_cases[ii].expression[0].line,
                0
            );
            break;
        }
        ii += 1;
    }
    return the_switch;
});
stmt("throw", function () {
    const the_throw = token;
    the_throw.disrupt = true;
    the_throw.expression = expression(10);
    semicolon();
    if (functionage.try > 0) {
        warn("unexpected_a", the_throw);
    }
    return the_throw;
});
stmt("try", function () {
    let the_catch;
    let the_disrupt;
    const the_try = token;
    if (functionage.try > 0) {
        warn("unexpected_a", the_try);
    }
    functionage.try += 1;
    the_try.block = block();
    the_disrupt = the_try.block.disrupt;
    if (next_token.id === "catch") {
        let ignored = "ignore";
        the_catch = next_token;
        the_try.catch = the_catch;
        advance("catch");
        if (next_token.id === "(") {
            advance("(");
            if (!next_token.identifier) {
                return stop("expected_identifier_a", next_token);
            }
            if (next_token.id !== "ignore") {
                ignored = undefined;
                the_catch.name = next_token;
                enroll(next_token, "exception", true);
            }
            advance();
            advance(")");
        }
        the_catch.block = block(ignored);
        if (the_catch.block.disrupt !== true) {
            the_disrupt = false;
        }
    } else {
        warn(
            "expected_a_before_b",
            next_token,
            "catch",
            artifact(next_token)
        );
    }
    if (next_token.id === "finally") {
        functionage.finally += 1;
        advance("finally");
        the_try.else = block();
        the_disrupt = the_try.else.disrupt;
        functionage.finally -= 1;
    }
    the_try.disrupt = the_disrupt;
    functionage.try -= 1;
    return the_try;
});
stmt("var", do_var);
stmt("while", function () {
    const the_while = token;
    not_top_level(the_while);
    functionage.loop += 1;
    the_while.expression = condition();
    the_while.block = block();
    if (the_while.block.disrupt === true) {
        warn("weird_loop", the_while);
    }
    functionage.loop -= 1;
    return the_while;
});
stmt("with", function () {
    stop("unexpected_a", token);
});

ternary("?", ":");

// Ambulation of the parse tree.

function action(when) {

// Produce a function that will register task functions that will be called as
// the tree is traversed.

    return function (arity, id, task) {
        let a_set = when[arity];
        let i_set;

// The id parameter is optional. If excluded, the task will be applied to all
// ids.

        if (typeof id !== "string") {
            task = id;
            id = "(all)";
        }

// If this arity has no registrations yet, then create a set object to hold
// them.

        if (a_set === undefined) {
            a_set = empty();
            when[arity] = a_set;
        }

// If this id has no registrations yet, then create a set array to hold them.

        i_set = a_set[id];
        if (i_set === undefined) {
            i_set = [];
            a_set[id] = i_set;
        }

// Register the task with the arity and the id.

        i_set.push(task);
    };
}

function amble(when) {

// Produce a function that will act on the tasks registered by an action
// function while walking the tree.

    return function (the_token) {

// Given a task set that was built by an action function, run all of the
// relevant tasks on the token.

        let a_set = when[the_token.arity];
        let i_set;

// If there are tasks associated with the token's arity...

        if (a_set !== undefined) {

// If there are tasks associated with the token's id...

            i_set = a_set[the_token.id];
            if (i_set !== undefined) {
                i_set.forEach(function (task) {
                    return task(the_token);
                });
            }

// If there are tasks for all ids.

            i_set = a_set["(all)"];
            if (i_set !== undefined) {
                i_set.forEach(function (task) {
                    return task(the_token);
                });
            }
        }
    };
}

const posts = empty();
const pres = empty();
const preaction = action(pres);
const postaction = action(posts);
const preamble = amble(pres);
const postamble = amble(posts);

function walk_expression(thing) {
    if (thing) {
        if (Array.isArray(thing)) {
            thing.forEach(walk_expression);
        } else {
            preamble(thing);
            walk_expression(thing.expression);
            if (thing.id === "function") {
                walk_statement(thing.block);
            }
            if (thing.arity === "pre" || thing.arity === "post") {
                warn("unexpected_a", thing);
            } else if (
                thing.arity === "statement"
                || thing.arity === "assignment"
            ) {
                warn("unexpected_statement_a", thing);
            }
            postamble(thing);
        }
    }
}

function walk_statement(thing) {
    if (thing) {
        if (Array.isArray(thing)) {
            thing.forEach(walk_statement);
        } else {
            preamble(thing);
            walk_expression(thing.expression);
            if (thing.arity === "binary") {
                if (thing.id !== "(") {
                    warn("unexpected_expression_a", thing);
                }
            } else if (
                thing.arity !== "statement"
                && thing.arity !== "assignment"
                && thing.id !== "import"
            ) {
                warn("unexpected_expression_a", thing);
            }
            walk_statement(thing.block);
            walk_statement(thing.else);
            postamble(thing);
        }
    }
}

function lookup(thing) {
    if (thing.arity === "variable") {

// Look up the variable in the current context.

        let the_variable = functionage.context[thing.id];

// If it isn't local, search all the other contexts. If there are name
// collisions, take the most recent.

        if (the_variable === undefined) {
            stack.forEach(function (outer) {
                const a_variable = outer.context[thing.id];
                if (
                    a_variable !== undefined
                    && a_variable.role !== "label"
                ) {
                    the_variable = a_variable;
                }
            });

// If it isn't in any of those either, perhaps it is a predefined global.
// If so, add it to the global context.

            if (the_variable === undefined) {
                if (declared_globals[thing.id] === undefined) {
                    warn("undeclared_a", thing);
                    return;
                }
                the_variable = {
                    dead: false,
                    parent: global,
                    id: thing.id,
                    init: true,
                    role: "variable",
                    used: 0,
                    writable: false
                };
                global.context[thing.id] = the_variable;
            }
            the_variable.closure = true;
            functionage.context[thing.id] = the_variable;
        } else if (the_variable.role === "label") {
            warn("label_a", thing);
        }
        if (
            the_variable.dead
            && (
                the_variable.calls === undefined
                || functionage.name === undefined
                || the_variable.calls[functionage.name.id] === undefined
            )
        ) {
            warn("out_of_scope_a", thing);
        }
        return the_variable;
    }
}

function subactivate(name) {
    name.init = true;
    name.dead = false;
    blockage.live.push(name);
}

function preaction_function(thing) {
    if (thing.arity === "statement" && blockage.body !== true) {
        warn("unexpected_a", thing);
    }
    stack.push(functionage);
    block_stack.push(blockage);
    functionage = thing;
    blockage = thing;
    thing.live = [];
    if (typeof thing.name === "object") {
        thing.name.dead = false;
        thing.name.init = true;
    }
    if (thing.extra === "get") {
        if (thing.parameters.length !== 0) {
            warn("bad_get", thing);
        }
    } else if (thing.extra === "set") {
        if (thing.parameters.length !== 1) {
            warn("bad_set", thing);
        }
    }
    thing.parameters.forEach(function (name) {
        walk_expression(name.expression);
        if (name.id === "{" || name.id === "[") {
            name.names.forEach(subactivate);
        } else {
            name.dead = false;
            name.init = true;
        }
    });
}

function bitwise_check(thing) {
    if (!option.bitwise && bitwiseop[thing.id] === true) {
        warn("unexpected_a", thing);
    }
    if (
        thing.id !== "("
        && thing.id !== "&&"
        && thing.id !== "||"
        && thing.id !== "="
        && Array.isArray(thing.expression)
        && thing.expression.length === 2
        && (
            relationop[thing.expression[0].id] === true
            || relationop[thing.expression[1].id] === true
        )
    ) {
        warn("unexpected_a", thing);
    }
}

function pop_block() {
    blockage.live.forEach(function (name) {
        name.dead = true;
    });
    delete blockage.live;
    blockage = block_stack.pop();
}

function activate(name) {
    name.dead = false;
    if (name.expression !== undefined) {
        walk_expression(name.expression);
        if (name.id === "{" || name.id === "[") {
            name.names.forEach(subactivate);
        } else {
            name.init = true;
        }
    }
    blockage.live.push(name);
}

function action_var(thing) {
    thing.names.forEach(activate);
}

preaction("assignment", bitwise_check);
preaction("binary", bitwise_check);
preaction("binary", function (thing) {
    if (relationop[thing.id] === true) {
        const left = thing.expression[0];
        const right = thing.expression[1];
        if (left.id === "NaN" || right.id === "NaN") {
            warn("number_isNaN", thing);
        } else if (left.id === "typeof") {
            if (right.id !== "(string)") {
                if (right.id !== "typeof") {
                    warn("expected_string_a", right);
                }
            } else {
                const value = right.value;
                if (value === "null" || value === "undefined") {
                    warn("unexpected_typeof_a", right, value);
                } else if (
                    value !== "boolean"
                    && value !== "function"
                    && value !== "number"
                    && value !== "object"
                    && value !== "string"
                    && value !== "symbol"
                ) {
                    warn("expected_type_string_a", right, value);
                }
            }
        }
    }
});
preaction("binary", "==", function (thing) {
    warn("expected_a_b", thing, "===", "==");
});
preaction("binary", "!=", function (thing) {
    warn("expected_a_b", thing, "!==", "!=");
});
preaction("binary", "=>", preaction_function);
preaction("binary", "||", function (thing) {
    thing.expression.forEach(function (thang) {
        if (thang.id === "&&" && !thang.wrapped) {
            warn("and", thang);
        }
    });
});
preaction("binary", "(", function (thing) {
    const left = thing.expression[0];
    if (
        left.identifier
        && functionage.context[left.id] === undefined
        && typeof functionage.name === "object"
    ) {
        const parent = functionage.name.parent;
        if (parent) {
            const left_variable = parent.context[left.id];
            if (
                left_variable !== undefined
                && left_variable.dead
                && left_variable.parent === parent
                && left_variable.calls !== undefined
                && left_variable.calls[functionage.name.id] !== undefined
            ) {
                left_variable.dead = false;
            }
        }
    }
});
preaction("binary", "in", function (thing) {
    warn("infix_in", thing);
});
preaction("binary", "instanceof", function (thing) {
    warn("unexpected_a", thing);
});
preaction("binary", ".", function (thing) {
    if (thing.expression.new) {
        thing.new = true;
    }
});
preaction("statement", "{", function (thing) {
    block_stack.push(blockage);
    blockage = thing;
    thing.live = [];
});
preaction("statement", "for", function (thing) {
    if (thing.name !== undefined) {
        const the_variable = lookup(thing.name);
        if (the_variable !== undefined) {
            the_variable.init = true;
            if (!the_variable.writable) {
                warn("bad_assignment_a", thing.name);
            }
        }
    }
    walk_statement(thing.initial);
});
preaction("statement", "function", preaction_function);
preaction("unary", "~", bitwise_check);
preaction("unary", "function", preaction_function);
preaction("variable", function (thing) {
    const the_variable = lookup(thing);
    if (the_variable !== undefined) {
        thing.variable = the_variable;
        the_variable.used += 1;
    }
});

function init_variable(name) {
    const the_variable = lookup(name);
    if (the_variable !== undefined) {
        if (the_variable.writable) {
            the_variable.init = true;
            return;
        }
    }
    warn("bad_assignment_a", name);
}

postaction("assignment", "+=", function (thing) {
    let right = thing.expression[1];
    if (right.constant) {
        if (
            right.value === ""
            || (right.id === "(number)" && right.value === "0")
            || right.id === "(boolean)"
            || right.id === "null"
            || right.id === "undefined"
            || Number.isNaN(right.value)
        ) {
            warn("unexpected_a", right);
        }
    }
});
postaction("assignment", function (thing) {

// Assignment using = sets the init property of a variable. No other assignment
// operator can do this. A = token keeps that variable (or array of variables
// in case of destructuring) in its name property.

    const lvalue = thing.expression[0];
    if (thing.id === "=") {
        if (thing.names !== undefined) {
            if (Array.isArray(thing.names)) {
                thing.names.forEach(init_variable);
            } else {
                init_variable(thing.names);
            }
        } else {
            if (lvalue.id === "[" || lvalue.id === "{") {
                lvalue.expression.forEach(function (thing) {
                    if (thing.variable) {
                        thing.variable.init = true;
                    }
                });
            } else if (
                lvalue.id === "."
                && thing.expression[1].id === "undefined"
            ) {
                warn(
                    "expected_a_b",
                    lvalue.expression,
                    "delete",
                    "undefined"
                );
            }
        }
    } else {
        if (lvalue.arity === "variable") {
            if (!lvalue.variable || lvalue.variable.writable !== true) {
                warn("bad_assignment_a", lvalue);
            }
        }
        const right = syntax[thing.expression[1].id];
        if (
            right !== undefined
            && (
                right.id === "function"
                || right.id === "=>"
                || (
                    right.constant
                    && right.id !== "(number)"
                    && (right.id !== "(string)" || thing.id !== "+=")
                )
            )
        ) {
            warn("unexpected_a", thing.expression[1]);
        }
    }
});

function postaction_function(thing) {
    delete functionage.finally;
    delete functionage.loop;
    delete functionage.switch;
    delete functionage.try;
    functionage = stack.pop();
    if (thing.wrapped) {
        warn("unexpected_parens", thing);
    }
    return pop_block();
}

postaction("binary", function (thing) {
    let right;
    if (relationop[thing.id]) {
        if (
            is_weird(thing.expression[0])
            || is_weird(thing.expression[1])
            || are_similar(thing.expression[0], thing.expression[1])
            || (
                thing.expression[0].constant === true
                && thing.expression[1].constant === true
            )
        ) {
            warn("weird_relation_a", thing);
        }
    }
    if (thing.id === "+") {
        if (!option.convert) {
            if (thing.expression[0].value === "") {
                warn("expected_a_b", thing, "String(...)", "\"\" +");
            } else if (thing.expression[1].value === "") {
                warn("expected_a_b", thing, "String(...)", "+ \"\"");
            }
        }
    } else if (thing.id === "[") {
        if (thing.expression[0].id === "window") {
            warn("weird_expression_a", thing, "window[...]");
        }
        if (thing.expression[0].id === "self") {
            warn("weird_expression_a", thing, "self[...]");
        }
    } else if (thing.id === "." || thing.id === "?.") {
        if (thing.expression.id === "RegExp") {
            warn("weird_expression_a", thing);
        }
    } else if (thing.id !== "=>" && thing.id !== "(") {
        right = thing.expression[1];
        if (
            (thing.id === "+" || thing.id === "-")
            && right.id === thing.id
            && right.arity === "unary"
            && !right.wrapped
        ) {
            warn("wrap_unary", right);
        }
        if (
            thing.expression[0].constant === true
            && right.constant === true
        ) {
            thing.constant = true;
        }
    }
});
postaction("binary", "&&", function (thing) {
    if (
        is_weird(thing.expression[0])
        || are_similar(thing.expression[0], thing.expression[1])
        || thing.expression[0].constant === true
        || thing.expression[1].constant === true
    ) {
        warn("weird_condition_a", thing);
    }
});
postaction("binary", "||", function (thing) {
    if (
        is_weird(thing.expression[0])
        || are_similar(thing.expression[0], thing.expression[1])
        || thing.expression[0].constant === true
    ) {
        warn("weird_condition_a", thing);
    }
});
postaction("binary", "=>", postaction_function);
postaction("binary", "(", function (thing) {
    let left = thing.expression[0];
    let the_new;
    let arg;
    if (left.id === "new") {
        the_new = left;
        left = left.expression;
    }
    if (left.id === "function") {
        if (!thing.wrapped) {
            warn("wrap_immediate", thing);
        }
    } else if (left.identifier) {
        if (the_new !== undefined) {
            if (
                left.id[0] > "Z"
                || left.id === "Boolean"
                || left.id === "Number"
                || left.id === "String"
                || left.id === "Symbol"
            ) {
                warn("unexpected_a", the_new);
            } else if (left.id === "Function") {
                if (!option.eval) {
                    warn("unexpected_a", left, "new Function");
                }
            } else if (left.id === "Array") {
                arg = thing.expression;
                if (arg.length !== 2 || arg[1].id === "(string)") {
                    warn("expected_a_b", left, "[]", "new Array");
                }
            } else if (left.id === "Object") {
                warn(
                    "expected_a_b",
                    left,
                    "Object.create(null)",
                    "new Object"
                );
            }
        } else {
            if (
                left.id[0] >= "A"
                && left.id[0] <= "Z"
                && left.id !== "Boolean"
                && left.id !== "Number"
                && left.id !== "String"
                && left.id !== "Symbol"
            ) {
                warn(
                    "expected_a_before_b",
                    left,
                    "new",
                    artifact(left)
                );
            }
        }
    } else if (left.id === ".") {
        let cack = the_new !== undefined;
        if (left.expression.id === "Date" && left.name.id === "UTC") {
            cack = !cack;
        }
        if (rx_cap.test(left.name.id) !== cack) {
            if (the_new !== undefined) {
                warn("unexpected_a", the_new);
            } else {
                warn(
                    "expected_a_before_b",
                    left.expression,
                    "new",
                    left.name.id
                );
            }
        }
        if (left.name.id === "getTime") {
            const paren = left.expression;
            if (paren.id === "(") {
                const array = paren.expression;
                if (array.length === 1) {
                    const new_date = array[0];
                    if (
                        new_date.id === "new"
                        && new_date.expression.id === "Date"
                    ) {
                        warn(
                            "expected_a_b",
                            new_date,
                            "Date.now()",
                            "new Date().getTime()"
                        );
                    }
                }
            }
        }
    }
});
postaction("binary", "[", function (thing) {
    if (thing.expression[0].id === "RegExp") {
        warn("weird_expression_a", thing);
    }
    if (is_weird(thing.expression[1])) {
        warn("weird_expression_a", thing.expression[1]);
    }
});
postaction("statement", "{", pop_block);
postaction("statement", "const", action_var);
postaction("statement", "export", top_level_only);
postaction("statement", "for", function (thing) {
    walk_statement(thing.inc);
});
postaction("statement", "function", postaction_function);
postaction("statement", "import", function (the_thing) {
    const name = the_thing.name;
    if (name) {
        if (Array.isArray(name)) {
            name.forEach(function (name) {
                name.dead = false;
                name.init = true;
                blockage.live.push(name);
            });
        } else {
            name.dead = false;
            name.init = true;
            blockage.live.push(name);
        }
        return top_level_only(the_thing);
    }
});
postaction("statement", "let", action_var);
postaction("statement", "try", function (thing) {
    if (thing.catch !== undefined) {
        const the_name = thing.catch.name;
        if (the_name !== undefined) {
            const the_variable = functionage.context[the_name.id];
            the_variable.dead = false;
            the_variable.init = true;
        }
        walk_statement(thing.catch.block);
    }
});
postaction("statement", "var", action_var);
postaction("ternary", function (thing) {
    if (
        is_weird(thing.expression[0])
        || thing.expression[0].constant === true
        || are_similar(thing.expression[1], thing.expression[2])
    ) {
        warn("unexpected_a", thing);
    } else if (are_similar(thing.expression[0], thing.expression[1])) {
        warn("expected_a_b", thing, "||", "?");
    } else if (are_similar(thing.expression[0], thing.expression[2])) {
        warn("expected_a_b", thing, "&&", "?");
    } else if (
        thing.expression[1].id === "true"
        && thing.expression[2].id === "false"
    ) {
        warn("expected_a_b", thing, "!!", "?");
    } else if (
        thing.expression[1].id === "false"
        && thing.expression[2].id === "true"
    ) {
        warn("expected_a_b", thing, "!", "?");
    } else if (
        thing.expression[0].wrapped !== true
        && (
            thing.expression[0].id === "||"
            || thing.expression[0].id === "&&"
        )
    ) {
        warn("wrap_condition", thing.expression[0]);
    }
});
postaction("unary", function (thing) {
    if (thing.id === "`") {
        if (thing.expression.every(function (thing) {
            return thing.constant;
        })) {
            thing.constant = true;
        }
    } else if (thing.id === "!") {
        if (thing.expression.constant === true) {
            warn("unexpected_a", thing);
        }
    } else if (thing.id === "!!") {
        if (!option.convert) {
            warn("expected_a_b", thing, "Boolean(...)", "!!");
        }
    } else if (
        thing.id !== "["
        && thing.id !== "{"
        && thing.id !== "function"
        && thing.id !== "new"
    ) {
        if (thing.expression.constant === true) {
            thing.constant = true;
        }
    }
});
postaction("unary", "function", postaction_function);
postaction("unary", "+", function (thing) {
    if (!option.convert) {
        warn("expected_a_b", thing, "Number(...)", "+");
    }
    const right = thing.expression;
    if (right.id === "(" && right.expression[0].id === "new") {
        warn("unexpected_a_before_b", thing, "+", "new");
    } else if (
        right.constant
        || right.id === "{"
        || (right.id === "[" && right.arity !== "binary")
    ) {
        warn("unexpected_a", thing, "+");
    }
});

function delve(the_function) {
    Object.keys(the_function.context).forEach(function (id) {
        if (id !== "ignore") {
            const name = the_function.context[id];
            if (name.parent === the_function) {
                if (
                    name.used === 0
                    && (
                        name.role !== "function"
                        || name.parent.arity !== "unary"
                    )
                ) {
                    warn("unused_a", name);
                } else if (!name.init) {
                    warn("uninitialized_a", name);
                }
            }
        }
    });
}

function uninitialized_and_unused() {

// Delve into the functions looking for variables that were not initialized
// or used. If the file imports or exports, then its global object is also
// delved.

    if (module_mode === true || option.node) {
        delve(global);
    }
    functions.forEach(delve);
}

// Go through the token list, looking at usage of whitespace.

function whitage() {
    let closer = "(end)";
    let free = false;
    let left = global;
    let margin = 0;
    let nr_comments_skipped = 0;
    let open = true;
    let opening = true;
    let right;

    function pop() {
        const previous = stack.pop();
        closer = previous.closer;
        free = previous.free;
        margin = previous.margin;
        open = previous.open;
        opening = previous.opening;
    }

    function push() {
        stack.push({
            closer,
            free,
            margin,
            open,
            opening
        });
    }

    function expected_at(at) {
        warn(
            "expected_a_at_b_c",
            right,
            artifact(right),
            fudge + at,
            artifact_column(right)
        );
    }

    function at_margin(fit) {
        const at = margin + fit;
        // hack-jslint - exact-margin
        if (right.from !== at) {
            return expected_at(at);
        }
    }

    function no_space_only() {
        if (
            left.id !== "(global)"
            && left.nr + 1 === right.nr
            && (
                left.line !== right.line
                || left.thru !== right.from
            )
        ) {
            warn(
                "unexpected_space_a_b",
                right,
                artifact(left),
                artifact(right)
            );
        }
    }

    function no_space() {
        if (left.line === right.line) {
            if (left.thru !== right.from && nr_comments_skipped === 0) {
                warn(
                    "unexpected_space_a_b",
                    right,
                    artifact(left),
                    artifact(right)
                );
            }
        } else {
            if (open) {
                const at = (
                    free
                    ? margin
                    : margin + 8
                );
                // hack-jslint - exact-margin
                if (right.from !== at) {
                    expected_at(at);
                }
            } else {
                // hack-jslint - exact-margin
                if (right.from !== margin + 8) {
                    expected_at(margin + 8);
                }
            }
        }
    }

    function one_space_only() {
        if (left.line !== right.line || left.thru + 1 !== right.from) {
            warn(
                "expected_space_a_b",
                right,
                artifact(left),
                artifact(right)
            );
        }
    }

    function one_space() {
        if (left.line === right.line || !open) {
            if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {
                warn(
                    "expected_space_a_b",
                    right,
                    artifact(left),
                    artifact(right)
                );
            }
        } else {
            // hack-jslint - exact-margin
            if (right.from !== margin) {
                expected_at(margin);
            }
        }
    }

    stack = [];
    tokens.forEach(function (the_token) {
        right = the_token;
        if (right.id === "(comment)" || right.id === "(end)") {
            nr_comments_skipped += 1;
        } else {

// If left is an opener and right is not the closer, then push the previous
// state. If the token following the opener is on the next line, then this is
// an open form. If the tokens are on the same line, then it is a closed form.
// Open form is more readable, with each item (statement, argument, parameter,
// etc) starting on its own line. Closed form is more compact. Statement blocks
// are always in open form.

            const new_closer = opener[left.id];
            if (typeof new_closer === "string") {
                if (new_closer !== right.id) {
                    opening = left.open || (left.line !== right.line);
                    push();
                    closer = new_closer;
                    if (opening) {
                        free = closer === ")" && left.free;
                        open = true;
                        // hack-jslint - conditional-margin
                        if (
                            !option.modeUtility2
                            || lines[right.line].startsWith(" ")
                        ) {
                            margin += 4;
                        }
                        if (right.role === "label") {
                            // hack-jslint - exact-margin
                            if (right.from !== 0) {
                                expected_at(0);
                            }
                        } else if (right.switch) {
                            at_margin(-4);
                        } else {
                            at_margin(0);
                        }
                    } else {
                        if (right.statement || right.role === "label") {
                            warn(
                                "expected_line_break_a_b",
                                right,
                                artifact(left),
                                artifact(right)
                            );
                        }
                        free = false;
                        open = false;
                        no_space_only();
                    }
                } else {

// If left and right are opener and closer, then the placement of right depends
// on the openness. Illegal pairs (like '{]') have already been detected.

                    if (left.line === right.line) {
                        no_space();
                    } else {
                        at_margin(0);
                    }
                }
            } else {
                if (right.statement === true) {
                    if (left.id === "else") {
                        one_space_only();
                    } else {
                        at_margin(0);
                        open = false;
                    }

// If right is a closer, then pop the previous state.
                } else if (right.id === closer) {
                    pop();
                    if (opening && right.id !== ";") {
                        at_margin(0);
                    } else {
                        no_space_only();
                    }
                } else {

// Left is not an opener, and right is not a closer.
// The nature of left and right will determine the space between them.

// If left is ',' or ';' or right is a statement then if open,
// right must go at the margin, or if closed, a space between.

                    if (right.switch) {
                        at_margin(-4);
                    } else if (right.role === "label") {
                        // hack-jslint - exact-margin
                        if (right.from !== 0) {
                            expected_at(0);
                        }
                    } else if (left.id === ",") {
                        if (!open || (
                            (free || closer === "]")
                            && left.line === right.line
                        )) {
                            one_space();
                        } else {
                            at_margin(0);
                        }

// If right is a ternary operator, line it up on the margin.
                    } else if (right.arity === "ternary") {
                        if (open) {
                            at_margin(0);
                        } else {
                            warn("use_open", right);
                        }
                    } else if (
                        right.arity === "binary"
                        && right.id === "("
                        && free
                    ) {
                        no_space();
                    } else if (
                        left.id === "."
                        || left.id === "?."
                        || left.id === "..."
                        || right.id === ","
                        || right.id === ";"
                        || right.id === ":"
                        || (
                            right.arity === "binary"
                            && (right.id === "(" || right.id === "[")
                        )
                        || (
                            right.arity === "function"
                            && left.id !== "function"
                        )
                    ) {
                        no_space_only();
                    } else if (right.id === "." || right.id === "?.") {
                        no_space_only();
                    } else if (left.id === ";") {
                        if (open) {
                            at_margin(0);
                        }
                    } else if (
                        left.arity === "ternary"
                        || left.id === "case"
                        || left.id === "catch"
                        || left.id === "else"
                        || left.id === "finally"
                        || left.id === "while"
                        || right.id === "catch"
                        || right.id === "else"
                        || right.id === "finally"
                        || (right.id === "while" && !right.statement)
                        || (left.id === ")" && right.id === "{")
                    ) {
                        one_space_only();
                    } else if (

// There is a space between left and right.

                        spaceop[left.id] === true
                        || spaceop[right.id] === true
                        || (
                            left.arity === "binary"
                            && (left.id === "+" || left.id === "-")
                        )
                        || (
                            right.arity === "binary"
                            && (right.id === "+" || right.id === "-")
                        )
                        || left.id === "function"
                        || left.id === ":"
                        || (
                            (
                                left.identifier
                                || left.id === "(string)"
                                || left.id === "(number)"
                            )
                            && (
                                right.identifier
                                || right.id === "(string)"
                                || right.id === "(number)"
                            )
                        )
                        || (left.arity === "statement" && right.id !== ";")
                    ) {
                        one_space();
                    } else if (left.arity === "unary" && left.id !== "`") {
                        no_space_only();
                    }
                }
            }
            nr_comments_skipped = 0;
            delete left.calls;
            delete left.dead;
            delete left.free;
            delete left.init;
            delete left.open;
            delete left.used;
            left = right;
        }
    });
}

// The jslint function itself.

// hack-jslint - jslint0
local.jslint0 = Object.freeze(function (
    source = "",
    option_object = empty(),
    global_array = []
) {
    // hack-jslint - init lines_extra
    line_ignore = undefined;
    lines = (
        Array.isArray(source)
        ? source
        : source.split(
            /\n|\r\n?/
        )
    );
    lines_extra = lines.map(function () {
        return {};
    });
    try {
        warnings = [];
        option = Object.assign(empty(), option_object);
        anon = "anonymous";
        block_stack = [];
        declared_globals = empty();
        directive_mode = true;
        directives = [];
        early_stop = true;
        exports = empty();
        froms = [];
        fudge = (
            option.fudge
            ? 1
            : 0
        );
        functions = [];
        global = {
            id: "(global)",
            body: true,
            context: empty(),
            from: 0,
            level: 0,
            line: 0,
            live: [],
            loop: 0,
            switch: 0,
            thru: 0
        };
        blockage = global;
        functionage = global;
        json_mode = false;
        mega_mode = false;
        module_mode = false;
        next_token = global;
        property = empty();
        shebang = false;
        stack = [];
        tenure = undefined;
        token = global;
        token_nr = 0;
        var_mode = undefined;
        populate(standard, declared_globals, false);
        populate(global_array, declared_globals, false);
        Object.keys(option).forEach(function (name) {
            if (option[name] === true) {
                const allowed = allowed_option[name];
                if (Array.isArray(allowed)) {
                    populate(allowed, declared_globals, false);
                }
            }
        });
        tokenize(source);
        advance();
        if (json_mode) {
            tree = json_value();
            advance("(end)");
        } else {

// Because browsers encourage combining of script files, the first token might
// be a semicolon to defend against a missing semicolon in the preceding file.

            if (option.browser) {
                if (next_token.id === ";") {
                    advance(";");
                }
            } else {

// If we are not in a browser, then the file form of strict pragma may be used.

                if (
                    next_token.value === "use strict"
                ) {
                    advance("(string)");
                    advance(";");
                }
            }
            tree = statements();
            advance("(end)");
            functionage = global;
            walk_statement(tree);
            if (warnings.length === 0) {
                uninitialized_and_unused();
                if (!option.white) {
                    whitage();
                }
            }
        }
        if (!option.browser) {
            directives.forEach(function (comment) {
                if (comment.directive === "global") {
                    warn("missing_browser", comment);
                }
            });
        }
        early_stop = false;
        // hack-jslint - throw_error
        if (option.throw_error) {
            throw new Error();
        }
    } catch (e) {
        // hack-jslint - early_stop
        e.early_stop = true;
        e.column = e.column || -1;
        e.line = e.line || -1;
        if (e.name !== "JSLintError") {
            warnings.push(e);
        }
    }
    // hack-jslint - autofix
    warnings = warnings.filter(function (warning) {
        let aa;
        let bb;
        let tmp;
        if (!lines_extra[warning.line]) {
            return true;
        }
        aa = lines_extra[warning.line].source;
        warning.a = warning.a || aa.trim();
        switch (option.modeAutofix && warning.code) {
        // expected_a_at_b_c: "Expected '{a}' at column {b}, not column {c}.",
        case "expected_a_at_b_c":
            // autofix indent - increment
            tmp = warning.b - warning.c;
            if (tmp >= 0) {
                bb = " ".repeat(tmp) + aa;
                break;
            }
            // autofix indent - decrement
            tmp = -tmp;
            if ((
                /^\u0020*?$/m
            ).test(aa.slice(0, warning.column))) {
                bb = aa.slice(tmp);
                break;
            }
            // autofix indent - newline
            bb = (
                aa.slice(0, warning.column) + "\n"
                + " ".repeat(warning.b) + aa.slice(warning.column)
            );
            break;
        // expected_a_b: "Expected '{a}' and instead saw '{b}'.",
        case "expected_a_b":
            if (
                (warning.a === "\\s" || warning.a === "\\u0020")
                && warning.b === " "
            ) {
                bb = (
                    aa.slice(0, warning.column) + "\\u0020"
                    + aa.slice(warning.column + 1)
                );
            }
            break;
        // expected_identifier_a:
        // "Expected an identifier and instead saw '{a}'.",
        case "expected_identifier_a":
            if (
                (
                    /^\d+$/m
                ).test(warning.a)
                && aa[warning.column + warning.a.length] === ":"
            ) {
                bb = (
                    aa.slice(0, warning.column) + "\"" + warning.a + "\""
                    + aa.slice(warning.column + warning.a.length)
                );
                break;
            }
            break;
        // expected_space_a_b: "Expected one space between '{a}' and '{b}'.",
        case "expected_space_a_b":
            bb = (
                aa.slice(0, warning.column).trimRight() + " "
                + aa.slice(warning.column)
            );
            break;
        // unexpected_space_a_b: "Unexpected space between '{a}' and '{b}'.",
        case "unexpected_space_a_b":
            bb = (
                aa.slice(0, warning.column).trimRight()
                + aa.slice(warning.column)
            );
            break;
        // use_double: "Use double quotes, not single quotes.",
        case "use_double":
            tmp = undefined;
            bb = aa.slice(
                0,
                warning.column - 1
            ) + "\"" + aa.slice(warning.column, tmp).replace((
                /\\.|"|'/g
            ), function (match0) {
                if (tmp) {
                    return match0;
                }
                if (match0 === "'") {
                    tmp = true;
                    return "\"";
                }
                return (
                    match0 === "\""
                    ? "\\\""
                    : match0[1] === "'"
                    ? "'"
                    : match0
                );
            });
            break;
        // use_spaces: "Use spaces, not tabs.",
        case "use_spaces":
            bb = aa.replace((
                /^(\u0020*?)\t/
            ), "$1   ");
            break;
        }
        if (bb !== undefined) {
            lines_extra[warning.line].source_autofixed = bb;
            return;
        }
        return true;
    });
    // hack-jslint - debug warning
    warnings.some(function (warning) {
        if (!option.modeUtility2) {
            return true;
        }
        warning.option = Object.assign({}, option);
        Object.keys(warning.option).forEach(function (key) {
            if (typeof warning.option[key] === "object") {
                delete warning.option[key];
            }
        });
        return true;
    });
    return {
        directives,
        edition: "2020-11-06",
        exports,
        froms,
        functions,
        global,
        id: "(JSLint)",
        json: json_mode,
        lines,
        module: module_mode === true,
        ok: warnings.length === 0 && !early_stop,
        option,
        property,
        shebang: (
            shebang
            ? lines[0]
            : undefined
        ),
        stop: early_stop,
        tokens,
        tree,
        // hack-jslint - sort by early_stop
        warnings: warnings.sort(function (a, b) {
            return Boolean(b.early_stop) - Boolean(a.early_stop)
            || (a.line - b.line);
        }),
        // hack-jslint - autofix
        source_autofixed: lines_extra.map(function (element, ii) {
            return element.source_autofixed || lines[ii];
        }).join("\n")
    };
});


/*
file none
*/
local.CSSLint = CSSLint;
/* jslint ignore:end */


let jslintRecurse;
let jslintUtility2;
let stringGetLineAndCol;

function jslintAutofix(code, file, opt, {fileType, globalList, iiLine}) {
/*
 * this function will jslint-autofix <code>
 */
    let code0;
    let code2;
    let dataList;
    let ignoreList;
    let ii;
    let result;
    let rgx1;
    let rgx2;
    let tmp;
    // autofix-all - normalize local-function
    if (
        globalThis.utility2
        && typeof globalThis.utility2.jslintAutofixLocalFunction
        === "function"
    ) {
        code = globalThis.utility2.jslintAutofixLocalFunction(code, file);
    }
    // autofix-all - remove trailing-whitespace
    code = code.replace((
        /\u0020+$/gm
    ), "");
    // autofix-all - remove newlines before )]}
    code = code.replace((
        /\n+?(\n\u0020*?[)\]}])/g
    ), "$1");
    // autofix-all - eslint - no-multiple-empty-lines
    // https://github.com/eslint/eslint/blob/v7.2.0/docs/rules/no-multiple-empty-lines.md
    code = code.replace((
        /\n{4,}/g
    ), "\n\n\n");
    // autofix-all - recurse <script>...</script>, <style>...</style>
    code = code.replace((
        /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/\\n\\\n(?:^.*?\\n\\\n)*?)(';$|<\/script>\\n\\$|<\/style>\\n\\$)/gm
    ), function (ignore, match1, match2, ii) {
        return jslintRecurse(code, file + (
            match2.indexOf("style") >= 0
            ? ".<style>.css"
            : ".<script>.js"
        ), opt, {
            fileType0: ".\\n\\",
            iiEnd: ii + match1.length,
            iiLine,
            iiStart: ii
        }) + match2;
    });
    switch (fileType) {
    case ".css":
        break;
    case ".html":
        // autofix-html - recurse <script>...</script>, <style>...</style>
        code = code.replace((
            /^(\/\*\u0020jslint\u0020utility2:true\u0020\*\/\n[\S\s]*?\n)(<\/(?:script|style)>)$/gm
        ), function (ignore, match1, footer, ii) {
            return jslintRecurse(code, file + (
                footer === "</style>"
                ? ".<style>.css"
                : ".<script>.js"
            ), opt, {
                fileType0: fileType,
                iiEnd: ii + match1.length,
                iiLine,
                iiStart: ii
            }) + footer;
        });
        break;
    case ".js":
        // de-mux - code to [code, ignoreList]
        ignoreList = [];
        code = code.replace((
            /^\u0020*?\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]*?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
        ), function (match0) {
            ignoreList.push(match0);
            return "/* jslint ignore:start:end */";
        });
        // de-mux - code2 to [code2, ignoreList]
        code2 = "";
        dataList = [];
        ii = 0;
        rgx1 = (
            /\\.|\/\*|\*\/|\/\/!!|\/\/|["'\/`]|$/gm
        );
        // parse rgx
        // https://github.com/douglascrockford/JSLint/blob/557afd32bcaa35480d31a86f02d3a8c06a4e5b5c/jslint.js#L1383
        rgx2 = (
            /(?:[^.]\b(?:case|delete|in|instanceof|new|return|typeof|void|yield)|[!%&(*+,\-\/:;<=>?\[\^{|}~])[\s\u0028]*?\/[^*\/]/g
        );
        tmp = "";
        // de-mux - shebang
        code.replace((
            /^#!.*/
        ), function (match0) {
            code2 += "#!";
            dataList.push({
                code: match0,
                type: "#_"
            });
            rgx1.lastIndex = match0.length;
            ii = rgx1.lastIndex;
            return "";
        });
        while (rgx1.lastIndex < code.length) {
            tmp = rgx1.exec(code);
            switch (tmp[0]) {
            case "":
            case "\"":
            case "'":
            case "/*":
            case "//!!":
            case "//":
            case "`":
                if (tmp[0] === "") {
                    rgx1.lastIndex += 1;
                }
                // de-mux - rgx /_/
                rgx2.lastIndex = ii;
                // normalize rgx /_*/ to /_/
                if (rgx2.test(code) && rgx2.lastIndex - 2 <= tmp.index) {
                    rgx1.lastIndex = rgx2.lastIndex - 1;
                    tmp[0] = "/";
                }
                if (tmp[0] === "") {
                    break;
                }
                // de-mux - code to [code, dataList]
                code2 += code.slice(ii, rgx1.lastIndex);
                ii = rgx1.lastIndex;
                while (rgx1.lastIndex < code.length) {
                    tmp[1] = rgx1.exec(code)[0];
                    tmp[2] = tmp[0] + "_" + tmp[1];
                    switch (tmp[2]) {
                    // de-mux - false-positive rgx /_/
                    case "/_":
                        code2 += code.slice(ii, rgx1.lastIndex);
                        ii = 0;
                        break;
                    case "\"_\"":
                    case "'_'":
                    case "/*_*/":
                    case "//!!_":
                    case "//_":
                    case "/_*/":
                    case "/_/":
                    case "`_`":
                        code2 += "_" + tmp[1];
                        dataList.push({
                            code: tmp[0] + code.slice(ii, rgx1.lastIndex),
                            type: tmp[2].replace("/_*/", "/_/")
                        });
                        ii = 0;
                        break;
                    }
                    if (!ii) {
                        break;
                    }
                    if (!tmp[1]) {
                        rgx1.lastIndex += 1;
                    }
                }
                ii = rgx1.lastIndex;
                break;
            }
        }
        code2 += code.slice(ii);
        code = code2;
        // normalize rgx /_*/ to /_/
        code = code.replace((
            /\/_\*\//g
        ), "/_/");
        // autofix-js - left-align comment //_
        tmp = "";
        code = code.split("\n").reverse().map(function (line) {
            return line.replace((
                /^(\u0020*)(\/\/_)?/
            ), function (match0, match1, match2) {
                if (match1 && match2) {
                    return tmp + match2;
                }
                tmp = match1;
                return match0;
            });
        }).reverse().join("\n");
        // autofix-js-braket - normalize rgx /_/ to (/_/)
        code = code.replace((
            /\/_\/[\w\s]*(\S)/g
        ), function (match0, match1) {
            return (
                match1 === ")"
                ? match0
                : match0.replace((
                    /\/_\/\w*/
                ), "($&)")
            );
        });
        // autofix-js-braket - normalize rgx (/_/) to (\n/_/\n)
        code = code.replace((
            /\((\/_\/\w*)\)/g
        ), "(\n    $1\n)");
        // autofix-js-braket - normalize {... to {\n   ...
        code = code.replace((
            /^(\u0020+)(.*?(?:\u0020\[|\(\[|\{))\u0020*?(\S)/gm
        ), "$1$2\n$1    $3");
        // autofix-js-braket - normalize {\s+} to {}
        code = code.replace((
            /([(\[{])\s*?([)\]}])/g
        ), "$1$2");
        // autofix-js-whitespace - normalize 8-space-indent to 4-space-indent
        tmp = "";
        code = code.replace((
            /^\u0020+/gm
        ), function (match0) {
            if (match0.length > tmp.length + 4) {
                match0 = tmp;
            }
            tmp = match0;
            return match0;
        });
        code = ("\n" + code + "\n");
        // autofix-js-whitespace - normalize comment //_... to //_\n...
        code = code.replace((
            /\/\/_([^\n])/g
        ), "//_\n$1");
        // autofix-js-whitespace - normalize (function { to \n\n\n(function {
        code = code.replace((
            /\n+((?:\/\*_\*\/\n|\/\/_\n)*?\(function\u0020.*?)\n+/g
        ), "\n\n\n$1\n");
        code = code.trim();
        dataList.forEach(function (data) {
            switch (data.type) {
            case "/*_*/":
                // autofix-js - comment - "/*" to "\*"
                data.code = "/*" + data.code.slice(2).replace((
                    /\/\*/g
                ), "/\\*");
                break;
            }
        });
        // re-mux - shebang
        code = code.replace((
            /^#!/
        ), function () {
            return dataList.shift().code;
        });
        // re-mux - [code, dataList] to code
        code = code.replace((
            /"_"|'_'|\/\*_\*\/|\/\/!!_|\/\/_|\/_\/|`_`/g
        ), function (match0) {
            // re-mux - defer rgx /_/
            if (match0 === "/_/") {
                dataList.push(dataList.shift());
                return "/\u0000/";
            }
            return dataList.shift().code;
        });
        // autofix-js - jslint autofixed code
        ii = 0;
        while (true) {
            ii += 1;
            code0 = code;
            result = local.jslint0(code, opt, globalList);
            code = result.source_autofixed;
            if (ii >= 10 || result.stop || code0 === code) {
                break;
            }
        }
        // re-mux - rgx /_/
        code = code.replace((
            /\/\u0000\//g
        ), function () {
            return dataList.shift().code;
        });
        // autofix-js - sort const, let, var
        code = code.replace((
            /(?:^\u0020*?(?:const|let|var)\u0020[\w$]*?;.*?\n)+/gm
        ), function (match0) {
            return match0.split("\n").slice(0, -1).sort().join("\n") + "\n";
        });
        // re-mux - [code, ignoreList] to code
        code = code.replace((
            /^\u0020*?\/\*\u0020jslint\u0020ignore:start:end\u0020\*\/$/gm
        ), function () {
            return ignoreList.shift().trimStart();
        });
        break;
    case ".json":
        code = JSON.stringify(local.objectDeepCopyWithKeysSorted(JSON.parse(
            code
        )), undefined, 4);
        break;
    case ".md":
        // autofix-md - recurse ```javascript...```
        code = code.replace((
            /^(```javascript\n)([\S\s]*?\n)```$/gm
        ), function (ignore, match1, match2, ii) {
            return match1 + jslintRecurse(code, (
                file + ".<```javascript>.js"
            ), opt, {
                fileType0: fileType,
                iiEnd: ii + match1.length + match2.length,
                iiLine,
                iiStart: ii + match1.length
            }) + "```";
        });
        break;
    case ".sh":
        // autofix-sh - recurse node -e '...'
        code = code.replace((
            /^\/\*\u0020jslint\u0020utility2:true\u0020\*\/\n[\S\s]*?\n'/gm
        ), function (match0, ii) {
            return jslintRecurse(code, file + ".<node -e>.js", opt, {
                fileType0: fileType,
                iiEnd: ii + match0.length - 1,
                iiLine,
                iiStart: ii
            }) + "'";
        });
        break;
    }
    return code;
}

jslintRecurse = function (code, file, opt, {
    fileType0,
    iiEnd,
    iiLine = 0,
    iiStart = 0
}) {
/*
 * this function will recursively jslint <code> for embedded code
 */
    let code0;
    let errList;
    let errMsg;
    let fileType;
    let globalList;
    let result;
    let tmp;
    // init opt
    local.jslintResult = {};
    opt = Object.assign(local.jslintResult, opt, {
        errList: [],
        errMsg: ""
    });
    // init var
    errList = [];
    fileType = (
        /\.\w+?$|$/m
    ).exec(file)[0];
    globalList = opt.globalList;
    result = {};
    // preserve lineno - save iiLine
    iiLine += stringGetLineAndCol(code, iiStart).line;
    // de-embed
    code = code.slice(iiStart, iiEnd || code.length);
    switch (fileType0) {
    // de-embed-js - '\\n\\\n...\\n\\\n'
    case ".\\n\\":
        // rgx - remove \\n\\
        code = code.replace((
            /\\n\\$|\\(.)/gm
        ), function (ignore, match1) {
            return match1 || "";
        });
        break;
    // de-embed-js - '\n...\n'
    case ".sh":
        // rgx - convert '"'"' to '
        code = code.replace((
            /'"'"'/g
        ), "'");
        break;
    }
    // init
    code0 = code;
    tmp = {
        ".css": (
            /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
        ),
        ".html": (
            /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
        ),
        ".js": (
            /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
        ),
        ".json": (
            /^\s*?\{\s*?"!!jslint_utility2":\s*?true/
        ),
        ".md": (
            /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
        ),
        ".sh": (
            /(^#\u0020jslint\u0020utility2:true$)/m
        )
    };
    // jslint - .json
    if (fileType === ".js" && tmp[".json"].test(code.slice(0, 4096))) {
        fileType = ".json";
    }
    // init mode-utility2
    tmp = tmp[fileType] && tmp[fileType].exec(code.slice(0, 4096));
    opt.modeUtility2 = Boolean((tmp && tmp[1]) || opt.modeAutofix);
    // if not modeConditional, then do not jslint
    if (opt.modeConditional && !tmp) {
        return code;
    }
    // jslint - modeAutofix
    if (opt.modeAutofix) {
        code = jslintAutofix(code, file, opt, {
            fileType,
            globalList,
            iiLine
        });
    }
    // preserve lineno - restore iiLine
    code = "\n".repeat(iiLine) + code;
    switch (fileType) {
    // jslint - .css
    case ".css":
        // call csslint
        result = local.CSSLint.verify(code);
        // init errList
        errList = result.messages.map(function (err) {
            err.column = Math.max(err.col - 1, 0);
            err.message = (
                err.type + " - " + err.rule.id + " - " + err.message
                + "\n    " + err.rule.desc
            );
            return err;
        });
        break;
    case ".html":
        jslintAutofix(code, file, opt, {
            fileType,
            globalList,
            iiLine
        });
        break;
    case ".md":
    case ".sh":
        break;
    // jslint - .js
    default:
        // call jslint
        result = local.jslint0(code, opt, globalList);
        code = result.source_autofixed || code;
        // init errList
        errList = result.warnings.filter(function (err) {
            return err && err.message;
        }).map(function (err) {
            err.column = err.column + 1;
            err.evidence = err.source;
            err.line = err.line + 1;
            // debug early_stop
            if (err.early_stop) {
                err.message = (
                    "[JSLint was unable to finish] - "
                    + err.message
                );
            }
            return err;
        });
    }
    if (opt.modeUtility2) {
        jslintUtility2({
            code,
            errList,
            fileType
        });
    }
    // jslint - print
    switch (Boolean(fileType0) && fileType0) {
    // re-embed-js - '\\n\\\n...\\n\\\n'
    case ".\\n\\":
        code = code.trim();
        // rgx - escape \ to \\
        code = code.replace((
            /\\/g
        ), "\\\\");
        // rgx - append \n\
        code = code.replace((
            /$/gm
        ), "\\n\\");
        // rgx - escape ' to \'
        code = code.replace((
            /'/g
        ), "\\'");
        // rgx - escape js-env to js\-env
        code = code.replace((
            /\u0020js\u002denv\u0020/g
        ), " js\\\u002denv ");
        code += "\n";
        break;
    // re-embed-js - '\n...\n'
    case ".sh":
        // rgx - escape ' to '"'"'
        code = code.trim().replace((
            /'/g
        ), "'\"'\"'") + "\n";
        break;
    case false:
        code = code.trimEnd() + "\n";
        break;
    default:
        code = code.trim() + "\n";
    }
    // autofix-save
    if (
        local.isEnvNode
        && opt.modeAutofix
        && !fileType0
        && !result.stop
        && code !== code0
        && require("fs").existsSync(file)
    ) {
        require("fs").writeFileSync(file, code);
        require("fs").writeFileSync(file + ".autofix.old", code0);
        require("child_process").spawnSync(
            "diff",
            [
                "-u", file + ".autofix.old", file
            ],
            {
                stdio: [
                    "ignore", 2, "ignore"
                ]
            }
        );
        require("fs").unlinkSync(file + ".autofix.old");
        console.error(
            "\u001b[1mjslint-autofix - modified and saved file " + file
            + "\u001b[22m"
        );
    }
    // print colorized errMsg to stderr
    // https://github.com/kaizhu256/JSLint/blob/cli/cli.js#L99
    errMsg = "";
    errList.filter(function (warning) {
        return warning && warning.message;
    // print only first 10 warnings
    }).slice(0, 10).forEach(function (err, ii) {
        errMsg = errMsg || " \u001b[1mjslint " + file + "\u001b[22m\n";
        errMsg += (
            ("  " + String(ii + 1)).slice(-3)
            + " \u001b[31m" + err.message + "\u001b[39m"
            + " \u001b[90m\/\/ line " + err.line + ", column "
            + (err.column + 1)
            + "\u001b[39m\n"
            + ("    " + String(err.evidence).trim()).slice(0, 80) + "\n"
        );
        if (!ii && err.stack && err.a !== "debug\u0049nline") {
            tmp = err.stack;
            Object.entries(err).forEach(function ([
                key, val
            ]) {
                if ((typeof val === "object" && val) || key === "stack") {
                    delete err[key];
                }
            });
            errMsg += (
                JSON.stringify(err, undefined, 4) + "\n" + tmp.trim() + "\n"
            );
        }
    });
    errMsg = errMsg.trim();
    if (errMsg) {
        // print err to stderr
        console.error(errMsg);
    }
    return Object.assign(local.jslintResult, opt, result, {
        code,
        errList,
        errMsg
    }).code;
};

jslintUtility2 = function ({code, errList, fileType}) {
/*
 * this function will jslint <code> with utiity2-specific rules
 */
    let code2;
    let err;
    let indent;
    let previous;
    // jslintUtility2 - all
    code2 = code;
    // ignore start to end
    code2 = code2.replace((
        /^\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]+?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
    ), function (match0) {
        // preserve lineno
        return match0.replace((
            /.+/g
        ), "");
    });
    // lint whitespace
    code2.replace((
        /^\u0020+?(?:\*|\/\/!!)|^\u0020+|[\r\t]/gm
    ), function (match0, ii) {
        switch (match0.slice(-1)) {
        case " ":
            if (match0.length % 4 === 0) {
                return "";
            }
            err = {
                message: "non 4-space indent"
            };
            break;
        case "\r":
            err = {
                message: "unexpected \\r"
            };
            break;
        case "\t":
            err = {
                message: "unexpected \\t"
            };
            break;
        default:
            return "";
        }
        Object.assign(err, stringGetLineAndCol(code2, ii));
        errList.push({
            column: err.column,
            evidence: JSON.stringify(err.evidence),
            line: err.line + 1,
            message: err.message
        });
        return "";
    });
    switch (fileType) {
    // jslintUtility2 - .css
    case ".css":
        // ignore comment
        code2 = code2.replace((
            /^\u0020*?\/\*[\S\s]*?\*\/\u0020*?$/gm
        ), function (match0) {
            // preserve lineno
            return match0.replace((
                /.+/g
            ), "");
        });
        code2.replace((
            /\S\u0020{2}|\u0020,|^\S.*?,.|[;{}]./gm
        ), function (match0, ii) {
            switch (match0.slice(-2)) {
            case "  ":
                err = {
                    colOffset: 2,
                    message: "unexpected multi-whitespace"
                };
                break;
            case " ,":
                err = {
                    colOffset: 1,
                    message: "unexpected whitespace before comma"
                };
                break;
            default:
                err = {
                    colOffset: match0.length,
                    message: "unexpected multiline-statement"
                };
            }
            Object.assign(err, stringGetLineAndCol(code2, ii));
            errList.push({
                column: err.column + err.colOffset,
                evidence: JSON.stringify(err.evidence),
                line: err.line + 1,
                message: err.message
            });
            return "";
        });
        // validate line-sorted - css-selector
        previous = "";
        code2 = code2.replace((
            /^.|[#.>]|[,}]$|\u0020\{$|\b\w/gm
        ), function (match0) {
            switch (match0) {
            case " ":
                return match0;
            case " {":
                return "\u0001" + match0;
            case "#":
                return "\u0002" + match0;
            case ",":
                return "\u0000" + match0;
            case ".":
                return "\u0001" + match0;
            case ">":
                return "\u0003" + match0;
            case "}":
                return match0;
            default:
                return "\u0000" + match0;
            }
        });
        code2.replace((
            /\n{2,}|^\u0000@|^\}\n\}|\}|^(?:\S.*?\n)+/gm
        ), function (match0, ii) {
            switch (match0.slice(0, 2)) {
            case "\n\n":
            case "\u0000@":
            case "}\n":
                previous = "";
                return "";
            case "}":
                return "";
            }
            match0 = match0.trim();
            err = (
                !(previous < match0)
                ? {
                    message: "lines not sorted\n" + previous + "\n" + match0
                }
                : match0.split("\n").sort().join("\n") !== match0
                ? {
                    message: "lines not sorted\n" + match0
                }
                : undefined
            );
            if (err) {
                Object.assign(err, stringGetLineAndCol(code2, ii));
                errList.push({
                    column: err.column,
                    evidence: err.evidence,
                    line: err.line + 1,
                    message: err.message.replace((
                        /[\u0000-\u0007]/g
                    ), "")
                });
            }
            previous = match0;
            return "";
        });
        break;
    // jslintUtility2 - .html
    case ".html":
        break;
    // jslintUtility2 - .js
    case ".js":
        // validate line-sorted - "local.xxx = "
        previous = "";
        code2.replace((
            /^\/\*\u0020validateLineSortedReset\u0020\*\/$|^\(function\u0020\(|(^local\.\S*?\u0020=\u0020.*?$)/gm
        ), function (ignore, match1, ii) {
            if (!match1) {
                previous = "";
                return;
            }
            if (match1.slice(-3) === "\\n\\") {
                return;
            }
            if (!(previous < match1)) {
                err = {
                    message: "lines not sorted\n" + previous + "\n" + match1
                };
                Object.assign(err, stringGetLineAndCol(code2, ii));
                errList.push({
                    column: err.column,
                    evidence: err.evidence,
                    line: err.line + 1,
                    message: err.message
                });
            }
            previous = match1;
        });
        break;
    // jslintUtility2 - .md
    case ".md":
        break;
    // jslintUtility2 - .sh
    case ".sh":
        previous = "";
        code2.replace((
            /(^sh\w+?\(\)\u0020\{)|^sh\w+?\u0020*?\(\)\u0020*?\{/gm
        ), function (ignore, match1, ii) {
            err = undefined;
            if (!match1) {
                err = {
                    message: "invalid whitespace"
                };
            } else {
                if (!(previous < match1)) {
                    err = {
                        message: (
                            "lines not sorted\n" + previous + "\n" + match1
                        )
                    };
                }
                previous = match1;
            }
            if (err) {
                Object.assign(err, stringGetLineAndCol(code2, ii));
                errList.push({
                    column: err.column,
                    evidence: err.evidence,
                    line: err.line + 1,
                    message: err.message
                });
            }
            return "";
        });
        // validate line-sorted - case-esac-statement
        previous = "";
        code2.replace((
            /^(\u0020+?)(case\u0020.+?\u0020in|esac|[^\u0020()]+?\))$/gm
        ), function (ignore, match1, match2, ii) {
            err = undefined;
            match2 = match2.replace("*", "~*");
            switch (match2.slice(0, 5)) {
            case "case ":
                indent = indent || match1;
                break;
            case "esac":
                if (match1 === indent) {
                    indent = "";
                    previous = "";
                }
                break;
            default:
                if (match1 !== indent) {
                    break;
                }
                if (!(previous < match2)) {
                    err = {
                        message: (
                            "lines not sorted\n" + previous + "\n" + match2
                        )
                    };
                }
                previous = match2;
            }
            if (err) {
                Object.assign(err, stringGetLineAndCol(code2, ii));
                errList.push({
                    column: err.column,
                    evidence: err.evidence,
                    line: err.line + 1,
                    message: err.message
                });
            }
            return "";
        });
        break;
    }
};

stringGetLineAndCol = function (code, ii) {
/*
 * this function will get line and column from <code> at <ii>
 */
    let aa;
    let bb;
    let line;
    // https://jsperf.com/regexp-counting-2/8
    bb = 0;
    line = 0;
    while (true) {
        aa = bb;
        bb = code.indexOf("\n", bb) + 1;
        if (bb === 0 || ii < bb) {
            break;
        }
        line += 1;
    }
    return {
        column: ii - aa,
        evidence: code.slice(aa, Math.max((bb || code.length) - 1, 0)),
        line
    };
};

local.jslintAndPrint = function (code, file = "undefined", opt = {}) {
/*
 * this function will jslint-autofix <code>
 */
    return jslintRecurse(code, file, opt, {});
};

local.jslintAndPrintDir = function (dir, opt, onError) {
/*
 * this function will jslint files in <dir>
 */
    let errCnt;
    errCnt = 0;
    onError = onError || function (err) {
        process.exit(Math.min((err && err.message) | 0, 127));
    };
    dir = require("path").resolve(dir) + require("path").sep;
    require("fs").readdir(dir, function (err, fileList) {
        local.onErrorThrow(err);
        Promise.all(fileList.map(function (file) {
            return new Promise(function (resolve) {
                let timeStart;
                timeStart = Date.now();
                file = dir + file;
                switch ((
                    /\.\w+?$|$/m
                ).exec(file)[0]) {
                case ".css":
                case ".html":
                case ".js":
                case ".json":
                case ".md":
                case ".sh":
                    if ((
                        /\b(?:assets\.app\.js|lock|min|raw|rollup)\b/
                    ).test(file)) {
                        resolve();
                        return;
                    }
                    // jslint file
                    require("fs").readFile(file, "utf8", function (err, data) {
                        if (err) {
                            return;
                        }
                        local.jslintAndPrint(data, file, opt);
                        errCnt += local.jslintResult.errList.length;
                        console.error(
                            "jslint - " + (Date.now() - timeStart) + "ms - "
                            + file
                        );
                        resolve();
                    });
                    return;
                }
                resolve();
            });
        })).then(function () {
            onError(errCnt && new Error(errCnt));
        });
    });
};

local.jslintResult = {};
}());


/* istanbul ignore next */
// run node js-env code - init-after
(function () {
if (!local.isEnvNode) {
    return;
}

local.cliDict = {};

local.cliDict._default = function () {
/*
 * <file1> <file2> ...
 * will jslint <file1> <file2> ... and print errors to stderr
 */
    // jslint files
    process.argv.slice(2).forEach(function (file) {
        if (file[0] === "-") {
            return;
        }
        local.jslintAndPrint(
            require("fs").readFileSync(require("path").resolve(file), "utf8"),
            file,
            {
                modeAutofix: process.argv.indexOf("--autofix") >= 0,
                modeConditional: process.argv.indexOf("--conditional") >= 0
            }
        );
    });
    // if err occurred, then exit with non-zero code
    process.exit(Boolean(local.jslintResult.errList.length));
};

local.cliDict.dir = function () {
/*
 * <dir>
 * will jslint files in shallow <dir>
 */
    local.jslintAndPrintDir(process.argv[3], {
        modeAutofix: process.argv.indexOf("--autofix") >= 0,
        modeConditional: process.argv.indexOf("--conditional") >= 0
    });
};

// run the cli
if (module === require.main && !globalThis.utility2_rollup) {
    local.cliRun({});
}
}());
}());
/* script-end /assets.utility2.lib.jslint.js */



/* script-begin /assets.utility2.lib.marked.js */
// usr/bin/env node


/* istanbul instrument in package marked */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_marked = local;
}
// init lib main
local.marked = local;


/* validateLineSortedReset */
return;
}());


/* jslint ignore:start */
(function () { var exports, module; exports = module = {};
// rollup-file marked.js
// 2017-01-19T23:03:37Z
// https://github.com/markedjs/marked/blob/v0.3.7/lib/marked.js
// utility2-uglifyjs https://raw.githubusercontent.com/chjj/marked/v0.3.7/lib/marked.js > /tmp/out.js
(function(){function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&&(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}function r(e,t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error("Tokens array requires a `links` property."
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&&(this.rules=n.pedantic)}function i(e){this.options=e||{}}function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}function o(e,t){return e.replace(t?/&/g:/&(?!#?\w+;)/g,"&amp;").replace
(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}
function u(e){return e.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g,function(
e,t){return t=t.toLowerCase(),t==="colon"?":":t.charAt(0)==="#"?t.charAt(1)==="x"?
String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring
(1)):""})}function a(e,t){return e=e.source,t=t||"",function n(r,i){return r?(i=
i.source||i,i=i.replace(/(^|[^\[])\^/g,"$1"),e=e.replace(r,i),n):new RegExp(e,t)
}}function f(){}function l(e){var t=1,n,r;for(;t<arguments.length;t++){n=arguments
[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}function c
(e,n,r){if(r||typeof n=="function"){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length<3)return p();delete n.highlight;if(!
a)return p();for(;f<u.length;f++)(function(e){return e.type!=="code"?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&&(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+="\nPlease report this to https://github.com/chjj/marked."
;if((n||c.defaults).silent)return"<p>An error occured:</p><pre>"+o(h.message+"",!0
)+"</pre>";throw h}}var e={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:f,hr:/^( *[-*_]){3,} *(?:\n+|$)/
,heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,nptable:f,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/
,blockquote:/^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/
,html:/^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/
,def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,table:f
,paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,text
:/^[^\n]+/};e.bullet=/(?:[*+-]|\d+\.)/,e.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/
,e.item=a(e.item,"gm")(/bull/g,e.bullet)(),e.list=a(e.list)(/bull/g,e.bullet)("hr"
,"\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def","\\n+(?="+e.def.source+")")(),e.
blockquote=a(e.blockquote)("def",e.def)(),e._tag="(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b"
,e.html=a(e.html)("comment",/<!--[\s\S]*?-->/)("closed",/<(tag)[\s\S]+?<\/\1>/)("closing"
,/<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g,e._tag)(),e.paragraph=a(e.paragraph
)("hr",e.hr)("heading",e.heading)("lheading",e.lheading)("blockquote",e.blockquote
)("tag","<"+e._tag)("def",e.def)(),e.normal=l({},e),e.gfm=l({},e.normal,{fences:/^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/
,paragraph:/^/,heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/}),e.gfm.paragraph=
a(e.paragraph)("(?!","(?!"+e.gfm.fences.source.replace("\\1","\\2")+"|"+e.list.source
.replace("\\1","\\3")+"|")(),e.tables=l({},e.gfm,{nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/
,table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/}),t.rules=e,t
.lex=function(e,n){var r=new t(n);return r.lex(e)},t.prototype.lex=function(e){return e=
e.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g
,"\n"),this.token(e,!0)},t.prototype.token=function(t,n,r){var t=t.replace(/^ +$/gm
,""),i,s,o,u,a,f,l,c,h;while(t){if(o=this.rules.newline.exec(t))t=t.substring(o[0
].length),o[0].length>1&&this.tokens.push({type:"space"});if(o=this.rules.code.exec
(t)){t=t.substring(o[0].length),o=o[0].replace(/^ {4}/gm,""),this.tokens.push({type
:"code",text:this.options.pedantic?o:o.replace(/\n+$/,"")});continue}if(o=this.rules
.fences.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:"code",lang:o
[2],text:o[3]||""});continue}if(o=this.rules.heading.exec(t)){t=t.substring(o[0]
.length),this.tokens.push({type:"heading",depth:o[1].length,text:o[2]});continue}
if(n&&(o=this.rules.nptable.exec(t))){t=t.substring(o[0].length),f={type:"table"
,header:o[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,"").split(/ *\| */),cells:o[3].replace(/\n$/,"").split("\n")};for(c=0;c<f.align
.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]="right":/^ *:-+: *$/.test(f.
align[c])?f.align[c]="center":/^ *:-+ *$/.test(f.align[c])?f.align[c]="left":f.align
[c]=null;for(c=0;c<f.cells.length;c++)f.cells[c]=f.cells[c].split(/ *\| */);this
.tokens.push(f);continue}if(o=this.rules.lheading.exec(t)){t=t.substring(o[0].length
),this.tokens.push({type:"heading",depth:o[2]==="="?1:2,text:o[1]});continue}if(
o=this.rules.hr.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:"hr"}
);continue}if(o=this.rules.blockquote.exec(t)){t=t.substring(o[0].length),this.tokens
.push({type:"blockquote_start"}),o=o[0].replace(/^ *> ?/gm,""),this.token(o,n,!0
),this.tokens.push({type:"blockquote_end"});continue}if(o=this.rules.list.exec(t
)){t=t.substring(o[0].length),u=o[2],this.tokens.push({type:"list_start",ordered
:u.length>1}),o=o[0].match(this.rules.item),i=!1,h=o.length,c=0;for(;c<h;c++)f=o
[c],l=f.length,f=f.replace(/^ *([*+-]|\d+\.) +/,""),~f.indexOf("\n ")&&(l-=f.length
,f=this.options.pedantic?f.replace(/^ {1,4}/gm,""):f.replace(new RegExp("^ {1,"+
l+"}","gm"),"")),this.options.smartLists&&c!==h-1&&(a=e.bullet.exec(o[c+1])[0],u!==
a&&!(u.length>1&&a.length>1)&&(t=o.slice(c+1).join("\n")+t,c=h-1)),s=i||/\n\n(?!\s*$)/
.test(f),c!==h-1&&(i=f.charAt(f.length-1)==="\n",s||(s=i)),this.tokens.push({type
:s?"loose_item_start":"list_item_start"}),this.token(f,!1,r),this.tokens.push({type
:"list_item_end"});this.tokens.push({type:"list_end"});continue}if(o=this.rules.
html.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:this.options.sanitize?"paragraph"
:"html",pre:!this.options.sanitizer&&(o[1]==="pre"||o[1]==="script"||o[1]==="style"
),text:o[0]});continue}if(!r&&n&&(o=this.rules.def.exec(t))){t=t.substring(o[0].
length),this.tokens.links[o[1].toLowerCase()]={href:o[2],title:o[3]};continue}if(
n&&(o=this.rules.table.exec(t))){t=t.substring(o[0].length),f={type:"table",header
:o[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,"").split(/ *\| */),cells:o[3].replace(/(?: *\| *)?\n$/,"").split("\n")};for(c=0
;c<f.align.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]="right":/^ *:-+: *$/
.test(f.align[c])?f.align[c]="center":/^ *:-+ *$/.test(f.align[c])?f.align[c]="left"
:f.align[c]=null;for(c=0;c<f.cells.length;c++)f.cells[c]=f.cells[c].replace(/^ *\| *| *\| *$/g
,"").split(/ *\| */);this.tokens.push(f);continue}if(n&&(o=this.rules.paragraph.
exec(t))){t=t.substring(o[0].length),this.tokens.push({type:"paragraph",text:o[1
].charAt(o[1].length-1)==="\n"?o[1].slice(0,-1):o[1]});continue}if(o=this.rules.
text.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:"text",text:o[0]
});continue}if(t)throw new Error("Infinite loop on byte: "+t.charCodeAt(0))}return this
.tokens};var n={escape:/^\\([\\`*{}\[\]()#+\-.!_>])/,autolink:/^<([^ >]+(@|:\/)[^ >]+)>/
,url:f,tag:/^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,link:/^!?\[(inside)\]\(href\)/
,reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/,nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/
,strong:/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,em:/^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/
,code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:f,text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};n._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,n._href=/\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/
,n.link=a(n.link)("inside",n._inside)("href",n._href)(),n.reflink=a(n.reflink)("inside"
,n._inside)(),n.normal=l({},n),n.pedantic=l({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)("])","~|])")(),url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)("]|","~]|")("|","|https?://|")()}),n.breaks=
l({},n.gfm,{br:a(n.br)("{2,}","*")(),text:a(n.gfm.text)("{2,}","*")()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.output(e)},r.prototype.output=
function(e){var t="",n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]==="@"?(r=s[1].charAt(6)===":"?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle("mailto:")+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&&(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&&/^<a /i.test(s[0])?this.inLink=!0:this.inLink&&/^<\/a>/i
.test(s[0])&&(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g," "),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error("Infinite loop on byte: "+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!=="!"?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,"\u2014"
).replace(/--/g,"\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1\u2018").replace(/'/g
,"\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1\u201c").replace(/"/g,"\u201d"
).replace(/\.{3}/g,"\u2026"):e},r.prototype.mangle=function(e){if(!this.options.
mangle)return e;var t="",n=e.length,r=0,i;for(;r<n;r++)i=e.charCodeAt(r),Math.random
()>.5&&(i="x"+i.toString(16)),t+="&#"+i+";";return t},i.prototype.code=function(
e,t,n){if(this.options.highlight){var r=this.options.highlight(e,t);r!=null&&r!==
e&&(n=!0,e=r)}return t?'<pre><code class="'+this.options.langPrefix+o(t,!0)+'">'+
(n?e:o(e,!0))+"\n</code></pre>\n":"<pre><code>"+(n?e:o(e,!0))+"\n</code></pre>"}
,i.prototype.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},
i.prototype.html=function(e){return e},i.prototype.heading=function(e,t,n){return"<h"+
t+' id="'+this.options.headerPrefix+n.toLowerCase().replace(/[^\w]+/g,"-")+'">'+
e+"</h"+t+">\n"},i.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"
},i.prototype.list=function(e,t){var n=t?"ol":"ul";return"<"+n+">\n"+e+"</"+n+">\n"
},i.prototype.listitem=function(e){return"<li>"+e+"</li>\n"},i.prototype.paragraph=
function(e){return"<p>"+e+"</p>\n"},i.prototype.table=function(e,t){return"<table>\n<thead>\n"+
e+"</thead>\n"+"<tbody>\n"+t+"</tbody>\n"+"</table>\n"},i.prototype.tablerow=function(
e){return"<tr>\n"+e+"</tr>\n"},i.prototype.tablecell=function(e,t){var n=t.header?"th"
:"td",r=t.align?"<"+n+' style="text-align:'+t.align+'">':"<"+n+">";return r+e+"</"+
n+">\n"},i.prototype.strong=function(e){return"<strong>"+e+"</strong>"},i.prototype
.em=function(e){return"<em>"+e+"</em>"},i.prototype.codespan=function(e){return"<code>"+
e+"</code>"},i.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"}
,i.prototype.del=function(e){return"<del>"+e+"</del>"},i.prototype.link=function(
e,t,n){if(this.options.sanitize){try{var r=decodeURIComponent(u(e)).replace(/[^\w:]/g
,"").toLowerCase()}catch(i){return""}if(r.indexOf("javascript:")===0||r.indexOf("vbscript:"
)===0||r.indexOf("data:")===0)return""}var s='<a href="'+e+'"';return t&&(s+=' title="'+
t+'"'),s+=">"+n+"</a>",s},i.prototype.image=function(e,t,n){var r='<img src="'+e+'" alt="'+
n+'"';return t&&(r+=' title="'+t+'"'),r+=this.options.xhtml?"/>":">",r},i.prototype
.text=function(e){return e},s.parse=function(e,t,n){var r=new s(t,n);return r.parse
(e)},s.prototype.parse=function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t="";while(this.next())t+=this.tok();return t},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type==="text")e+="\n"+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case"space"
:return"";case"hr":return this.renderer.hr();case"heading":return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case"code"
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case"table"
:var e="",t="",n,r,i,s,o;i="";for(n=0;n<this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n<this.token.cells.length;n++){r=this.token.cells[n],i="";for(o=0;o<r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case"blockquote_start"
:var t="";while(this.next().type!=="blockquote_end")t+=this.tok();return this.renderer
.blockquote(t);case"list_start":var t="",u=this.token.ordered;while(this.next().
type!=="list_end")t+=this.tok();return this.renderer.list(t,u);case"list_item_start"
:var t="";while(this.next().type!=="list_item_end")t+=this.token.type==="text"?this
.parseText():this.tok();return this.renderer.listitem(t);case"loose_item_start":
var t="";while(this.next().type!=="list_item_end")t+=this.tok();return this.renderer
.listitem(t);case"html":var a=!this.token.pre&&!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case"paragraph"
:return this.renderer.paragraph(this.inline.output(this.token.text));case"text":
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
langPrefix:"lang-",smartypants:!1,headerPrefix:"",renderer:new i,xhtml:!1},c.Parser=
s,c.parser=s.parse,c.Renderer=i,c.Lexer=t,c.lexer=t.lex,c.InlineLexer=r,c.inlineLexer=
r.output,c.parse=c,typeof module!="undefined"&&typeof exports=="object"?module.exports=
c:typeof define=="function"&&define.amd?define(function(){return c}):this.marked=
c}).call(function(){return this||(typeof window!="undefined"?window:global)}())
local.marked = module.exports; }());
/* jslint ignore:end */
// init exports
if (local.isEnvNode) {
    module.exports = local.marked;
} else {
    globalThis.utility2_marked = local.marked;
}
}());
/* script-end /assets.utility2.lib.marked.js */



/* script-begin /assets.utility2.js */
// usr/bin/env node
/*
 * lib.utility2.js (2020.12.3)
 * https://github.com/kaizhu256/node-utility2
 * this zero-dependency package will provide high-level functions to to build, test, and deploy webapps
 *
 */


/* istanbul instrument in package utility2 */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_utility2 = local;
}
// init lib main
local.utility2 = local;


/* validateLineSortedReset */
// bug-workaround - throw unhandledRejections in node-process
if (
    typeof process === "object" && process &&
    typeof process.on === "function" &&
    !process.unhandledRejections
) {
    process.unhandledRejections = "throw";
    process.on("unhandledRejection", function (err) {
        throw err;
    });
}
}());


(function () {
// init lib utility2
globalThis.utility2 = local;


// run shared js-env code - state
(function () {
    let packageJson;
    let state;
    // init state - default
    state = {
        apidocCreate: local.identity,
        coverageMerge: local.identity,
        coverageReportCreate: local.identity,
        instrumentInPackage: local.identity,
        jslintAndPrint: local.identity,
        jslintAndPrintDir: local.identity,
        npm_config_timeout: 30000,
        npm_package_description: "the greatest app in the world!",
        npm_package_name: "my-app",
        npm_package_version: "0.0.1"
    };
    // init state - utility2_state
    state = Object.assign(state, globalThis.utility2_state);
    // init state - package.json
    try {
        packageJson = JSON.parse(require("fs").readFileSync("package.json"));
        Object.entries(packageJson).forEach(function ([
            key, val
        ]) {
            state["npm_package_" + key] = String(val);
        });
        packageJson.repository.url.replace((
            /https:\/\/github\.com\/([^\/]+?\/[^.]+)/
        ), function (ignore, match1) {
            state.GITHUB_FULLNAME = match1;
            return "";
        });
    } catch (ignore) {}
    // init state - process.env
    state = Object.assign(
        state,
        (typeof process === "object" && process && process.env)
    );
    // init state - location.search
    if (
        typeof location === "object" && location &&
        typeof location.search === "string"
    ) {
        location.search.replace((
            /\b(npm_config_mode_test|npm_config_mode_test_case|npm_config_timeout)=([^&#]+)/g
        ), function (ignore, key, val) {
            state[key] = decodeURIComponent(val);
            return "";
        });
    }
    // init state - misc
    state = Object.assign({
        GITHUB_OWNER: String(state.GITHUB_FULLNAME).split("/")[0],
        GITHUB_REPO: String(state.GITHUB_FULLNAME).split("/")[1],
        UTILITY2_DIR_BUILD: (
            local.isEnvNode
            ? require("path").resolve(".tmp/build")
            : "/"
        ),
        npm_config_mode_test_case: "",
        npm_package_nameLib: String(state.npm_package_name).replace((
            /\W/g
        ), "_")
    }, state);
    state.npm_config_timeout |= 0;
    // init lib extra
    [
        "apidoc",
        "dummy",
        // cbranch-no cstat-no fstat-no missing-if-branch
        "istanbul",
        "jslint",
        "marked"
    ].forEach(function (key) {
        try {
            local[key] = (
                local.isEnvNode
                ? require("./lib." + key + ".js")
                : globalThis["utility2_" + key]
            );
        } catch (errCaught) {
            local.assertOrThrow(
                errCaught.code === "MODULE_NOT_FOUND",
                errCaught
            );
        }
        local[key] = local[key] || {};
        Object.assign(state, local[key]);
    });
    [
        "coverageReportCreate",
        "jslintAndPrintDir",
        "CI_BRANCH",
        "CI_COMMIT_ID",
        "CI_COMMIT_MESSAGE",
        "CI_HOST",
        "GITHUB_FULLNAME",
        "GITHUB_OWNER",
        "GITHUB_REPO",
        "HOME",
        "MODE_CI",
        "PATH",
        "PORT",
        "UTILITY2_DIR_BUILD",
        "apidocCreate",
        "coverageMerge",
        "instrumentInPackage",
        "jslintAndPrint",
        "npm_config_mode_auto_restart",
        "npm_config_mode_lib",
        "npm_config_mode_start",
        "npm_config_mode_test",
        "npm_config_mode_test_case",
        "npm_config_mode_test_report_merge",
        "npm_config_timeout",
        "npm_config_timeout_exit",
        "npm_package_description",
        "npm_package_homepage",
        "npm_package_main",
        "npm_package_name",
        "npm_package_nameHeroku",
        "npm_package_nameLib",
        "npm_package_nameOriginal",
        "npm_package_version"
    ].forEach(function (key) {
        local[key] = state[key];
    });
}());
let {
    assertJsonEqual,
    assertOrThrow,
    documentQuerySelectorAll,
    isEnvNode,
    noop,
    onErrorThrow,
    CI_BRANCH,
    CI_COMMIT_ID,
    CI_COMMIT_MESSAGE,
    CI_HOST,
    GITHUB_FULLNAME,
    GITHUB_OWNER,
    GITHUB_REPO,
    HOME,
    MODE_CI,
    PATH,
    PORT,
    UTILITY2_DIR_BUILD,
    apidocCreate,
    coverageMerge,
    instrumentInPackage,
    jslintAndPrint,
    npm_config_mode_auto_restart,
    npm_config_mode_lib,
    npm_config_mode_start,
    npm_config_mode_test,
    npm_config_mode_test_case,
    npm_config_mode_test_report_merge,
    npm_config_timeout,
    npm_config_timeout_exit,
    npm_package_description,
    npm_package_homepage,
    npm_package_main,
    npm_package_name,
    npm_package_nameHeroku,
    npm_package_nameLib,
    npm_package_nameOriginal,
    npm_package_version
} = local;


/* validateLineSortedReset */
// run shared js-env code - assetsDict
local.assetsDict = local.assetsDict || {};
local.assetsDict["/assets.utility2.header.js"] = (
    "// assets.utility2.header.js - start\n" +
    "/* jslint utility2:true */\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-local\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    let isEnvNode;\n" +
    "    let local;\n" +
    "    // init debugInline\n" +
    "    if (!globalThis.debugInline) {\n" +
    "        let consoleError;\n" +
    "        consoleError = console.error;\n" +
    "        globalThis.debugInline = function (...argList) {\n" +
    "        /*\n" +
    "         * this function will both print <argList> to stderr and\n" +
    "         * return <argList>[0]\n" +
    "         */\n" +
    "            consoleError(\"\\n\\ndebugInline\");\n" +
    "            consoleError(...argList);\n" +
    "            consoleError(\"\\n\");\n" +
    "            return argList[0];\n" +
    "        };\n" +
    "    }\n" +
    "    // init isEnvNode\n" +
    "    isEnvNode = (\n" +
    "        typeof process === \"object\" && process &&\n" +
    "        process.versions && typeof process.versions.node === " +
    "\"string\"\n" +
    "    );\n" +
    "    // init function\n" +
    "    function objectDeepCopyWithKeysSorted(obj) {\n" +
    "    /*\n" +
    "     * this function will recursively deep-copy <obj> with keys sorted\n" +
    "     */\n" +
    "        let sorted;\n" +
    "        if (typeof obj !== \"object\" || !obj) {\n" +
    "            return obj;\n" +
    "        }\n" +
    "        // recursively deep-copy list with child-keys sorted\n" +
    "        if (Array.isArray(obj)) {\n" +
    "            return obj.map(objectDeepCopyWithKeysSorted);\n" +
    "        }\n" +
    "        // recursively deep-copy obj with keys sorted\n" +
    "        sorted = {};\n" +
    "        Object.keys(obj).sort().forEach(function (key) {\n" +
    "            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n" +
    "        });\n" +
    "        return sorted;\n" +
    "    }\n" +
    "    function assertJsonEqual(aa, bb) {\n" +
    "    /*\n" +
    "     * this function will assert JSON.stringify(<aa>) === " +
    "JSON.stringify(<bb>)\n" +
    "     */\n" +
    "        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n" +
    "        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n" +
    "        if (aa !== bb) {\n" +
    "            throw new Error(JSON.stringify(aa) + \" !== \" + " +
    "JSON.stringify(bb));\n" +
    "        }\n" +
    "    }\n" +
    "    function assertOrThrow(passed, msg) {\n" +
    "    /*\n" +
    "     * this function will throw <msg> if <passed> is falsy\n" +
    "     */\n" +
    "        if (passed) {\n" +
    "            return;\n" +
    "        }\n" +
    "        throw (\n" +
    "            (\n" +
    "                msg &&\n" +
    "                typeof msg.message === \"string\" &&\n" +
    "                typeof msg.stack === \"string\"\n" +
    "            )\n" +
    "            // if msg is err, then leave as is\n" +
    "            ? msg\n" +
    "            : new Error(\n" +
    "                typeof msg === \"string\"\n" +
    "                // if msg is string, then leave as is\n" +
    "                ? msg\n" +
    "                // else JSON.stringify(msg)\n" +
    "                : JSON.stringify(msg, undefined, 4)\n" +
    "            )\n" +
    "        );\n" +
    "    }\n" +
    "    function documentQuerySelectorAll(selector) {\n" +
    "    /*\n" +
    "     * this function will return document.querySelectorAll(<selector>) " +
    "or\n" +
    "     * empty list if function is not available\n" +
    "     */\n" +
    "        return Array.from(\n" +
    "            (\n" +
    "                typeof document === \"object\" && document &&\n" +
    "                typeof document.querySelectorAll === \"function\"\n" +
    "            )\n" +
    "            ? document.querySelectorAll(selector)\n" +
    "            : []\n" +
    "        );\n" +
    "    }\n" +
    "    function identity(val) {\n" +
    "    /*\n" +
    "     * this function will return <val>\n" +
    "     */\n" +
    "        return val;\n" +
    "    }\n" +
    "    function noop() {\n" +
    "    /*\n" +
    "     * this function will do nothing\n" +
    "     */\n" +
    "        return;\n" +
    "    }\n" +
    "    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n" +
    "    /*\n" +
    "     * this function will if items from <tgt> are null, undefined, or\n" +
    "     * \"\", then overwrite them with items from <src>\n" +
    "     */\n" +
    "        function recurse(tgt, src, depth) {\n" +
    "            Object.entries(src).forEach(function ([\n" +
    "                key, bb\n" +
    "            ]) {\n" +
    "                let aa;\n" +
    "                aa = tgt[key];\n" +
    "                if (aa === undefined || aa === null || aa === \"\") {\n" +
    "                    tgt[key] = bb;\n" +
    "                    return;\n" +
    "                }\n" +
    "                if (\n" +
    "                    depth !== 0 &&\n" +
    "                    typeof aa === \"object\" && aa && " +
    "!Array.isArray(aa) &&\n" +
    "                    typeof bb === \"object\" && bb && " +
    "!Array.isArray(bb)\n" +
    "                ) {\n" +
    "                    recurse(aa, bb, depth - 1);\n" +
    "                }\n" +
    "            });\n" +
    "        }\n" +
    "        recurse(tgt, src, depth | 0);\n" +
    "        return tgt;\n" +
    "    }\n" +
    "    function onErrorThrow(err) {\n" +
    "    /*\n" +
    "     * this function will throw <err> if exists\n" +
    "     */\n" +
    "        if (err) {\n" +
    "            throw err;\n" +
    "        }\n" +
    "    }\n" +
    "    // init local\n" +
    "    local = {\n" +
    "        assertJsonEqual,\n" +
    "        assertOrThrow,\n" +
    "        documentQuerySelectorAll,\n" +
    "        identity,\n" +
    "        isEnvNode,\n" +
    "        local,\n" +
    "        noop,\n" +
    "        objectAssignDefault,\n" +
    "        objectDeepCopyWithKeysSorted,\n" +
    "        onErrorThrow\n" +
    "    };\n" +
    "    globalThis.globalLocal = local;\n" +
    "}());\n" +
    "// assets.utility2.header.js - end\n"
);
local.assetsDict["/assets.utility2.template.html"] = (
    "<!doctype html>\n" +
    "<html lang=\"en\">\n" +
    "<head>\n" +
    "<meta charset=\"utf-8\">\n" +
    "<meta\n" +
    "    content=\"width=device-width, initial-scale=1\"\n" +
    "    name=\"viewport\"\n" +
    ">\n" +
    "<!-- \"assets.utility2.template.html\" -->\n" +
    "<title>{{npm_package_name}} ({{npm_package_version}})</title>\n" +
    "<style>\n" +
    "/* jslint\u0020utility2:true */\n" +
    "/*csslint\n" +
    "*/\n" +
    "/* csslint ignore:start */\n" +
    "*,\n" +
    "*:after,\n" +
    "*:before {\n" +
    "    box-sizing: border-box;\n" +
    "}\n" +
    ".uiAnimateSlide {\n" +
    "    overflow-y: hidden;\n" +
    "    transition:\n" +
    "        max-height ease-in 250ms,\n" +
    "        min-height ease-in 250ms,\n" +
    "        padding-bottom ease-in 250ms,\n" +
    "        padding-top ease-in 250ms;\n" +
    "}\n" +
    "/* csslint ignore:end */\n" +
    "@keyframes uiAnimateSpin {\n" +
    "0% {\n" +
    "    transform: rotate(0deg);\n" +
    "}\n" +
    "100% {\n" +
    "    transform: rotate(360deg);\n" +
    "}\n" +
    "}\n" +
    "a {\n" +
    "    overflow-wrap: break-word;\n" +
    "}\n" +
    "body {\n" +
    "    background: #f7f7f7;\n" +
    "    font-family: Arial, Helvetica, sans-serif;\n" +
    "    font-size: small;\n" +
    "    margin: 0 40px;\n" +
    "}\n" +
    "body > div,\n" +
    "body > input,\n" +
    "body > pre,\n" +
    "body > .button,\n" +
    "body > .textarea {\n" +
    "    margin-bottom: 20px;\n" +
    "    margin-top: 0;\n" +
    "}\n" +
    "body > input,\n" +
    "body > .button {\n" +
    "    width: 20rem;\n" +
    "}\n" +
    "body > .readonly {\n" +
    "    background: #ddd;\n" +
    "}\n" +
    "body > .textarea {\n" +
    "    height: 10rem;\n" +
    "    resize: vertical;\n" +
    "    width: 100%;\n" +
    "}\n" +
    "code,\n" +
    "pre,\n" +
    ".textarea {\n" +
    "    font-family: Consolas, Menlo, monospace;\n" +
    "    font-size: smaller;\n" +
    "}\n" +
    "pre {\n" +
    "    overflow-wrap: break-word;\n" +
    "    white-space: pre-wrap;\n" +
    "}\n" +
    ".button {\n" +
    "    background: #ddd;\n" +
    "    border: 1px solid #999;\n" +
    "    color: #000;\n" +
    "    cursor: pointer;\n" +
    "    display: inline-block;\n" +
    "    padding: 2px 5px;\n" +
    "    text-align: center;\n" +
    "    text-decoration: none;\n" +
    "}\n" +
    ".button:hover {\n" +
    "    background: #bbb;\n" +
    "}\n" +
    ".colorError {\n" +
    "    color: #d00;\n" +
    "}\n" +
    ".textarea {\n" +
    "    background: #fff;\n" +
    "    border: 1px solid #999;\n" +
    "    border-radius: 0;\n" +
    "    cursor: auto;\n" +
    "    overflow: auto;\n" +
    "    padding: 2px;\n" +
    "}\n" +
    ".zeroPixel {\n" +
    "    border: 0;\n" +
    "    height: 0;\n" +
    "    margin: 0;\n" +
    "    padding: 0;\n" +
    "    width: 0;\n" +
    "}\n" +
    "</style>\n" +
    "</head>\n" +
    "<body>\n" +
    "<div class=\"uiAnimateSpin\" style=\"\n" +
    "    animation: uiAnimateSpin 2s linear infinite;\n" +
    "    border-radius: 50%;\n" +
    "    border-top: 5px solid #7d7;\n" +
    "    border: 5px solid #999;\n" +
    "    display: none;\n" +
    "    height: 25px;\n" +
    "    vertical-align: middle;\n" +
    "    width: 25px;\n" +
    "\"></div>\n" +
    "<script>\n" +
    "/* jslint\u0020utility2:true */\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    // polyfill globalThis\n" +
    "    window.globalThis = window;\n" +
    "    // measure-and-print time-elapsed for window.onload\n" +
    "    if (!window.domOnEventWindowOnloadTimeElapsed) {\n" +
    "        window.domOnEventWindowOnloadTimeElapsed = Date.now() + 100;\n" +
    "        window.addEventListener(\"load\", function () {\n" +
    "            setTimeout(function () {\n" +
    "                window.domOnEventWindowOnloadTimeElapsed = (\n" +
    "                    Date.now() -\n" +
    "                    window.domOnEventWindowOnloadTimeElapsed\n" +
    "                );\n" +
    "                console.error(\n" +
    "                    \"domOnEventWindowOnloadTimeElapsed = \" +\n" +
    "                    window.domOnEventWindowOnloadTimeElapsed\n" +
    "                );\n" +
    "            }, 100);\n" +
    "        });\n" +
    "    }\n" +
    "    // limit select-all within <pre tabIndex=\"0\"> elem\n" +
    "    if (!window.domOnEventSelectAllWithinPre) {\n" +
    "        window.domOnEventSelectAllWithinPre = function (evt) {\n" +
    "            let range;\n" +
    "            let selection;\n" +
    "            if (\n" +
    "                (evt.ctrlKey || evt.metaKey) &&\n" +
    "                evt.key === \"a\" &&\n" +
    "                evt.target.closest(\"pre\")\n" +
    "            ) {\n" +
    "                range = document.createRange();\n" +
    "                range.selectNodeContents(evt.target.closest(\"pre\"));\n" +
    "                selection = window.getSelection();\n" +
    "                selection.removeAllRanges();\n" +
    "                selection.addRange(range);\n" +
    "                evt.preventDefault();\n" +
    "            }\n" +
    "        };\n" +
    "        // handle evt\n" +
    "        document.addEventListener(\n" +
    "            \"keydown\",\n" +
    "            window.domOnEventSelectAllWithinPre\n" +
    "        );\n" +
    "    }\n" +
    "}());\n" +
    "</script>\n" +
    "<h1>\n" +
    "<a href=\"{{npm_package_homepage}}\" target=\"_blank\">\n" +
    "    {{npm_package_name}} ({{npm_package_version}})\n" +
    "</a>\n" +
    "</h1>\n" +
    "<h3>{{npm_package_description}}</h3>\n" +
    "<!-- utility2-comment\n" +
    "<a\n" +
    "    class=\"button\" download href=\"assets.app.js\"\n" +
    ">download standalone app</a><br>\n" +
    "<button\n" +
    "    class=\"button\"\n" +
    "    id=\"buttonTestRun1\"\n" +
    ">run browser-tests</button><br>\n" +
    "<div class=\"uiAnimateSlide\" id=\"htmlTestReport1\" style=\"\n" +
    "    border-bottom: 0;\n" +
    "    border-top: 0;\n" +
    "    margin-bottom: 0;\n" +
    "    margin-top: 0;\n" +
    "    max-height: 0;\n" +
    "    padding-bottom: 0;\n" +
    "    padding-top: 0;\n" +
    "\"></div>\n" +
    "utility2-comment -->\n" +
    "\n" +
    "\n" +
    "<!-- custom-html-start -->\n" +
    "<label>stderr and stdout</label>\n" +
    "<textarea\n" +
    "    class=\"onevent-output-reset readonly textarea\"\n" +
    "    id=\"outputStdout1\"\n" +
    "    readonly\n" +
    "></textarea>\n" +
    "<!-- custom-html-end -->\n" +
    "\n" +
    "\n" +
    "<!-- utility2-comment\n" +
    "<script>\n" +
    "window.utility2_state = {\n" +
    "npm_config_mode_backend: {{npm_config_mode_backend jsonStringify}},\n" +
    "npm_package_description: {{npm_package_description jsonStringify}},\n" +
    "npm_package_homepage: {{npm_package_homepage jsonStringify}},\n" +
    "npm_package_name: {{npm_package_name jsonStringify}},\n" +
    "npm_package_nameLib: {{npm_package_nameLib jsonStringify}},\n" +
    "npm_package_version: {{npm_package_version jsonStringify}}\n" +
    "}\n" +
    "</script>\n" +
    "<script src=\"assets.utility2.rollup.js\"></script>\n" +
    "<script>\n" +
    "/* jslint utility2:true */\n" +
    "window.utility2.onReadyIncrement();\n" +
    "window.addEventListener(\"load\", function () {\n" +
    "    \"use strict\";\n" +
    "    let local;\n" +
    "    function onTestRun({\n" +
    "        msg,\n" +
    "        target,\n" +
    "        type\n" +
    "    }) {\n" +
    "        switch ((target && target.id) || type) {\n" +
    "        case \"buttonTestRun1\":\n" +
    "            window.utility2_modeTest = 1;\n" +
    "            local.testRunDefault(window.local);\n" +
    "            return;\n" +
    "        case \"utility2.testRunEnd\":\n" +
    "            document.querySelectorAll(\n" +
    "                \"#buttonTestRun1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"run tests\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        case \"utility2.testRunStart\":\n" +
    "            document.querySelectorAll(\n" +
    "                \".onevent-output-reset\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#buttonTestRun1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"running tests\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                local.uiAnimateSlideDown(elem);\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        case \"utility2.testRunUpdate\":\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                local.uiAnimateSlideDown(elem);\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        }\n" +
    "    }\n" +
    "    local = window.utility2;\n" +
    "    document.querySelectorAll(\n" +
    "        \"#buttonTestRun1\"\n" +
    "    ).forEach(function (elem) {\n" +
    "        elem.addEventListener(\"click\", onTestRun);\n" +
    "    });\n" +
    "    local.eventListenerAdd(\"utility2.testRunEnd\", {}, onTestRun);\n" +
    "    local.eventListenerAdd(\"utility2.testRunUpdate\", {}, onTestRun);\n" +
    "    local.eventListenerAdd(\"utility2.testRunStart\", {}, onTestRun);\n" +
    "    local.onReadyDecrement();\n" +
    "});\n" +
    "</script>\n" +
    "utility2-comment -->\n" +
    "<script src=\"assets.{{npm_package_nameLib}}.js\"></script>\n" +
    "<script src=\"assets.example.js\"></script>\n" +
    "<script src=\"assets.test.js\"></script>\n" +
    "<div style=\"text-align: center;\">\n" +
    "    [\n" +
    "    this app was created with\n" +
    "    <a\n" +
    "        href=\"https://github.com/kaizhu256/node-utility2\"\n" +
    "        target=\"_blank\"\n" +
    "    >utility2</a>\n" +
    "    ]\n" +
    "</div>\n" +
    "</body>\n" +
    "</html>\n"
);
/* validateLineSortedReset */
local.assetsDict["/assets.example.html"] = "";
local.assetsDict["/assets.example.template.js"] = (
    "/*\n" +
    "example.js\n" +
    "\n" +
    "this script will run web-demo of my-app\n" +
    "\n" +
    "instruction\n" +
    "    1. save this script as example.js\n" +
    "    2. run shell-cmd:\n" +
    "        $ npm install my-app && \\\n" +
    "            PORT=8081 node example.js\n" +
    "    3. open browser to http://127.0.0.1:8081 and play with web-demo\n" +
    "    4. edit this script to suit your needs\n" +
    "*/\n" +
    "\n" +
    "\n" +
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = (\n" +
    "    globalThis.utility2_rollup ||\n" +
    "    globalThis.utility2_my_app ||\n" +
    "    require(\"my-app\")\n" +
    ");\n" +
    "// init exports\n" +
    "globalThis.local = local;\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run browser js\u002denv code - init-test\n" +
    "(function () {\n" +
    "if (local.isEnvNode) {\n" +
    "    return;\n" +
    "}\n" +
    "// log stderr and stdout to #outputStdout1\n" +
    "[\"error\", \"log\"].forEach(function (key) {\n" +
    "    let elem;\n" +
    "    let fnc;\n" +
    "    elem = document.querySelector(\"#outputStdout1\");\n" +
    "    if (!elem) {\n" +
    "        return;\n" +
    "    }\n" +
    "    fnc = console[key];\n" +
    "    console[key] = function (...argList) {\n" +
    "        fnc(...argList);\n" +
    "        // append text to #outputStdout1\n" +
    "        elem.textContent += argList.map(function (arg) {\n" +
    "            return (\n" +
    "                typeof arg === \"string\"\n" +
    "                ? arg\n" +
    "                : JSON.stringify(arg, undefined, 4)\n" +
    "            );\n" +
    "        }).join(\" \").replace((\n" +
    "            /\\u001b\\[\\d+?m/g\n" +
    "        ), \"\") + \"\\n\";\n" +
    "        // scroll textarea to bottom\n" +
    "        elem.scrollTop = elem.scrollHeight;\n" +
    "    };\n" +
    "});\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run node js\u002denv code - init-test\n" +
    "(function () {\n" +
    "if (!local.isEnvNode) {\n" +
    "    return;\n" +
    "}\n" +
    "// init exports\n" +
    "module.exports = local;\n" +
    "// init assetsDict\n" +
    "local.assetsDict = local.assetsDict || {};\n" +
    "local.assetsDict[\"/assets.my_app.js\"] = (\n" +
    "    local.assetsDict[\"/assets.my_app.js\"] ||\n" +
    "    require(\"fs\").readFileSync(\n" +
    "        require(\"path\").resolve(local.__dirname + " +
    "\"/lib.my_app.js\"),\n" +
    "        \"utf8\"\n" +
    "    ).replace((\n" +
    "        /^#!\\//\n" +
    "    ), \"// \")\n" +
    ");\n" +
    "/* validateLineSortedReset */\n" +
    "/* jslint ignore:start */\n" +
    "local.assetsDict[\"/\"] = `" +
    local.assetsDict["/assets.utility2.template.html"].replace((
        /[$\\`]/g
    ), "\\$&") +
    "`;\n" +
    "/* jslint ignore:end */\n" +
    "local.assetsDict[\"/assets.example.html\"] = local.assetsDict[\"/\"];\n" +
    "// init cli\n" +
    "if (module !== require.main || globalThis.utility2_rollup) {\n" +
    "    return;\n" +
    "}\n" +
    "local.assetsDict[\"/assets.example.js\"] = (\n" +
    "    local.assetsDict[\"/assets.example.js\"] ||\n" +
    "    require(\"fs\").readFileSync(__filename, \"utf8\")\n" +
    ");\n" +
    "local.assetsDict[\"/favicon.ico\"] = " +
    "local.assetsDict[\"/favicon.ico\"] || \"\";\n" +
    "local.assetsDict[\"/index.html\"] = local.assetsDict[\"/\"];\n" +
    "// if $npm_config_timeout_exit exists,\n" +
    "// then exit this process after $npm_config_timeout_exit ms\n" +
    "if (process.env.npm_config_timeout_exit) {\n" +
    "    setTimeout(\n" +
    "        process.exit.bind(undefined, 15),\n" +
    "        process.env.npm_config_timeout_exit | 0\n" +
    "    ).unref();\n" +
    "}\n" +
    "// start server\n" +
    "if (globalThis.utility2_serverHttp1) {\n" +
    "    return;\n" +
    "}\n" +
    "process.env.PORT = process.env.PORT || \"8081\";\n" +
    "console.error(\"http-server listening on port \" + process.env.PORT);\n" +
    "require(\"http\").createServer(function (req, res) {\n" +
    "    let data;\n" +
    "    data = local.assetsDict[require(\"url\").parse(req.url).pathname];\n" +
    "    if (data !== undefined) {\n" +
    "        res.end(data);\n" +
    "        return;\n" +
    "    }\n" +
    "    res.statusCode = 404;\n" +
    "    res.end();\n" +
    "}).listen(process.env.PORT);\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.my_app.template.js"] = (
    "#!/usr/bin/env node\n" +
    "/*\n" +
    " * lib.my_app.js ({{npm_package_version}})\n" +
    " * https://github.com/kaizhu256/node-my-app\n" +
    " * {{npm_package_description}}\n" +
    " *\n" +
    " */\n" +
    "\n" +
    "\n" +
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = (\n" +
    "    globalThis.utility2_rollup ||\n" +
    "    // globalThis.utility2_rollup_old ||\n" +
    "    // require(\"./assets.utility2.rollup.js\") ||\n" +
    "    globalThis.globalLocal\n" +
    ");\n" +
    "// init exports\n" +
    "if (local.isEnvNode) {\n" +
    "    module.exports = local;\n" +
    "    module.exports.__dirname = __dirname;\n" +
    "} else {\n" +
    "    globalThis.utility2_my_app = local;\n" +
    "}\n" +
    "// init lib main\n" +
    "local.my_app = local;\n" +
    "\n" +
    "\n" +
    "/* validateLineSortedReset */\n" +
    "return;\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.readme.template.md"] = String(
    "# my-app\n" +
    "the greatest app in the world!\n" +
    "\n" +
    "# live web demo\n" +
    "- [{{app.io}}/build..beta..github.com/app]" +
    "({{app.io}}/build..beta..github.com/app)\n" +
    "\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})]" +
    "({{app.io}}/build..beta..github.com/app)\n" +
    "\n" +
    "\n" +
    "[![github.com ci-status]" +
    "(https://github.com/kaizhu256/node-my-app/workflows/" +
    "Node.js%20CI/badge.svg)]" +
    "(https://github.com/kaizhu256/node-my-app/actions) " +
    "[![coverage]" +
    "({{app.io}}/build/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build/coverage/index.html)\n" +
    "\n" +
    "[![NPM]" +
    "(https://nodei.co/npm/my-app.png?downloads=true)]" +
    "(https://www.npmjs.com/package/my-app)\n" +
    "\n" +
    "[![commit status]" +
    "({{app.io}}/build/commit.badge.svg)]" +
    "(https://github.com/kaizhu256/node-my-app/actions)\n" +
    "\n" +
    "| git-branch : | " +
    "[master]" +
    "({{app.com}}/tree/master) | " +
    "[beta]" +
    "({{app.com}}/tree/beta) | " +
    "[alpha]" +
    "({{app.com}}/tree/alpha)|\n" +
    "|--:|:--|:--|:--|\n" +
    "| test-server-github : | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..master..github.com/app) | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..beta..github.com/app) | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..alpha..github.com/app)|\n" +
    "| test-server-heroku : | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-master.herokuapp.com) | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-beta.herokuapp.com) | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-alpha.herokuapp.com)|\n" +
    "| test-report : | " +
    "[![test-report]" +
    "({{app.io}}/build..master..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..master..github.com/test-report.html) | " +
    "[![test-report]" +
    "({{app.io}}/build..beta..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..beta..github.com/test-report.html) | " +
    "[![test-report]" +
    "({{app.io}}/build..alpha..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..alpha..github.com/test-report.html)|\n" +
    "| coverage : | " +
    "[![coverage]" +
    "({{app.io}}/build..master..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..master..github.com/coverage/index.html) | " +
    "[![coverage]" +
    "({{app.io}}/build..beta..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..beta..github.com/coverage/index.html) | " +
    "[![coverage]" +
    "({{app.io}}/build..alpha..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..alpha..github.com/coverage/index.html)|\n" +
    "| build-artifacts : | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..master..github.com) | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..beta..github.com) | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..alpha..github.com)|\n" +
    "\n" +
    "[![npmPackageListing]" +
    "({{app.io}}/build/screenshot.npmPackageListing.svg)]" +
    "({{app.com}})\n" +
    "\n" +
    "![npmPackageDependencyTree]" +
    "({{app.io}}/build/screenshot.npmPackageDependencyTree.svg)\n" +
    "\n" +
    "\n" +
    "# table of contents\n" +
    "\n" +
    "\n" +
    "# cdn download\n" +
    "- [{{app.io}}/build..beta..github.com/app/assets.my_app.js]" +
    "({{app.io}}/build..beta..github.com/app/assets.my_app.js)\n" +
    "\n" +
    "\n" +
    "# documentation\n" +
    "#### api doc\n" +
    "- [{{app.io}}/build..beta..github.com/apidoc.html]" +
    "({{app.io}}/build..beta..github.com/apidoc.html)\n" +
    "\n" +
    "[![apidoc]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)]" +
    "({{app.io}}/build..beta..github.com/apidoc.html)\n" +
    "\n" +
    "#### cli help\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.npmPackageCliHelp.svg)\n" +
    "\n" +
    "#### changelog 0.0.1\n" +
    "- update build\n" +
    "- none\n" +
    "\n" +
    "#### todo\n" +
    "- none\n" +
    "\n" +
    "\n" +
    "# quickstart standalone app\n" +
    "#### to run this example, follow instruction in script below\n" +
    "- [assets.app.js]" +
    "({{app.io}}/build..beta..github.com/app/assets.app.js)\n" +
    "```shell\n" +
    "# example.sh\n" +
    "\n" +
    "# this shell script will download and run web-demo of my-app " +
    "as standalone app\n" +
    "\n" +
    "# 1. download standalone app\n" +
    "curl -O {{app.io}}/build..beta..github.com/app/assets.app.js\n" +
    "# 2. run standalone app\n" +
    "PORT=8081 node ./assets.app.js\n" +
    "# 3. open browser to http://127.0.0.1:8081 and play with web-demo\n" +
    "# 4. edit file assets.app.js to suit your needs\n" +
    "```\n" +
    "\n" +
    "#### output from browser\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### output from shell\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.svg)\n" +
    "\n" +
    "\n" +
    "# quickstart example.js\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### to run this example, follow instruction in script below\n" +
    "- [example.js]" +
    "({{app.io}}/build..beta..github.com/example.js)\n" +
    "```javascript\n" +
    local.assetsDict["/assets.example.template.js"] +
    "```\n" +
    "\n" +
    "#### output from browser\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### output from shell\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.svg)\n" +
    "\n" +
    "\n" +
    "# extra screenshots\n" +
    "1. [{{app.io}}/build/{{screenshot}}apidoc.html.png]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/{{screenshot}}coverage.lib.html.png]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/{{screenshot}}test-report.html.png]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployGithub.{{app.png}}]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployGithubTest.{{app.png}}]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployHeroku.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.npmTest.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\n" +
    "\n" +
    "\n" +
    "# package.json\n" +
    "```json\n" +
    "{\n" +
    "    \"!!jslint_utility2\": true,\n" +
    "    \"author\": \"kai zhu <kaizhu256@gmail.com>\",\n" +
    "    \"description\": \"the greatest app in the world!\",\n" +
    "    \"devDependencies\": {\n" +
    "        \"utility2\": \"kaizhu256/node-utility2#alpha\"\n" +
    "    },\n" +
    "    \"engines\": {\n" +
    "        \"node\": \">=12.0\"\n" +
    "    },\n" +
    "    \"fileCount\": 0,\n" +
    "    \"homepage\": \"{{app.com}}\",\n" +
    "    \"keywords\": [],\n" +
    "    \"license\": \"MIT\",\n" +
    "    \"main\": \"lib.my_app.js\",\n" +
    "    \"name\": \"my-app\",\n" +
    "    \"nameAliasPublish\": \"\",\n" +
    "    \"repository\": {\n" +
    "        \"type\": \"git\",\n" +
    "        \"url\": \"{{app.com}}.git\"\n" +
    "    },\n" +
    "    \"scripts\": {\n" +
    "        \"build-ci\": \"sh npm_scripts.sh\",\n" +
    "        \"env\": \"env\",\n" +
    "        \"eval\": \"sh npm_scripts.sh\",\n" +
    "        \"heroku-postbuild\": \"sh npm_scripts.sh\",\n" +
    "        \"postinstall\": \"sh npm_scripts.sh\",\n" +
    "        \"start\": \"sh npm_scripts.sh\",\n" +
    "        \"test\": \"sh npm_scripts.sh\",\n" +
    "        \"utility2\": \"sh npm_scripts.sh\"\n" +
    "    },\n" +
    "    \"version\": \"0.0.1\"\n" +
    "}\n" +
    "```\n" +
    "\n" +
    "\n" +
    "# changelog of last 50 commits\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.gitLog.svg)]" +
    "({{app.com}}/commits)\n" +
    "\n" +
    "\n" +
    "# internal build script\n" +
    "- build_ci.sh\n" +
    "```shell\n" +
    "# build_ci.sh\n" +
    "\n" +
    "# this shell script will run build-ci for this package\n" +
    "\n" +
    "shCiAfter () {(set -e\n" +
    "    # shDeployCustom\n" +
    "    shDeployGithub\n" +
    "    # shDeployHeroku\n" +
    "    shReadmeEval example.sh\n" +
    ")}\n" +
    "\n" +
    "shCiBefore () {(set -e\n" +
    "    # shNpmTestPublished\n" +
    "    shReadmeEval example.js\n" +
    ")}\n" +
    "\n" +
    "# run shCiMain\n" +
    "eval \"$(utility2 source)\"\n" +
    "shCiMain\n" +
    "```\n" +
    "\n" +
    "\n" +
    "# misc\n" +
    "- this package was created with [utility2]" +
    "(https://github.com/kaizhu256/node-utility2)\n"
).replace((
    /\{\{app\.com\}\}/g
), "https://github.com/kaizhu256/node-my-app").replace((
    /\{\{app\.io\}\}/g
), "https://kaizhu256.github.io/node-my-app").replace((
    /\{\{app.png\}\}/g
), "browser.%252Fnode-my-app%252Fbuild%252Fapp.png").replace((
    /\{\{screenshot\}\}/g
), "screenshot.ci.browser.%252F.tmp%252Fbuild%252F");
local.assetsDict["/assets.test.template.js"] = (
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = globalThis.utility2 || require(\"utility2\");\n" +
    "local = local.requireReadme();\n" +
    "globalThis.local = local;\n" +
    "// init test\n" +
    "local.testRunDefault(local);\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "// run shared js\u002denv code - function\n" +
    "(function () {\n" +
    "return;\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.utility2.rollup.content.js"] = (
    "(function (local) {\n" +
    "    \"use strict\";\n" +
    "/* jslint ignore:start */\n" +
    "/* utility2.rollup.js content */\n" +
    "/* jslint ignore:end */\n" +
    "    return local;\n" +
    "}(globalThis.utility2_rollup));\n"
);
local.assetsDict["/assets.utility2.rollup.end.js"] = (
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    globalThis.utility2_rollup_old = globalThis.utility2_rollup;\n" +
    "    globalThis.utility2_rollup = null;\n" +
    "}());\n" +
    "/* utility2.rollup.js end */\n"
);
local.assetsDict["/assets.utility2.rollup.start.js"] = (
    "/* utility2.rollup.js begin */\n" +
    "/* istanbul ignore all */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    // init utility2_rollup\n" +
    "    globalThis.utility2_rollup = (\n" +
    "        globalThis.utility2_rollup_old\n" +
    "        || globalThis.globalLocal\n" +
    "    );\n" +
    "    globalThis.utility2_rollup.local = globalThis.utility2_rollup;\n" +
    "    globalThis.utility2_rollup_old = null;\n" +
    "}());\n"
);
local.assetsDict["/favicon.ico"] = "";


/* validateLineSortedReset */
// run shared js-env code - function
let localEventListenerDict;
let localEventListenerId;
let localOnReadyCnt;
localEventListenerDict = {};
localEventListenerId = 0;
localOnReadyCnt = 0;

local._testCase_buildApidoc_default = function (opt, onError) {
/*
 * this function will test buildApidoc's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    function require2(file) {
    /*
     * this function will require <file> in sandbox-env
     */
        let exports;
        let mockDict;
        let mockList;
        mockList = [
            [
                globalThis, {
                    setImmediate: noop,
                    setInterval: noop,
                    setTimeout: noop
                }
            ]
        ];
        // disable io and side-effect
        [
            process,
            process.stdin,
            process.stdout,
            require("child_process"),
            require("cluster"),
            require("crypto"),
            require("dgram"),
            require("dns"),
            require("domain"),
            require("events").prototype,
            require("http"),
            require("https"),
            require("net"),
            require("os"),
            require("readline"),
            require("repl"),
            require("stream").prototype,
            require("timers"),
            require("tls"),
            require("tty"),
            require("util"),
            require("v8"),
            require("vm"),
            {
                // coverage-hack
                "__zjqx1234__": noop
            }
        ].forEach(function (dict) {
            mockDict = {};
            Object.keys(dict).forEach(function (key) {
                if (typeof dict[key] === "function" && (
                    // coverage-hack
                    key === "__zjqx1234__" ||
                    npm_config_mode_test_case === "testCase_buildApidoc_default"
                )) {
                    mockDict[key] = noop;
                }
            });
            mockList.push([
                dict, mockDict
            ]);
        });
        local.testMock(mockList, function (onError) {
            try {
                exports = require(file);
            } catch (errCaught) {
                console.error(errCaught);
            }
            onError();
        }, onErrorThrow);
        return exports;
    }
    // coverage-hack
    require2();
    // save apidoc.html
    local.fsWriteFileWithMkdirpSync(".tmp/build/apidoc.html", apidocCreate(
        Object.assign({
            blacklistDict: local,
            modeNoop: (
                npm_config_mode_test_case !== "testCase_buildApidoc_default"
            ),
            require: require2
        }, opt)
    ));
    onError();
};

local._testCase_buildApp_default = function (opt, onError) {
/*
 * this function will test buildApp's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    local.buildApp(opt, onError);
};

local._testCase_webpage_default = async function (opt, onError) {
/*
 * this function will test webpage's default handling-behavior
 */
    local.domQuerySelectorAllTagName("html");
    local.domStyleValidate();
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    await local.browserTest({
        url: (
            "http://127.0.0.1:" + PORT +
            "/?npm_config_mode_test=1&npm_config_timeout=" +
            npm_config_timeout +
            "&npm_config_mode_test_case=" + npm_config_mode_test_case.replace((
                /\b_?testCase_webpage_default\b/
            ), "")
        )
    });
    onError(undefined, opt);
};

local.browserTest = async function ({
    modeSilent,
    modeWindowSize,
    url
}) {
/*
 * this function will spawn google-chrome-process to test <url>
 */
    let chromeClient;
    let chromeFrameId;
    let fileScreenshot;
    let isDone;
    let promiseScreenshot;
    let testErr;
    let testId;
    let testName;
    let testReport;
    let {
        chromeDevtoolsClientCreate,
        testReportMerge
    } = local;
    // node - init
    testId = Math.random().toString(16);
    testName = MODE_CI + ".browser." + encodeURIComponent(
        require("url").parse(url).pathname.replace(
            "/build.." + CI_BRANCH + ".." + CI_HOST,
            "/build"
        )
    );
    fileScreenshot = (
        UTILITY2_DIR_BUILD + "/screenshot." + testName + ".png"
    );
    chromeClient = await chromeDevtoolsClientCreate({
        modeSilent,
        modeWindowSize,
        timeout: npm_config_timeout
    });
    // init page
    chromeClient.rpc("Page.enable");
    chromeClient.rpc("Page.setLifecycleEventsEnabled", {
        enabled: true
    });
    chromeClient.rpc("Performance.enable");
    // load url
    chromeClient.rpc("Page.navigate", {
        url
    });
    chromeFrameId = (
        await chromeClient.rpc("Page.getFrameTree")
    ).frameTree.frame.id;
    await new Promise(function (resolve) {
        chromeClient.on("Page.lifecycleEvent", function onLoad({
            frameId,
            name
        }) {
            if (frameId === chromeFrameId && name === "load") {
                chromeClient.removeListener("Page.lifecycleEvent", onLoad);
                resolve();
            }
        });
    });
    console.error("chrome-devtools - loaded - page " + url);
    // screenshot
    promiseScreenshot = new Promise(async function (resolve) {
        let data;
        await new Promise(function (resolve) {
            setTimeout(resolve, 100);
        });
        data = await chromeClient.rpc("Page.captureScreenshot", {
            format: "png"
        });
        await require("fs").promises.writeFile(
            fileScreenshot,
            Buffer.from(data.data, "base64")
        );
        console.error("chrome-devtools - wrote - screenshot " + fileScreenshot);
        resolve();
    });
    chromeClient.evaluate(
        // coverage-hack
        "console.timeStamp();\n" +
        "window.utility2_testId=\"" + testId + "\";\n" +
        "if(!window.utility2_modeTest){\n" +
        "console.timeStamp(window.utility2_testId);\n" +
        "}\n"
    );
    testReport = await new Promise(function (resolve) {
        chromeClient.on("Performance.metrics", function ({
            title
        }) {
            if (isDone || title !== testId) {
                return;
            }
            isDone = true;
            resolve(chromeClient.evaluate(
                "JSON.stringify(\n" +
                "window.utility2_testReport\n" +
                "||{testPlatformList:[{}]}\n" +
                ");\n"
            ));
        });
    });
    testReport = JSON.parse(testReport);
    // init testErr
    testErr = testReport.testPlatformList[0].testsFailed && new Error(
        testReport.testPlatformList[0].testsFailed
    );
    // merge browser-screenshot
    testReport.testPlatformList[0].screenshot = fileScreenshot.replace((
        /.*\//
    ), "");
    // merge browser-coverage
    coverageMerge(globalThis.__coverage__, testReport.coverage);
    // merge browser-test-report
    testReportMerge(globalThis.utility2_testReport, testReport);
    // save test-report.json
    await require("fs").promises.writeFile(
        require("path").resolve(UTILITY2_DIR_BUILD + "/test-report.json"),
        JSON.stringify(globalThis.utility2_testReport)
    );
    console.error(
        "\nbrowserTest - merged test-report " +
        UTILITY2_DIR_BUILD + "/test-report.json" + "\n"
    );
    noop(await promiseScreenshot);
    // cleanup chromeClient
    chromeClient.destroy();
    onErrorThrow(testErr);
};

local.buildApp = function ({
    customizeAssetsList = [],
    customizeReadmeList = []
}, onError) {
/*
 * this function will build app
 */
    let assert;
    let fileDict;
    let packageJson;
    let packageNameLib;
    let port;
    let promiseList;
    let src;
    let tgt;
    assert = require("assert");
    function tgtReplaceConditional(conditional, replaceList) {
    /*
     * this function will conditionally replace <tgt> with replacements in
     * <replaceList>
     */
        replaceList.forEach(function ({
            aa,
            bb,
            merge
        }) {
            let isMatch;
            if (!conditional) {
                aa = aa || merge;
                console.error(
                    "buildApp - replace-skipped - " +
                    JSON.stringify((aa && aa.source) || aa)
                );
                return;
            }
            if (aa) {
                if (!tgt.match(aa)) {
                    console.error(
                        "buildApp - replace-unmatched - " +
                        JSON.stringify((aa && aa.source) || aa)
                    );
                    return;
                }
                tgt = tgt.replace(aa, bb);
                return;
            }
            src.replace(merge, function (match2) {
                tgt.replace(merge, function (match1) {
                    isMatch = true;
                    // disable $-escape in replacement-string
                    tgt = tgt.replace(match1, function () {
                        return match2;
                    });
                    return "";
                });
                return "";
            });
            if (!isMatch) {
                console.error(
                    "buildApp - replace-unmatched - " +
                    JSON.stringify(merge.source)
                );
            }
        });
    }
    function writeFileLog(file) {
    /*
     * this function will notify <file> written
     */
        console.error("buildApp - wrote - " + require("path").resolve(file));
    }
    function writeFile(file, data, resolve) {
    /*
     * this function will write <data> to <file> with notification
     */
        require("fs").writeFile(file, data, function (err) {
            onErrorThrow(err);
            writeFileLog(file);
            resolve();
        });
    }
    async function buildAppAssets(resolve) {
        // fetch assets
        await Promise.all([
            {
                url: "/LICENSE"
            }, {
                file: "/assets." + packageNameLib + ".html",
                url: "/index.html"
            }, {
                url: "/assets." + packageNameLib + ".css"
            }, {
                url: "/assets." + packageNameLib + ".js"
            }, {
                url: "/assets.app.js"
            }, {
                url: "/assets.example.html"
            }, {
                url: "/assets.example.js"
            }, {
                url: "/assets.test.js"
            }, {
                url: "/assets.utility2.html"
            }, {
                url: "/assets.utility2.lib.jslint.js"
            }, {
                url: "/assets.utility2.rollup.js"
            }, {
                url: "/index.html"
            }
        ].concat(customizeAssetsList).map(function ({
            file,
            url
        }) {
            return new Promise(function (resolve) {
                require("http").get((
                    "http://127.0.0.1:" + PORT + url
                ), function (res) {
                    let bufList;
                    assert.ok(res.statusCode === 200, url);
                    bufList = [];
                    res.on("data", function (chunk) {
                        bufList.push(chunk);
                    }).on("end", function () {
                        writeFile(
                            ".tmp/build/app/" + (file || url),
                            Buffer.concat(bufList),
                            resolve
                        );
                    });
                });
            });
        }));
        // jslint assets
        require("child_process").spawn("node", [
            "assets.utility2.lib.jslint.js", "dir", ".", "--conditional"
        ], {
            cwd: ".tmp/build/app",
            stdio: [
                "ignore", 1, 2
            ]
        }).on("exit", resolve);
    }
    async function buildAppStandalone(resolve) {
        let fileList;
        // write native-module
        fileList = await require("fs").promises.readdir(".");
        await Promise.all(fileList.map(function (file) {
            return new Promise(function (resolve) {
                if (require("path").extname(file) !== ".node") {
                    resolve();
                    return;
                }
                require("fs").copyFile(file, (
                    ".tmp/build/app.standalone/" + file
                ), function (err) {
                    onErrorThrow(err);
                    resolve();
                });
            });
        }));
        // write assets.app.js
        writeFile((
            ".tmp/build/app.standalone/assets.app.js"
        ), local.assetsDict["/assets.app.js"], function () {
            let child;
            // test-file assets.app.js
            child = require("child_process").spawn("node", [
                "assets.app.js"
            ], {
                cwd: ".tmp/build/app.standalone",
                env: {
                    HOME,
                    PATH,
                    PORT: port
                },
                stdio: [
                    "ignore", 1, 2
                ]
            }).on("exit", function (exitCode, signal) {
                assert.ok(!exitCode && signal === "SIGTERM", JSON.stringify({
                    exitCode,
                    signal
                }));
                resolve();
            });
            setTimeout(child.kill.bind(child, "SIGTERM"), 4000);
        });
    }
    function buildLib(resolve) {
        src = fileDict["lib." + packageNameLib + ".js"];
        // render lib.xxx.js
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.my_app.template.js"]
        );
        tgtReplaceConditional(true, [
            {
                // customize top-level comment-description
                merge: (
                    /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
                )
            }, {
                // customize code after /* validateLineSortedReset */
                merge: (
                    /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
                )
            }
        ]);
        // customize assets.utility2.rollup.js
        tgtReplaceConditional(fileDict["assets.utility2.rollup.js"], [
            {
                aa: "    // || globalThis.utility2_rollup_old",
                bb: "    || globalThis.utility2_rollup_old"
            }, {
                aa: "    // || require(\"./assets.utility2.rollup.js\")",
                bb: "    || require(\"./assets.utility2.rollup.js\")"
            }
        ]);
        // write lib.xxx.js
        writeFile("lib." + packageNameLib + ".js", tgt, resolve);
    }
    function buildReadme(resolve) {
    /*
     * this function will build readme with template assets.readme.template.md
     */
        let packageJsonRgx;
        let toc;
        // reset toc
        src = fileDict["README.md"].replace((
            /\n#\u0020table\u0020of\u0020contents$[\S\s]*?\n\n\n/m
        ), "\n# table of contents\n\n\n");
        packageJsonRgx = (
            /\n#\u0020package.json\n```json\n([\S\s]*?)\n```\n/
        );
        // render README.md
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.readme.template.md"]
        );
        // init packageJson
        src.replace(packageJsonRgx, function (match0, match1) {
            // remove null from package.json
            packageJson = JSON.parse(match1.replace((
                /\u0020{4}".*?":\u0020null,?$/gm
            ), ""));
            packageJson.description = src.split("\n")[1];
            local.objectAssignDefault(packageJson, {
                nameLib: JSON.parse(fileDict["package.json"]).nameLib
            });
            packageJson = local.objectAssignDefault(packageJson, {
                nameLib: packageJson.name.replace((
                    /\W/g
                ), "_"),
                nameOriginal: packageJson.name
            });
            packageJson = local.objectAssignDefault(
                packageJson,
                JSON.parse(local.templateRenderMyApp(packageJsonRgx.exec(
                    local.assetsDict["/assets.readme.template.md"]
                )[1])),
                2
            );
            // avoid npm-installing that
            delete packageJson.devDependencies[packageJson.name];
            // reset scripts
            packageJson.scripts = {
                "build-ci": "sh npm_scripts.sh",
                env: "env",
                eval: "sh npm_scripts.sh",
                "heroku-postbuild": "sh npm_scripts.sh",
                postinstall: "sh npm_scripts.sh",
                start: "sh npm_scripts.sh",
                test: "sh npm_scripts.sh",
                utility2: "sh npm_scripts.sh"
            };
            // write package.json
            require("fs").writeFileSync(
                "package.json",
                JSON.stringify(local.objectDeepCopyWithKeysSorted(
                    packageJson
                ), undefined, 4) + "\n"
            );
            writeFileLog("package.json");
            // re-render README.md
            tgt = local.templateRenderMyApp(
                local.assetsDict["/assets.readme.template.md"]
            ).replace(packageJsonRgx, match0.replace(
                match1,
                JSON.stringify(local.objectDeepCopyWithKeysSorted(
                    packageJson
                ), undefined, 4)
            ));
            return "";
        });
        tgtReplaceConditional(true, [
            // customize name and description
            {
                merge: (
                    /.*?\n.*?\n/
                )
            // customize cdn-download
            }, {
                merge: (
                    /\n#\u0020cdn\u0020download\n[\S\s]*?\n\n\n/
                )
            // customize live-web-demo
            }, {
                merge: (
                    /\n#\u0020live\u0020web\u0020demo\n[\S\s]*?\n\n\n/
                )
            // customize changelog
            }, {
                merge: (
                    /\n####\u0020changelog\u0020[\S\s]*?\n\n\n/
                )
            // customize example.js - shared js\u002denv code - init-before
            }, {
                merge: (
                    /\nglobalThis\.local\u0020=\u0020local;\n[^`]*?\n\/\*\u0020istanbul\u0020ignore\u0020next\u0020\*\/\n\/\/\u0020run\u0020browser\u0020js\u002denv\u0020code\u0020-\u0020init-test\n/
                )
            // customize example.js - html-body
            }, {
                merge: (
                    /\n<!--\u0020custom-html-start\u0020-->\n[\S\s]*?\n<!--\u0020custom-html-end\u0020-->\n/
                )
            // customize build_ci - shCiAfter
            }, {
                merge: (
                    /\nshCiAfter\u0020\(\)\u0020\{\(set\u0020-e\n[\S\s]*?\n\)\}\n/
                )
            // customize build_ci - shCiBefore
            }, {
                merge: (
                    /\nshCiBefore\u0020\(\)\u0020\{\(set\u0020-e\n[\S\s]*?\n\)\}\n/
                )
            }
        ]);
        // customize private-repository
        tgtReplaceConditional(packageJson.private, [
            {
                aa: (
                    /\n\[!\[NPM\]\(https:\/\/nodei.co\/npm\/.*?\n/
                ),
                bb: ""
            }, {
                aa: "$ npm install ",
                bb: (
                    "$ git clone \\\n" +
                    packageJson.repository.url.replace(
                        "git+https://github.com/",
                        "git@github.com:"
                    ) + " \\\n--single-branch -b beta node_modules/"
                )
            }
        ]);
        // customize version
        [
            src, tgt
        ] = [
            src, tgt
        ].map(function (elem) {
            return elem.replace((
                /\n(####\u0020changelog\u0020|-\u0020npm\u0020publish\u0020)\d+?\.\d+?\.\d+?.*?\n/g
            ), "\n$1" + packageJson.version + "\n");
        });
        // customize example.js
        tgtReplaceConditional(local.assetsDict[
            "/index.html"
        ].indexOf("<script src=\"assets.example.js\"></script>") < 0, [
            {
                aa: (
                    /\nif\u0020\(local.isEnvNode\)\u0020\{\n[\S\s]*?\n\}\(\)\);\n/g
                ),
                bb: "\nif (local.isEnvNode) {\n    return;\n}\n}());\n"
            }
        ]);
        // customize comment
        src.replace((
            /^(\u0020*?)(?:#\!\!\u0020|#\/\/\u0020|\/\/\!\!\u0020|<!--\u0020)(.*?)(?:\u0020-->)?$/gm
        ), function (match0, match1, match2) {
            tgt = tgt.replace(
                "\n" + match1 + match2 + "\n",
                "\n" + match0 + "\n"
            );
        });
        // customize - user-defined
        tgtReplaceConditional(true, customizeReadmeList);
        // customize index.html
        tgtReplaceConditional(local.assetsDict[
            "/index.html"
        ].indexOf("\"assets.utility2.template.html\"") < 0, [
            {
                aa: (
                    /\n\/\*\u0020jslint\u0020ignore:start\u0020\*\/\nlocal.assetsDict\["\/index.html"\]\u0020=\u0020'\\\n[\S\s]*?\n\/\*\u0020jslint\u0020ignore:end\u0020\*\/\n/
                ),
                bb: "\n"
            }
        ]);
        // customize shDeployCustom
        tgtReplaceConditional(src.indexOf("    shDeployCustom\n") >= 0, [
            {
                // customize example.sh
                merge: (
                    /\n####\u0020changelog\u0020[\S\s]*?\n#\u0020quickstart\u0020example.js\n/
                )
            }, {
                // customize screenshot
                merge: (
                    /\n#\u0020quickstart\u0020[\S\s]*?\n#\u0020extra\u0020screenshots\n/
                )
            }, {
                // customize screenshot
                aa: (
                    /^1\.\u0020.*?screenshot\.(?:npmTest|readmeEvalExampleJs|readmeEvalExampleSh).*?\.png[\S\s]*?\n\n/gm
                ),
                bb: ""
            }
        ]);
        // customize shNpmTestPublished
        tgt = tgt.replace(
            "$ npm install " + GITHUB_FULLNAME + "#alpha",
            "$ npm install " + packageJson.name
        );
        tgtReplaceConditional(src.indexOf("    shNpmTestPublished\n") < 0, [
            {
                aa: "$ npm install " + packageJson.name,
                bb: "$ npm install " + GITHUB_FULLNAME + "#alpha"
            }, {
                aa: (
                    /\n.*?\bhttps:\/\/www.npmjs.com\/package\/.*?\n/
                ),
                bb: ""
            }, {
                aa: (
                    /\n.*?npmPackageDependencyTree.*?\n/
                ),
                bb: ""
            }
        ]);
        // customize shCiAfter and shCiBefore
        [
            [
                "shDeployGithub", (
                    /.*?\/screenshot\.deployGithub.*?\n/g
                )
            ], [
                "shDeployHeroku", (
                    /.*?\/screenshot\.deployHeroku.*?\n/g
                )
            ], [
                "shReadmeEval example.js", (
                    /.*?\/screenshot\.readmeEvalExampleJs.*?\n/g
                )
            ], [
                "shReadmeEval example.sh", (
                    /.*?\/screenshot\.readmeEvalExampleSh.*?\n/g
                )
            ], [
                // coverage-hack
                "__zjqx1234__" + Math.random(), "__zjqx1234__" + Math.random()
            ]
        ].forEach(function ([
            conditional, rgxScreenshot
        ]) {
            if (src.indexOf("    " + conditional + "\n") >= 0) {
                return;
            }
            // customize test-server
            tgt = tgt.replace(
                new RegExp(
                    "\\n\\| test-server-" +
                    conditional.replace("shDeploy", "").toLowerCase() +
                    " : \\|.*?\\n"
                ),
                "\n"
            );
            // customize screenshot
            tgt = tgt.replace(rgxScreenshot, "");
        });
        tgt = local.templateRenderMyApp(tgt);
        // customize toc
        toc = "\n# table of contents\n";
        tgt.replace((
            /\n\n\n#\u0020(.*)/g
        ), function (ignore, match1) {
            if (match1 === "table of contents") {
                return;
            }
            toc += "1. [" + match1 + "](#" + match1.toLowerCase().replace((
                /[^\u0020\-0-9A-Z_a-z]/g
            ), "").replace((
                /\u0020/g
            ), "-") + ")\n";
        });
        tgt = tgt.replace("\n# table of contents\n", toc);
        // eslint - no-multiple-empty-lines
        // https://github.com/eslint/eslint/blob/v7.2.0/docs/rules/no-multiple-empty-lines.md
        tgt = tgt.replace((
            /\n{4,}/g
        ), "\n\n\n");
        // write README.md
        writeFile("README.md", tgt, resolve);
    }
    function buildTest(resolve) {
        src = fileDict["test.js"];
        // render test.js
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.test.template.js"]
        );
        // customize shared js\u002denv code - function
        tgtReplaceConditional(true, [
            {
                merge: (
                    /\n\}\(\)\);\n\n\n\/\/\u0020run\u0020shared\u0020js\u002denv\u0020code\u0020-\u0020function\n[\S\s]*?$/
                )
            }
        ]);
        // customize require("utility2")
        Array.from([
            "assets.utility2.rollup.js",
            "lib.utility2.js"
        ]).some(function (file) {
            if (fileDict[file]) {
                tgt = tgt.replace(
                    "require(\"utility2\")",
                    "require(\"./" + file + "\")"
                );
                return true;
            }
        });
        // write test.js
        writeFile("test.js", tgt, resolve);
    }
    // buildInit
    Promise.resolve().then(function () {
        // init packageJson
        packageJson = JSON.parse(
            require("fs").readFileSync("package.json", "utf8")
        );
        // init packageNameLib
        packageNameLib = packageJson.nameLib || packageJson.name;
        fileDict = {};
        promiseList = [];
        // cleanup build-dir
        promiseList.push(new Promise(function (resolve) {
            require("child_process").spawn((
                "for DIR in .tmp/build/app/ .tmp/build/app.standalone/;" +
                "do rm -rf $DIR; mkdir -p $DIR; done"
            ), {
                shell: true,
                stdio: [
                    "ignore", 1, 2
                ]
            }).on("exit", resolve);
        }));
        // init port
        promiseList.push(new Promise(function (resolve) {
            let server;
            function recurse(err) {
                if (server) {
                    server.close();
                }
                if (!err) {
                    resolve();
                    return;
                }
                port = (
                    "0x" + require("crypto").randomBytes(2).toString("hex")
                ) | 0x8000;
                server = require("net").createServer().listen(port);
                server.on("error", recurse).on("listening", recurse);
            }
            recurse(true);
        }));
        // read file
        [
            "README.md",
            "lib." + packageNameLib + ".js",
            "package.json",
            "test.js"
        ].forEach(function (file) {
            promiseList.push(new Promise(function (resolve) {
                require("fs").readFile(file, "utf8", function (err, data) {
                    fileDict[file] = data;
                    resolve(err);
                });
            }));
        });
        // exists file
        [
            "assets.utility2.rollup.js",
            "lib.utility2.js"
        ].forEach(function (file) {
            promiseList.push(new Promise(function (resolve) {
                require("fs").access(file, function (notExists) {
                    fileDict[file] = !notExists;
                    resolve();
                });
            }));
        });
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        promiseList = [];
        promiseList.push(new Promise(buildReadme));
        promiseList.push(new Promise(buildLib));
        promiseList.push(new Promise(buildTest));
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        promiseList = [];
        promiseList.push(new Promise(buildAppAssets));
        promiseList.push(new Promise(buildAppStandalone));
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        onError();
    });
};

local.chromeDevtoolsClientCreate = async function ({
    chromeBin,
    modeCoverageHack,
    modeSilent,
    modeWindowSize = "800x600",
    processPlatform,
    timeout
}) {
/*
 * this function with create chrome-devtools-client from <chromeBin>
 */
    let WS_READ_HEADER;
    let WS_READ_LENGTH16;
    let WS_READ_LENGTH63;
    let WS_READ_PAYLOAD;
    let assert;
    let callbackDict;
    let callbackId;
    let chromeClient;
    let chromeProcess;
    let chromeSessionId;
    let chromeUserDataDir;
    let secWebsocketKey;
    let timerTimeout;
    let websocket;
    let websocketUrl;
    let wsBufList;
    let wsPayloadLength;
    let wsReadState;
    let wsReader;
    if (modeCoverageHack === 1) {
        [
            "darwin", "linux", "win32"
        ].forEach(function (processPlatform) {
            local.chromeDevtoolsClientCreate({
                modeCoverageHack: 2,
                processPlatform
            }).catch(noop);
        });
        return;
    }
    WS_READ_HEADER = 0;
    WS_READ_LENGTH16 = 1;
    WS_READ_LENGTH63 = 2;
    WS_READ_PAYLOAD = 3;
    assert = require("assert");
    callbackDict = {};
    callbackId = 0;
    wsBufList = [];
    wsPayloadLength = 0;
    wsReadState = WS_READ_HEADER;
    function chromeCleanup() {
    /*
     * this function will
     * 1. kill <chromeProcess>
     * 2. rm -rf <chromeUserDataDir>
     * 3. destroy <chromeClient>, <websocket>, <wsReader>
     */
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // 1. kill <chromeProcess>
        try {
            if (processPlatform === "win32") {
                require("child_process").spawnSync("taskkill", [
                    "/pid", chromeProcess.pid, "/T", "/F"
                ], {
                    stdio: "ignore"
                });
            } else {
                // kill child process tree with ".kill(-pid)" cmd.
                process.kill(-chromeProcess.pid, "SIGKILL");
            }
        } catch (ignore) {}
        // 2. rm -rf <chromeUserDataDir>
        if (chromeUserDataDir) {
            require("fs").rmdirSync(chromeUserDataDir, {
                recursive: true
            });
        }
        // 3. destroy <chromeClient>, <websocket>, <wsReader>
        chromeClient.destroy();
        if (websocket) {
            websocket.destroy();
        }
        wsReader.destroy();
    }
    async function chromeEvaluate(expression) {
    /*
     * this function will eval <expression> in chrome-browser
     */
        let {
            exceptionDetails,
            result
        } = await chromeClient.rpc("Runtime.evaluate", {
            awaitPromise: true,
            expression,
            returnByValue: false,
            userGesture: true
        });
        assert.ok(!exceptionDetails, (
            "chrome-devtools - evaluate - " +
            JSON.stringify(exceptionDetails)
        ));
        return result.value;
    }
    function chromeOnData(payload) {
    /*
     * this function will handle callback for <payload>
     * received from chrome-browser using chrome-devtools-protocol
     */
        // console.error("\u25c0 RECV " + payload.slice(0, 256).toString());
        let callback;
        let {
            error,
            id,
            method,
            params,
            result
        } = JSON.parse(payload);
        assert.ok(!method || (
            /^[A-Z]\w*?\.[a-z]\w*?$/
        ).test(method), "chrome-devtools - read - invalid method " + method);
        // init callback
        callback = callbackDict[id];
        delete callbackDict[id];
        // callback.resolve
        if (callback) {
            // preserve stack-trace
            callback.err.message = (
                "chrome-devtools - read - " + JSON.stringify(error)
            );
            assert.ok(!error, callback.err);
            callback.resolve(result);
            return;
        }
        assert.ok(!error, "chrome-devtools - read - " + JSON.stringify(error));
        chromeClient.emit(method, params);
    }
    function chromeRead() {
    /*
     * this function will implement stream.Duplex.prototype._read
     */
        if (websocket && websocket.readable) {
            websocket.resume();
        }
    }
    function chromeRpc(method, params) {
    /*
     * this function will message-pass
     * JSON.stringify({
     *     id: <callbackId>,
     *     method: <method>,
     *     params: <params>,
     *     sessionId: <chromeSessionId>
     * })
     * to chrome-browser using chrome-devtools-protocol
     */
        callbackId = (callbackId % 256) + 1;
        chromeClient.write(Buffer.from(JSON.stringify({
            id: callbackId,
            method,
            params,
            sessionId: (
                typeof chromeSessionId === "string"
                ? chromeSessionId
                : undefined
            )
        })));
        return new Promise(function (resolve) {
            callbackDict[callbackId] = {
                err: new Error(),
                method,
                resolve
            };
        });
    }
    function chromeWrite(payload, ignore, callback) {
    /*
     * this function will implement stream.Duplex.prototype._write
     */
        // console.error("SEND \u25ba " + payload.slice(0, 256).toString());
        let header;
        let maskKey;
        let result;
        // init header
        header = Buffer.alloc(2 + 8 + 4);
        // init fin = true
        header[0] |= 0x80;
        // init opcode = text-frame
        header[0] |= 1;
        // init mask = true
        header[1] |= 0x80;
        // init payload.length
        if (payload.length < 126) {
            header = header.slice(0, 2 + 0 + 4);
            header[1] |= payload.length;
        // } else if (payload.length < 65536) {
        } else {
            assert.ok(payload.length < 65536, (
                "chrome-devtools - write - " +
                "payload-length must be less than 65536 bytes, not " +
                payload.length
            ));
            header = header.slice(0, 2 + 2 + 4);
            header[1] |= 126;
            header.writeUInt16BE(payload.length, 2);
        /*
        } else {
            header[1] |= 127;
            header.writeUInt32BE(payload.length, 6);
        */
        }
        // init maskKey
        maskKey = require("crypto").randomBytes(4);
        maskKey.copy(header, header.length - 4);
        // send header
        websocket.cork();
        websocket.write(header);
        // send payload ^ maskKey
        payload.forEach(function (ignore, ii) {
            payload[ii] ^= maskKey[ii & 3];
        });
        // return write-result
        result = websocket.write(payload, callback);
        websocket.uncork();
        return result;
    }
    function wsBufListRead(nn) {
    /*
     * this function will read <nn> bytes from <wsBufList>
     */
        let buf;
        wsBufList = (
            wsBufList.length === 1
            ? wsBufList[0]
            : Buffer.concat(wsBufList)
        );
        buf = wsBufList.slice(0, nn);
        wsBufList = [
            wsBufList.slice(nn)
        ];
        return buf;
    }
    function wsFrameRead() {
    /*
     * this function will read websocket-data-frame
     */
        let buf;
        let opcode;
        if (wsBufList.reduce(function (aa, bb) {
            return aa + bb.length;
        }, 0) < (
            wsReadState === WS_READ_PAYLOAD
            ? Math.max(wsPayloadLength, 1)
            : wsReadState === WS_READ_LENGTH63
            ? 8
            : 2
        )) {
            return;
        }
        switch (wsReadState) {
        // read frame-header
        case WS_READ_HEADER:
            buf = wsBufListRead(2);
            // validate opcode
            opcode = buf[0] & 0x0f;
            assert.ok(opcode === 0x01, (
                "chrome-devtools - read - opcode must be 0x01, not 0x0" +
                opcode.toString(16)
            ));
            wsPayloadLength = buf[1] & 0x7f;
            wsReadState = (
                wsPayloadLength === 126
                ? WS_READ_LENGTH16
                : wsPayloadLength === 127
                ? WS_READ_LENGTH63
                : WS_READ_PAYLOAD
            );
            break;
        // read frame-payload-length-16
        case WS_READ_LENGTH16:
            wsPayloadLength = wsBufListRead(2).readUInt16BE(0);
            wsReadState = WS_READ_PAYLOAD;
            break;
        // read frame-payload-length-63
        case WS_READ_LENGTH63:
            buf = wsBufListRead(8);
            wsPayloadLength = (
                buf.readUInt32BE(0) * 0x100000000 + buf.readUInt32BE(4)
            );
            wsReadState = WS_READ_PAYLOAD;
            break;
        // read frame-payload-data
        case WS_READ_PAYLOAD:
            assert.ok((
                0 <= wsPayloadLength && wsPayloadLength <= 10000000
            ), (
                "chrome-devtools - read - " +
                "payload-length must be between 0 and 256 MiB, not " +
                wsPayloadLength
            ));
            buf = wsBufListRead(wsPayloadLength);
            wsReadState = WS_READ_HEADER;
            chromeClient.push(buf);
            break;
        }
        return true;
    }
    function wsReaderTransform(chunk, ignore, callback) {
    /*
     * this function will implement Transform.prototype._transform
     */
        wsBufList.push(chunk);
        while (true) {
            if (!wsFrameRead()) {
                break;
            }
        }
        callback();
    }
    // init chromeClient
    function ChromeClient() {
    /*
     * this function will construct <chromeClient>
     */
        chromeClient = this;
        require("util").inherits(ChromeClient, require("stream").Duplex);
        require("stream").Duplex.call(chromeClient);
        Object.assign(chromeClient.__proto__, {
            _destroy: chromeCleanup,
            _read: chromeRead,
            _write: chromeWrite,
            evaluate: chromeEvaluate,
            rpc: chromeRpc
        });
        chromeClient.on("data", chromeOnData);
    }
    chromeClient = new ChromeClient();
/*
https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-13#section-5.2
+---------------------------------------------------------------+
|0               1               2               3              |
|0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f|
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
FIN: 1 bit
    Indicates that this is the final fragment in a message.  The first
    fragment MAY also be the final fragment.
RSV1, RSV2, RSV3: 1 bit each
    MUST be 0 unless an extension is negotiated which defines meanings
    for non-zero values.  If a nonzero value is received and none of
    the negotiated extensions defines the meaning of such a nonzero
    value, the receiving endpoint MUST _Fail the WebSocket
    Connection_.
Opcode: 4 bits
    Defines the interpretation of the payload data.  If an unknown
    opcode is received, the receiving endpoint MUST _Fail the
    WebSocket Connection_.  The following values are defined.
    *  %x0 denotes a continuation frame
    *  %x1 denotes a text frame
    *  %x2 denotes a binary frame
    *  %x3-7 are reserved for further non-control frames
    *  %x8 denotes a connection close
    *  %x9 denotes a ping
    *  %xA denotes a pong
    *  %xB-F are reserved for further control frames
Mask: 1 bit
    Defines whether the payload data is masked.  If set to 1, a
    masking key is present in masking-key, and this is used to unmask
    the payload data as per Section 5.3.  All frames sent from client
    to server have this bit set to 1.
Payload length: 7 bits, 7+16 bits, or 7+64 bits
    The length of the payload data, in bytes: if 0-125, that is the
    payload length.  If 126, the following 2 bytes interpreted as a 16
    bit unsigned integer are the payload length.  If 127, the
    following 8 bytes interpreted as a 64-bit unsigned integer (the
    most significant bit MUST be 0) are the payload length.  Multibyte
    length quantities are expressed in network byte order.  The
    payload length is the length of the extension data + the length of
    the application data.  The length of the extension data may be
    zero, in which case the payload length is the length of the
    application data.
Masking-key: 0 or 4 bytes
    All frames sent from the client to the server are masked by a 32-
    bit value that is contained within the frame.  This field is
    present if the mask bit is set to 1, and is absent if the mask bit
    is set to 0.  See Section 5.3 for further information on client-
    to-server masking.
Payload data: (x+y) bytes
    The payload data is defined as extension data concatenated with
    application data.
Extension data: x bytes
    The extension data is 0 bytes unless an extension has been
    negotiated.  Any extension MUST specify the length of the
    extension data, or how that length may be calculated, and how the
    extension use MUST be negotiated during the opening handshake.  If
    present, the extension data is included in the total payload
    length.
Application data: y bytes
    Arbitrary application data, taking up the remainder of the frame
    after any extension data.  The length of the application data is
    equal to the payload length minus the length of the extension
    data.
*/
    // init wsReader that can read websocket-frames from websocket
    function WsReader() {
    /*
     * this function will construct <wsReader>
     */
        wsReader = this;
        require("util").inherits(WsReader, require("stream").Transform);
        require("stream").Transform.call(wsReader);
        Object.assign(wsReader.__proto__, {
            _transform: wsReaderTransform
        });
    }
    wsReader = new WsReader();
    // init chromeProcess
    processPlatform = processPlatform || process.platform;
    chromeUserDataDir = await require("fs").promises.mkdtemp(
        require("path").join(require("os").tmpdir(), "puppeteer_dev_profile-")
    );
    chromeBin = chromeBin || (
        processPlatform === "darwin"
        ? "/Applications/Google Chrome.app/Contents/MacOS/" +
        "Google Chrome"
        : processPlatform === "win32"
        ? "C:\\Program Files (x86)\\Google\\Chrome\\Application\\" +
        "chrome.exe"
        : "/usr/bin/google-chrome-stable"
    );
    console.error("chrome-devtools - spawning - " + chromeBin);
    chromeProcess = require("child_process").spawn((
        chromeBin
    ), [
        "--headless",
        "--incognito",
        "--remote-debugging-port=0",
        "--user-data-dir=" + chromeUserDataDir,
        "--window-size=" + modeWindowSize,
        Array.from([
            "", "--no-sandbox"
        ])[(process.getuid && process.getuid() === 0) | 0]
    ], {
        // On non-windows platforms, `detached: false` makes child process
        // a leader of a new process group, making it possible to kill
        // child process tree with `.kill(-pid)` cmd.
        // https://nodejs.org/api/child_process.html#child_process_options_detached
        detached: process.platform !== "win32",
        stdio: [
            "ignore", (
                !modeSilent
                ? 1
                : "ignore"
            ), "pipe"
        ]
    });
    if (!modeSilent) {
        chromeProcess.stderr.pipe(process.stderr, {
            end: false
        });
    }
    process.on("exit", chromeCleanup);
    process.on("SIGINT", chromeCleanup);
    process.on("SIGTERM", chromeCleanup);
    process.on("SIGHUP", chromeCleanup);
    // init timerTimeout
    timeout = timeout || 30000;
    if (modeCoverageHack === 2) {
        chromeClient.on("error", noop);
        chromeProcess.on("error", noop);
        timeout = 0;
    }
    timerTimeout = setTimeout(function () {
        chromeCleanup();
        chromeClient.emit("error", new Error(
            "chrome-devtools - timeout - " + timeout + " ms"
        ));
    }, timeout);
    // init websocketUrl
    websocketUrl = await new Promise(function (resolve) {
        let stderr;
        stderr = "";
        chromeProcess.stderr.on("data", function onData(chunk) {
            assert.ok(
                stderr.length < 65536,
                "chrome-devtools - connecting - cannot connect to chrome"
            );
            stderr += chunk;
            stderr.replace((
                /^DevTools\u0020listening\u0020on\u0020(ws:\/\/.*)$/m
            ), function (ignore, url) {
                chromeProcess.stderr.removeListener("data", onData);
                resolve(url);
                return "";
            });
        });
    });
    // init websocket
    console.error("chrome-devtools - connecting - " + websocketUrl);
    secWebsocketKey = require("crypto").randomBytes(16).toString("base64");
    await new Promise(function (resolve) {
        require("http").get((
            websocketUrl
        ), {
            createConnection: function (opt) {
                delete opt.path;
                return require("net").connect(opt);
            },
            headers: {
                Connection: "Upgrade",
                "Sec-WebSocket-Key": secWebsocketKey,
                "Sec-WebSocket-Version": 13,
                Upgrade: "websocket"
            },
            protocol: "http:",
            protocolVersion: 13
        }).once("upgrade", function (res, _, head) {
            assert.ok((
                res.headers[
                    "sec-websocket-accept"
                ] === require("crypto").createHash("sha1").update(
                    secWebsocketKey +
                    "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
                ).digest("base64")
            ), (
                "chrome-devtools - connecting - " +
                "invalid header sec-websocket-accept"
            ));
            websocket = _;
            websocket.unshift(head);
            // websocket - disable timeout
            websocket.setTimeout(0);
            // websocket - disable nagle's algorithm
            websocket.setNoDelay();
            websocket.on("end", websocket.end.bind(websocket));
            // pipe websocket to wsReader
            websocket.pipe(wsReader);
            resolve();
        });
    });
    // init chromeSessionId
    chromeSessionId = await chromeClient.rpc("Target.createTarget", {
        url: "about:blank"
    });
    chromeSessionId = await chromeClient.rpc("Target.attachToTarget", {
        targetId: chromeSessionId.targetId,
        flatten: true
    });
    chromeSessionId = chromeSessionId.sessionId;
    console.error("chrome-devtools - created - blank-page with sessionId");
    return chromeClient;
};

local.cliRun = function ({
    rgxComment
}) {
/*
 * this function will run cli
 */
    let {
        _default,
        _eval,
        _help,
        _interactive,
        _version,
        cliDict,
        replStart
    } = Object.assign({}, local, local.cliDict);
    _eval = _eval || function () {
    /*
     * <code>
     * will eval <code>
     */
        Object.assign(globalThis, local);
        require("vm").runInThisContext(process.argv[3]);
    };
    _help = _help || function () {
    /*
     *
     * will print help
     */
        let cmdList;
        let file;
        let packageJson;
        let str;
        let strDict;
        cmdList = [
            {
                argList: "<arg2>  ...",
                description: "usage:",
                cmd: [
                    "<arg1>"
                ]
            }, {
                argList: "'console.log(\"hello world\")'",
                description: "example:",
                cmd: [
                    "--eval"
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), "");
        packageJson = require("./package.json");
        // validate comment
        rgxComment = rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020<[^>]*?>|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(cliDict).sort().forEach(function (key, ii) {
            if (key[0] === "_" && key !== "_default") {
                return;
            }
            str = String(cliDict[key]);
            if (key === "_default") {
                key = "";
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (cmdList[ii]) {
                cmdList[ii].cmd.push(key);
                return;
            }
            cmdList[ii] = rgxComment.exec(str);
            if (!cmdList[ii]) {
                throw new Error(
                    "cliRun - cannot parse comment in cmd " +
                    key + ":\nnew RegExp(" +
                    JSON.stringify(rgxComment.source) +
                    ").exec(" + JSON.stringify(str).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") + ");"
                );
            }
            cmdList[ii] = {
                argList: String(cmdList[ii][1] || "").trim(),
                cmd: [
                    key
                ],
                description: cmdList[ii][2]
            };
        });
        str = "";
        str += packageJson.name + " (" + packageJson.version + ")\n\n";
        str += cmdList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.cmd = elem.cmd.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(" ");
                elem.description = (
                    "# CMD " +
                    (elem.cmd[0] || "<none>") + "\n# " +
                    elem.description
                );
            }
            return (
                elem.description + "\n  " + file +
                "  " + elem.cmd.sort().join("|") + "  " +
                elem.argList.join("  ")
            );
        }).join("\n\n");
        console.log(str);
    };
    _interactive = _interactive || function () {
    /*
     *
     * will start interactive-mode
     */
        Object.assign(globalThis, local);
        replStart = replStart || require("repl").start;
        replStart({
            useGlobal: true
        });
    };
    _version = _version || function () {
    /*
     *
     * will print version
     */
        console.log(require(__dirname + "/package.json").version);
    };
    _default = _default || _help;
    Object.assign(cliDict, {
        "--eval": _eval,
        "--help": _help,
        "--interactive": _interactive,
        "--version": _version,
        "-e": _eval,
        "-h": _help,
        "-i": _interactive,
        "-v": _version,
        _default,
        _eval,
        _help,
        _interactive,
        _version
    });
    // run help-cmd if no arguments are given
    if (process.argv.length <= 2) {
        _help();
        return;
    }
    // run defined-cmd if it exists
    if (cliDict[process.argv[2]]) {
        cliDict[process.argv[2]]();
        return;
    }
    // run default-cmd
    _default();
};

local.domQuerySelectorAllTagName = function (selector) {
/*
 * this function will return list of tagName matching <selector>
 */
    let dict;
    dict = {};
    documentQuerySelectorAll(selector).forEach(function (elem) {
        dict[elem.tagName] = true;
    });
    return Object.keys(dict).sort();
};

local.domStyleValidate = function () {
/*
 * this function will validate <style> tags
 */
    let list;
    let rgx;
    rgx = (
        /^0\u0020(?:(body\u0020>\u0020)?(?:\.test-report-div\u0020.+|\.x-istanbul\u0020.+|\.button|\.colorError|\.readonly|\.textarea|\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\u0020\{))|^[1-9]\d*?\u0020#/m
    );
    list = [];
    documentQuerySelectorAll("style").forEach(function (elem, ii) {
        elem.innerHTML.replace((
            /\/\*[\S\s]*?\*\/|;|\}/g
        ), "\n").replace((
            /^([^\n\u0020@].*?)[,{:].*?$/gm
        ), function (match0, match1) {
            try {
                ii = document.querySelectorAll(match1).length;
            } catch (errCaught) {
                console.error(errCaught);
            }
            if (!(ii > 1) && !rgx.test(elem)) {
                list.push(ii + " " + match0);
            }
        });
    });
    list.filter(function (elem) {
        return !rgx.test(elem);
    }).sort().reverse().forEach(function (elem, ii, list) {
        console.error(
            "domStyleValidateUnmatched " + (list.length - ii) + ". " + elem
        );
    });
};

local.eventListenerAdd = function (type, {
    once
}, listener) {
/*
 * this function will listen evt <type> with <listener>
 */
    localEventListenerId = (localEventListenerId + 1) | 0;
    localEventListenerDict[localEventListenerId] = {
        listener,
        once,
        type
    };
};

local.eventListenerEmit = function (type, msg) {
/*
 * this function will emit evt <type> with <msg>
 */
    Object.entries(localEventListenerDict).forEach(function ([
        id, elem
    ]) {
        if (elem.type === type) {
            if (elem.once) {
                delete localEventListenerDict[id];
            }
            elem.listener({
                msg,
                type
            });
        }
    });
};

local.eventListenerRemove = function (listener) {
/*
 * this function will emit evt <type> with <msg>
 */
    Object.entries(localEventListenerDict).forEach(function ([
        id, elem
    ]) {
        if (elem.listener === listener) {
            delete localEventListenerDict[id];
        }
    });
};

local.fsReadFileOrDefaultSync = function (pathname, type, dflt) {
/*
 * this function will sync-read <pathname> with given <type> and <dflt>
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return dflt;
    }
    // try to read pathname
    try {
        return (
            type === "json"
            ? JSON.parse(fs.readFileSync(pathname, "utf8"))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};

local.fsWriteFileWithMkdirpSync = function (pathname, data) {
/*
 * this function will sync write <data> to <pathname> with "mkdir -p"
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return;
    }
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require("path").dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
    }
    console.error("fsWriteFileWithMkdirpSync - wrote - " + pathname);
    return true;
};

local.httpFetch = async function (url, opt = {}) {
/*
 * this function fetch <url> with given <opt>
 */
    let buf;
    let bufList;
    let req;
    let res;
    function arrayBuffer() {
        return buf;
    }
    async function json() {
        return JSON.stringify(await buf);
    }
    async function text() {
        return String(await buf);
    }
    // use browser fetch
    if (
        typeof globalThis.XMLHttpRequest === "function" &&
        typeof globalThis.fetch === "function"
    ) {
        return globalThis.fetch(url, opt);
    }
    // use node http-request
    if (!(
        /^https?:/
    ).test(url)) {
        url = "http://127.0.0.1:" + process.env.PORT + "/" + url.replace((
            /^\//
        ), "");
    }
    res = await new Promise(function (resolve) {
        req = require(url.split(":")[0]).request(url, opt, resolve).end();
    });
    let {
        headers,
        statusCode
    } = res;
    bufList = [];
    res.on("data", function (chunk) {
        bufList.push(chunk);
    });
    buf = new Promise(function (resolve) {
        res.on("end", function () {
            resolve(Buffer.concat(bufList));
        });
    });
    return Object.assign(res, {
        arrayBuffer,
        blob: arrayBuffer,
        headers: new Map(Object.entries(headers)),
        json,
        ok: 200 <= statusCode && statusCode <= 299,
        req,
        status: statusCode,
        statusText: require("http").STATUS_CODES[statusCode],
        text,
        url
    });
};

local.jslintAutofixLocalFunction = function (code, file) {
/*
 * this function will jslint-autofix local-function
 */
    let code2;
    let dictFnc;
    let dictProp;
    function stringMerge(str1, str2, rgx) {
    /*
     * this function will merge <str2> into <str1>,
     * for sections where both match <rgx> with no magic
     */
        str2.replace(rgx, function (match2) {
            str1.replace(rgx, function (match1) {
                str1 = str1.replace(match1, function () {
                    return match2;
                });
                return "";
            });
            return "";
        });
        return str1;
    }
    if (!isEnvNode) {
        return code;
    }
    // make file relative
    file = require("path").resolve(file);
    if (file.indexOf(process.cwd() + require("path").sep) === 0) {
        file = file.replace(process.cwd() + require("path").sep, "");
    }
    switch (file) {
    case "README.md":
    case "lib." + npm_package_nameLib + ".js":
    case "lib." + npm_package_nameLib + ".sh":
    case "lib.apidoc.js":
    case "lib.istanbul.js":
    case "lib.jslint.js":
    case "lib.marked.js":
    case "npm_scripts.sh":
    case "test.js":
        break;
    default:
        return code;
    }
    // autofix - assets.utility2.header.js
    code = code.replace((
        /\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020start\n[\S\s]*?\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020end\n/
    ), "\n" + local.assetsDict["/assets.utility2.header.js"]);
    // autofix - assets.my_app.template.js
    code = stringMerge(
        code,
        local.assetsDict["/assets.my_app.template.js"].replace((
            /my_app/g
        ), file.split(".")[1]),
        (
            file === "README.md"
            ? (
                /$^/m
            )
            : (
                /\n\/\*\u0020istanbul\u0020instrument\u0020in\u0020package\u0020[\S\s]*?\n\/\*\u0020validateLineSortedReset\u0020\*\/\n/
            )
        )
    );
    // customize local for assets.utility2.rollup.js
    if (
        file === "lib." + npm_package_nameLib + ".js" &&
        require("fs").existsSync("./assets.utility2.rollup.js")
    ) {
        code = code.replace(
            "    // || globalThis.utility2_rollup_old",
            "    || globalThis.utility2_rollup_old"
        ).replace(
            "    // || require(\"./assets.utility2.rollup.js\")",
            "    || require(\"./assets.utility2.rollup.js\")"
        );
    }
    // init functionAllDict and functionBaseDict
    [
        [
            "utility2"
        ], [
            "utility2", "apidoc"
        ]
    ].forEach(function (dictList, ii) {
        dictFnc = (
            ii
            ? "functionAllDict"
            : "functionBaseDict"
        );
        if (local[dictFnc]) {
            return;
        }
        local[dictFnc] = {};
        dictList.forEach(function (dict) {
            dict = local[dict];
            Object.keys(dict).forEach(function (key) {
                if (
                    !(
                        /^[A-Z_]|^testCase_/m
                    ).test(key) &&
                    typeof dict[key] === "function"
                ) {
                    local[dictFnc][key] = (
                        local[dictFnc][key] || String(dict[key])
                    );
                }
            });
        });
        Object.keys(local[dictFnc]).forEach(function (key) {
            if (process.binding("natives")[key]) {
                local[dictFnc][key] = undefined;
            }
        });
    });
    // autofix - local-function
    dictFnc = {};
    dictProp = {};
    code = code.replace((
        /^local\.(.*?)\u0020=\u0020(function\u0020\([\S\s]*?\n\});\n+/gm
    ), function (match0, key, match2, match3) {
        // local-function - duplicate
        if (dictFnc[key]) {
            return "";
        }
        // local-function - normalize
        dictFnc[key] = true;
        match3 = local.functionAllDict[key] || "";
        // make shell-safe
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c
        if (file.slice(-3) === ".sh") {
            match3 = match3.replace((
                /'/g
            ), "'\"'\"'");
        }
        if (match3 && match3 !== match2) {
            match0 = match0.replace(match2, match3.replace((
                /\$\$|\$/g
            ), "$$$$"));
        }
        return match0.trimEnd() + "\n\n";
    });
    // comment
    code2 = code;
    code2 = code2.replace((
        /^\u0020*?\/\*[\S\s]*?\*\/|^\u0020*?(?:\/\/.*?|.*?\\)$/gm
    ), "");
    // local-function - update dictFnc and dictProp
    code2.replace((
        /\blocal\.(\w+?\b)(?:\u0020(===|=|\|\|)(?:\u0020"function"\u0020&&\u0020local\.\w|\u0020|$))?/gm
    ), function (ignore, match1, match2) {
        switch (match2) {
        case "=":
            dictFnc[match1] = true;
            break;
        case "===":
        case "||":
            dictProp[match1] = false;
            break;
        default:
            dictProp[match1] = true;
        }
    });
    [
        dictFnc, dictProp
    ].forEach(function (dict) {
        Object.keys(dict).forEach(function (key) {
            dict[key] = dict[key] && local.functionBaseDict[key];
        });
    });
    dictFnc = JSON.parse(JSON.stringify(dictFnc));
    dictProp = JSON.parse(JSON.stringify(dictProp));
    [
        "assertJsonEqual",
        "assertOrThrow",
        "identity",
        "noop",
        "objectAssignDefault",
        "objectDeepCopyWithKeysSorted",
        "onErrorThrow"
    ].forEach(function (key) {
        dictFnc[key] = true;
        dictProp[key] = true;
    });
    // local-function - missing
    switch (require("fs").existsSync("assets.utility2.rollup.js") || file) {
    case "README.md":
    case "lib.utility2.js":
    case "test.js":
    case true:
        break;
    default:
        Object.keys(dictProp).forEach(function (key) {
            if (dictProp[key] && !dictFnc[key]) {
                console.error(
                    "local-function - missing (" + file + ") local." + key
                );
            }
        });
    }
    // local-function - unused
    switch (file) {
    case "lib.utility2.js":
    case "lib.utility2.sh":
        break;
    default:
        Object.keys(dictFnc).forEach(function (key) {
            if (!dictProp.hasOwnProperty(key)) {
                console.error(
                    "local-function - unused (" + file + ") local." + key
                );
            }
        });
    }
    return code;
};

local.listShuffle = function (list) {
/*
 * this function will inplace shuffle <list> using fisher-yates algorithm
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
    let ii;
    let random;
    let swap;
    ii = list.length;
    while (ii > 1) {
        ii -= 1;
        random = Math.floor(Math.random() * (ii + 1));
        swap = list[ii];
        list[ii] = list[random];
        list[random] = swap;
    }
    return list;
};

local.onReadyDecrement = function (err) {
/*
 * this function will decrement <onReadyCnt>
 */
    localOnReadyCnt -= 1;
    if (localOnReadyCnt === 0) {
        local.eventListenerEmit("utility2.onReady", err);
    }
    return localOnReadyCnt;
};

local.onReadyIncrement = function () {
/*
 * this function will increment <onReadyCnt>
 */
    localOnReadyCnt += 1;
    return localOnReadyCnt;
};

local.replStart = function () {
/*
 * this function will start repl-debugger
 */
    let that;
    if (globalThis.utility2_repl1) {
        return;
    }
    // start repl
    that = require("repl").start({
        useGlobal: true
    });
    globalThis.utility2_repl1 = that;
    // init history
    that.setupHistory(require("path").resolve(
        process.env.HOME + "/.node_repl_history"
    ), function () {
        return;
    });
    // save eval-function
    that.evalDefault = that.eval;
    // hook custom-eval-function
    that.eval = function (script, context, file, onError) {
        script.replace((
            /^(\S+)\u0020(.*?)\n/
        ), function (ignore, match1, match2) {
            switch (match1) {
            // syntax-sugar - run shell-cmd
            case "$":
                switch (match2.split(" ").slice(0, 2).join(" ")) {
                // syntax-sugar - run git diff
                case "git diff":
                    match2 += " --color";
                    break;
                // syntax-sugar - run git log
                case "git log":
                    match2 += " -n 10";
                    break;
                // syntax-sugar - run ll
                case "ll":
                    match2 = "ls -Fal";
                    break;
                }
                match2 = match2.replace((
                    /^git\u0020/
                ), "git --no-pager ");
                // source lib.utility2.sh
                match2 = (
                    (
                        process.platform !== "win32" &&
                        process.env.UTILITY2_BIN && (match2 !== ":")
                    )
                    ? ". " + process.env.UTILITY2_BIN + "; " + match2
                    : match2
                );
                // run shell-cmd
                console.error("$ " + match2);
                require("child_process").spawn(match2, {
                    shell: true,
                    stdio: [
                        "ignore", 1, 2
                    ]
                // print exitCode
                }).on("exit", function (exitCode) {
                    console.error("$ EXIT_CODE=" + exitCode);
                    that.evalDefault("\n", context, file, onError);
                });
                script = "\n";
                break;
            // syntax-sugar - map text with charCodeAt
            case "charCode":
                console.error(
                    match2.split("").map(function (chr) {
                        return (
                            "\\u" +
                            chr.charCodeAt(0).toString(16).padStart(4, 0)
                        );
                    }).join("")
                );
                script = "\n";
                break;
            // syntax-sugar - sort chr
            case "charSort":
                console.error(JSON.stringify(match2.split("").sort().join("")));
                script = "\n";
                break;
            // syntax-sugar - list obj-keys, sorted by item-type
            // console.error(Object.keys(global).map(function(key){return(typeof global[key]==='object'&&global[key]&&global[key]===global[key]?'global':typeof global[key])+' '+key;}).sort().join('\n')) // jslint ignore:line
            case "keys":
                script = (
                    "console.error(Object.keys(" + match2 +
                    ").map(function(key){return(" +
                    "typeof " + match2 + "[key]==='object'&&" +
                    match2 + "[key]&&" +
                    match2 + "[key]===global[key]" +
                    "?'global'" +
                    ":typeof " + match2 + "[key]" +
                    ")+' '+key;" +
                    "}).sort().join('\\n'))\n"
                );
                break;
            // syntax-sugar - print String(val)
            case "print":
                script = "console.error(String(" + match2 + "))\n";
                break;
            }
        });
        // eval script
        that.evalDefault(script, context, file, onError);
    };
};

local.requireReadme = function () {
/*
 * this function will require and export example.js embedded in README.md
 */
    let Module;
    let code;
    let exports;
    let file;
    let {
        assetsDict,
        fsReadFileOrDefaultSync,
        objectAssignDefault,
        replStart,
        templateRenderMyApp
    } = local;
    // if library-mode, then return local
    if (npm_config_mode_lib) {
        local.testRunDefault = noop;
        return local;
    }
    // if file modified, then restart process
    if (npm_config_mode_auto_restart) {
        require("fs").readdir(".", function (ignore, fileList) {
            fileList.concat(__filename).forEach(async function (file) {
                let stats;
                if (file[0] === ".") {
                    return;
                }
                stats = await require("fs").promises.stat(file);
                if (!stats.isFile()) {
                    return;
                }
                require("fs").watchFile(file, {
                    interval: 1000,
                    persistent: false
                }, function () {
                    console.error("watchFile - modified - " + file);
                    setTimeout(process.exit.bind(undefined, 77), 1000);
                });
            });
        });
    }
    // if browser-env, then return local
    if (!isEnvNode) {
        return objectAssignDefault(
            globalThis.utility2_rollup || globalThis.local,
            local
        );
    }
    // start repl-debugger
    replStart();
    // jslint $PWD
    require("child_process").spawn("node", [
        "-e", (
            "require(" + JSON.stringify(__filename) +
            ").jslintAndPrintDir(" + JSON.stringify(process.cwd()) +
            ", {modeAutofix:" + !npm_config_mode_test +
            ",modeConditional:true});"
        )
    ], {
        env: Object.assign({}, process.env, {
            npm_config_mode_lib: "1"
        }),
        stdio: [
            "ignore", 1, 2
        ]
    });
    // if rollup, then return local
    if (globalThis.utility2_rollup || npm_config_mode_start) {
        assetsDict["/assets.app.js"] = require("fs").readFileSync(
            __filename,
            "utf8"
        ).replace((
            /^#!\//
        ), "// ");
        // init exports
        local[npm_package_nameLib] = local;
        return local;
    }
    // init utility2_moduleExports from $npm_package_main
    globalThis.utility2_moduleExports = require(
        require("path").resolve(npm_package_main)
    );
    // read example.js from README.md
    code = assetsDict["/assets.example.template.js"];
    fsReadFileOrDefaultSync("README.md", "utf8", "").replace((
        /\n```javascript(\n\/\*\nexample\.js\n[\S\s]*?\n)```\n/
    ), function (ignore, match1, ii, input) {
        // preserve lineno
        code = input.slice(0, ii).replace((
            /.+/g
        ), "") + "\n" + match1;
        return "";
    });
    // alias require($npm_package_name) to utility2_moduleExports;
    code = code.replace(
        new RegExp("require\\(." + npm_package_name + ".\\)"),
        "globalThis.utility2_moduleExports"
    ).replace(
        new RegExp("require\\(." + npm_package_nameOriginal + ".\\)"),
        "globalThis.utility2_moduleExports"
    );
    // jslint example.js
    file = require("path").resolve("example.js");
    jslintAndPrint(code, file);
    // instrument example.js
    code = instrumentInPackage(code, file);
    // eval example.js
    Module = require("module");
    exports = new Module(file);
    require.cache[file] = exports;
    exports._compile(code, file);
    // export example.js
    exports = exports.exports;
    exports.utility2 = local;
    exports[npm_package_nameLib] = globalThis.utility2_moduleExports;
    // cleanup utility2_moduleExports
    delete globalThis.utility2_moduleExports;
    // init assets lib.xxx.js
    [
        ".css", ".js"
    ].forEach(function (extname) {
        assetsDict[
            "/assets." + npm_package_nameLib + extname
        ] = fsReadFileOrDefaultSync(
            require("path").resolve(npm_package_main).replace((
                /\.\w+?$/
            ), extname),
            "utf8",
            ""
        ).replace((
            /^#!\//
        ), "// ");
    });
    Object.assign(assetsDict, exports.assetsDict);
    // instrument assets lib.xxx.js
    assetsDict["/assets." + npm_package_nameLib + ".js"] = (
        instrumentInPackage(
            assetsDict["/assets." + npm_package_nameLib + ".js"],
            npm_package_main
        )
    );
    exports.assetsDict = assetsDict;
    assetsDict["/assets.example.js"] = code;
    assetsDict["/assets.test.js"] = instrumentInPackage(
        require("fs").readFileSync("test.js", "utf8"),
        "test.js"
    );
    // init assets index.html
    file = assetsDict["/"];
    // uncomment utility2-comment
    file = file.replace((
        /\n<!--\u0020utility2-comment\n|\nutility2-comment\u0020-->\n/g
    ), "\n\n");
    // interpolate {{...}}
    file = templateRenderMyApp(file);
    assetsDict["/"] = file;
    assetsDict["/index.html"] = file;
    // init assets.app.js
    assetsDict["/assets.app.js"] = [
        "header",
        "/assets.utility2.rollup.js",
        "/assets.utility2.rollup.start.js",
        "/assets.my_app.css",
        "/assets.my_app.js",
        "/assets.example.js",
        "/assets.test.js",
        "/assets.utility2.rollup.end.js"
    ].map(function (key) {
        switch (key) {
        case "/assets.my_app.css":
            file = "/assets." + npm_package_nameLib + ".css";
            // disable $-escape in replacement-string
            code = assetsDict[
                "/assets.utility2.rollup.content.js"
            ].replace("/* utility2.rollup.js content */", function () {
                return (
                    "local.assetsDict[\"" + file + "\"] = (\n" +
                    JSON.stringify(assetsDict[file]).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") +
                    ");\n"
                );
            });
            break;
        case "/assets.my_app.js":
            file = "/assets." + npm_package_nameLib + ".js";
            // disable $-escape in replacement-string
            code = assetsDict[
                "/assets.utility2.rollup.content.js"
            ].replace("/* utility2.rollup.js content */", function () {
                return (
                    "local.assetsDict[\"" + file + "\"] = (\n" +
                    JSON.stringify(assetsDict[file]).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") +
                    ");\n" +
                    assetsDict[file]
                );
            });
            break;
        case "header":
            return (
                "/* this rollup was created with utility2\n" +
                " * https://github.com/kaizhu256/node-utility2\n" +
                " */\n" +
                "\n" +
                "\n" +
                "/*\n" +
                "assets.app.js\n" +
                "\n" +
                npm_package_description + "\n" +
                "\n" +
                "instruction\n" +
                "    1. save this script as assets.app.js\n" +
                "    2. run shell-cmd:\n" +
                "        $ PORT=8081 node assets.app.js\n" +
                "    3. open browser to http://127.0.0.1:8081 " +
                "and play with web-demo\n" +
                "    4. edit this script to suit your needs\n" +
                "*/\n" +
                assetsDict["/assets.utility2.rollup.start.js"].replace((
                    /utility2_rollup/g
                ), "utility2_app")
            );
        default:
            code = assetsDict[key];
        }
        return (
            "/* script-begin " + key + " */\n" +
            code.trim() +
            "\n/* script-end " + key + " */\n"
        );
    }).join("\n\n\n");
    objectAssignDefault(exports, local);
    // init testCase_buildXxx
    Object.keys(local).forEach(function (key) {
        if (
            key.indexOf("_testCase_build") === 0 ||
            key === "_testCase_webpage_default"
        ) {
            exports[key.slice(1)] = exports[key.slice(1)] || local[key];
        }
    });
    return exports;
};

local.serverRequestListener = function (req, res) {
/*
 * this function will handle server-<req> and server-<res> using
 * express-like middleware-chaining
 */
    let isDone;
    let list;
    let timeStart;
    let timeout;
    let timerTimeout;
    let urlParsed;
    let {
        assetsDict,
        middlewareList
    } = local;
    function onClose() {
    /*
     * this function will hand "close" evt
     */
        console.error("serverLog - " + JSON.stringify({
            time: new Date(timeStart).toISOString(),
            type: "serverResponse",
            method: req.method,
            url: urlParsed.pathname,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - timeStart
        }) + "\n");
        isDone = true;
        clearTimeout(timerTimeout);
        req.destroy();
        res.destroy();
    }
    function onError(err) {
    /*
     * this function will end server-request
     */
        if (!isDone && !err) {
            isDone = true;
            res.statusCode = 404;
            res.end("404 Not Found");
            return;
        }
        console.error(err || new Error("onError called more than once"));
        if (isDone) {
            req.destroy();
            res.destroy();
            return;
        }
        isDone = true;
        res.statusCode = 500;
        res.end("500 Internal Server Error");
    }
    function onTimeout() {
        isDone = true;
        onError(new Error("timeout - " + timeout + " ms"));
    }
    async function middlewareInit(req, ignore, next) {
        let contentType;
        // init timeStart
        timeStart = Date.now();
        // init timerTimeout
        timeout = timeout || npm_config_timeout;
        timerTimeout = setTimeout(onTimeout, timeout);
        // init urlParsed
        urlParsed = new URL("http://127.0.0.1:" + PORT + req.url);
        // init evt-handling
        req.on("abort", onError);
        req.on("close", onClose);
        req.on("error", onError);
        res.on("error", onError);
        res.on("close", onClose);
        // set reponse-header "content-type"
        contentType = {
            // application
            ".js": "application/javascript; charset=utf-8",
            ".json": "application/json; charset=utf-8",
            ".mjs": "application/javascript; charset=utf-8",
            ".pdf": "application/pdf",
            ".wasm": "application/wasm",
            ".xml": "application/xml; charset=utf-8",
            // image
            ".bmp": "image/bmp",
            ".gif": "image/gif",
            ".jpe": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".jpg": "image/jpeg",
            ".png": "image/png",
            ".svg": "image/svg+xml; charset=utf-8",
            // text
            ".css": "text/css; charset=utf-8",
            ".htm": "text/html; charset=utf-8",
            ".html": "text/html; charset=utf-8",
            ".md": "text/markdown; charset=utf-8",
            ".txt": "text/plain; charset=utf-8",
            "/": "text/html; charset=utf-8"
        };
        contentType = contentType[(
            /^\/$|\.[^.]*?$|$/m
        ).exec(urlParsed.pathname)[0]];
        if (contentType) {
            res.setHeader("content-type", contentType);
        }
        await next();
    }
    async function middlewareServeAsset(ignore, res, next) {
    /*
     * this function will serve assets from <assetsDict>
     */
        if (!assetsDict.hasOwnProperty(urlParsed.pathname)) {
            await next();
            return;
        }
        res.statusCode = 200;
        res.end(assetsDict[urlParsed.pathname]);
    }
    async function middlewareServeFile(req, res, next) {
    /*
     * this function will serve <file> from fs
     */
        let file;
        if (req.method !== "GET") {
            await next();
            return;
        }
        file = urlParsed.pathname.slice(1);
        // replace trailing "/" with "/index.html"
        file = file.replace((
            /\/$/
        ), "/index.html");
        // resolve file
        file = require("path").resolve(file);
        if (
            // security - disable parent-directory lookup
            file.indexOf(process.cwd() + require("path").sep) !== 0 ||
            // security - ignore file with non-alphanumeric-first-character
            !(
                /[0-9A-Za-z]/
            ).test(require("path").basename(file)[0])
        ) {
            await next();
            return;
        }
        try {
            file = await require("fs").promises.readFile(file);
        } catch (ignore) {
            await next();
            return;
        }
        res.end(file);
    }
    async function next() {
        let middleware;
        try {
            middleware = list.shift();
            if (isDone || !middleware) {
                onError();
                return;
            }
            // recurse
            await middleware(req, res, next);
        } catch (errCaught) {
            onError(errCaught);
        }
    }
    // init list
    list = [].concat(
        middlewareInit,
        middlewareList,
        middlewareServeAsset,
        middlewareServeFile
    );
    next();
};

local.serverRespondEcho = function (req, res) {
/*
 * this function will respond with debug info
 */
    res.write(
        req.method + " " + req.url +
        " HTTP/" + req.httpVersion + "\r\n" +
        Object.keys(req.headers).map(function (key) {
            return key + ": " + req.headers[key] + "\r\n";
        }).join("") + "\r\n"
    );
    req.pipe(res);
};

local.setTimeoutOnError = function (onError, timeout, err, data) {
/*
 * this function will after timeout has passed,
 * then call <onError>(<err>, <data>)
 */
    if (typeof onError === "function") {
        setTimeout(function () {
            onError(err, data);
        }, timeout);
    }
    return data;
};

local.stringHtmlSafe = function (str) {
/*
 * this function will make <str> html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
    return str.replace((
        /&/gu
    ), "&amp;").replace((
        /"/gu
    ), "&quot;").replace((
        /'/gu
    ), "&apos;").replace((
        /</gu
    ), "&lt;").replace((
        />/gu
    ), "&gt;").replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
    ), "&$1");
};

local.stringRegexpEscape = function (str) {
/*
 * this function will regexp-escape <str>
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
 */
    return str.replace((
        /[\-\/\\\^$*+?.()|\[\]{}]/g
    ), "\\$&");
};

local.svgBadgeCreate = function ({
    fill,
    str1,
    str2
}) {
/*
 * this function will create svg-badge
 */
    let xx1;
    let xx2;
    str1 = String(str1);
    str2 = String(str2);
    xx1 = 6 * str1.length + 20;
    xx2 = 6 * str2.length + 20;
    return (
        "<svg height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\" xmlns=\"http://www.w3.org/2000/svg\">\n" +
        "<rect fill=\"#555\" height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\"/>\n" +
        "<rect fill=\"" + fill + "\" height=\"20\" width=\"" +
        xx2 + "\" x=\"" + xx1 + "\"/>\n" +
        "<g\n" +
        "fill=\"#fff\"\n" +
        "font-family=\"DejaVu Sans,Verdana,Geneva,sans-serif\"\n" +
        "font-size=\"11\"\n" +
        "text-anchor=\"middle\"\n" +
        ">\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        0.5 * xx1 + "\" y=\"15\">" + str1 + "</text>\n" +
        "<text x=\"" + 0.5 * xx1 + "\" y=\"14\">" + str1 + "</text>\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        (xx1 + 0.5 * xx2) + "\" y=\"15\">" + str2 + "</text>\n" +
        "<text x=\"" + (xx1 + 0.5 * xx2) + "\" y=\"14\">" + str2 + "</text>\n" +
        "</g>\n" +
        "</svg>\n"
    );
};

local.templateRenderMyApp = function (template) {
/*
 * this function will render my-app template
 */
    template = template.replace((
        /kaizhu256(\.github\.io\/|%252F|\/)/g
    ), GITHUB_OWNER + "$1");
    template = template.replace((
        /node-my-app/g
    ), GITHUB_REPO);
    template = template.replace((
        /\bh1-my-app\b/g
    ), (
        npm_package_nameHeroku ||
        ("h1-" + npm_package_nameLib.replace((
            /_/g
        ), "-"))
    ));
    template = template.replace((
        /\bmy-app\b/g
    ), npm_package_name);
    template = template.replace((
        /my_app/g
    ), npm_package_nameLib);
    template = template.replace((
        /\{\{(\w+)(\u0020jsonStringify)?\}\}/g
    ), function (ignore, key, jsonStringify) {
        return String(
            jsonStringify
            ? JSON.stringify(local[key])
            : String(local[key])
        ).replace((
            /<\//g
        ), "<\\/");
    });
    return template;
};

local.testCase_noop_default = function (opt, onError) {
/*
 * this function will test noop's default handling-behavior
 */
    noop();
    onError(undefined, opt);
};

local.testMock = function (mockList, onTestCase, onError) {
/*
 * this function will mock objects in <mockList> when running <onTestCase>
 */
    let onError2;
    onError2 = function (err) {
        // restore mock[0] from mock[2]
        mockList.reverse().forEach(function (mock) {
            Object.keys(mock[2]).forEach(function (key) {
                try {
                    mock[0][key] = mock[2][key];
                } catch (errCaught) {
                    console.error(errCaught);
                }
            });
        });
        onError(err);
    };
    // suppress console.error and console.log
    mockList.unshift([
        console, {}
    ]);
    local.objectAssignDefault(mockList[0][1], {
        error: noop,
        log: noop
    });
    // mock mock[0]
    mockList.forEach(function (mock) {
        mock[2] = {};
        // backup mock[0] into mock[2]
        Object.keys(mock[1]).forEach(function (key) {
            mock[2][key] = mock[0][key];
        });
        // override mock[0] with mock[1]
        Object.keys(mock[1]).forEach(function (key) {
            try {
                mock[0][key] = mock[1][key];
            } catch (errCaught) {
                console.error(errCaught);
            }
        });
    });
    // try to run onTestCase with mock[0]
    try {
        // run onTestCase
        onTestCase(onError2);
    } catch (errCaught) {
        onError2(errCaught);
    }
};

local.testReportMerge = function (
    testReport = {},
    testReport2 = {},
    mode = undefined
) {
/*
 * this function will
 * 1. merge <testReport2> into <testReport>
 * 2. render <testReport>.html
 * 3. write <testReport> to fs
 */
    let html;
    let testCaseNumber;
    let testPlatformDict;
    let testPlatformList;
    function fileWrite(file, data) {
    /*
     * this function will write <data> to <file>
     */
        file = require("path").resolve(UTILITY2_DIR_BUILD + "/" + file);
        require("fs").writeFileSync(file, data);
        console.error("test-report - wrote - " + file);
    }
    // 1. merge <testReport2> into <testReport>
    testReport = local.objectAssignDefault(testReport, {
        coverage: globalThis.__coverage__,
        date: new Date().toISOString(),
        testPlatformList: [
            {}
        ]
    });
    testPlatformDict = {};
    // deduplicate testPlatform with same name
    testPlatformList = [].concat(
        testReport.testPlatformList,
        testReport2.testPlatformList || []
    ).reverse().map(function (testPlatform) {
        local.objectAssignDefault(testPlatform, {
            date: new Date().toISOString(),
            modeBuild: MODE_CI,
            nameBase: (
                isEnvNode
                ? "node - " + process.platform + " - " + process.version
                : "browser - " + location.pathname + " - " + navigator.userAgent
            ),
            status: "pending",
            testCaseList: [],
            testsFailed: 0,
            testsPassed: 0,
            testsPending: 0,
            timeElapsed: 0,
            timeOnload: (
                globalThis.domOnEventWindowOnloadTimeElapsed < 0x10000000000 &&
                globalThis.domOnEventWindowOnloadTimeElapsed | 0
            ),
            timeStart: 0
        });
        testPlatform.name = (
            testPlatform.modeBuild + " - " + testPlatform.nameBase
        );
        testPlatformDict[testPlatform.name] = testPlatform;
        return testPlatform;
    }).slice(-1);
    delete testPlatformDict[testPlatformList[0].name];
    testPlatformList = [
        testPlatformList[0]
    ].concat(Object.values(testPlatformDict).sort(function (aa, bb) {
        return (
            aa.date < bb.date
            ? 1
            : -1
        );
    }));
    Object.assign(testReport, {
        testsFailed: 0,
        testsPassed: 0,
        testsPending: 0
    });
    testPlatformList.forEach(function (testPlatform) {
        Object.assign(testPlatform, {
            testsFailed: 0,
            testsPassed: 0,
            testsPending: 0
        });
        testPlatform.testCaseList.forEach(function ({
            status
        }) {
            switch (status) {
            // update failed tests
            case "failed":
                testPlatform.testsFailed += 1;
                testReport.testsFailed += 1;
                break;
            // update passed tests
            case "passed":
                testPlatform.testsPassed += 1;
                testReport.testsPassed += 1;
                break;
            // update pending tests
            default:
                testPlatform.testsPending += 1;
                testReport.testsPending += 1;
            }
        });
        // update testPlatform.status
        testPlatform.status = (
            testPlatform.testsFailed
            ? "failed"
            : testPlatform.testsPending
            ? "pending"
            : "passed"
        );
        // sort testCaseList by status and name
        testPlatform.testCaseList.sort(function (aa, bb) {
            return (
                (aa.status.replace("passed", "z") + aa.name) >
                (bb.status.replace("passed", "z") + bb.name)
                ? 1
                : -1
            );
        });
    });
    // 2. render <testReport>.html
    testCaseNumber = 0;
    html = local.assetsDict["/assets.utility2.template.html"];
    html = html.replace("assets.utility2.template.html", "");
    html = html.replace((
        /<title>.*?<\/title>/
    ), "<title>test-report</title>");
    // init html - style
    html = html.replace((
        "\n</style>\n"
    ), (
        "\n" +
        "</style>\n" +
        "<style>\n" +
        "/* jslint utility2:true */\n" +
        ".test-report-div img {\n" +
        "    border: 1px solid #999;\n" +
        "    margin: 5px 0 5px 0;\n" +
        "    max-height: 256px;\n" +
        "    max-width: 512px;\n" +
        "}\n" +
        ".test-report-div pre {\n" +
        "    background: #fdd;\n" +
        "    border-top: 1px solid #999;\n" +
        "    margin-bottom: 0;\n" +
        "    padding: 10px;\n" +
        "}\n" +
        ".test-report-div span {\n" +
        "    display: inline-block;\n" +
        "    width: 120px;\n" +
        "}\n" +
        ".test-report-div table {\n" +
        "    border-top: 1px solid #999;\n" +
        "    text-align: left;\n" +
        "    width: 100%;\n" +
        "}\n" +
        ".test-report-div table > tbody > tr:nth-child(odd) {\n" +
        "    background: #bfb;\n" +
        "}\n" +
        ".test-report-div .footer {\n" +
        "    text-align: center;\n" +
        "}\n" +
        ".test-report-div .platform {\n" +
        "    background: #fff;\n" +
        "    border: 1px solid #999;\n" +
        "    margin-bottom: 20px;\n" +
        "    padding: 0 10px 10px 10px;\n" +
        "    text-align: left;\n" +
        "}\n" +
        ".test-report-div .summary {\n" +
        "    background: #bfb;\n" +
        "}\n" +
        ".test-report-div .test-failed {\n" +
        "    background: #f99;\n" +
        "}\n" +
        ".test-report-div .test-pending {\n" +
        "    background: #99f;\n" +
        "}\n" +
        "</style>\n"
    ));
    // init html - body
    html = html.replace((
        /\n<\/script>[\S\s]*?<\/body>\n/
    ), function () {
        return (
            "\n" +
            "</script>\n" +
            "<div class=\"test-report-div\">\n" +
            // init html - header
            "<h1>test-report for\n" +
            "    <a href=\"" + (npm_package_homepage || "#") + "\">\n" +
            "    " + npm_package_name + " (" + npm_package_version + ")\n" +
            "    </a>\n" +
            "</h1>\n" +
            "\n" +
            // init html - summary
            "<div class=\"platform summary\">\n" +
            "<h2>summary</h2>\n" +
            "<h4>\n" +
            "    <span>version</span>- " + npm_package_version + "<br>\n" +
            "    <span>test-date</span>- " + testReport.date + "<br>\n" +
            "    <span>commit-info</span>- " +
            CI_COMMIT_ID + " - " + CI_COMMIT_MESSAGE + "<br>\n" +
            "</h4>\n" +
            "<table>\n" +
            "<thead>\n" +
            "    <tr>\n" +
            "    <th>total tests-failed</th>\n" +
            "    <th>total tests-passed</th>\n" +
            "    <th>total tests-pending</th>\n" +
            "    </tr>\n" +
            "</thead>\n" +
            "<tbody>\n" +
            "    <tr>\n" +
            "    <td class=\"" + (
                testReport.testsFailed
                ? "testFailed"
                : "testPassed"
            ) + "\">" + testReport.testsFailed + "</td>\n" +
            "    <td>" + testReport.testsPassed + "</td>\n" +
            "    <td>" + testReport.testsPending + "</td>\n" +
            "    </tr>\n" +
            "</tbody>\n" +
            "</table>\n" +
            "</div>\n" +
            "\n" +
            // init html - testPlatformList
            testPlatformList.map(function ({
                date,
                name,
                screenshot,
                testCaseList,
                testsFailed,
                testsPassed,
                testsPending,
                timeElapsed,
                timeOnload
            }, ii) {
                let errStackList;
                errStackList = [];
                screenshot = screenshot && encodeURIComponent(screenshot);
                return (
                    "<div class=\"platform\">\n" +
                    "<h4>\n" +
                    (ii + 1) + ". " + name + "<br>\n" + (
                        screenshot
                        ? "<a href=\"" + screenshot + "\">\n" +
                        "<img\n" +
                        "alt=\"" + screenshot + "\"\n" +
                        "src=\"" + screenshot + "\"\n" +
                        ">\n" +
                        "</a>\n" +
                        "<br>\n"
                        : ""
                    ) + (
                        timeOnload
                        ? "<span>onload-time</span>- " +
                        timeOnload +
                        " ms<br>\n"
                        : ""
                    ) +
                    "<span>test-date</span>- " + date + "<br>\n" +
                    "<span>time-elapsed</span>- " + timeElapsed + " ms<br>\n" +
                    "<span>tests-failed</span>- " + testsFailed + "<br>\n" +
                    "<span>tests-passed</span>- " + testsPassed + "<br>\n" +
                    "<span>tests-pending</span>- " + testsPending + "<br>\n" +
                    "</h4>\n" +
                    "\n" +
                    // init html - testCaseList
                    "<table>\n" +
                    "<thead><tr>\n" +
                    "<th>#</th>\n" +
                    "<th>time-elapsed</th>\n" +
                    "<th>status</th>\n" +
                    "<th>test-case</th>\n" +
                    "</tr></thead>\n" +
                    "<tbody>\n" +
                    testCaseList.map(function ({
                        errStack,
                        name,
                        status,
                        timeElapsed
                    }) {
                        testCaseNumber += 1;
                        if (errStack) {
                            errStackList.push(
                                testCaseNumber + ". " + name + "\n" +
                                errStack
                            );
                        }
                        return (
                            "<tr>\n" +
                            "<td>" + testCaseNumber + "</td>\n" +
                            "<td>" + timeElapsed + " ms</td>\n" +
                            "<td class=\"test-" + status + "\">" +
                            status + "</td>\n" +
                            "<td>" + name + "</td>\n" +
                            "</tr>\n"
                        );
                    }).join("") +
                    "</tbody>\n" +
                    "</table>\n" +
                    "\n" + (
                        errStackList.length
                        ? "<pre tabIndex=\"0\">\n" +
                        errStackList.join("\n") + "\n" +
                        "</pre>\n"
                        : ""
                    ) +
                    "</div>\n"
                );
            }).join("") +
            "\n" +
            // init html - footer
            "<div class=\"footer\">\n" +
            "[ this document was created with <a\n" +
            "    href=\"https://github.com/kaizhu256/node-utility2\"\n" +
            "    target=\"_blank\"\n" +
            ">utility2</a> ]\n" +
            "</div>\n" +
            "\n" +
            "</div>\n" +
            "</body>\n"
        );
    });
    testReport = Object.assign(testReport, {
        html,
        testPlatformList
    });
    // 3. write <testReport> to fs
    if (mode !== "modeWrite") {
        return testReport;
    }
    delete testReport.coverage;
    delete testReport.html;
    // print test-report summary
    console.error(
        "\n" + new Array(56).join("-") + "\n" +
        testPlatformList.filter(function (testPlatform) {
            // if testPlatform has no tests, then filter it out
            return testPlatform.testCaseList.length;
        }).map(function (testPlatform) {
            return (
                "| test-report - " + testPlatform.name + "\n|" +
                String(
                    testPlatform.timeElapsed + " ms     "
                ).padStart(16, " ") +
                String(
                    testPlatform.testsFailed + " failed "
                ).padStart(16, " ") +
                String(
                    testPlatform.testsPassed + " passed "
                ).padStart(16, " ") +
                "     |\n" + new Array(56).join("-") + "\n"
            );
        }).join("")
    );
    // print failed testCase
    testPlatformList.forEach(function (testPlatform) {
        testPlatform.testCaseList.forEach(function (testCase) {
            if (testCase.status !== "passed") {
                console.error(JSON.stringify(testCase, undefined, 4));
            }
        });
    });
    // jslint html
    jslintAndPrint(html, "test-report.html");
    // create test-report.html
    fileWrite("test-report.html", html);
    // create commit.badge.svg
    fileWrite("commit.badge.svg", local.svgBadgeCreate({
        fill: "#07f",
        str1: "last build",
        str2: (
            new Date().toISOString().slice(0, 19).replace("T", " ") +
            " - " + CI_BRANCH + " - " + CI_COMMIT_ID
        )
    }));
    // create test-report.badge.svg
    fileWrite("test-report.badge.svg", local.svgBadgeCreate({
        fill: (
            testPlatformList[0].testsFailed
            ? "#d00"
            : "#0d0"
        ),
        str1: "tests failed",
        str2: testPlatformList[0].testsFailed
    }));
    // if tests failed, then exit with non-zero exitCode
    process.exit(testReport.testsFailed !== 0);
};

local.testRunDefault = async function (testCaseDict = {}) {
/*
 * this function will run tests in <testCaseDict>
 */
    let consoleError;
    let isCoverage;
    let processExit;
    let testPlatform;
    let testReport;
    let timerInterval;
    function timeElapsedPoll(opt) {
    /*
     * this function will poll "Date.now() - <opt>.timeStart"
     */
        opt.timeStart = opt.timeStart || Date.now();
        opt.timeElapsed = Date.now() - opt.timeStart;
    }
    async function testCaseRun(testCase) {
        let testCasePromise;
        let testCaseResolve;
        testCasePromise = new Promise(function (resolve) {
            testCaseResolve = resolve;
        });
        function onError(err) {
            // update testPlatform.timeElapsed
            timeElapsedPoll(testPlatform);
            // if testCase isDone, then fail testCase
            if (testCase.isDone) {
                err = err || new Error(
                    "callback in testCase " +
                    testCase.name +
                    " called multiple times"
                );
            }
            // if err occurred, then fail testCase
            if (err) {
                // restore console.log
                console.error = consoleError;
                testCase.status = "failed";
                consoleError(
                    "\ntestRunDefault - " +
                    testPlatform.timeElapsed + " ms - testCase failed - " +
                    testCase.name + "\n" + err.message + "\n" + err.stack
                );
                testCase.errStack = (
                    testCase.errStack || err.message + "\n" + err.stack
                );
                // validate errStack is non-empty
                assertOrThrow(
                    testCase.errStack,
                    "invalid errStack " + testCase.errStack
                );
            }
            // if tests isDone, then do nothing
            if (testCase.isDone) {
                return;
            }
            testCase.isDone = true;
            if (testCase.status === "pending") {
                testCase.status = "passed";
            }
            // stop testCase timer
            timeElapsedPoll(testCase);
            consoleError(
                "testRunDefault - " +
                testPlatform.timeElapsed + " ms - [" + (
                    isEnvNode
                    ? "node"
                    : "browser"
                ) + " test-case " +
                testPlatform.testCaseList.filter(function (testCase) {
                    return testCase.isDone;
                }).length + " of " + testPlatform.testCaseList.length
                + " " + testCase.status + "] - " + testCase.name
            );
            testCaseResolve();
        }
        try {
            timeElapsedPoll(testCase);
            testCase.onTestCase({}, onError);
            noop(await testCasePromise);
        } catch (errCaught) {
            onError(errCaught);
        }
    }
    if (npm_config_mode_lib) {
        return;
    }
    // init middlewareList
    local.middlewareList = local.middlewareList || [];
    // init http-server on $PORT
    if (isEnvNode && !globalThis.utility2_serverHttp1) {
        globalThis.utility2_serverHttp1 = require("http").createServer(
            local.serverRequestListener
        );
        console.error("http-server listening on port " + PORT);
        local.onReadyIncrement();
        globalThis.utility2_serverHttp1.listen(PORT, local.onReadyDecrement);
    }
    globalThis.utility2_modeTest = (
        globalThis.utility2_modeTest ||
        testCaseDict.modeTest ||
        npm_config_mode_test
    ) | 0;
    if (
        globalThis.utility2_modeTest !== 1 ||
        Object.keys(testCaseDict).length === 0
    ) {
        return;
    }
    if (localOnReadyCnt !== 0) {
        local.eventListenerAdd("utility2.onReady", {
            once: true
        }, local.testRunDefault.bind(undefined, testCaseDict));
        return;
    }
    globalThis.utility2_modeTest += 1;
    // visual notification - testRun
    // mock console.error
    consoleError = console.error;
    isCoverage = (
        typeof globalThis.__coverage__ === "object" &&
        globalThis.__coverage__ &&
        Object.keys(globalThis.__coverage__).length
    );
    console.error = function (...argList) {
    /*
     * this function will ignore serverLog-msg during test-run
     */
        if (!isCoverage && !(
            /^serverLog\u0020-\u0020\{/
        ).test(argList[0])) {
            consoleError(...argList);
        }
    };
    // mock proces.exit
    if (isEnvNode) {
        processExit = process.exit;
        process.exit = function (exitCode) {
            local.eventListenerEmit(
                "utility2.testRunMock.process.exit",
                exitCode | 0
            );
        };
    }
    // init testReport
    testReport = globalThis.utility2_testReport;
    // init testPlatform
    testPlatform = testReport.testPlatformList[0];
    // init testPlatform timer
    timeElapsedPoll(testPlatform);
    // reset testPlatform.testCaseList
    testPlatform.testCaseList.length = 0;
    // add tests into testPlatform.testCaseList
    Object.entries(testCaseDict).forEach(function ([
        key, val
    ]) {
        // add testCase testCaseDict[key] to testPlatform.testCaseList
        if (
            key && typeof val === "function" && (
                npm_config_mode_test_case
                ? npm_config_mode_test_case.split(",").indexOf(key) >= 0
                : key.indexOf("testCase_") === 0
            )
        ) {
            testPlatform.testCaseList.push({
                name: key,
                status: "pending",
                onTestCase: val
            });
        }
    });
    local.testReportMerge(testReport);
    local.eventListenerEmit("utility2.testRunStart", testReport);
    // testRunUpdate every 2000 ms until isDone
    timerInterval = setInterval(function () {
        // update testPlatform.timeElapsed
        timeElapsedPoll(testPlatform);
        local.testReportMerge(testReport);
        local.eventListenerEmit("utility2.testRunUpdate", testReport);
        // cleanup timerInterval
        if (!testReport.testsPending) {
            clearInterval(timerInterval);
        }
        // list pending testCase every 5000 ms
        if (testPlatform.timeElapsed % 5000 < 3000) {
            consoleError(
                "testRunDefault - " +
                testPlatform.timeElapsed + " ms - testCase pending - " +
                testPlatform.testCaseList.filter(function (testCase) {
                    return testCase.status === "pending";
                }).slice(0, 4).map(function (testCase) {
                    return testCase.name;
                }).join(", ") + " ..."
            );
        }
    }, 2000);
    // run testCaseList
    await Promise.all(testPlatform.testCaseList.map(testCaseRun));
    clearInterval(timerInterval);
    // update timeElapsed
    timeElapsedPoll(testPlatform);
    // finalize testReport
    local.testReportMerge(testReport);
    // restore console.log
    console.error = consoleError;
    // restore process.exit
    if (processExit) {
        process.exit = processExit;
    }
    // create test-report.json
    delete testReport.coverage;
    local.fsWriteFileWithMkdirpSync(
        UTILITY2_DIR_BUILD + "/test-report.json",
        JSON.stringify(testReport, undefined, 4)
    );
    // reset utility2_modeTest
    globalThis.utility2_modeTest = 0;
    // save testReport and coverage
    testReport.coverage = globalThis.__coverage__;
    console.timeStamp(globalThis.utility2_testId);
    local.eventListenerEmit("utility2.testRunEnd", testReport);
    // exit with number of tests failed
    if (processExit) {
        process.exit(testReport.testsFailed, testReport);
    }
};

local.tryCatchOnError = function (fnc, onError) {
/*
 * this function will run <fnc> in tryCatch block,
 * else call onError with errCaught
 */
    let result;
    // validate onError
    local.assertOrThrow(typeof onError === "function", typeof onError);
    try {
        // reset errCaught
        delete local._debugTryCatchError;
        result = fnc();
        delete local._debugTryCatchError;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
};

local.uiAnimateSlideAccordian = function (elem, elemList, onError) {
/*
 * this function will slideDown <elem>, but slideUp elements in <elemList>
 */
    elemList.forEach(function (elem2) {
        if (elem2 !== elem) {
            local.uiAnimateSlideUp(elem2);
        }
    });
    setTimeout(function () {
        local.uiAnimateSlideDown(elem, onError);
    }, 250);
};

local.uiAnimateSlideDown = function (elem, onError) {
/*
 * this function will slideDown dom-<elem>
 */
    onError = onError || noop;
    if (!(
        elem &&
        elem.style && elem.style.maxHeight !== "100%" &&
        elem.classList && elem.classList.contains("uiAnimateSlide")
    )) {
        onError();
        return;
    }
    elem.style.borderBottom = "";
    elem.style.borderTop = "";
    elem.style.marginBottom = "";
    elem.style.marginTop = "";
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + "px";
    elem.style.paddingBottom = "";
    elem.style.paddingTop = "";
    setTimeout(function () {
        elem.style.maxHeight = "100%";
        onError();
    }, 250);
};

local.uiAnimateSlideUp = function (elem, onError) {
/*
 * this function will slideUp dom-<elem>
 */
    if (!(
        elem &&
        elem.style && elem.style.maxHeight !== "0px" &&
        elem.classList && elem.classList.contains("uiAnimateSlide")
    )) {
        local.setTimeoutOnError(onError);
        return;
    }
    elem.style.borderBottom = "0";
    elem.style.borderTop = "0";
    elem.style.marginBottom = "0";
    elem.style.marginTop = "0";
    elem.style.maxHeight = "0";
    elem.style.paddingBottom = "0";
    elem.style.paddingTop = "0";
    local.setTimeoutOnError(onError, 250);
};

local.urlJoin = function (aa, bb) {
/*
 * this function will if bb is relative, url-join aa with bb
 */
    // bb is absolute-url
    if ((
        /^\w+?:\/\//
    ).test(bb)) {
        return bb;
    }
    // bb is absolute-url without protocol
    if (bb.slice(0, 2) === "//") {
        return aa.split("/")[0] + bb;
    }
    // bb is absolute-url without host
    if (bb[0] === "/") {
        return aa.split("/").slice(0, 3).join("/") + bb;
    }
    // bb is relative-url
    if (aa.split("/").length < 4) {
        aa += "/";
    }
    return aa.replace((
        /[?#].*?$/
    ), "").replace((
        /[^\/]*?$/
    ), "") + bb;
};

local.uuid4Create = function () {
/*
 * this function will create random uuid with format
 * "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
 */
    // code derived from http://jsperf.com/uuid4
    let id;
    let ii;
    id = "";
    ii = 0;
    while (ii < 32) {
        switch (ii) {
        case 8:
        case 20:
            id += "-";
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
            break;
        case 12:
            id += "-";
            id += "4";
            break;
        case 16:
            id += "-";
            id += local.identity((Math.random() * 4) | 8).toString(16);
            break;
        default:
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
        }
        ii += 1;
    }
    return id;
};

/* validateLineSortedReset */
// run shared js-env code - init-after
// init utility2_testReport
globalThis.utility2_testReport = local.testReportMerge(
    globalThis.utility2_testReport
);
local.regexpCharsetEncodeUri = (
    /!#\$%&'\(\)\*\+,-\.\/0123456789:;=\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/
);
local.regexpCharsetEncodeUriComponent = (
    /!%'\(\)\*-\.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/
);
// https://www.w3.org/TR/html5/sec-forms.html#email-state-typeemail
local.regexpValidateEmail = (
    /^[a-zA-Z0-9.!#$%&'*+\/=?\^_`{|}~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/
);
// https://en.wikipedia.org/wiki/E.164
local.regexpValidatePhone = (
    /^(?:\+\d{1,3}[\u0020\-]?)?(?:\(\d{1,4}\)[\u0020\-]?)?\d[\d\u0020\-]{7,17}$/
);
local.regexpValidateUuid = (
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
);
local.stringCharsetAscii = (
    "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" +
    "\b\t\n\u000b\f\r\u000e\u000f" +
    "\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017" +
    "\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f" +
    " !\"#$%&'()*+,-./0123456789:;<=>?" +
    "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_" +
    "`abcdefghijklmnopqrstuvwxyz{|}~\u007f"
);
assertJsonEqual(
    local.stringCharsetAscii,
    Array.from(new Array(128), function (ignore, ii) {
        return String.fromCharCode(ii);
    }).join("")
);
local.stringCharsetEncodeUri = (
    "!#$%&'()*+,-./" +
    "0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
);
local.stringCharsetEncodeUriComponent = (
    "!%'()*-." +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
);
local.stringHelloEmoji = "hello \ud83d\ude01\n";


/* istanbul ignore next */
// run node js-env code - init-after
(function () {
if (!isEnvNode) {
    return;
}
// exit after $npm_config_timeout_exit
if (!npm_config_mode_lib && npm_config_timeout_exit) {
    setTimeout(process.exit.bind(undefined, 15), npm_config_timeout_exit);
}
// merge previous test-report
if (!npm_config_mode_lib && npm_config_mode_test_report_merge) {
    local.testReportMerge(
        globalThis.utility2_testReport,
        local.fsReadFileOrDefaultSync(
            UTILITY2_DIR_BUILD + "/test-report.json",
            "json",
            {}
        )
    );
    if (process.argv[2] !== "--help") {
        console.error(
            "\n" + MODE_CI + " - merged test-report from file " +
            UTILITY2_DIR_BUILD + "/test-report.json"
        );
    }
}
// init cli
local.cliDict = {};
local.cliDict["utility2.browserTest"] = async function () {
/*
 * <urlList> <mode>
 * will browser-test in parallel, comma-separated <urlList> with given <mode>
 */
    local.browserTest({
        url: process.argv[3]
    });
};

local.cliDict["utility2.testReportCreate"] = function () {
/*
 *
 * will create test-report
 */
    let testReport;
    try {
        testReport = JSON.parse(require("fs").readFileSync(
            UTILITY2_DIR_BUILD + "/test-report.json",
            "utf8"
        ));
    } catch (ignore) {}
    local.testReportMerge(testReport, {}, "modeWrite");
};

if (module === require.main && (!globalThis.utility2_rollup || (
    process.argv[2] &&
    local.cliDict[process.argv[2]] &&
    process.argv[2].indexOf("utility2.") === 0
))) {
    local.cliRun({});
    if (local.cliDict[process.argv[2]]) {
        switch (process.argv[2]) {
        case "--interactive":
        case "-i":
        case "utility2.start":
            break;
        default:
            return;
        }
    }
}
// override assets
if (globalThis.utility2_rollup) {
    local.assetsDict["/assets.utility2.rollup.js"] = (
        require("fs").readFileSync(
            __filename,
            "utf8"
        ).split("\n/* script-end /assets.utility2.rollup.end.js */")[0] +
        "\n/* script-end /assets.utility2.rollup.end.js */\n"
    );
    return;
}
// init assets
[
    "/assets.utility2.example.js",
    "/assets.utility2.html",
    "/assets.utility2.test.js",
    "lib.apidoc.js",
    "lib.istanbul.js",
    "lib.jslint.js",
    "lib.marked.js",
    "lib.utility2.js",
    "test.js"
].forEach(function (key) {
    switch (key) {
    case "/assets.utility2.example.js":
        local.assetsDict[key] = "";
        local.fsReadFileOrDefaultSync(
            __dirname + "/README.md",
            "utf8",
            ""
        ).replace((
            /```javascript([\S\s]*?)```/
        ), function (ignore, match1) {
            local.assetsDict[key] = match1.trim() + "\n";
            return "";
        });
        break;
    case "/assets.utility2.html":
        local.assetsDict[key] = "";
        local.fsReadFileOrDefaultSync(
            __dirname + "/README.md",
            "utf8",
            ""
        ).replace((
            /<!doctype\u0020html>[\S\s]*?<\/html>\\n\\\n/
        ), function (match0) {
            match0 = match0.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || "";
            });
            match0 = match0.replace(
                "<script src=\"assets.app.js\"></script>\n",
                (
                    "<script " +
                    "src=\"assets.utility2.rollup.js\"></script>\n" +
                    "<script " +
                    "src=\"assets.utility2.example.js\"></script>\n" +
                    "<script " +
                    "src=\"assets.utility2.test.js\"></script>\n"
                )
            );
            match0 = match0.replace(
                "assets.example.js",
                "assets.utility2.example.js"
            );
            match0 = match0.replace(
                "assets.test.js",
                "assets.utility2.test.js"
            );
            match0 = match0.replace((
                /npm_package_/g
            ), "");
            match0 = match0.replace((
                /<!--\u0020utility2-comment\b([\S\s]*?)\butility2-comment\u0020-->/g
            ), "$1");
            return "";
        });
        break;
    case "/assets.utility2.test.js":
        local.assetsDict[key] = local.fsReadFileOrDefaultSync(
            __dirname + "/test.js",
            "utf8",
            ""
        );
        break;
    case "lib.utility2.js":
        key = key.replace("lib.", "");
        local.assetsDict["/assets." + key] = local.fsReadFileOrDefaultSync(
            __dirname + "/lib." + key,
            "utf8",
            ""
        ).replace((
            /^#!\//
        ), "// ");
        break;
    default:
        local.assetsDict["/assets.utility2." + key] = (
            local.fsReadFileOrDefaultSync(
                __dirname + "/" + key,
                "utf8",
                ""
            ).replace((
                /^#!\//
            ), "// ")
        );
    }
});
/* validateLineSortedReset */
local.assetsDict["/assets.utility2.rollup.js"] = [
    "header",
    "/assets.utility2.rollup.start.js",
    "lib.apidoc.js",
    "lib.istanbul.js",
    "lib.jslint.js",
    "lib.marked.js",
    "lib.utility2.js",
    "/assets.utility2.example.js",
    "/assets.utility2.html",
    "/assets.utility2.lib.jslint.js",
    "/assets.utility2.test.js",
    "/assets.utility2.rollup.end.js"
].map(function (key) {
    let code;
    switch (key) {
    case "/assets.utility2.example.js":
    case "/assets.utility2.html":
    case "/assets.utility2.lib.jslint.js":
    case "/assets.utility2.test.js":
        // disable $-escape in replacement-string
        code = local.assetsDict[
            "/assets.utility2.rollup.content.js"
        ].replace("/* utility2.rollup.js content */", function () {
            return (
                "local.assetsDict[\"" + key + "\"] = (\n" +
                JSON.stringify(local.assetsDict[key]).replace((
                    /\\\\/g
                ), "\u0000").replace((
                    /\\n/g
                ), "\\n\\\n").replace((
                    /\u0000/g
                ), "\\\\") +
                ");\n"
            );
        });
        break;
    case "/assets.utility2.rollup.start.js":
    case "/assets.utility2.rollup.end.js":
        code = local.assetsDict[key];
        break;
    case "header":
        return (
            "/* this rollup was created with utility2\n" +
            " * https://github.com/kaizhu256/node-utility2\n" +
            " */\n"
        );
    case "lib.utility2.js":
        key = "/assets." + key.replace("lib.", "");
        code = local.assetsDict[key];
        break;
    default:
        key = "/assets.utility2." + key;
        code = local.assetsDict[key];
    }
    return (
        "/* script-begin " + key + " */\n" +
        code.trim() +
        "\n/* script-end " + key + " */\n"
    );
}).join("\n\n\n");
}());
}());
}());
/* script-end /assets.utility2.js */



/* script-begin /assets.utility2.example.js */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.example.js"] = (
"/*\n\
example.js\n\
\n\
this script will demo automated browser-tests with coverage\n\
(via puppeteer and istanbul)\n\
\n\
instruction\n\
    1. save this script as example.js\n\
    2. run the shell-command:\n\
        $ npm install utility2 && \\\n\
            PATH=\"$(pwd)/node_modules/.bin:$PATH\" \\\n\
            PORT=8081 \\\n\
            UTILITY2_DIR_BUILD=.tmp/build \\\n\
            npm_config_mode_coverage=utility2 \\\n\
            node_modules/.bin/utility2 test example.js\n\
    3. view test-report in .tmp/build/test-report.html\n\
    4. view coverage in .tmp/build/coverage/index.html\n\
*/\n\
\n\
\n\
/* istanbul instrument in package utility2 */\n\
// assets.utility2.header.js - start\n\
/* jslint utility2:true */\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-local\n\
(function () {\n\
    \"use strict\";\n\
    let isEnvNode;\n\
    let local;\n\
    // init debugInline\n\
    if (!globalThis.debugInline) {\n\
        let consoleError;\n\
        consoleError = console.error;\n\
        globalThis.debugInline = function (...argList) {\n\
        /*\n\
         * this function will both print <argList> to stderr and\n\
         * return <argList>[0]\n\
         */\n\
            consoleError(\"\\n\\ndebugInline\");\n\
            consoleError(...argList);\n\
            consoleError(\"\\n\");\n\
            return argList[0];\n\
        };\n\
    }\n\
    // init isEnvNode\n\
    isEnvNode = (\n\
        typeof process === \"object\" && process &&\n\
        process.versions && typeof process.versions.node === \"string\"\n\
    );\n\
    // init function\n\
    function objectDeepCopyWithKeysSorted(obj) {\n\
    /*\n\
     * this function will recursively deep-copy <obj> with keys sorted\n\
     */\n\
        let sorted;\n\
        if (typeof obj !== \"object\" || !obj) {\n\
            return obj;\n\
        }\n\
        // recursively deep-copy list with child-keys sorted\n\
        if (Array.isArray(obj)) {\n\
            return obj.map(objectDeepCopyWithKeysSorted);\n\
        }\n\
        // recursively deep-copy obj with keys sorted\n\
        sorted = {};\n\
        Object.keys(obj).sort().forEach(function (key) {\n\
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n\
        });\n\
        return sorted;\n\
    }\n\
    function assertJsonEqual(aa, bb) {\n\
    /*\n\
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)\n\
     */\n\
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n\
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n\
        if (aa !== bb) {\n\
            throw new Error(JSON.stringify(aa) + \" !== \" + JSON.stringify(bb));\n\
        }\n\
    }\n\
    function assertOrThrow(passed, msg) {\n\
    /*\n\
     * this function will throw <msg> if <passed> is falsy\n\
     */\n\
        if (passed) {\n\
            return;\n\
        }\n\
        throw (\n\
            (\n\
                msg &&\n\
                typeof msg.message === \"string\" &&\n\
                typeof msg.stack === \"string\"\n\
            )\n\
            // if msg is err, then leave as is\n\
            ? msg\n\
            : new Error(\n\
                typeof msg === \"string\"\n\
                // if msg is string, then leave as is\n\
                ? msg\n\
                // else JSON.stringify(msg)\n\
                : JSON.stringify(msg, undefined, 4)\n\
            )\n\
        );\n\
    }\n\
    function documentQuerySelectorAll(selector) {\n\
    /*\n\
     * this function will return document.querySelectorAll(<selector>) or\n\
     * empty list if function is not available\n\
     */\n\
        return Array.from(\n\
            (\n\
                typeof document === \"object\" && document &&\n\
                typeof document.querySelectorAll === \"function\"\n\
            )\n\
            ? document.querySelectorAll(selector)\n\
            : []\n\
        );\n\
    }\n\
    function identity(val) {\n\
    /*\n\
     * this function will return <val>\n\
     */\n\
        return val;\n\
    }\n\
    function noop() {\n\
    /*\n\
     * this function will do nothing\n\
     */\n\
        return;\n\
    }\n\
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n\
    /*\n\
     * this function will if items from <tgt> are null, undefined, or\n\
     * \"\", then overwrite them with items from <src>\n\
     */\n\
        function recurse(tgt, src, depth) {\n\
            Object.entries(src).forEach(function ([\n\
                key, bb\n\
            ]) {\n\
                let aa;\n\
                aa = tgt[key];\n\
                if (aa === undefined || aa === null || aa === \"\") {\n\
                    tgt[key] = bb;\n\
                    return;\n\
                }\n\
                if (\n\
                    depth !== 0 &&\n\
                    typeof aa === \"object\" && aa && !Array.isArray(aa) &&\n\
                    typeof bb === \"object\" && bb && !Array.isArray(bb)\n\
                ) {\n\
                    recurse(aa, bb, depth - 1);\n\
                }\n\
            });\n\
        }\n\
        recurse(tgt, src, depth | 0);\n\
        return tgt;\n\
    }\n\
    function onErrorThrow(err) {\n\
    /*\n\
     * this function will throw <err> if exists\n\
     */\n\
        if (err) {\n\
            throw err;\n\
        }\n\
    }\n\
    // init local\n\
    local = {\n\
        assertJsonEqual,\n\
        assertOrThrow,\n\
        documentQuerySelectorAll,\n\
        identity,\n\
        isEnvNode,\n\
        local,\n\
        noop,\n\
        objectAssignDefault,\n\
        objectDeepCopyWithKeysSorted,\n\
        onErrorThrow\n\
    };\n\
    globalThis.globalLocal = local;\n\
}());\n\
// assets.utility2.header.js - end\n\
\n\
\n\
/* jslint utility2:true */\n\
(function (local) {\n\
\"use strict\";\n\
\n\
\n\
// run shared js-env code - init-before\n\
(function () {\n\
// init local\n\
local = (\n\
    globalThis.utility2_rollup ||\n\
    globalThis.utility2_utility2 ||\n\
    require(\"utility2\")\n\
);\n\
// init exports\n\
globalThis.local = local;\n\
}());\n\
\n\
\n\
// run shared js-env code - function\n\
(function () {\n\
// init assets\n\
local.assetsDict[\"/assets.hello.txt\"] = \"hello \\ud83d\\ude01\\n\";\n\
local.assetsDict[\"/assets.index.template.html\"] = \"\";\n\
\n\
local.testCase_httpFetch_200 = async function (opt, onError) {\n\
/*\n\
 * this function will test httpFetch's \"200 ok\" handling-behavior\n\
 */\n\
    // test httpFetch-path \"assets.hello.txt\"\n\
    opt = await local.httpFetch(\"assets.hello.txt\");\n\
    // validate status is 200\n\
    local.assertJsonEqual(opt.status, 200);\n\
    // validate responseText\n\
    local.assertJsonEqual(await opt.text(), \"hello \\ud83d\\ude01\\n\");\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_httpFetch_404 = async function (opt, onError) {\n\
/*\n\
 * this function will test httpFetch's \"404 not found\" handling-behavior\n\
 */\n\
    // test httpFetch-path \"undefined\"\n\
    opt = await local.httpFetch(\"assets.hello.txt\");\n\
    // validate status is 200 - should fail\n\
    local.assertJsonEqual(opt.status, 200);\n\
    onError();\n\
};\n\
\n\
local.testCase_webpage_default = async function (opt, onError) {\n\
/*\n\
 * this function will test webpage's default handling-behavior\n\
 */\n\
    if (!local.isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    await local.browserTest({\n\
        url: \"http://127.0.0.1:\" + process.env.PORT + \"/?npm_config_mode_test=1\"\n\
    });\n\
    onError(undefined, opt);\n\
};\n\
\n\
// run tests\n\
if (local.isEnvNode && process.env.npm_config_mode_test) {\n\
    local.testRunDefault(local);\n\
}\n\
}());\n\
\n\
\n\
/* istanbul ignore next */\n\
// run browser js-env code - init-test\n\
(function () {\n\
if (local.isEnvNode) {\n\
    return;\n\
}\n\
// log stderr and stdout to #outputStdout1\n\
[\"error\", \"log\"].forEach(function (key) {\n\
    let elem;\n\
    let fnc;\n\
    elem = document.querySelector(\"#outputStdout1\");\n\
    if (!elem) {\n\
        return;\n\
    }\n\
    fnc = console[key];\n\
    console[key] = function (...argList) {\n\
        fnc(...argList);\n\
        // append text to #outputStdout1\n\
        elem.textContent += argList.map(function (arg) {\n\
            return (\n\
                typeof arg === \"string\"\n\
                ? arg\n\
                : JSON.stringify(arg, undefined, 4)\n\
            );\n\
        }).join(\" \").replace((\n\
            /\\u001b\\[\\d+?m/g\n\
        ), \"\") + \"\\n\";\n\
        // scroll textarea to bottom\n\
        elem.scrollTop = elem.scrollHeight;\n\
    };\n\
});\n\
}());\n\
\n\
\n\
/* istanbul ignore next */\n\
// run node js-env code - init-test\n\
(function () {\n\
if (!local.isEnvNode) {\n\
    return;\n\
}\n\
// init exports\n\
module.exports = local;\n\
// init assetsDict\n\
local.assetsDict = local.assetsDict || {};\n\
local.assetsDict[\"/assets.utility2.js\"] = (\n\
    local.assetsDict[\"/assets.utility2.js\"] ||\n\
    require(\"fs\").readFileSync(\n\
        require(\"path\").resolve(local.__dirname + \"/lib.utility2.js\"),\n\
        \"utf8\"\n\
    ).replace((\n\
        /^#!\\//\n\
    ), \"// \")\n\
);\n\
/* validateLineSortedReset */\n\
/* jslint ignore:start */\n\
local.assetsDict[\"/\"] = `<!doctype html>\n\
<html lang=\"en\">\n\
<head>\n\
<meta charset=\"utf-8\">\n\
<meta\n\
    content=\"width=device-width, initial-scale=1\"\n\
    name=\"viewport\"\n\
>\n\
<!-- \"assets.utility2.template.html\" -->\n\
<title>utility2 (2020.12.3)</title>\n\
<style>\n\
/* jslint utility2:true */\n\
/*csslint\n\
*/\n\
/* csslint ignore:start */\n\
*,\n\
*:after,\n\
*:before {\n\
    box-sizing: border-box;\n\
}\n\
.uiAnimateSlide {\n\
    overflow-y: hidden;\n\
    transition:\n\
        max-height ease-in 250ms,\n\
        min-height ease-in 250ms,\n\
        padding-bottom ease-in 250ms,\n\
        padding-top ease-in 250ms;\n\
}\n\
/* csslint ignore:end */\n\
@keyframes uiAnimateSpin {\n\
0% {\n\
    transform: rotate(0deg);\n\
}\n\
100% {\n\
    transform: rotate(360deg);\n\
}\n\
}\n\
a {\n\
    overflow-wrap: break-word;\n\
}\n\
body {\n\
    background: #f7f7f7;\n\
    font-family: Arial, Helvetica, sans-serif;\n\
    font-size: small;\n\
    margin: 0 40px;\n\
}\n\
body > div,\n\
body > input,\n\
body > pre,\n\
body > .button,\n\
body > .textarea {\n\
    margin-bottom: 20px;\n\
    margin-top: 0;\n\
}\n\
body > input,\n\
body > .button {\n\
    width: 20rem;\n\
}\n\
body > .readonly {\n\
    background: #ddd;\n\
}\n\
body > .textarea {\n\
    height: 10rem;\n\
    resize: vertical;\n\
    width: 100%;\n\
}\n\
code,\n\
pre,\n\
.textarea {\n\
    font-family: Consolas, Menlo, monospace;\n\
    font-size: smaller;\n\
}\n\
pre {\n\
    overflow-wrap: break-word;\n\
    white-space: pre-wrap;\n\
}\n\
.button {\n\
    background: #ddd;\n\
    border: 1px solid #999;\n\
    color: #000;\n\
    cursor: pointer;\n\
    display: inline-block;\n\
    padding: 2px 5px;\n\
    text-align: center;\n\
    text-decoration: none;\n\
}\n\
.button:hover {\n\
    background: #bbb;\n\
}\n\
.colorError {\n\
    color: #d00;\n\
}\n\
.textarea {\n\
    background: #fff;\n\
    border: 1px solid #999;\n\
    border-radius: 0;\n\
    cursor: auto;\n\
    overflow: auto;\n\
    padding: 2px;\n\
}\n\
.zeroPixel {\n\
    border: 0;\n\
    height: 0;\n\
    margin: 0;\n\
    padding: 0;\n\
    width: 0;\n\
}\n\
</style>\n\
</head>\n\
<body>\n\
<div class=\"uiAnimateSpin\" style=\"\n\
    animation: uiAnimateSpin 2s linear infinite;\n\
    border-radius: 50%;\n\
    border-top: 5px solid #7d7;\n\
    border: 5px solid #999;\n\
    display: none;\n\
    height: 25px;\n\
    vertical-align: middle;\n\
    width: 25px;\n\
\"></div>\n\
<script>\n\
/* jslint utility2:true */\n\
(function () {\n\
    \"use strict\";\n\
    // polyfill globalThis\n\
    window.globalThis = window;\n\
    // measure-and-print time-elapsed for window.onload\n\
    if (!window.domOnEventWindowOnloadTimeElapsed) {\n\
        window.domOnEventWindowOnloadTimeElapsed = Date.now() + 100;\n\
        window.addEventListener(\"load\", function () {\n\
            setTimeout(function () {\n\
                window.domOnEventWindowOnloadTimeElapsed = (\n\
                    Date.now() -\n\
                    window.domOnEventWindowOnloadTimeElapsed\n\
                );\n\
                console.error(\n\
                    \"domOnEventWindowOnloadTimeElapsed = \" +\n\
                    window.domOnEventWindowOnloadTimeElapsed\n\
                );\n\
            }, 100);\n\
        });\n\
    }\n\
    // limit select-all within <pre tabIndex=\"0\"> elem\n\
    if (!window.domOnEventSelectAllWithinPre) {\n\
        window.domOnEventSelectAllWithinPre = function (evt) {\n\
            let range;\n\
            let selection;\n\
            if (\n\
                (evt.ctrlKey || evt.metaKey) &&\n\
                evt.key === \"a\" &&\n\
                evt.target.closest(\"pre\")\n\
            ) {\n\
                range = document.createRange();\n\
                range.selectNodeContents(evt.target.closest(\"pre\"));\n\
                selection = window.getSelection();\n\
                selection.removeAllRanges();\n\
                selection.addRange(range);\n\
                evt.preventDefault();\n\
            }\n\
        };\n\
        // handle evt\n\
        document.addEventListener(\n\
            \"keydown\",\n\
            window.domOnEventSelectAllWithinPre\n\
        );\n\
    }\n\
}());\n\
</script>\n\
<h1>\n\
<a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">\n\
    utility2 (2020.12.3)\n\
</a>\n\
</h1>\n\
<h3>this zero-dependency package will provide high-level functions to to build, test, and deploy webapps</h3>\n\
<a\n\
    class=\"button\" download href=\"assets.app.js\"\n\
>download standalone app</a><br>\n\
<button\n\
    class=\"button\"\n\
    id=\"buttonTestRun1\"\n\
>run browser-tests</button><br>\n\
<div class=\"uiAnimateSlide\" id=\"htmlTestReport1\" style=\"\n\
    border-bottom: 0;\n\
    border-top: 0;\n\
    margin-bottom: 0;\n\
    margin-top: 0;\n\
    max-height: 0;\n\
    padding-bottom: 0;\n\
    padding-top: 0;\n\
\"></div>\n\
\n\
\n\
<!-- custom-html-start -->\n\
<label>edit or paste script below to cover and test</label>\n\
<textarea\n\
    class=\"textarea\"\n\
    id=\"inputTextarea1\">\n\
// remove comment below to disable jslint\n\
/*jslint browser, devel*/\n\
/*global window*/\n\
(function () {\n\
    \"use strict\";\n\
    let local = window.utility2;\n\
    let testCaseDict = {\n\
        modeTest: 1\n\
    };\n\
\n\
    // comment this testCase to disable failed error demo\n\
    testCaseDict.testCase_failed_error_demo = function (opt, onError) {\n\
    /*\n\
     * this function will run a failed error demo\n\
     */\n\
        onError(new Error(\"this is a failed error demo\"), opt);\n\
    };\n\
\n\
    testCaseDict.testCase_passed_http_fetch_demo = function (opt, onError) {\n\
    /*\n\
     * this function will demo a passed http-fetch test\n\
     */\n\
        // fetch main-page \"/\"\n\
        window.fetch(\"/\").then(function (res) {\n\
            // validate \"200 ok\" status\n\
            local.assertOrThrow(res.status === 200, res.status);\n\
            return res.text();\n\
        }).then(function (data) {\n\
            // validate non-empty data\n\
            local.assertOrThrow(data && data.length > 0, data);\n\
            onError(undefined, opt);\n\
        // handle err\n\
        }).catch(onError);\n\
    };\n\
\n\
    // create coverage-report\n\
    local.eventListenerAdd(\"utility2.testRunEnd\", {}, function () {\n\
        document.querySelector(\n\
            \"#htmlCoverageReport1\"\n\
        ).innerHTML = local.coverageReportCreate({});\n\
    });\n\
\n\
    // run tests\n\
    if (!(\n\
        /\\bnpm_config_mode_test=1\\b/\n\
    ).test(location.search)) {\n\
        local.testRunDefault(testCaseDict);\n\
    }\n\
}());\n\
</textarea>\n\
<button\n\
    class=\"button\"\n\
    id=\"buttonJslintAutofix1\"\n\
>jslint autofix</button><br>\n\
<pre class= \"colorError\" id=\"outputJslintPre1\" tabindex=\"0\"></pre>\n\
<label>instrumented-code</label>\n\
<textarea\n\
    class=\"readonly textarea\"\n\
    id=\"outputTextarea1\"\n\
    readonly\n\
    tabindex=\"0\"\n\
></textarea>\n\
<label>stderr and stdout</label>\n\
<textarea\n\
    class=\"onevent-output-reset readonly textarea\"\n\
    id=\"outputStdout1\"\n\
    readonly\n\
></textarea>\n\
<div id=\"htmlCoverageReport1\"></div>\n\
<script>\n\
/* jslint utility2:true */\n\
/*jslint eval*/\n\
window.addEventListener(\"load\", function () {\n\
    \"use strict\";\n\
    let local;\n\
    function testRun(evt) {\n\
        // jslint #inputTextarea1\n\
        local.jslintAndPrint(document.querySelector(\n\
            \"#inputTextarea1\"\n\
        ).value, \"inputTextarea1.js\", {\n\
            modeAutofix: evt.target.id === \"buttonJslintAutofix1\",\n\
            modeConditional: evt.target.id !== \"buttonJslintAutofix1\"\n\
        });\n\
        document.querySelector(\n\
            \"#outputJslintPre1\"\n\
        ).textContent = local.jslint.jslintResult.errMsg.replace((\n\
            /\\\\u001b\\\\[\\\\d*m/g\n\
        ), \"\").trim();\n\
        // jslint-autofix #inputTextarea1\n\
        if (local.jslint.jslintResult.autofix) {\n\
            document.querySelector(\n\
                \"#inputTextarea1\"\n\
            ).value = local.jslint.jslintResult.code;\n\
        }\n\
        // try to cleanup __coverage__\n\
        try {\n\
            delete globalThis.__coverage__[\"/inputTextarea1.js\"];\n\
        } catch (ignore) {}\n\
        // try to cover and eval #inputTextarea1\n\
        try {\n\
            document.querySelector(\n\
                \"#outputTextarea1\"\n\
            ).value = local.istanbul.instrumentSync(\n\
                document.querySelector(\"#inputTextarea1\").value,\n\
                \"/inputTextarea1.js\"\n\
            );\n\
            eval(\n\
                document.querySelector(\"#outputTextarea1\").value\n\
            );\n\
        } catch (errCaught) {\n\
            console.error(errCaught);\n\
        }\n\
    }\n\
    // init local\n\
    local = window.utility2;\n\
    // init evt-handling\n\
    document.querySelector(\n\
        \"#buttonJslintAutofix1\"\n\
    ).addEventListener(\"click\", testRun);\n\
    document.querySelector(\n\
        \"#inputTextarea1\"\n\
    ).addEventListener(\"keyup\", testRun);\n\
    // testRun\n\
    testRun({\n\
        target: {}\n\
    });\n\
});\n\
</script>\n\
<!-- custom-html-end -->\n\
\n\
\n\
<script>\n\
window.utility2_state = {\n\
npm_config_mode_backend: undefined,\n\
npm_package_description: \"this zero-dependency package will provide high-level functions to to build, test, and deploy webapps\",\n\
npm_package_homepage: \"https://github.com/kaizhu256/node-utility2\",\n\
npm_package_name: \"utility2\",\n\
npm_package_nameLib: \"utility2\",\n\
npm_package_version: \"2020.12.3\"\n\
}\n\
</script>\n\
<script src=\"assets.utility2.lib.istanbul.js\"></script>\n\
<script src=\"assets.utility2.lib.jslint.js\"></script>\n\
<script src=\"assets.utility2.lib.marked.js\"></script>\n\
<script src=\"assets.utility2.js\"></script>\n\
<script>\n\
/* jslint utility2:true */\n\
window.utility2.onReadyIncrement();\n\
window.addEventListener(\"load\", function () {\n\
    \"use strict\";\n\
    let local;\n\
    function onTestRun({\n\
        msg,\n\
        target,\n\
        type\n\
    }) {\n\
        switch ((target && target.id) || type) {\n\
        case \"buttonTestRun1\":\n\
            window.utility2_modeTest = 1;\n\
            local.testRunDefault(window.local);\n\
            return;\n\
        case \"utility2.testRunEnd\":\n\
            document.querySelectorAll(\n\
                \"#buttonTestRun1\"\n\
            ).forEach(function (elem) {\n\
                elem.textContent = \"run tests\";\n\
            });\n\
            document.querySelectorAll(\n\
                \"#htmlTestReport1\"\n\
            ).forEach(function (elem) {\n\
                elem.innerHTML = msg.html;\n\
            });\n\
            return;\n\
        case \"utility2.testRunStart\":\n\
            document.querySelectorAll(\n\
                \".onevent-output-reset\"\n\
            ).forEach(function (elem) {\n\
                elem.textContent = \"\";\n\
            });\n\
            document.querySelectorAll(\n\
                \"#buttonTestRun1\"\n\
            ).forEach(function (elem) {\n\
                elem.textContent = \"running tests\";\n\
            });\n\
            document.querySelectorAll(\n\
                \"#htmlTestReport1\"\n\
            ).forEach(function (elem) {\n\
                local.uiAnimateSlideDown(elem);\n\
                elem.innerHTML = msg.html;\n\
            });\n\
            return;\n\
        case \"utility2.testRunUpdate\":\n\
            document.querySelectorAll(\n\
                \"#htmlTestReport1\"\n\
            ).forEach(function (elem) {\n\
                local.uiAnimateSlideDown(elem);\n\
                elem.innerHTML = msg.html;\n\
            });\n\
            return;\n\
        }\n\
    }\n\
    local = window.utility2;\n\
    document.querySelectorAll(\n\
        \"#buttonTestRun1\"\n\
    ).forEach(function (elem) {\n\
        elem.addEventListener(\"click\", onTestRun);\n\
    });\n\
    local.eventListenerAdd(\"utility2.testRunEnd\", {}, onTestRun);\n\
    local.eventListenerAdd(\"utility2.testRunUpdate\", {}, onTestRun);\n\
    local.eventListenerAdd(\"utility2.testRunStart\", {}, onTestRun);\n\
    local.onReadyDecrement();\n\
});\n\
</script>\n\
\n\
<script src=\"assets.example.js\"></script>\n\
<script src=\"assets.test.js\"></script>\n\
<div style=\"text-align: center;\">\n\
    [\n\
    this app was created with\n\
    <a\n\
        href=\"https://github.com/kaizhu256/node-utility2\"\n\
        target=\"_blank\"\n\
    >utility2</a>\n\
    ]\n\
</div>\n\
</body>\n\
</html>\n\
`;\n\
/* jslint ignore:end */\n\
local.assetsDict[\"/assets.example.html\"] = local.assetsDict[\"/\"];\n\
// init cli\n\
if (module !== require.main || globalThis.utility2_rollup) {\n\
    return;\n\
}\n\
local.assetsDict[\"/assets.example.js\"] = (\n\
    local.assetsDict[\"/assets.example.js\"] ||\n\
    require(\"fs\").readFileSync(__filename, \"utf8\")\n\
);\n\
local.assetsDict[\"/favicon.ico\"] = local.assetsDict[\"/favicon.ico\"] || \"\";\n\
local.assetsDict[\"/index.html\"] = local.assetsDict[\"/\"];\n\
// if $npm_config_timeout_exit exists,\n\
// then exit this process after $npm_config_timeout_exit ms\n\
if (process.env.npm_config_timeout_exit) {\n\
    setTimeout(\n\
        process.exit.bind(undefined, 15),\n\
        process.env.npm_config_timeout_exit | 0\n\
    ).unref();\n\
}\n\
// start server\n\
if (globalThis.utility2_serverHttp1) {\n\
    return;\n\
}\n\
process.env.PORT = process.env.PORT || \"8081\";\n\
console.error(\"http-server listening on port \" + process.env.PORT);\n\
require(\"http\").createServer(function (req, res) {\n\
    let data;\n\
    data = local.assetsDict[require(\"url\").parse(req.url).pathname];\n\
    if (data !== undefined) {\n\
        res.end(data);\n\
        return;\n\
    }\n\
    res.statusCode = 404;\n\
    res.end();\n\
}).listen(process.env.PORT);\n\
}());\n\
}());\n\
");

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.utility2.example.js */



/* script-begin /assets.utility2.html */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.html"] = (
"");

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.utility2.html */



/* script-begin /assets.utility2.lib.jslint.js */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.lib.jslint.js"] = (
"// usr/bin/env node\n\
/*\n\
 * lib.jslint.js (2020.11.3)\n\
 * https://github.com/kaizhu256/node-jslint-lite\n\
 * this zero-dependency package will provide browser-compatible versions of jslint (v2020.7.2) and csslint (v2018.2.25), with working web-demo\n\
 *\n\
 */\n\
\n\
\n\
/* istanbul instrument in package jslint */\n\
// assets.utility2.header.js - start\n\
/* jslint utility2:true */\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-local\n\
(function () {\n\
    \"use strict\";\n\
    let isEnvNode;\n\
    let local;\n\
    // init debugInline\n\
    if (!globalThis.debugInline) {\n\
        let consoleError;\n\
        consoleError = console.error;\n\
        globalThis.debugInline = function (...argList) {\n\
        /*\n\
         * this function will both print <argList> to stderr and\n\
         * return <argList>[0]\n\
         */\n\
            consoleError(\"\\n\\ndebugInline\");\n\
            consoleError(...argList);\n\
            consoleError(\"\\n\");\n\
            return argList[0];\n\
        };\n\
    }\n\
    // init isEnvNode\n\
    isEnvNode = (\n\
        typeof process === \"object\" && process &&\n\
        process.versions && typeof process.versions.node === \"string\"\n\
    );\n\
    // init function\n\
    function objectDeepCopyWithKeysSorted(obj) {\n\
    /*\n\
     * this function will recursively deep-copy <obj> with keys sorted\n\
     */\n\
        let sorted;\n\
        if (typeof obj !== \"object\" || !obj) {\n\
            return obj;\n\
        }\n\
        // recursively deep-copy list with child-keys sorted\n\
        if (Array.isArray(obj)) {\n\
            return obj.map(objectDeepCopyWithKeysSorted);\n\
        }\n\
        // recursively deep-copy obj with keys sorted\n\
        sorted = {};\n\
        Object.keys(obj).sort().forEach(function (key) {\n\
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n\
        });\n\
        return sorted;\n\
    }\n\
    function assertJsonEqual(aa, bb) {\n\
    /*\n\
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)\n\
     */\n\
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n\
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n\
        if (aa !== bb) {\n\
            throw new Error(JSON.stringify(aa) + \" !== \" + JSON.stringify(bb));\n\
        }\n\
    }\n\
    function assertOrThrow(passed, msg) {\n\
    /*\n\
     * this function will throw <msg> if <passed> is falsy\n\
     */\n\
        if (passed) {\n\
            return;\n\
        }\n\
        throw (\n\
            (\n\
                msg &&\n\
                typeof msg.message === \"string\" &&\n\
                typeof msg.stack === \"string\"\n\
            )\n\
            // if msg is err, then leave as is\n\
            ? msg\n\
            : new Error(\n\
                typeof msg === \"string\"\n\
                // if msg is string, then leave as is\n\
                ? msg\n\
                // else JSON.stringify(msg)\n\
                : JSON.stringify(msg, undefined, 4)\n\
            )\n\
        );\n\
    }\n\
    function documentQuerySelectorAll(selector) {\n\
    /*\n\
     * this function will return document.querySelectorAll(<selector>) or\n\
     * empty list if function is not available\n\
     */\n\
        return Array.from(\n\
            (\n\
                typeof document === \"object\" && document &&\n\
                typeof document.querySelectorAll === \"function\"\n\
            )\n\
            ? document.querySelectorAll(selector)\n\
            : []\n\
        );\n\
    }\n\
    function identity(val) {\n\
    /*\n\
     * this function will return <val>\n\
     */\n\
        return val;\n\
    }\n\
    function noop() {\n\
    /*\n\
     * this function will do nothing\n\
     */\n\
        return;\n\
    }\n\
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n\
    /*\n\
     * this function will if items from <tgt> are null, undefined, or\n\
     * \"\", then overwrite them with items from <src>\n\
     */\n\
        function recurse(tgt, src, depth) {\n\
            Object.entries(src).forEach(function ([\n\
                key, bb\n\
            ]) {\n\
                let aa;\n\
                aa = tgt[key];\n\
                if (aa === undefined || aa === null || aa === \"\") {\n\
                    tgt[key] = bb;\n\
                    return;\n\
                }\n\
                if (\n\
                    depth !== 0 &&\n\
                    typeof aa === \"object\" && aa && !Array.isArray(aa) &&\n\
                    typeof bb === \"object\" && bb && !Array.isArray(bb)\n\
                ) {\n\
                    recurse(aa, bb, depth - 1);\n\
                }\n\
            });\n\
        }\n\
        recurse(tgt, src, depth | 0);\n\
        return tgt;\n\
    }\n\
    function onErrorThrow(err) {\n\
    /*\n\
     * this function will throw <err> if exists\n\
     */\n\
        if (err) {\n\
            throw err;\n\
        }\n\
    }\n\
    // init local\n\
    local = {\n\
        assertJsonEqual,\n\
        assertOrThrow,\n\
        documentQuerySelectorAll,\n\
        identity,\n\
        isEnvNode,\n\
        local,\n\
        noop,\n\
        objectAssignDefault,\n\
        objectDeepCopyWithKeysSorted,\n\
        onErrorThrow\n\
    };\n\
    globalThis.globalLocal = local;\n\
}());\n\
// assets.utility2.header.js - end\n\
\n\
\n\
(function (local) {\n\
\"use strict\";\n\
\n\
\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-before\n\
(function () {\n\
// init local\n\
local = (\n\
    globalThis.utility2_rollup ||\n\
    // globalThis.utility2_rollup_old ||\n\
    // require(\"./assets.utility2.rollup.js\") ||\n\
    globalThis.globalLocal\n\
);\n\
// init exports\n\
if (local.isEnvNode) {\n\
    module.exports = local;\n\
    module.exports.__dirname = __dirname;\n\
} else {\n\
    globalThis.utility2_jslint = local;\n\
}\n\
// init lib main\n\
local.jslint = local;\n\
\n\
\n\
/* validateLineSortedReset */\n\
local.cliRun = function ({\n\
    rgxComment\n\
}) {\n\
/*\n\
 * this function will run cli\n\
 */\n\
    let {\n\
        _default,\n\
        _eval,\n\
        _help,\n\
        _interactive,\n\
        _version,\n\
        cliDict,\n\
        replStart\n\
    } = Object.assign({}, local, local.cliDict);\n\
    _eval = _eval || function () {\n\
    /*\n\
     * <code>\n\
     * will eval <code>\n\
     */\n\
        Object.assign(globalThis, local);\n\
        require(\"vm\").runInThisContext(process.argv[3]);\n\
    };\n\
    _help = _help || function () {\n\
    /*\n\
     *\n\
     * will print help\n\
     */\n\
        let cmdList;\n\
        let file;\n\
        let packageJson;\n\
        let str;\n\
        let strDict;\n\
        cmdList = [\n\
            {\n\
                argList: \"<arg2>  ...\",\n\
                description: \"usage:\",\n\
                cmd: [\n\
                    \"<arg1>\"\n\
                ]\n\
            }, {\n\
                argList: \"'console.log(\\\"hello world\\\")'\",\n\
                description: \"example:\",\n\
                cmd: [\n\
                    \"--eval\"\n\
                ]\n\
            }\n\
        ];\n\
        file = __filename.replace((\n\
            /.*\\//\n\
        ), \"\");\n\
        packageJson = require(\"./package.json\");\n\
        // validate comment\n\
        rgxComment = rgxComment || (\n\
            /\\)\\u0020\\{\\n(?:|\\u0020{4})\\/\\*\\n(?:\\u0020|\\u0020{5})\\*((?:\\u0020<[^>]*?>|\\u0020\\.\\.\\.)*?)\\n(?:\\u0020|\\u0020{5})\\*\\u0020(will\\u0020.*?\\S)\\n(?:\\u0020|\\u0020{5})\\*\\/\\n(?:\\u0020{4}|\\u0020{8})\\S/\n\
        );\n\
        strDict = {};\n\
        Object.keys(cliDict).sort().forEach(function (key, ii) {\n\
            if (key[0] === \"_\" && key !== \"_default\") {\n\
                return;\n\
            }\n\
            str = String(cliDict[key]);\n\
            if (key === \"_default\") {\n\
                key = \"\";\n\
            }\n\
            strDict[str] = strDict[str] || (ii + 2);\n\
            ii = strDict[str];\n\
            if (cmdList[ii]) {\n\
                cmdList[ii].cmd.push(key);\n\
                return;\n\
            }\n\
            cmdList[ii] = rgxComment.exec(str);\n\
            if (!cmdList[ii]) {\n\
                throw new Error(\n\
                    \"cliRun - cannot parse comment in cmd \" +\n\
                    key + \":\\nnew RegExp(\" +\n\
                    JSON.stringify(rgxComment.source) +\n\
                    \").exec(\" + JSON.stringify(str).replace((\n\
                        /\\\\\\\\/g\n\
                    ), \"\\u0000\").replace((\n\
                        /\\\\n/g\n\
                    ), \"\\\\n\\\\\\n\").replace((\n\
                        /\\u0000/g\n\
                    ), \"\\\\\\\\\") + \");\"\n\
                );\n\
            }\n\
            cmdList[ii] = {\n\
                argList: String(cmdList[ii][1] || \"\").trim(),\n\
                cmd: [\n\
                    key\n\
                ],\n\
                description: cmdList[ii][2]\n\
            };\n\
        });\n\
        str = \"\";\n\
        str += packageJson.name + \" (\" + packageJson.version + \")\\n\\n\";\n\
        str += cmdList.filter(function (elem) {\n\
            return elem;\n\
        }).map(function (elem, ii) {\n\
            elem.cmd = elem.cmd.filter(function (elem) {\n\
                return elem;\n\
            });\n\
            switch (ii) {\n\
            case 0:\n\
            case 1:\n\
                elem.argList = [\n\
                    elem.argList\n\
                ];\n\
                break;\n\
            default:\n\
                elem.argList = elem.argList.split(\" \");\n\
                elem.description = (\n\
                    \"# CMD \" +\n\
                    (elem.cmd[0] || \"<none>\") + \"\\n# \" +\n\
                    elem.description\n\
                );\n\
            }\n\
            return (\n\
                elem.description + \"\\n  \" + file +\n\
                \"  \" + elem.cmd.sort().join(\"|\") + \"  \" +\n\
                elem.argList.join(\"  \")\n\
            );\n\
        }).join(\"\\n\\n\");\n\
        console.log(str);\n\
    };\n\
    _interactive = _interactive || function () {\n\
    /*\n\
     *\n\
     * will start interactive-mode\n\
     */\n\
        Object.assign(globalThis, local);\n\
        replStart = replStart || require(\"repl\").start;\n\
        replStart({\n\
            useGlobal: true\n\
        });\n\
    };\n\
    _version = _version || function () {\n\
    /*\n\
     *\n\
     * will print version\n\
     */\n\
        console.log(require(__dirname + \"/package.json\").version);\n\
    };\n\
    _default = _default || _help;\n\
    Object.assign(cliDict, {\n\
        \"--eval\": _eval,\n\
        \"--help\": _help,\n\
        \"--interactive\": _interactive,\n\
        \"--version\": _version,\n\
        \"-e\": _eval,\n\
        \"-h\": _help,\n\
        \"-i\": _interactive,\n\
        \"-v\": _version,\n\
        _default,\n\
        _eval,\n\
        _help,\n\
        _interactive,\n\
        _version\n\
    });\n\
    // run help-cmd if no arguments are given\n\
    if (process.argv.length <= 2) {\n\
        _help();\n\
        return;\n\
    }\n\
    // run defined-cmd if it exists\n\
    if (cliDict[process.argv[2]]) {\n\
        cliDict[process.argv[2]]();\n\
        return;\n\
    }\n\
    // run default-cmd\n\
    _default();\n\
};\n\
}());\n\
\n\
\n\
// run shared js-env code - function\n\
(function () {\n\
/* jslint ignore:start */\n\
/*\n\
repo https://github.com/CSSLint/csslint/tree/e8aeeda06c928636e21428e09b1af93f66621209\n\
committed 2018-02-25T11:28:16Z\n\
*/\n\
\n\
\n\
/*\n\
file https://github.com/CSSLint/csslint/blob/e8aeeda06c928636e21428e09b1af93f66621209/dist/csslint.js\n\
*/\n\
/*!\n\
CSSLint v1.0.5\n\
Copyright (c) 2017 Nicole Sullivan and Nicholas C. Zakas. All rights reserved.\n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the 'Software'), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in\n\
all copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\
THE SOFTWARE.\n\
\n\
*/\n\
\n\
/* istanbul ignore next */\n\
var CSSLint = (function(){\n\
  var module = module || {},\n\
      exports = exports || {};\n\
\n\
/*!\n\
Parser-Lib\n\
Copyright (c) 2009-2016 Nicholas C. Zakas. All rights reserved.\n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the \"Software\"), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in\n\
all copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\
THE SOFTWARE.\n\
*/\n\
/* Version v1.1.0, Build time: 6-December-2016 10:31:29 */\n\
var parserlib = (function () {\n\
var require;\n\
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
/* exported Colors */\n\
\n\
var Colors = module.exports = {\n\
    __proto__       :null,\n\
    aliceblue       :\"#f0f8ff\",\n\
    antiquewhite    :\"#faebd7\",\n\
    aqua            :\"#00ffff\",\n\
    aquamarine      :\"#7fffd4\",\n\
    azure           :\"#f0ffff\",\n\
    beige           :\"#f5f5dc\",\n\
    bisque          :\"#ffe4c4\",\n\
    black           :\"#000000\",\n\
    blanchedalmond  :\"#ffebcd\",\n\
    blue            :\"#0000ff\",\n\
    blueviolet      :\"#8a2be2\",\n\
    brown           :\"#a52a2a\",\n\
    burlywood       :\"#deb887\",\n\
    cadetblue       :\"#5f9ea0\",\n\
    chartreuse      :\"#7fff00\",\n\
    chocolate       :\"#d2691e\",\n\
    coral           :\"#ff7f50\",\n\
    cornflowerblue  :\"#6495ed\",\n\
    cornsilk        :\"#fff8dc\",\n\
    crimson         :\"#dc143c\",\n\
    cyan            :\"#00ffff\",\n\
    darkblue        :\"#00008b\",\n\
    darkcyan        :\"#008b8b\",\n\
    darkgoldenrod   :\"#b8860b\",\n\
    darkgray        :\"#a9a9a9\",\n\
    darkgrey        :\"#a9a9a9\",\n\
    darkgreen       :\"#006400\",\n\
    darkkhaki       :\"#bdb76b\",\n\
    darkmagenta     :\"#8b008b\",\n\
    darkolivegreen  :\"#556b2f\",\n\
    darkorange      :\"#ff8c00\",\n\
    darkorchid      :\"#9932cc\",\n\
    darkred         :\"#8b0000\",\n\
    darksalmon      :\"#e9967a\",\n\
    darkseagreen    :\"#8fbc8f\",\n\
    darkslateblue   :\"#483d8b\",\n\
    darkslategray   :\"#2f4f4f\",\n\
    darkslategrey   :\"#2f4f4f\",\n\
    darkturquoise   :\"#00ced1\",\n\
    darkviolet      :\"#9400d3\",\n\
    deeppink        :\"#ff1493\",\n\
    deepskyblue     :\"#00bfff\",\n\
    dimgray         :\"#696969\",\n\
    dimgrey         :\"#696969\",\n\
    dodgerblue      :\"#1e90ff\",\n\
    firebrick       :\"#b22222\",\n\
    floralwhite     :\"#fffaf0\",\n\
    forestgreen     :\"#228b22\",\n\
    fuchsia         :\"#ff00ff\",\n\
    gainsboro       :\"#dcdcdc\",\n\
    ghostwhite      :\"#f8f8ff\",\n\
    gold            :\"#ffd700\",\n\
    goldenrod       :\"#daa520\",\n\
    gray            :\"#808080\",\n\
    grey            :\"#808080\",\n\
    green           :\"#008000\",\n\
    greenyellow     :\"#adff2f\",\n\
    honeydew        :\"#f0fff0\",\n\
    hotpink         :\"#ff69b4\",\n\
    indianred       :\"#cd5c5c\",\n\
    indigo          :\"#4b0082\",\n\
    ivory           :\"#fffff0\",\n\
    khaki           :\"#f0e68c\",\n\
    lavender        :\"#e6e6fa\",\n\
    lavenderblush   :\"#fff0f5\",\n\
    lawngreen       :\"#7cfc00\",\n\
    lemonchiffon    :\"#fffacd\",\n\
    lightblue       :\"#add8e6\",\n\
    lightcoral      :\"#f08080\",\n\
    lightcyan       :\"#e0ffff\",\n\
    lightgoldenrodyellow  :\"#fafad2\",\n\
    lightgray       :\"#d3d3d3\",\n\
    lightgrey       :\"#d3d3d3\",\n\
    lightgreen      :\"#90ee90\",\n\
    lightpink       :\"#ffb6c1\",\n\
    lightsalmon     :\"#ffa07a\",\n\
    lightseagreen   :\"#20b2aa\",\n\
    lightskyblue    :\"#87cefa\",\n\
    lightslategray  :\"#778899\",\n\
    lightslategrey  :\"#778899\",\n\
    lightsteelblue  :\"#b0c4de\",\n\
    lightyellow     :\"#ffffe0\",\n\
    lime            :\"#00ff00\",\n\
    limegreen       :\"#32cd32\",\n\
    linen           :\"#faf0e6\",\n\
    magenta         :\"#ff00ff\",\n\
    maroon          :\"#800000\",\n\
    mediumaquamarine:\"#66cdaa\",\n\
    mediumblue      :\"#0000cd\",\n\
    mediumorchid    :\"#ba55d3\",\n\
    mediumpurple    :\"#9370d8\",\n\
    mediumseagreen  :\"#3cb371\",\n\
    mediumslateblue :\"#7b68ee\",\n\
    mediumspringgreen   :\"#00fa9a\",\n\
    mediumturquoise :\"#48d1cc\",\n\
    mediumvioletred :\"#c71585\",\n\
    midnightblue    :\"#191970\",\n\
    mintcream       :\"#f5fffa\",\n\
    mistyrose       :\"#ffe4e1\",\n\
    moccasin        :\"#ffe4b5\",\n\
    navajowhite     :\"#ffdead\",\n\
    navy            :\"#000080\",\n\
    oldlace         :\"#fdf5e6\",\n\
    olive           :\"#808000\",\n\
    olivedrab       :\"#6b8e23\",\n\
    orange          :\"#ffa500\",\n\
    orangered       :\"#ff4500\",\n\
    orchid          :\"#da70d6\",\n\
    palegoldenrod   :\"#eee8aa\",\n\
    palegreen       :\"#98fb98\",\n\
    paleturquoise   :\"#afeeee\",\n\
    palevioletred   :\"#d87093\",\n\
    papayawhip      :\"#ffefd5\",\n\
    peachpuff       :\"#ffdab9\",\n\
    peru            :\"#cd853f\",\n\
    pink            :\"#ffc0cb\",\n\
    plum            :\"#dda0dd\",\n\
    powderblue      :\"#b0e0e6\",\n\
    purple          :\"#800080\",\n\
    red             :\"#ff0000\",\n\
    rosybrown       :\"#bc8f8f\",\n\
    royalblue       :\"#4169e1\",\n\
    saddlebrown     :\"#8b4513\",\n\
    salmon          :\"#fa8072\",\n\
    sandybrown      :\"#f4a460\",\n\
    seagreen        :\"#2e8b57\",\n\
    seashell        :\"#fff5ee\",\n\
    sienna          :\"#a0522d\",\n\
    silver          :\"#c0c0c0\",\n\
    skyblue         :\"#87ceeb\",\n\
    slateblue       :\"#6a5acd\",\n\
    slategray       :\"#708090\",\n\
    slategrey       :\"#708090\",\n\
    snow            :\"#fffafa\",\n\
    springgreen     :\"#00ff7f\",\n\
    steelblue       :\"#4682b4\",\n\
    tan             :\"#d2b48c\",\n\
    teal            :\"#008080\",\n\
    thistle         :\"#d8bfd8\",\n\
    tomato          :\"#ff6347\",\n\
    turquoise       :\"#40e0d0\",\n\
    violet          :\"#ee82ee\",\n\
    wheat           :\"#f5deb3\",\n\
    white           :\"#ffffff\",\n\
    whitesmoke      :\"#f5f5f5\",\n\
    yellow          :\"#ffff00\",\n\
    yellowgreen     :\"#9acd32\",\n\
    //'currentColor' color keyword https://www.w3.org/TR/css3-color/#currentcolor\n\
    currentColor        :\"The value of the 'color' property.\",\n\
    //CSS2 system colors https://www.w3.org/TR/css3-color/#css2-system\n\
    activeBorder        :\"Active window border.\",\n\
    activecaption       :\"Active window caption.\",\n\
    appworkspace        :\"Background color of multiple document interface.\",\n\
    background          :\"Desktop background.\",\n\
    buttonface          :\"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n\
    buttonhighlight     :\"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n\
    buttonshadow        :\"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n\
    buttontext          :\"Text on push buttons.\",\n\
    captiontext         :\"Text in caption, size box, and scrollbar arrow box.\",\n\
    graytext            :\"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\",\n\
    greytext            :\"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.\",\n\
    highlight           :\"Item(s) selected in a control.\",\n\
    highlighttext       :\"Text of item(s) selected in a control.\",\n\
    inactiveborder      :\"Inactive window border.\",\n\
    inactivecaption     :\"Inactive window caption.\",\n\
    inactivecaptiontext :\"Color of text in an inactive caption.\",\n\
    infobackground      :\"Background color for tooltip controls.\",\n\
    infotext            :\"Text color for tooltip controls.\",\n\
    menu                :\"Menu background.\",\n\
    menutext            :\"Text in menus.\",\n\
    scrollbar           :\"Scroll bar gray area.\",\n\
    threeddarkshadow    :\"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n\
    threedface          :\"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n\
    threedhighlight     :\"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n\
    threedlightshadow   :\"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n\
    threedshadow        :\"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n\
    window              :\"Window background.\",\n\
    windowframe         :\"Window frame.\",\n\
    windowtext          :\"Text in windows.\"\n\
};\n\
},{}],2:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = Combinator;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a selector combinator (whitespace, +, >).\n\
 * @namespace parserlib.css\n\
 * @class Combinator\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {String} text The text representation of the unit.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function Combinator(text, line, col) {\n\
\n\
    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);\n\
\n\
    /**\n\
     * The type of modifier.\n\
     * @type String\n\
     * @property type\n\
     */\n\
    this.type = \"unknown\";\n\
\n\
    //pretty simple\n\
    if (/^\\s+$/.test(text)) {\n\
        this.type = \"descendant\";\n\
    } else if (text === \">\") {\n\
        this.type = \"child\";\n\
    } else if (text === \"+\") {\n\
        this.type = \"adjacent-sibling\";\n\
    } else if (text === \"~\") {\n\
        this.type = \"sibling\";\n\
    }\n\
}\n\
\n\
Combinator.prototype = new SyntaxUnit();\n\
Combinator.prototype.constructor = Combinator;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],3:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = Matcher;\n\
\n\
var StringReader = require(\"../util/StringReader\");\n\
var SyntaxError = require(\"../util/SyntaxError\");\n\
\n\
/**\n\
 * This class implements a combinator library for matcher functions.\n\
 * The combinators are described at:\n\
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators\n\
 */\n\
function Matcher(matchFunc, toString) {\n\
    this.match = function(expression) {\n\
        // Save/restore marks to ensure that failed matches always restore\n\
        // the original location in the expression.\n\
        var result;\n\
        expression.mark();\n\
        result = matchFunc(expression);\n\
        if (result) {\n\
            expression.drop();\n\
        } else {\n\
            expression.restore();\n\
        }\n\
        return result;\n\
    };\n\
    this.toString = typeof toString === \"function\" ? toString : function() {\n\
        return toString;\n\
    };\n\
}\n\
\n\
/** Precedence table of combinators. */\n\
Matcher.prec = {\n\
    MOD:    5,\n\
    SEQ:    4,\n\
    ANDAND: 3,\n\
    OROR:   2,\n\
    ALT:    1\n\
};\n\
\n\
/** Simple recursive-descent grammar to build matchers from strings. */\n\
Matcher.parse = function(str) {\n\
    var reader, eat, expr, oror, andand, seq, mod, term, result;\n\
    reader = new StringReader(str);\n\
    eat = function(matcher) {\n\
        var result = reader.readMatch(matcher);\n\
        if (result === null) {\n\
            throw new SyntaxError(\n\
                \"Expected \"+matcher, reader.getLine(), reader.getCol());\n\
        }\n\
        return result;\n\
    };\n\
    expr = function() {\n\
        // expr = oror (\" | \" oror)*\n\
        var m = [ oror() ];\n\
        while (reader.readMatch(\" | \") !== null) {\n\
            m.push(oror());\n\
        }\n\
        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);\n\
    };\n\
    oror = function() {\n\
        // oror = andand ( \" || \" andand)*\n\
        var m = [ andand() ];\n\
        while (reader.readMatch(\" || \") !== null) {\n\
            m.push(andand());\n\
        }\n\
        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);\n\
    };\n\
    andand = function() {\n\
        // andand = seq ( \" && \" seq)*\n\
        var m = [ seq() ];\n\
        while (reader.readMatch(\" && \") !== null) {\n\
            m.push(seq());\n\
        }\n\
        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);\n\
    };\n\
    seq = function() {\n\
        // seq = mod ( \" \" mod)*\n\
        var m = [ mod() ];\n\
        while (reader.readMatch(/^ (?![&|\\]])/) !== null) {\n\
            m.push(mod());\n\
        }\n\
        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);\n\
    };\n\
    mod = function() {\n\
        // mod = term ( \"?\" | \"*\" | \"+\" | \"#\" | \"{<num>,<num>}\" )?\n\
        var m = term();\n\
        if (reader.readMatch(\"?\") !== null) {\n\
            return m.question();\n\
        } else if (reader.readMatch(\"*\") !== null) {\n\
            return m.star();\n\
        } else if (reader.readMatch(\"+\") !== null) {\n\
            return m.plus();\n\
        } else if (reader.readMatch(\"#\") !== null) {\n\
            return m.hash();\n\
        } else if (reader.readMatch(/^\\{\\s*/) !== null) {\n\
            var min = eat(/^\\d+/);\n\
            eat(/^\\s*,\\s*/);\n\
            var max = eat(/^\\d+/);\n\
            eat(/^\\s*\\}/);\n\
            return m.braces(+min, +max);\n\
        }\n\
        return m;\n\
    };\n\
    term = function() {\n\
        // term = <nt> | literal | \"[ \" expression \" ]\"\n\
        if (reader.readMatch(\"[ \") !== null) {\n\
            var m = expr();\n\
            eat(\" ]\");\n\
            return m;\n\
        }\n\
        return Matcher.fromType(eat(/^[^ ?*+#{]+/));\n\
    };\n\
    result = expr();\n\
    if (!reader.eof()) {\n\
        throw new SyntaxError(\n\
            \"Expected end of string\", reader.getLine(), reader.getCol());\n\
    }\n\
    return result;\n\
};\n\
\n\
/**\n\
 * Convert a string to a matcher (parsing simple alternations),\n\
 * or do nothing if the argument is already a matcher.\n\
 */\n\
Matcher.cast = function(m) {\n\
    if (m instanceof Matcher) {\n\
        return m;\n\
    }\n\
    return Matcher.parse(m);\n\
};\n\
\n\
/**\n\
 * Create a matcher for a single type.\n\
 */\n\
Matcher.fromType = function(type) {\n\
    // Late require of ValidationTypes to break a dependency cycle.\n\
    var ValidationTypes = require(\"./ValidationTypes\");\n\
    return new Matcher(function(expression) {\n\
        return expression.hasNext() && ValidationTypes.isType(expression, type);\n\
    }, type);\n\
};\n\
\n\
/**\n\
 * Create a matcher for one or more juxtaposed words, which all must\n\
 * occur, in the given order.\n\
 */\n\
Matcher.seq = function() {\n\
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\n\
    if (ms.length === 1) {\n\
        return ms[0];\n\
    }\n\
    return new Matcher(function(expression) {\n\
        var i, result = true;\n\
        for (i = 0; result && i < ms.length; i++) {\n\
            result = ms[i].match(expression);\n\
        }\n\
        return result;\n\
    }, function(prec) {\n\
        var p = Matcher.prec.SEQ;\n\
        var s = ms.map(function(m) {\n\
            return m.toString(p);\n\
        }).join(\" \");\n\
        if (prec > p) {\n\
            s = \"[ \" + s + \" ]\";\n\
        }\n\
        return s;\n\
    });\n\
};\n\
\n\
/**\n\
 * Create a matcher for one or more alternatives, where exactly one\n\
 * must occur.\n\
 */\n\
Matcher.alt = function() {\n\
    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\n\
    if (ms.length === 1) {\n\
        return ms[0];\n\
    }\n\
    return new Matcher(function(expression) {\n\
        var i, result = false;\n\
        for (i = 0; !result && i < ms.length; i++) {\n\
            result = ms[i].match(expression);\n\
        }\n\
        return result;\n\
    }, function(prec) {\n\
        var p = Matcher.prec.ALT;\n\
        var s = ms.map(function(m) {\n\
            return m.toString(p);\n\
        }).join(\" | \");\n\
        if (prec > p) {\n\
            s = \"[ \" + s + \" ]\";\n\
        }\n\
        return s;\n\
    });\n\
};\n\
\n\
/**\n\
 * Create a matcher for two or more options.  This implements the\n\
 * double bar (||) and double ampersand (&&) operators, as well as\n\
 * variants of && where some of the alternatives are optional.\n\
 * This will backtrack through even successful matches to try to\n\
 * maximize the number of items matched.\n\
 */\n\
Matcher.many = function(required) {\n\
    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {\n\
        if (v.expand) {\n\
            // Insert all of the options for the given complex rule as\n\
            // individual options.\n\
            var ValidationTypes = require(\"./ValidationTypes\");\n\
            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);\n\
        } else {\n\
            acc.push(Matcher.cast(v));\n\
        }\n\
        return acc;\n\
    }, []);\n\
\n\
    if (required === true) {\n\
        required = ms.map(function() {\n\
            return true;\n\
        });\n\
    }\n\
\n\
    var result = new Matcher(function(expression) {\n\
        var seen = [], max = 0, pass = 0;\n\
        var success = function(matchCount) {\n\
            if (pass === 0) {\n\
                max = Math.max(matchCount, max);\n\
                return matchCount === ms.length;\n\
            } else {\n\
                return matchCount === max;\n\
            }\n\
        };\n\
        var tryMatch = function(matchCount) {\n\
            for (var i = 0; i < ms.length; i++) {\n\
                if (seen[i]) {\n\
                    continue;\n\
                }\n\
                expression.mark();\n\
                if (ms[i].match(expression)) {\n\
                    seen[i] = true;\n\
                    // Increase matchCount iff this was a required element\n\
                    // (or if all the elements are optional)\n\
                    if (tryMatch(matchCount + ((required === false || required[i]) ? 1 : 0))) {\n\
                        expression.drop();\n\
                        return true;\n\
                    }\n\
                    // Backtrack: try *not* matching using this rule, and\n\
                    // let's see if it leads to a better overall match.\n\
                    expression.restore();\n\
                    seen[i] = false;\n\
                } else {\n\
                    expression.drop();\n\
                }\n\
            }\n\
            return success(matchCount);\n\
        };\n\
        if (!tryMatch(0)) {\n\
            // Couldn't get a complete match, retrace our steps to make the\n\
            // match with the maximum # of required elements.\n\
            pass++;\n\
            tryMatch(0);\n\
        }\n\
\n\
        if (required === false) {\n\
            return max > 0;\n\
        }\n\
        // Use finer-grained specification of which matchers are required.\n\
        for (var i = 0; i < ms.length; i++) {\n\
            if (required[i] && !seen[i]) {\n\
                return false;\n\
            }\n\
        }\n\
        return true;\n\
    }, function(prec) {\n\
        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;\n\
        var s = ms.map(function(m, i) {\n\
            if (required !== false && !required[i]) {\n\
                return m.toString(Matcher.prec.MOD) + \"?\";\n\
            }\n\
            return m.toString(p);\n\
        }).join(required === false ? \" || \" : \" && \");\n\
        if (prec > p) {\n\
            s = \"[ \" + s + \" ]\";\n\
        }\n\
        return s;\n\
    });\n\
    result.options = ms;\n\
    return result;\n\
};\n\
\n\
/**\n\
 * Create a matcher for two or more options, where all options are\n\
 * mandatory but they may appear in any order.\n\
 */\n\
Matcher.andand = function() {\n\
    var args = Array.prototype.slice.call(arguments);\n\
    args.unshift(true);\n\
    return Matcher.many.apply(Matcher, args);\n\
};\n\
\n\
/**\n\
 * Create a matcher for two or more options, where options are\n\
 * optional and may appear in any order, but at least one must be\n\
 * present.\n\
 */\n\
Matcher.oror = function() {\n\
    var args = Array.prototype.slice.call(arguments);\n\
    args.unshift(false);\n\
    return Matcher.many.apply(Matcher, args);\n\
};\n\
\n\
/** Instance methods on Matchers. */\n\
Matcher.prototype = {\n\
    constructor: Matcher,\n\
    // These are expected to be overridden in every instance.\n\
    match: function() { throw new Error(\"unimplemented\"); },\n\
    toString: function() { throw new Error(\"unimplemented\"); },\n\
    // This returns a standalone function to do the matching.\n\
    func: function() { return this.match.bind(this); },\n\
    // Basic combinators\n\
    then: function(m) { return Matcher.seq(this, m); },\n\
    or: function(m) { return Matcher.alt(this, m); },\n\
    andand: function(m) { return Matcher.many(true, this, m); },\n\
    oror: function(m) { return Matcher.many(false, this, m); },\n\
    // Component value multipliers\n\
    star: function() { return this.braces(0, Infinity, \"*\"); },\n\
    plus: function() { return this.braces(1, Infinity, \"+\"); },\n\
    question: function() { return this.braces(0, 1, \"?\"); },\n\
    hash: function() {\n\
        return this.braces(1, Infinity, \"#\", Matcher.cast(\",\"));\n\
    },\n\
    braces: function(min, max, marker, optSep) {\n\
        var m1 = this, m2 = optSep ? optSep.then(this) : this;\n\
        if (!marker) {\n\
            marker = \"{\" + min + \",\" + max + \"}\";\n\
        }\n\
        return new Matcher(function(expression) {\n\
            var result = true, i;\n\
            for (i = 0; i < max; i++) {\n\
                if (i > 0 && optSep) {\n\
                    result = m2.match(expression);\n\
                } else {\n\
                    result = m1.match(expression);\n\
                }\n\
                if (!result) {\n\
                    break;\n\
                }\n\
            }\n\
            return i >= min;\n\
        }, function() {\n\
            return m1.toString(Matcher.prec.MOD) + marker;\n\
        });\n\
    }\n\
};\n\
},{\"../util/StringReader\":24,\"../util/SyntaxError\":25,\"./ValidationTypes\":21}],4:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = MediaFeature;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a media feature, such as max-width:500.\n\
 * @namespace parserlib.css\n\
 * @class MediaFeature\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {SyntaxUnit} name The name of the feature.\n\
 * @param {SyntaxUnit} value The value of the feature or null if none.\n\
 */\n\
function MediaFeature(name, value) {\n\
\n\
    SyntaxUnit.call(this, \"(\" + name + (value !== null ? \":\" + value : \"\") + \")\", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);\n\
\n\
    /**\n\
     * The name of the media feature\n\
     * @type String\n\
     * @property name\n\
     */\n\
    this.name = name;\n\
\n\
    /**\n\
     * The value for the feature or null if there is none.\n\
     * @type SyntaxUnit\n\
     * @property value\n\
     */\n\
    this.value = value;\n\
}\n\
\n\
MediaFeature.prototype = new SyntaxUnit();\n\
MediaFeature.prototype.constructor = MediaFeature;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],5:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = MediaQuery;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents an individual media query.\n\
 * @namespace parserlib.css\n\
 * @class MediaQuery\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {String} modifier The modifier \"not\" or \"only\" (or null).\n\
 * @param {String} mediaType The type of media (i.e., \"print\").\n\
 * @param {Array} parts Array of selectors parts making up this selector.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function MediaQuery(modifier, mediaType, features, line, col) {\n\
\n\
    SyntaxUnit.call(this, (modifier ? modifier + \" \": \"\") + (mediaType ? mediaType : \"\") + (mediaType && features.length > 0 ? \" and \" : \"\") + features.join(\" and \"), line, col, Parser.MEDIA_QUERY_TYPE);\n\
\n\
    /**\n\
     * The media modifier (\"not\" or \"only\")\n\
     * @type String\n\
     * @property modifier\n\
     */\n\
    this.modifier = modifier;\n\
\n\
    /**\n\
     * The mediaType (i.e., \"print\")\n\
     * @type String\n\
     * @property mediaType\n\
     */\n\
    this.mediaType = mediaType;\n\
\n\
    /**\n\
     * The parts that make up the selector.\n\
     * @type Array\n\
     * @property features\n\
     */\n\
    this.features = features;\n\
}\n\
\n\
MediaQuery.prototype = new SyntaxUnit();\n\
MediaQuery.prototype.constructor = MediaQuery;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],6:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = Parser;\n\
\n\
var EventTarget = require(\"../util/EventTarget\");\n\
var SyntaxError = require(\"../util/SyntaxError\");\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Combinator = require(\"./Combinator\");\n\
var MediaFeature = require(\"./MediaFeature\");\n\
var MediaQuery = require(\"./MediaQuery\");\n\
var PropertyName = require(\"./PropertyName\");\n\
var PropertyValue = require(\"./PropertyValue\");\n\
var PropertyValuePart = require(\"./PropertyValuePart\");\n\
var Selector = require(\"./Selector\");\n\
var SelectorPart = require(\"./SelectorPart\");\n\
var SelectorSubPart = require(\"./SelectorSubPart\");\n\
var TokenStream = require(\"./TokenStream\");\n\
var Tokens = require(\"./Tokens\");\n\
var Validation = require(\"./Validation\");\n\
\n\
/**\n\
 * A CSS3 parser.\n\
 * @namespace parserlib.css\n\
 * @class Parser\n\
 * @constructor\n\
 * @param {Object} options (Optional) Various options for the parser:\n\
 *      starHack (true|false) to allow IE6 star hack as valid,\n\
 *      underscoreHack (true|false) to interpret leading underscores\n\
 *      as IE6-7 targeting for known properties, ieFilters (true|false)\n\
 *      to indicate that IE < 8 filters should be accepted and not throw\n\
 *      syntax errors.\n\
 */\n\
function Parser(options) {\n\
\n\
    //inherit event functionality\n\
    EventTarget.call(this);\n\
\n\
\n\
    this.options = options || {};\n\
\n\
    this._tokenStream = null;\n\
}\n\
\n\
//Static constants\n\
Parser.DEFAULT_TYPE = 0;\n\
Parser.COMBINATOR_TYPE = 1;\n\
Parser.MEDIA_FEATURE_TYPE = 2;\n\
Parser.MEDIA_QUERY_TYPE = 3;\n\
Parser.PROPERTY_NAME_TYPE = 4;\n\
Parser.PROPERTY_VALUE_TYPE = 5;\n\
Parser.PROPERTY_VALUE_PART_TYPE = 6;\n\
Parser.SELECTOR_TYPE = 7;\n\
Parser.SELECTOR_PART_TYPE = 8;\n\
Parser.SELECTOR_SUB_PART_TYPE = 9;\n\
\n\
Parser.prototype = function() {\n\
\n\
    var proto = new EventTarget(),  //new prototype\n\
        prop,\n\
        additions =  {\n\
            __proto__: null,\n\
\n\
            //restore constructor\n\
            constructor: Parser,\n\
\n\
            //instance constants - yuck\n\
            DEFAULT_TYPE : 0,\n\
            COMBINATOR_TYPE : 1,\n\
            MEDIA_FEATURE_TYPE : 2,\n\
            MEDIA_QUERY_TYPE : 3,\n\
            PROPERTY_NAME_TYPE : 4,\n\
            PROPERTY_VALUE_TYPE : 5,\n\
            PROPERTY_VALUE_PART_TYPE : 6,\n\
            SELECTOR_TYPE : 7,\n\
            SELECTOR_PART_TYPE : 8,\n\
            SELECTOR_SUB_PART_TYPE : 9,\n\
\n\
            //-----------------------------------------------------------------\n\
            // Grammar\n\
            //-----------------------------------------------------------------\n\
\n\
            _stylesheet: function() {\n\
\n\
                /*\n\
                 * stylesheet\n\
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?\n\
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*\n\
                 *    [ namespace [S|CDO|CDC]* ]*\n\
                 *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*\n\
                 *  ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    count,\n\
                    token,\n\
                    tt;\n\
\n\
                this.fire(\"startstylesheet\");\n\
\n\
                //try to read character set\n\
                this._charset();\n\
\n\
                this._skipCruft();\n\
\n\
                //try to read imports - may be more than one\n\
                while (tokenStream.peek() === Tokens.IMPORT_SYM) {\n\
                    this._import();\n\
                    this._skipCruft();\n\
                }\n\
\n\
                //try to read namespaces - may be more than one\n\
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {\n\
                    this._namespace();\n\
                    this._skipCruft();\n\
                }\n\
\n\
                //get the next token\n\
                tt = tokenStream.peek();\n\
\n\
                //try to read the rest\n\
                while (tt > Tokens.EOF) {\n\
\n\
                    try {\n\
\n\
                        switch (tt) {\n\
                            case Tokens.MEDIA_SYM:\n\
                                this._media();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.PAGE_SYM:\n\
                                this._page();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.FONT_FACE_SYM:\n\
                                this._font_face();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.KEYFRAMES_SYM:\n\
                                this._keyframes();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.VIEWPORT_SYM:\n\
                                this._viewport();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.DOCUMENT_SYM:\n\
                                this._document();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.SUPPORTS_SYM:\n\
                                this._supports();\n\
                                this._skipCruft();\n\
                                break;\n\
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule\n\
                                tokenStream.get();\n\
                                if (!this.options.strict) {\n\
\n\
                                    //fire error event\n\
                                    this.fire({\n\
                                        type:       \"error\",\n\
                                        error:      null,\n\
                                        message:    \"Unknown @ rule: \" + tokenStream.LT(0).value + \".\",\n\
                                        line:       tokenStream.LT(0).startLine,\n\
                                        col:        tokenStream.LT(0).startCol\n\
                                    });\n\
\n\
                                    //skip braces\n\
                                    count=0;\n\
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {\n\
                                        count++;    //keep track of nesting depth\n\
                                    }\n\
\n\
                                    while (count) {\n\
                                        tokenStream.advance([Tokens.RBRACE]);\n\
                                        count--;\n\
                                    }\n\
                                } else {\n\
                                    //not a syntax error, rethrow it\n\
                                    throw new SyntaxError(\"Unknown @ rule.\", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);\n\
                                }\n\
                                break;\n\
                            case Tokens.S:\n\
                                this._readWhitespace();\n\
                                break;\n\
                            default:\n\
                                if (!this._ruleset()) {\n\
\n\
                                    //error handling for known issues\n\
                                    switch (tt) {\n\
                                        case Tokens.CHARSET_SYM:\n\
                                            token = tokenStream.LT(1);\n\
                                            this._charset(false);\n\
                                            throw new SyntaxError(\"@charset not allowed here.\", token.startLine, token.startCol);\n\
                                        case Tokens.IMPORT_SYM:\n\
                                            token = tokenStream.LT(1);\n\
                                            this._import(false);\n\
                                            throw new SyntaxError(\"@import not allowed here.\", token.startLine, token.startCol);\n\
                                        case Tokens.NAMESPACE_SYM:\n\
                                            token = tokenStream.LT(1);\n\
                                            this._namespace(false);\n\
                                            throw new SyntaxError(\"@namespace not allowed here.\", token.startLine, token.startCol);\n\
                                        default:\n\
                                            tokenStream.get();  //get the last token\n\
                                            this._unexpectedToken(tokenStream.token());\n\
                                    }\n\
                                }\n\
                        }\n\
                    } catch (ex) {\n\
                        if (ex instanceof SyntaxError && !this.options.strict) {\n\
                            this.fire({\n\
                                type:       \"error\",\n\
                                error:      ex,\n\
                                message:    ex.message,\n\
                                line:       ex.line,\n\
                                col:        ex.col\n\
                            });\n\
                        } else {\n\
                            throw ex;\n\
                        }\n\
                    }\n\
\n\
                    tt = tokenStream.peek();\n\
                }\n\
\n\
                if (tt !== Tokens.EOF) {\n\
                    this._unexpectedToken(tokenStream.token());\n\
                }\n\
\n\
                this.fire(\"endstylesheet\");\n\
            },\n\
\n\
            _charset: function(emit) {\n\
                var tokenStream = this._tokenStream,\n\
                    charset,\n\
                    token,\n\
                    line,\n\
                    col;\n\
\n\
                if (tokenStream.match(Tokens.CHARSET_SYM)) {\n\
                    line = tokenStream.token().startLine;\n\
                    col = tokenStream.token().startCol;\n\
\n\
                    this._readWhitespace();\n\
                    tokenStream.mustMatch(Tokens.STRING);\n\
\n\
                    token = tokenStream.token();\n\
                    charset = token.value;\n\
\n\
                    this._readWhitespace();\n\
                    tokenStream.mustMatch(Tokens.SEMICOLON);\n\
\n\
                    if (emit !== false) {\n\
                        this.fire({\n\
                            type:   \"charset\",\n\
                            charset:charset,\n\
                            line:   line,\n\
                            col:    col\n\
                        });\n\
                    }\n\
                }\n\
            },\n\
\n\
            _import: function(emit) {\n\
                /*\n\
                 * import\n\
                 *   : IMPORT_SYM S*\n\
                 *    [STRING|URI] S* media_query_list? ';' S*\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    uri,\n\
                    importToken,\n\
                    mediaList   = [];\n\
\n\
                //read import symbol\n\
                tokenStream.mustMatch(Tokens.IMPORT_SYM);\n\
                importToken = tokenStream.token();\n\
                this._readWhitespace();\n\
\n\
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\n\
\n\
                //grab the URI value\n\
                uri = tokenStream.token().value.replace(/^(?:url\\()?[\"']?([^\"']+?)[\"']?\\)?$/, \"$1\");\n\
\n\
                this._readWhitespace();\n\
\n\
                mediaList = this._media_query_list();\n\
\n\
                //must end with a semicolon\n\
                tokenStream.mustMatch(Tokens.SEMICOLON);\n\
                this._readWhitespace();\n\
\n\
                if (emit !== false) {\n\
                    this.fire({\n\
                        type:   \"import\",\n\
                        uri:    uri,\n\
                        media:  mediaList,\n\
                        line:   importToken.startLine,\n\
                        col:    importToken.startCol\n\
                    });\n\
                }\n\
            },\n\
\n\
            _namespace: function(emit) {\n\
                /*\n\
                 * namespace\n\
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col,\n\
                    prefix,\n\
                    uri;\n\
\n\
                //read import symbol\n\
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);\n\
                line = tokenStream.token().startLine;\n\
                col = tokenStream.token().startCol;\n\
                this._readWhitespace();\n\
\n\
                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    prefix = tokenStream.token().value;\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\n\
                /*if (!tokenStream.match(Tokens.STRING)){\n\
                    tokenStream.mustMatch(Tokens.URI);\n\
                }*/\n\
\n\
                //grab the URI value\n\
                uri = tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/, \"$1\");\n\
\n\
                this._readWhitespace();\n\
\n\
                //must end with a semicolon\n\
                tokenStream.mustMatch(Tokens.SEMICOLON);\n\
                this._readWhitespace();\n\
\n\
                if (emit !== false) {\n\
                    this.fire({\n\
                        type:   \"namespace\",\n\
                        prefix: prefix,\n\
                        uri:    uri,\n\
                        line:   line,\n\
                        col:    col\n\
                    });\n\
                }\n\
            },\n\
\n\
            _supports: function(emit) {\n\
                /*\n\
                 * supports_rule\n\
                 *  : SUPPORTS_SYM S* supports_condition S* group_rule_body\n\
                 *  ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col;\n\
\n\
                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {\n\
                    line = tokenStream.token().startLine;\n\
                    col = tokenStream.token().startCol;\n\
\n\
                    this._readWhitespace();\n\
                    this._supports_condition();\n\
                    this._readWhitespace();\n\
\n\
                    tokenStream.mustMatch(Tokens.LBRACE);\n\
                    this._readWhitespace();\n\
\n\
                    if (emit !== false) {\n\
                        this.fire({\n\
                            type:   \"startsupports\",\n\
                            line:   line,\n\
                            col:    col\n\
                        });\n\
                    }\n\
\n\
                    while (true) {\n\
                        if (!this._ruleset()) {\n\
                            break;\n\
                        }\n\
                    }\n\
\n\
                    tokenStream.mustMatch(Tokens.RBRACE);\n\
                    this._readWhitespace();\n\
\n\
                    this.fire({\n\
                        type:   \"endsupports\",\n\
                        line:   line,\n\
                        col:    col\n\
                    });\n\
                }\n\
            },\n\
\n\
            _supports_condition: function() {\n\
                /*\n\
                 * supports_condition\n\
                 *  : supports_negation | supports_conjunction | supports_disjunction |\n\
                 *    supports_condition_in_parens\n\
                 *  ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    ident;\n\
\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    ident = tokenStream.token().value.toLowerCase();\n\
\n\
                    if (ident === \"not\") {\n\
                        tokenStream.mustMatch(Tokens.S);\n\
                        this._supports_condition_in_parens();\n\
                    } else {\n\
                        tokenStream.unget();\n\
                    }\n\
                } else {\n\
                    this._supports_condition_in_parens();\n\
                    this._readWhitespace();\n\
\n\
                    while (tokenStream.peek() === Tokens.IDENT) {\n\
                        ident = tokenStream.LT(1).value.toLowerCase();\n\
                        if (ident === \"and\" || ident === \"or\") {\n\
                            tokenStream.mustMatch(Tokens.IDENT);\n\
                            this._readWhitespace();\n\
                            this._supports_condition_in_parens();\n\
                            this._readWhitespace();\n\
                        }\n\
                    }\n\
                }\n\
            },\n\
\n\
            _supports_condition_in_parens: function() {\n\
                /*\n\
                 * supports_condition_in_parens\n\
                 *  : ( '(' S* supports_condition S* ')' ) | supports_declaration_condition |\n\
                 *    general_enclosed\n\
                 *  ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    ident;\n\
\n\
                if (tokenStream.match(Tokens.LPAREN)) {\n\
                    this._readWhitespace();\n\
                    if (tokenStream.match(Tokens.IDENT)) {\n\
                        // look ahead for not keyword, if not given, continue with declaration condition.\n\
                        ident = tokenStream.token().value.toLowerCase();\n\
                        if (ident === \"not\") {\n\
                            this._readWhitespace();\n\
                            this._supports_condition();\n\
                            this._readWhitespace();\n\
                            tokenStream.mustMatch(Tokens.RPAREN);\n\
                        } else {\n\
                            tokenStream.unget();\n\
                            this._supports_declaration_condition(false);\n\
                        }\n\
                    } else {\n\
                        this._supports_condition();\n\
                        this._readWhitespace();\n\
                        tokenStream.mustMatch(Tokens.RPAREN);\n\
                    }\n\
                } else {\n\
                    this._supports_declaration_condition();\n\
                }\n\
            },\n\
\n\
            _supports_declaration_condition: function(requireStartParen) {\n\
                /*\n\
                 * supports_declaration_condition\n\
                 *  : '(' S* declaration ')'\n\
                 *  ;\n\
                 */\n\
                var tokenStream = this._tokenStream;\n\
\n\
                if (requireStartParen !== false) {\n\
                    tokenStream.mustMatch(Tokens.LPAREN);\n\
                }\n\
                this._readWhitespace();\n\
                this._declaration();\n\
                tokenStream.mustMatch(Tokens.RPAREN);\n\
            },\n\
\n\
            _media: function() {\n\
                /*\n\
                 * media\n\
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*\n\
                 *   ;\n\
                 */\n\
                var tokenStream     = this._tokenStream,\n\
                    line,\n\
                    col,\n\
                    mediaList;//       = [];\n\
\n\
                //look for @media\n\
                tokenStream.mustMatch(Tokens.MEDIA_SYM);\n\
                line = tokenStream.token().startLine;\n\
                col = tokenStream.token().startCol;\n\
\n\
                this._readWhitespace();\n\
\n\
                mediaList = this._media_query_list();\n\
\n\
                tokenStream.mustMatch(Tokens.LBRACE);\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:   \"startmedia\",\n\
                    media:  mediaList,\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
\n\
                while (true) {\n\
                    if (tokenStream.peek() === Tokens.PAGE_SYM) {\n\
                        this._page();\n\
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {\n\
                        this._font_face();\n\
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {\n\
                        this._viewport();\n\
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {\n\
                        this._document();\n\
                    } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {\n\
                        this._supports();\n\
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {\n\
                        this._media();\n\
                    } else if (!this._ruleset()) {\n\
                        break;\n\
                    }\n\
                }\n\
\n\
                tokenStream.mustMatch(Tokens.RBRACE);\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:   \"endmedia\",\n\
                    media:  mediaList,\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
            },\n\
\n\
\n\
            //CSS3 Media Queries\n\
            _media_query_list: function() {\n\
                /*\n\
                 * media_query_list\n\
                 *   : S* [media_query [ ',' S* media_query ]* ]?\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    mediaList   = [];\n\
\n\
\n\
                this._readWhitespace();\n\
\n\
                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {\n\
                    mediaList.push(this._media_query());\n\
                }\n\
\n\
                while (tokenStream.match(Tokens.COMMA)) {\n\
                    this._readWhitespace();\n\
                    mediaList.push(this._media_query());\n\
                }\n\
\n\
                return mediaList;\n\
            },\n\
\n\
            /*\n\
             * Note: \"expression\" in the grammar maps to the _media_expression\n\
             * method.\n\
\n\
             */\n\
            _media_query: function() {\n\
                /*\n\
                 * media_query\n\
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*\n\
                 *   | expression [ AND S* expression ]*\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    type        = null,\n\
                    ident       = null,\n\
                    token       = null,\n\
                    expressions = [];\n\
\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    ident = tokenStream.token().value.toLowerCase();\n\
\n\
                    //since there's no custom tokens for these, need to manually check\n\
                    if (ident !== \"only\" && ident !== \"not\") {\n\
                        tokenStream.unget();\n\
                        ident = null;\n\
                    } else {\n\
                        token = tokenStream.token();\n\
                    }\n\
                }\n\
\n\
                this._readWhitespace();\n\
\n\
                if (tokenStream.peek() === Tokens.IDENT) {\n\
                    type = this._media_type();\n\
                    if (token === null) {\n\
                        token = tokenStream.token();\n\
                    }\n\
                } else if (tokenStream.peek() === Tokens.LPAREN) {\n\
                    if (token === null) {\n\
                        token = tokenStream.LT(1);\n\
                    }\n\
                    expressions.push(this._media_expression());\n\
                }\n\
\n\
                if (type === null && expressions.length === 0) {\n\
                    return null;\n\
                } else {\n\
                    this._readWhitespace();\n\
                    while (tokenStream.match(Tokens.IDENT)) {\n\
                        if (tokenStream.token().value.toLowerCase() !== \"and\") {\n\
                            this._unexpectedToken(tokenStream.token());\n\
                        }\n\
\n\
                        this._readWhitespace();\n\
                        expressions.push(this._media_expression());\n\
                    }\n\
                }\n\
\n\
                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);\n\
            },\n\
\n\
            //CSS3 Media Queries\n\
            _media_type: function() {\n\
                /*\n\
                 * media_type\n\
                 *   : IDENT\n\
                 *   ;\n\
                 */\n\
                return this._media_feature();\n\
            },\n\
\n\
            /**\n\
             * Note: in CSS3 Media Queries, this is called \"expression\".\n\
             * Renamed here to avoid conflict with CSS3 Selectors\n\
             * definition of \"expression\". Also note that \"expr\" in the\n\
             * grammar now maps to \"expression\" from CSS3 selectors.\n\
             * @method _media_expression\n\
             * @private\n\
             */\n\
            _media_expression: function() {\n\
                /*\n\
                 * expression\n\
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*\n\
                 *  ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    feature     = null,\n\
                    token,\n\
                    expression  = null;\n\
\n\
                tokenStream.mustMatch(Tokens.LPAREN);\n\
\n\
                feature = this._media_feature();\n\
                this._readWhitespace();\n\
\n\
                if (tokenStream.match(Tokens.COLON)) {\n\
                    this._readWhitespace();\n\
                    token = tokenStream.LT(1);\n\
                    expression = this._expression();\n\
                }\n\
\n\
                tokenStream.mustMatch(Tokens.RPAREN);\n\
                this._readWhitespace();\n\
\n\
                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);\n\
            },\n\
\n\
            //CSS3 Media Queries\n\
            _media_feature: function() {\n\
                /*\n\
                 * media_feature\n\
                 *   : IDENT\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream;\n\
\n\
                this._readWhitespace();\n\
\n\
                tokenStream.mustMatch(Tokens.IDENT);\n\
\n\
                return SyntaxUnit.fromToken(tokenStream.token());\n\
            },\n\
\n\
            //CSS3 Paged Media\n\
            _page: function() {\n\
                /*\n\
                 * page:\n\
                 *    PAGE_SYM S* IDENT? pseudo_page? S*\n\
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\n\
                 *    ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col,\n\
                    identifier  = null,\n\
                    pseudoPage  = null;\n\
\n\
                //look for @page\n\
                tokenStream.mustMatch(Tokens.PAGE_SYM);\n\
                line = tokenStream.token().startLine;\n\
                col = tokenStream.token().startCol;\n\
\n\
                this._readWhitespace();\n\
\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    identifier = tokenStream.token().value;\n\
\n\
                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.\n\
                    if (identifier.toLowerCase() === \"auto\") {\n\
                        this._unexpectedToken(tokenStream.token());\n\
                    }\n\
                }\n\
\n\
                //see if there's a colon upcoming\n\
                if (tokenStream.peek() === Tokens.COLON) {\n\
                    pseudoPage = this._pseudo_page();\n\
                }\n\
\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:   \"startpage\",\n\
                    id:     identifier,\n\
                    pseudo: pseudoPage,\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
\n\
                this._readDeclarations(true, true);\n\
\n\
                this.fire({\n\
                    type:   \"endpage\",\n\
                    id:     identifier,\n\
                    pseudo: pseudoPage,\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
            },\n\
\n\
            //CSS3 Paged Media\n\
            _margin: function() {\n\
                /*\n\
                 * margin :\n\
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*\n\
                 *    ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col,\n\
                    marginSym   = this._margin_sym();\n\
\n\
                if (marginSym) {\n\
                    line = tokenStream.token().startLine;\n\
                    col = tokenStream.token().startCol;\n\
\n\
                    this.fire({\n\
                        type: \"startpagemargin\",\n\
                        margin: marginSym,\n\
                        line:   line,\n\
                        col:    col\n\
                    });\n\
\n\
                    this._readDeclarations(true);\n\
\n\
                    this.fire({\n\
                        type: \"endpagemargin\",\n\
                        margin: marginSym,\n\
                        line:   line,\n\
                        col:    col\n\
                    });\n\
                    return true;\n\
                } else {\n\
                    return false;\n\
                }\n\
            },\n\
\n\
            //CSS3 Paged Media\n\
            _margin_sym: function() {\n\
\n\
                /*\n\
                 * margin_sym :\n\
                 *    TOPLEFTCORNER_SYM |\n\
                 *    TOPLEFT_SYM |\n\
                 *    TOPCENTER_SYM |\n\
                 *    TOPRIGHT_SYM |\n\
                 *    TOPRIGHTCORNER_SYM |\n\
                 *    BOTTOMLEFTCORNER_SYM |\n\
                 *    BOTTOMLEFT_SYM |\n\
                 *    BOTTOMCENTER_SYM |\n\
                 *    BOTTOMRIGHT_SYM |\n\
                 *    BOTTOMRIGHTCORNER_SYM |\n\
                 *    LEFTTOP_SYM |\n\
                 *    LEFTMIDDLE_SYM |\n\
                 *    LEFTBOTTOM_SYM |\n\
                 *    RIGHTTOP_SYM |\n\
                 *    RIGHTMIDDLE_SYM |\n\
                 *    RIGHTBOTTOM_SYM\n\
                 *    ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream;\n\
\n\
                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,\n\
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,\n\
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,\n\
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,\n\
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,\n\
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,\n\
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {\n\
                    return SyntaxUnit.fromToken(tokenStream.token());\n\
                } else {\n\
                    return null;\n\
                }\n\
            },\n\
\n\
            _pseudo_page: function() {\n\
                /*\n\
                 * pseudo_page\n\
                 *   : ':' IDENT\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream;\n\
\n\
                tokenStream.mustMatch(Tokens.COLON);\n\
                tokenStream.mustMatch(Tokens.IDENT);\n\
\n\
                //TODO: CSS3 Paged Media says only \"left\", \"center\", and \"right\" are allowed\n\
\n\
                return tokenStream.token().value;\n\
            },\n\
\n\
            _font_face: function() {\n\
                /*\n\
                 * font_face\n\
                 *   : FONT_FACE_SYM S*\n\
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col;\n\
\n\
                //look for @page\n\
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);\n\
                line = tokenStream.token().startLine;\n\
                col = tokenStream.token().startCol;\n\
\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:   \"startfontface\",\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
\n\
                this._readDeclarations(true);\n\
\n\
                this.fire({\n\
                    type:   \"endfontface\",\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
            },\n\
\n\
            _viewport: function() {\n\
                /*\n\
                 * viewport\n\
                 *   : VIEWPORT_SYM S*\n\
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col;\n\
\n\
                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);\n\
                line = tokenStream.token().startLine;\n\
                col = tokenStream.token().startCol;\n\
\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:   \"startviewport\",\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
\n\
                this._readDeclarations(true);\n\
\n\
                this.fire({\n\
                    type:   \"endviewport\",\n\
                    line:   line,\n\
                    col:    col\n\
                });\n\
            },\n\
\n\
            _document: function() {\n\
                /*\n\
                 * document\n\
                 *   : DOCUMENT_SYM S*\n\
                 *     _document_function [ ',' S* _document_function ]* S*\n\
                 *     '{' S* ruleset* '}'\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token,\n\
                    functions = [],\n\
                    prefix = \"\";\n\
\n\
                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);\n\
                token = tokenStream.token();\n\
                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\n\
                    prefix = RegExp.$1;\n\
                }\n\
\n\
                this._readWhitespace();\n\
                functions.push(this._document_function());\n\
\n\
                while (tokenStream.match(Tokens.COMMA)) {\n\
                    this._readWhitespace();\n\
                    functions.push(this._document_function());\n\
                }\n\
\n\
                tokenStream.mustMatch(Tokens.LBRACE);\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:      \"startdocument\",\n\
                    functions: functions,\n\
                    prefix:    prefix,\n\
                    line:      token.startLine,\n\
                    col:       token.startCol\n\
                });\n\
\n\
                var ok = true;\n\
                while (ok) {\n\
                    switch (tokenStream.peek()) {\n\
                        case Tokens.PAGE_SYM:\n\
                            this._page();\n\
                            break;\n\
                        case Tokens.FONT_FACE_SYM:\n\
                            this._font_face();\n\
                            break;\n\
                        case Tokens.VIEWPORT_SYM:\n\
                            this._viewport();\n\
                            break;\n\
                        case Tokens.MEDIA_SYM:\n\
                            this._media();\n\
                            break;\n\
                        case Tokens.KEYFRAMES_SYM:\n\
                            this._keyframes();\n\
                            break;\n\
                        case Tokens.DOCUMENT_SYM:\n\
                            this._document();\n\
                            break;\n\
                        default:\n\
                            ok = Boolean(this._ruleset());\n\
                    }\n\
                }\n\
\n\
                tokenStream.mustMatch(Tokens.RBRACE);\n\
                token = tokenStream.token();\n\
                this._readWhitespace();\n\
\n\
                this.fire({\n\
                    type:      \"enddocument\",\n\
                    functions: functions,\n\
                    prefix:    prefix,\n\
                    line:      token.startLine,\n\
                    col:       token.startCol\n\
                });\n\
            },\n\
\n\
            _document_function: function() {\n\
                /*\n\
                 * document_function\n\
                 *   : function | URI S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value;\n\
\n\
                if (tokenStream.match(Tokens.URI)) {\n\
                    value = tokenStream.token().value;\n\
                    this._readWhitespace();\n\
                } else {\n\
                    value = this._function();\n\
                }\n\
\n\
                return value;\n\
            },\n\
\n\
            _operator: function(inFunction) {\n\
\n\
                /*\n\
                 * operator (outside function)\n\
                 *  : '/' S* | ',' S* | /( empty )/\n\
                 * operator (inside function)\n\
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/\n\
                 *  ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token       = null;\n\
\n\
                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||\n\
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))) {\n\
                    token =  tokenStream.token();\n\
                    this._readWhitespace();\n\
                }\n\
                return token ? PropertyValuePart.fromToken(token) : null;\n\
            },\n\
\n\
            _combinator: function() {\n\
\n\
                /*\n\
                 * combinator\n\
                 *  : PLUS S* | GREATER S* | TILDE S* | S+\n\
                 *  ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value       = null,\n\
                    token;\n\
\n\
                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {\n\
                    token = tokenStream.token();\n\
                    value = new Combinator(token.value, token.startLine, token.startCol);\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return value;\n\
            },\n\
\n\
            _unary_operator: function() {\n\
\n\
                /*\n\
                 * unary_operator\n\
                 *  : '-' | '+'\n\
                 *  ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream;\n\
\n\
                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {\n\
                    return tokenStream.token().value;\n\
                } else {\n\
                    return null;\n\
                }\n\
            },\n\
\n\
            _property: function() {\n\
\n\
                /*\n\
                 * property\n\
                 *   : IDENT S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value       = null,\n\
                    hack        = null,\n\
                    tokenValue,\n\
                    token,\n\
                    line,\n\
                    col;\n\
\n\
                //check for star hack - throws error if not allowed\n\
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {\n\
                    tokenStream.get();\n\
                    token = tokenStream.token();\n\
                    hack = token.value;\n\
                    line = token.startLine;\n\
                    col = token.startCol;\n\
                }\n\
\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    token = tokenStream.token();\n\
                    tokenValue = token.value;\n\
\n\
                    //check for underscore hack - no error if not allowed because it's valid CSS syntax\n\
                    if (tokenValue.charAt(0) === \"_\" && this.options.underscoreHack) {\n\
                        hack = \"_\";\n\
                        tokenValue = tokenValue.substring(1);\n\
                    }\n\
\n\
                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return value;\n\
            },\n\
\n\
            //Augmented with CSS3 Selectors\n\
            _ruleset: function() {\n\
                /*\n\
                 * ruleset\n\
                 *   : selectors_group\n\
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    tt,\n\
                    selectors;\n\
\n\
\n\
                /*\n\
                 * Error Recovery: If even a single selector fails to parse,\n\
                 * then the entire ruleset should be thrown away.\n\
                 */\n\
                try {\n\
                    selectors = this._selectors_group();\n\
                } catch (ex) {\n\
                    if (ex instanceof SyntaxError && !this.options.strict) {\n\
\n\
                        //fire error event\n\
                        this.fire({\n\
                            type:       \"error\",\n\
                            error:      ex,\n\
                            message:    ex.message,\n\
                            line:       ex.line,\n\
                            col:        ex.col\n\
                        });\n\
\n\
                        //skip over everything until closing brace\n\
                        tt = tokenStream.advance([Tokens.RBRACE]);\n\
                        if (tt === Tokens.RBRACE) {\n\
                            //if there's a right brace, the rule is finished so don't do anything\n\
                        } else {\n\
                            //otherwise, rethrow the error because it wasn't handled properly\n\
                            throw ex;\n\
                        }\n\
                    } else {\n\
                        //not a syntax error, rethrow it\n\
                        throw ex;\n\
                    }\n\
\n\
                    //trigger parser to continue\n\
                    return true;\n\
                }\n\
\n\
                //if it got here, all selectors parsed\n\
                if (selectors) {\n\
\n\
                    this.fire({\n\
                        type:       \"startrule\",\n\
                        selectors:  selectors,\n\
                        line:       selectors[0].line,\n\
                        col:        selectors[0].col\n\
                    });\n\
\n\
                    this._readDeclarations(true);\n\
\n\
                    this.fire({\n\
                        type:       \"endrule\",\n\
                        selectors:  selectors,\n\
                        line:       selectors[0].line,\n\
                        col:        selectors[0].col\n\
                    });\n\
                }\n\
\n\
                return selectors;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _selectors_group: function() {\n\
\n\
                /*\n\
                 * selectors_group\n\
                 *   : selector [ COMMA S* selector ]*\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    selectors   = [],\n\
                    selector;\n\
\n\
                selector = this._selector();\n\
                if (selector !== null) {\n\
\n\
                    selectors.push(selector);\n\
                    while (tokenStream.match(Tokens.COMMA)) {\n\
                        this._readWhitespace();\n\
                        selector = this._selector();\n\
                        if (selector !== null) {\n\
                            selectors.push(selector);\n\
                        } else {\n\
                            this._unexpectedToken(tokenStream.LT(1));\n\
                        }\n\
                    }\n\
                }\n\
\n\
                return selectors.length ? selectors : null;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _selector: function() {\n\
                /*\n\
                 * selector\n\
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    selector    = [],\n\
                    nextSelector = null,\n\
                    combinator  = null,\n\
                    ws          = null;\n\
\n\
                //if there's no simple selector, then there's no selector\n\
                nextSelector = this._simple_selector_sequence();\n\
                if (nextSelector === null) {\n\
                    return null;\n\
                }\n\
\n\
                selector.push(nextSelector);\n\
\n\
                do {\n\
\n\
                    //look for a combinator\n\
                    combinator = this._combinator();\n\
\n\
                    if (combinator !== null) {\n\
                        selector.push(combinator);\n\
                        nextSelector = this._simple_selector_sequence();\n\
\n\
                        //there must be a next selector\n\
                        if (nextSelector === null) {\n\
                            this._unexpectedToken(tokenStream.LT(1));\n\
                        } else {\n\
\n\
                            //nextSelector is an instance of SelectorPart\n\
                            selector.push(nextSelector);\n\
                        }\n\
                    } else {\n\
\n\
                        //if there's not whitespace, we're done\n\
                        if (this._readWhitespace()) {\n\
\n\
                            //add whitespace separator\n\
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);\n\
\n\
                            //combinator is not required\n\
                            combinator = this._combinator();\n\
\n\
                            //selector is required if there's a combinator\n\
                            nextSelector = this._simple_selector_sequence();\n\
                            if (nextSelector === null) {\n\
                                if (combinator !== null) {\n\
                                    this._unexpectedToken(tokenStream.LT(1));\n\
                                }\n\
                            } else {\n\
\n\
                                if (combinator !== null) {\n\
                                    selector.push(combinator);\n\
                                } else {\n\
                                    selector.push(ws);\n\
                                }\n\
\n\
                                selector.push(nextSelector);\n\
                            }\n\
                        } else {\n\
                            break;\n\
                        }\n\
                    }\n\
                } while (true);\n\
\n\
                return new Selector(selector, selector[0].line, selector[0].col);\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _simple_selector_sequence: function() {\n\
                /*\n\
                 * simple_selector_sequence\n\
                 *   : [ type_selector | universal ]\n\
                 *     [ HASH | class | attrib | pseudo | negation ]*\n\
                 *   | [ HASH | class | attrib | pseudo | negation ]+\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
\n\
                    //parts of a simple selector\n\
                    elementName = null,\n\
                    modifiers   = [],\n\
\n\
                    //complete selector text\n\
                    selectorText= \"\",\n\
\n\
                    //the different parts after the element name to search for\n\
                    components  = [\n\
                        //HASH\n\
                        function() {\n\
                            return tokenStream.match(Tokens.HASH) ?\n\
                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\n\
                                    null;\n\
                        },\n\
                        this._class,\n\
                        this._attrib,\n\
                        this._pseudo,\n\
                        this._negation\n\
                    ],\n\
                    i           = 0,\n\
                    len         = components.length,\n\
                    component   = null,\n\
                    line,\n\
                    col;\n\
\n\
\n\
                //get starting line and column for the selector\n\
                line = tokenStream.LT(1).startLine;\n\
                col = tokenStream.LT(1).startCol;\n\
\n\
                elementName = this._type_selector();\n\
                if (!elementName) {\n\
                    elementName = this._universal();\n\
                }\n\
\n\
                if (elementName !== null) {\n\
                    selectorText += elementName;\n\
                }\n\
\n\
                while (true) {\n\
\n\
                    //whitespace means we're done\n\
                    if (tokenStream.peek() === Tokens.S) {\n\
                        break;\n\
                    }\n\
\n\
                    //check for each component\n\
                    while (i < len && component === null) {\n\
                        component = components[i++].call(this);\n\
                    }\n\
\n\
                    if (component === null) {\n\
\n\
                        //we don't have a selector\n\
                        if (selectorText === \"\") {\n\
                            return null;\n\
                        } else {\n\
                            break;\n\
                        }\n\
                    } else {\n\
                        i = 0;\n\
                        modifiers.push(component);\n\
                        selectorText += component.toString();\n\
                        component = null;\n\
                    }\n\
                }\n\
\n\
\n\
                return selectorText !== \"\" ?\n\
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :\n\
                        null;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _type_selector: function() {\n\
                /*\n\
                 * type_selector\n\
                 *   : [ namespace_prefix ]? element_name\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    ns          = this._namespace_prefix(),\n\
                    elementName = this._element_name();\n\
\n\
                if (!elementName) {\n\
                    /*\n\
                     * Need to back out the namespace that was read due to both\n\
                     * type_selector and universal reading namespace_prefix\n\
                     * first. Kind of hacky, but only way I can figure out\n\
                     * right now how to not change the grammar.\n\
                     */\n\
                    if (ns) {\n\
                        tokenStream.unget();\n\
                        if (ns.length > 1) {\n\
                            tokenStream.unget();\n\
                        }\n\
                    }\n\
\n\
                    return null;\n\
                } else {\n\
                    if (ns) {\n\
                        elementName.text = ns + elementName.text;\n\
                        elementName.col -= ns.length;\n\
                    }\n\
                    return elementName;\n\
                }\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _class: function() {\n\
                /*\n\
                 * class\n\
                 *   : '.' IDENT\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token;\n\
\n\
                if (tokenStream.match(Tokens.DOT)) {\n\
                    tokenStream.mustMatch(Tokens.IDENT);\n\
                    token = tokenStream.token();\n\
                    return new SelectorSubPart(\".\" + token.value, \"class\", token.startLine, token.startCol - 1);\n\
                } else {\n\
                    return null;\n\
                }\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _element_name: function() {\n\
                /*\n\
                 * element_name\n\
                 *   : IDENT\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token;\n\
\n\
                if (tokenStream.match(Tokens.IDENT)) {\n\
                    token = tokenStream.token();\n\
                    return new SelectorSubPart(token.value, \"elementName\", token.startLine, token.startCol);\n\
                } else {\n\
                    return null;\n\
                }\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _namespace_prefix: function() {\n\
                /*\n\
                 * namespace_prefix\n\
                 *   : [ IDENT | '*' ]? '|'\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    value       = \"\";\n\
\n\
                //verify that this is a namespace prefix\n\
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {\n\
\n\
                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {\n\
                        value += tokenStream.token().value;\n\
                    }\n\
\n\
                    tokenStream.mustMatch(Tokens.PIPE);\n\
                    value += \"|\";\n\
                }\n\
\n\
                return value.length ? value : null;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _universal: function() {\n\
                /*\n\
                 * universal\n\
                 *   : [ namespace_prefix ]? '*'\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    value       = \"\",\n\
                    ns;\n\
\n\
                ns = this._namespace_prefix();\n\
                if (ns) {\n\
                    value += ns;\n\
                }\n\
\n\
                if (tokenStream.match(Tokens.STAR)) {\n\
                    value += \"*\";\n\
                }\n\
\n\
                return value.length ? value : null;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _attrib: function() {\n\
                /*\n\
                 * attrib\n\
                 *   : '[' S* [ namespace_prefix ]? IDENT S*\n\
                 *         [ [ PREFIXMATCH |\n\
                 *             SUFFIXMATCH |\n\
                 *             SUBSTRINGMATCH |\n\
                 *             '=' |\n\
                 *             INCLUDES |\n\
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*\n\
                 *         ]? ']'\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value       = null,\n\
                    ns,\n\
                    token;\n\
\n\
                if (tokenStream.match(Tokens.LBRACKET)) {\n\
                    token = tokenStream.token();\n\
                    value = token.value;\n\
                    value += this._readWhitespace();\n\
\n\
                    ns = this._namespace_prefix();\n\
\n\
                    if (ns) {\n\
                        value += ns;\n\
                    }\n\
\n\
                    tokenStream.mustMatch(Tokens.IDENT);\n\
                    value += tokenStream.token().value;\n\
                    value += this._readWhitespace();\n\
\n\
                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,\n\
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {\n\
\n\
                        value += tokenStream.token().value;\n\
                        value += this._readWhitespace();\n\
\n\
                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\n\
                        value += tokenStream.token().value;\n\
                        value += this._readWhitespace();\n\
                    }\n\
\n\
                    tokenStream.mustMatch(Tokens.RBRACKET);\n\
\n\
                    return new SelectorSubPart(value + \"]\", \"attribute\", token.startLine, token.startCol);\n\
                } else {\n\
                    return null;\n\
                }\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _pseudo: function() {\n\
\n\
                /*\n\
                 * pseudo\n\
                 *   : ':' ':'? [ IDENT | functional_pseudo ]\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    pseudo      = null,\n\
                    colons      = \":\",\n\
                    line,\n\
                    col;\n\
\n\
                if (tokenStream.match(Tokens.COLON)) {\n\
\n\
                    if (tokenStream.match(Tokens.COLON)) {\n\
                        colons += \":\";\n\
                    }\n\
\n\
                    if (tokenStream.match(Tokens.IDENT)) {\n\
                        pseudo = tokenStream.token().value;\n\
                        line = tokenStream.token().startLine;\n\
                        col = tokenStream.token().startCol - colons.length;\n\
                    } else if (tokenStream.peek() === Tokens.FUNCTION) {\n\
                        line = tokenStream.LT(1).startLine;\n\
                        col = tokenStream.LT(1).startCol - colons.length;\n\
                        pseudo = this._functional_pseudo();\n\
                    }\n\
\n\
                    if (pseudo) {\n\
                        pseudo = new SelectorSubPart(colons + pseudo, \"pseudo\", line, col);\n\
                    } else {\n\
                        var startLine = tokenStream.LT(1).startLine,\n\
                            startCol  = tokenStream.LT(0).startCol;\n\
                        throw new SyntaxError(\"Expected a `FUNCTION` or `IDENT` after colon at line \" + startLine + \", col \" + startCol + \".\", startLine, startCol);\n\
                    }\n\
                }\n\
\n\
                return pseudo;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _functional_pseudo: function() {\n\
                /*\n\
                 * functional_pseudo\n\
                 *   : FUNCTION S* expression ')'\n\
                 *   ;\n\
                */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value = null;\n\
\n\
                if (tokenStream.match(Tokens.FUNCTION)) {\n\
                    value = tokenStream.token().value;\n\
                    value += this._readWhitespace();\n\
                    value += this._expression();\n\
                    tokenStream.mustMatch(Tokens.RPAREN);\n\
                    value += \")\";\n\
                }\n\
\n\
                return value;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _expression: function() {\n\
                /*\n\
                 * expression\n\
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    value       = \"\";\n\
\n\
                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,\n\
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,\n\
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,\n\
                        Tokens.RESOLUTION, Tokens.SLASH])) {\n\
\n\
                    value += tokenStream.token().value;\n\
                    value += this._readWhitespace();\n\
                }\n\
\n\
                return value.length ? value : null;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _negation: function() {\n\
                /*\n\
                 * negation\n\
                 *   : NOT S* negation_arg S* ')'\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    line,\n\
                    col,\n\
                    value       = \"\",\n\
                    arg,\n\
                    subpart     = null;\n\
\n\
                if (tokenStream.match(Tokens.NOT)) {\n\
                    value = tokenStream.token().value;\n\
                    line = tokenStream.token().startLine;\n\
                    col = tokenStream.token().startCol;\n\
                    value += this._readWhitespace();\n\
                    arg = this._negation_arg();\n\
                    value += arg;\n\
                    value += this._readWhitespace();\n\
                    tokenStream.match(Tokens.RPAREN);\n\
                    value += tokenStream.token().value;\n\
\n\
                    subpart = new SelectorSubPart(value, \"not\", line, col);\n\
                    subpart.args.push(arg);\n\
                }\n\
\n\
                return subpart;\n\
            },\n\
\n\
            //CSS3 Selectors\n\
            _negation_arg: function() {\n\
                /*\n\
                 * negation_arg\n\
                 *   : type_selector | universal | HASH | class | attrib | pseudo\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    args        = [\n\
                        this._type_selector,\n\
                        this._universal,\n\
                        function() {\n\
                            return tokenStream.match(Tokens.HASH) ?\n\
                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\n\
                                    null;\n\
                        },\n\
                        this._class,\n\
                        this._attrib,\n\
                        this._pseudo\n\
                    ],\n\
                    arg         = null,\n\
                    i           = 0,\n\
                    len         = args.length,\n\
                    line,\n\
                    col,\n\
                    part;\n\
\n\
                line = tokenStream.LT(1).startLine;\n\
                col = tokenStream.LT(1).startCol;\n\
\n\
                while (i < len && arg === null) {\n\
\n\
                    arg = args[i].call(this);\n\
                    i++;\n\
                }\n\
\n\
                //must be a negation arg\n\
                if (arg === null) {\n\
                    this._unexpectedToken(tokenStream.LT(1));\n\
                }\n\
\n\
                //it's an element name\n\
                if (arg.type === \"elementName\") {\n\
                    part = new SelectorPart(arg, [], arg.toString(), line, col);\n\
                } else {\n\
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);\n\
                }\n\
\n\
                return part;\n\
            },\n\
\n\
            _declaration: function() {\n\
\n\
                /*\n\
                 * declaration\n\
                 *   : property ':' S* expr prio?\n\
                 *   | /( empty )/\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    property    = null,\n\
                    expr        = null,\n\
                    prio        = null,\n\
                    invalid     = null,\n\
                    propertyName= \"\";\n\
\n\
                property = this._property();\n\
                if (property !== null) {\n\
\n\
                    tokenStream.mustMatch(Tokens.COLON);\n\
                    this._readWhitespace();\n\
\n\
                    expr = this._expr();\n\
\n\
                    //if there's no parts for the value, it's an error\n\
                    if (!expr || expr.length === 0) {\n\
                        this._unexpectedToken(tokenStream.LT(1));\n\
                    }\n\
\n\
                    prio = this._prio();\n\
\n\
                    /*\n\
                     * If hacks should be allowed, then only check the root\n\
                     * property. If hacks should not be allowed, treat\n\
                     * _property or *property as invalid properties.\n\
                     */\n\
                    propertyName = property.toString();\n\
                    if (this.options.starHack && property.hack === \"*\" ||\n\
                            this.options.underscoreHack && property.hack === \"_\") {\n\
\n\
                        propertyName = property.text;\n\
                    }\n\
\n\
                    try {\n\
                        this._validateProperty(propertyName, expr);\n\
                    } catch (ex) {\n\
                        invalid = ex;\n\
                    }\n\
\n\
                    this.fire({\n\
                        type:       \"property\",\n\
                        property:   property,\n\
                        value:      expr,\n\
                        important:  prio,\n\
                        line:       property.line,\n\
                        col:        property.col,\n\
                        invalid:    invalid\n\
                    });\n\
\n\
                    return true;\n\
                } else {\n\
                    return false;\n\
                }\n\
            },\n\
\n\
            _prio: function() {\n\
                /*\n\
                 * prio\n\
                 *   : IMPORTANT_SYM S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);\n\
\n\
                this._readWhitespace();\n\
                return result;\n\
            },\n\
\n\
            _expr: function(inFunction) {\n\
                /*\n\
                 * expr\n\
                 *   : term [ operator term ]*\n\
                 *   ;\n\
                 */\n\
\n\
                var values      = [],\n\
                    //valueParts    = [],\n\
                    value       = null,\n\
                    operator    = null;\n\
\n\
                value = this._term(inFunction);\n\
                if (value !== null) {\n\
\n\
                    values.push(value);\n\
\n\
                    do {\n\
                        operator = this._operator(inFunction);\n\
\n\
                        //if there's an operator, keep building up the value parts\n\
                        if (operator) {\n\
                            values.push(operator);\n\
                        } /*else {\n\
                            //if there's not an operator, you have a full value\n\
                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\n\
                            valueParts = [];\n\
                        }*/\n\
\n\
                        value = this._term(inFunction);\n\
\n\
                        if (value === null) {\n\
                            break;\n\
                        } else {\n\
                            values.push(value);\n\
                        }\n\
                    } while (true);\n\
                }\n\
\n\
                //cleanup\n\
                /*if (valueParts.length) {\n\
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\n\
                }*/\n\
\n\
                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;\n\
            },\n\
\n\
            _term: function(inFunction) {\n\
\n\
                /*\n\
                 * term\n\
                 *   : unary_operator?\n\
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |\n\
                 *       TIME S* | FREQ S* | function | ie_function ]\n\
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    unary       = null,\n\
                    value       = null,\n\
                    endChar     = null,\n\
                    part        = null,\n\
                    token,\n\
                    line,\n\
                    col;\n\
\n\
                //returns the operator or null\n\
                unary = this._unary_operator();\n\
                if (unary !== null) {\n\
                    line = tokenStream.token().startLine;\n\
                    col = tokenStream.token().startCol;\n\
                }\n\
\n\
                //exception for IE filters\n\
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {\n\
\n\
                    value = this._ie_function();\n\
                    if (unary === null) {\n\
                        line = tokenStream.token().startLine;\n\
                        col = tokenStream.token().startCol;\n\
                    }\n\
\n\
                //see if it's a simple block\n\
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {\n\
\n\
                    token = tokenStream.token();\n\
                    endChar = token.endChar;\n\
                    value = token.value + this._expr(inFunction).text;\n\
                    if (unary === null) {\n\
                        line = tokenStream.token().startLine;\n\
                        col = tokenStream.token().startCol;\n\
                    }\n\
                    tokenStream.mustMatch(Tokens.type(endChar));\n\
                    value += endChar;\n\
                    this._readWhitespace();\n\
\n\
                //see if there's a simple match\n\
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,\n\
                        Tokens.ANGLE, Tokens.TIME,\n\
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {\n\
\n\
                    value = tokenStream.token().value;\n\
                    if (unary === null) {\n\
                        line = tokenStream.token().startLine;\n\
                        col = tokenStream.token().startCol;\n\
                        // Correct potentially-inaccurate IDENT parsing in\n\
                        // PropertyValuePart constructor.\n\
                        part = PropertyValuePart.fromToken(tokenStream.token());\n\
                    }\n\
                    this._readWhitespace();\n\
                } else {\n\
\n\
                    //see if it's a color\n\
                    token = this._hexcolor();\n\
                    if (token === null) {\n\
\n\
                        //if there's no unary, get the start of the next token for line/col info\n\
                        if (unary === null) {\n\
                            line = tokenStream.LT(1).startLine;\n\
                            col = tokenStream.LT(1).startCol;\n\
                        }\n\
\n\
                        //has to be a function\n\
                        if (value === null) {\n\
\n\
                            /*\n\
                             * This checks for alpha(opacity=0) style of IE\n\
                             * functions. IE_FUNCTION only presents progid: style.\n\
                             */\n\
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {\n\
                                value = this._ie_function();\n\
                            } else {\n\
                                value = this._function();\n\
                            }\n\
                        }\n\
\n\
                        /*if (value === null) {\n\
                            return null;\n\
                            //throw new Error(\"Expected identifier at line \" + tokenStream.token().startLine + \", character \" +  tokenStream.token().startCol + \".\");\n\
                        }*/\n\
                    } else {\n\
                        value = token.value;\n\
                        if (unary === null) {\n\
                            line = token.startLine;\n\
                            col = token.startCol;\n\
                        }\n\
                    }\n\
                }\n\
\n\
                return part !== null ? part : value !== null ?\n\
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :\n\
                        null;\n\
            },\n\
\n\
            _function: function() {\n\
\n\
                /*\n\
                 * function\n\
                 *   : FUNCTION S* expr ')' S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    functionText = null,\n\
                    expr        = null,\n\
                    lt;\n\
\n\
                if (tokenStream.match(Tokens.FUNCTION)) {\n\
                    functionText = tokenStream.token().value;\n\
                    this._readWhitespace();\n\
                    expr = this._expr(true);\n\
                    functionText += expr;\n\
\n\
                    //START: Horrible hack in case it's an IE filter\n\
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {\n\
                        do {\n\
\n\
                            if (this._readWhitespace()) {\n\
                                functionText += tokenStream.token().value;\n\
                            }\n\
\n\
                            //might be second time in the loop\n\
                            if (tokenStream.LA(0) === Tokens.COMMA) {\n\
                                functionText += tokenStream.token().value;\n\
                            }\n\
\n\
                            tokenStream.match(Tokens.IDENT);\n\
                            functionText += tokenStream.token().value;\n\
\n\
                            tokenStream.match(Tokens.EQUALS);\n\
                            functionText += tokenStream.token().value;\n\
\n\
                            //functionText += this._term();\n\
                            lt = tokenStream.peek();\n\
                            while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\n\
                                tokenStream.get();\n\
                                functionText += tokenStream.token().value;\n\
                                lt = tokenStream.peek();\n\
                            }\n\
                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\n\
                    }\n\
\n\
                    //END: Horrible Hack\n\
\n\
                    tokenStream.match(Tokens.RPAREN);\n\
                    functionText += \")\";\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return functionText;\n\
            },\n\
\n\
            _ie_function: function() {\n\
\n\
                /* (My own extension)\n\
                 * ie_function\n\
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    functionText = null,\n\
                    lt;\n\
\n\
                //IE function can begin like a regular function, too\n\
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {\n\
                    functionText = tokenStream.token().value;\n\
\n\
                    do {\n\
\n\
                        if (this._readWhitespace()) {\n\
                            functionText += tokenStream.token().value;\n\
                        }\n\
\n\
                        //might be second time in the loop\n\
                        if (tokenStream.LA(0) === Tokens.COMMA) {\n\
                            functionText += tokenStream.token().value;\n\
                        }\n\
\n\
                        tokenStream.match(Tokens.IDENT);\n\
                        functionText += tokenStream.token().value;\n\
\n\
                        tokenStream.match(Tokens.EQUALS);\n\
                        functionText += tokenStream.token().value;\n\
\n\
                        //functionText += this._term();\n\
                        lt = tokenStream.peek();\n\
                        while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\n\
                            tokenStream.get();\n\
                            functionText += tokenStream.token().value;\n\
                            lt = tokenStream.peek();\n\
                        }\n\
                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\n\
\n\
                    tokenStream.match(Tokens.RPAREN);\n\
                    functionText += \")\";\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return functionText;\n\
            },\n\
\n\
            _hexcolor: function() {\n\
                /*\n\
                 * There is a constraint on the color that it must\n\
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])\n\
                 * after the \"#\"; e.g., \"#000\" is OK, but \"#abcd\" is not.\n\
                 *\n\
                 * hexcolor\n\
                 *   : HASH S*\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token = null,\n\
                    color;\n\
\n\
                if (tokenStream.match(Tokens.HASH)) {\n\
\n\
                    //need to do some validation here\n\
\n\
                    token = tokenStream.token();\n\
                    color = token.value;\n\
                    if (!/#[a-f0-9]{3,6}/i.test(color)) {\n\
                        throw new SyntaxError(\"Expected a hex color but found '\" + color + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n\
                    }\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return token;\n\
            },\n\
\n\
            //-----------------------------------------------------------------\n\
            // Animations methods\n\
            //-----------------------------------------------------------------\n\
\n\
            _keyframes: function() {\n\
\n\
                /*\n\
                 * keyframes:\n\
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    token,\n\
                    tt,\n\
                    name,\n\
                    prefix = \"\";\n\
\n\
                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);\n\
                token = tokenStream.token();\n\
                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\n\
                    prefix = RegExp.$1;\n\
                }\n\
\n\
                this._readWhitespace();\n\
                name = this._keyframe_name();\n\
\n\
                this._readWhitespace();\n\
                tokenStream.mustMatch(Tokens.LBRACE);\n\
\n\
                this.fire({\n\
                    type:   \"startkeyframes\",\n\
                    name:   name,\n\
                    prefix: prefix,\n\
                    line:   token.startLine,\n\
                    col:    token.startCol\n\
                });\n\
\n\
                this._readWhitespace();\n\
                tt = tokenStream.peek();\n\
\n\
                //check for key\n\
                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {\n\
                    this._keyframe_rule();\n\
                    this._readWhitespace();\n\
                    tt = tokenStream.peek();\n\
                }\n\
\n\
                this.fire({\n\
                    type:   \"endkeyframes\",\n\
                    name:   name,\n\
                    prefix: prefix,\n\
                    line:   token.startLine,\n\
                    col:    token.startCol\n\
                });\n\
\n\
                this._readWhitespace();\n\
                tokenStream.mustMatch(Tokens.RBRACE);\n\
                this._readWhitespace();\n\
            },\n\
\n\
            _keyframe_name: function() {\n\
\n\
                /*\n\
                 * keyframe_name:\n\
                 *   : IDENT\n\
                 *   | STRING\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream;\n\
\n\
                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\n\
                return SyntaxUnit.fromToken(tokenStream.token());\n\
            },\n\
\n\
            _keyframe_rule: function() {\n\
\n\
                /*\n\
                 * keyframe_rule:\n\
                 *   : key_list S*\n\
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\n\
                 *   ;\n\
                 */\n\
                var keyList = this._key_list();\n\
\n\
                this.fire({\n\
                    type:   \"startkeyframerule\",\n\
                    keys:   keyList,\n\
                    line:   keyList[0].line,\n\
                    col:    keyList[0].col\n\
                });\n\
\n\
                this._readDeclarations(true);\n\
\n\
                this.fire({\n\
                    type:   \"endkeyframerule\",\n\
                    keys:   keyList,\n\
                    line:   keyList[0].line,\n\
                    col:    keyList[0].col\n\
                });\n\
            },\n\
\n\
            _key_list: function() {\n\
\n\
                /*\n\
                 * key_list:\n\
                 *   : key [ S* ',' S* key]*\n\
                 *   ;\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    keyList = [];\n\
\n\
                //must be least one key\n\
                keyList.push(this._key());\n\
\n\
                this._readWhitespace();\n\
\n\
                while (tokenStream.match(Tokens.COMMA)) {\n\
                    this._readWhitespace();\n\
                    keyList.push(this._key());\n\
                    this._readWhitespace();\n\
                }\n\
\n\
                return keyList;\n\
            },\n\
\n\
            _key: function() {\n\
                /*\n\
                 * There is a restriction that IDENT can be only \"from\" or \"to\".\n\
                 *\n\
                 * key\n\
                 *   : PERCENTAGE\n\
                 *   | IDENT\n\
                 *   ;\n\
                 */\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    token;\n\
\n\
                if (tokenStream.match(Tokens.PERCENTAGE)) {\n\
                    return SyntaxUnit.fromToken(tokenStream.token());\n\
                } else if (tokenStream.match(Tokens.IDENT)) {\n\
                    token = tokenStream.token();\n\
\n\
                    if (/from|to/i.test(token.value)) {\n\
                        return SyntaxUnit.fromToken(token);\n\
                    }\n\
\n\
                    tokenStream.unget();\n\
                }\n\
\n\
                //if it gets here, there wasn't a valid token, so time to explode\n\
                this._unexpectedToken(tokenStream.LT(1));\n\
            },\n\
\n\
            //-----------------------------------------------------------------\n\
            // Helper methods\n\
            //-----------------------------------------------------------------\n\
\n\
            /**\n\
             * Not part of CSS grammar, but useful for skipping over\n\
             * combination of white space and HTML-style comments.\n\
             * @return {void}\n\
             * @method _skipCruft\n\
             * @private\n\
             */\n\
            _skipCruft: function() {\n\
                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {\n\
                    //noop\n\
                }\n\
            },\n\
\n\
            /**\n\
             * Not part of CSS grammar, but this pattern occurs frequently\n\
             * in the official CSS grammar. Split out here to eliminate\n\
             * duplicate code.\n\
             * @param {Boolean} checkStart Indicates if the rule should check\n\
             *      for the left brace at the beginning.\n\
             * @param {Boolean} readMargins Indicates if the rule should check\n\
             *      for margin patterns.\n\
             * @return {void}\n\
             * @method _readDeclarations\n\
             * @private\n\
             */\n\
            _readDeclarations: function(checkStart, readMargins) {\n\
                /*\n\
                 * Reads the pattern\n\
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*\n\
                 * or\n\
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\n\
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.\n\
                 * A semicolon is only necessary following a declaration if there's another declaration\n\
                 * or margin afterwards.\n\
                 */\n\
                var tokenStream = this._tokenStream,\n\
                    tt;\n\
\n\
\n\
                this._readWhitespace();\n\
\n\
                if (checkStart) {\n\
                    tokenStream.mustMatch(Tokens.LBRACE);\n\
                }\n\
\n\
                this._readWhitespace();\n\
\n\
                try {\n\
\n\
                    while (true) {\n\
\n\
                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())) {\n\
                            //noop\n\
                        } else if (this._declaration()) {\n\
                            if (!tokenStream.match(Tokens.SEMICOLON)) {\n\
                                break;\n\
                            }\n\
                        } else {\n\
                            break;\n\
                        }\n\
\n\
                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){\n\
                        //    break;\n\
                        //}\n\
                        this._readWhitespace();\n\
                    }\n\
\n\
                    tokenStream.mustMatch(Tokens.RBRACE);\n\
                    this._readWhitespace();\n\
                } catch (ex) {\n\
                    if (ex instanceof SyntaxError && !this.options.strict) {\n\
\n\
                        //fire error event\n\
                        this.fire({\n\
                            type:       \"error\",\n\
                            error:      ex,\n\
                            message:    ex.message,\n\
                            line:       ex.line,\n\
                            col:        ex.col\n\
                        });\n\
\n\
                        //see if there's another declaration\n\
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);\n\
                        if (tt === Tokens.SEMICOLON) {\n\
                            //if there's a semicolon, then there might be another declaration\n\
                            this._readDeclarations(false, readMargins);\n\
                        } else if (tt !== Tokens.RBRACE) {\n\
                            //if there's a right brace, the rule is finished so don't do anything\n\
                            //otherwise, rethrow the error because it wasn't handled properly\n\
                            throw ex;\n\
                        }\n\
                    } else {\n\
                        //not a syntax error, rethrow it\n\
                        throw ex;\n\
                    }\n\
                }\n\
            },\n\
\n\
            /**\n\
             * In some cases, you can end up with two white space tokens in a\n\
             * row. Instead of making a change in every function that looks for\n\
             * white space, this function is used to match as much white space\n\
             * as necessary.\n\
             * @method _readWhitespace\n\
             * @return {String} The white space if found, empty string if not.\n\
             * @private\n\
             */\n\
            _readWhitespace: function() {\n\
\n\
                var tokenStream = this._tokenStream,\n\
                    ws = \"\";\n\
\n\
                while (tokenStream.match(Tokens.S)) {\n\
                    ws += tokenStream.token().value;\n\
                }\n\
\n\
                return ws;\n\
            },\n\
\n\
\n\
            /**\n\
             * Throws an error when an unexpected token is found.\n\
             * @param {Object} token The token that was found.\n\
             * @method _unexpectedToken\n\
             * @return {void}\n\
             * @private\n\
             */\n\
            _unexpectedToken: function(token) {\n\
                throw new SyntaxError(\"Unexpected token '\" + token.value + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n\
            },\n\
\n\
            /**\n\
             * Helper method used for parsing subparts of a style sheet.\n\
             * @return {void}\n\
             * @method _verifyEnd\n\
             * @private\n\
             */\n\
            _verifyEnd: function() {\n\
                if (this._tokenStream.LA(1) !== Tokens.EOF) {\n\
                    this._unexpectedToken(this._tokenStream.LT(1));\n\
                }\n\
            },\n\
\n\
            //-----------------------------------------------------------------\n\
            // Validation methods\n\
            //-----------------------------------------------------------------\n\
            _validateProperty: function(property, value) {\n\
                Validation.validate(property, value);\n\
            },\n\
\n\
            //-----------------------------------------------------------------\n\
            // Parsing methods\n\
            //-----------------------------------------------------------------\n\
\n\
            parse: function(input) {\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
                this._stylesheet();\n\
            },\n\
\n\
            parseStyleSheet: function(input) {\n\
                //just passthrough\n\
                return this.parse(input);\n\
            },\n\
\n\
            parseMediaQuery: function(input) {\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
                var result = this._media_query();\n\
\n\
                //if there's anything more, then it's an invalid selector\n\
                this._verifyEnd();\n\
\n\
                //otherwise return result\n\
                return result;\n\
            },\n\
\n\
            /**\n\
             * Parses a property value (everything after the semicolon).\n\
             * @return {parserlib.css.PropertyValue} The property value.\n\
             * @throws parserlib.util.SyntaxError If an unexpected token is found.\n\
             * @method parserPropertyValue\n\
             */\n\
            parsePropertyValue: function(input) {\n\
\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
                this._readWhitespace();\n\
\n\
                var result = this._expr();\n\
\n\
                //okay to have a trailing white space\n\
                this._readWhitespace();\n\
\n\
                //if there's anything more, then it's an invalid selector\n\
                this._verifyEnd();\n\
\n\
                //otherwise return result\n\
                return result;\n\
            },\n\
\n\
            /**\n\
             * Parses a complete CSS rule, including selectors and\n\
             * properties.\n\
             * @param {String} input The text to parser.\n\
             * @return {Boolean} True if the parse completed successfully, false if not.\n\
             * @method parseRule\n\
             */\n\
            parseRule: function(input) {\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
\n\
                //skip any leading white space\n\
                this._readWhitespace();\n\
\n\
                var result = this._ruleset();\n\
\n\
                //skip any trailing white space\n\
                this._readWhitespace();\n\
\n\
                //if there's anything more, then it's an invalid selector\n\
                this._verifyEnd();\n\
\n\
                //otherwise return result\n\
                return result;\n\
            },\n\
\n\
            /**\n\
             * Parses a single CSS selector (no comma)\n\
             * @param {String} input The text to parse as a CSS selector.\n\
             * @return {Selector} An object representing the selector.\n\
             * @throws parserlib.util.SyntaxError If an unexpected token is found.\n\
             * @method parseSelector\n\
             */\n\
            parseSelector: function(input) {\n\
\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
\n\
                //skip any leading white space\n\
                this._readWhitespace();\n\
\n\
                var result = this._selector();\n\
\n\
                //skip any trailing white space\n\
                this._readWhitespace();\n\
\n\
                //if there's anything more, then it's an invalid selector\n\
                this._verifyEnd();\n\
\n\
                //otherwise return result\n\
                return result;\n\
            },\n\
\n\
            /**\n\
             * Parses an HTML style attribute: a set of CSS declarations\n\
             * separated by semicolons.\n\
             * @param {String} input The text to parse as a style attribute\n\
             * @return {void}\n\
             * @method parseStyleAttribute\n\
             */\n\
            parseStyleAttribute: function(input) {\n\
                input += \"}\"; // for error recovery in _readDeclarations()\n\
                this._tokenStream = new TokenStream(input, Tokens);\n\
                this._readDeclarations();\n\
            }\n\
        };\n\
\n\
    //copy over onto prototype\n\
    for (prop in additions) {\n\
        if (Object.prototype.hasOwnProperty.call(additions, prop)) {\n\
            proto[prop] = additions[prop];\n\
        }\n\
    }\n\
\n\
    return proto;\n\
}();\n\
\n\
\n\
/*\n\
nth\n\
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |\n\
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*\n\
  ;\n\
*/\n\
},{\"../util/EventTarget\":23,\"../util/SyntaxError\":25,\"../util/SyntaxUnit\":26,\"./Combinator\":2,\"./MediaFeature\":4,\"./MediaQuery\":5,\"./PropertyName\":8,\"./PropertyValue\":9,\"./PropertyValuePart\":11,\"./Selector\":13,\"./SelectorPart\":14,\"./SelectorSubPart\":15,\"./TokenStream\":17,\"./Tokens\":18,\"./Validation\":19}],7:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
/* exported Properties */\n\
\n\
var Properties = module.exports = {\n\
    __proto__: null,\n\
\n\
    //A\n\
    \"align-items\"                   : \"flex-start | flex-end | center | baseline | stretch\",\n\
    \"align-content\"                 : \"flex-start | flex-end | center | space-between | space-around | stretch\",\n\
    \"align-self\"                    : \"auto | flex-start | flex-end | center | baseline | stretch\",\n\
    \"all\"                           : \"initial | inherit | unset\",\n\
    \"-webkit-align-items\"           : \"flex-start | flex-end | center | baseline | stretch\",\n\
    \"-webkit-align-content\"         : \"flex-start | flex-end | center | space-between | space-around | stretch\",\n\
    \"-webkit-align-self\"            : \"auto | flex-start | flex-end | center | baseline | stretch\",\n\
    \"alignment-adjust\"              : \"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>\",\n\
    \"alignment-baseline\"            : \"auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n\
    \"animation\"                     : 1,\n\
    \"animation-delay\"               : \"<time>#\",\n\
    \"animation-direction\"           : \"<single-animation-direction>#\",\n\
    \"animation-duration\"            : \"<time>#\",\n\
    \"animation-fill-mode\"           : \"[ none | forwards | backwards | both ]#\",\n\
    \"animation-iteration-count\"     : \"[ <number> | infinite ]#\",\n\
    \"animation-name\"                : \"[ none | <single-animation-name> ]#\",\n\
    \"animation-play-state\"          : \"[ running | paused ]#\",\n\
    \"animation-timing-function\"     : 1,\n\
\n\
    //vendor prefixed\n\
    \"-moz-animation-delay\"               : \"<time>#\",\n\
    \"-moz-animation-direction\"           : \"[ normal | alternate ]#\",\n\
    \"-moz-animation-duration\"            : \"<time>#\",\n\
    \"-moz-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\n\
    \"-moz-animation-name\"                : \"[ none | <single-animation-name> ]#\",\n\
    \"-moz-animation-play-state\"          : \"[ running | paused ]#\",\n\
\n\
    \"-ms-animation-delay\"               : \"<time>#\",\n\
    \"-ms-animation-direction\"           : \"[ normal | alternate ]#\",\n\
    \"-ms-animation-duration\"            : \"<time>#\",\n\
    \"-ms-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\n\
    \"-ms-animation-name\"                : \"[ none | <single-animation-name> ]#\",\n\
    \"-ms-animation-play-state\"          : \"[ running | paused ]#\",\n\
\n\
    \"-webkit-animation-delay\"               : \"<time>#\",\n\
    \"-webkit-animation-direction\"           : \"[ normal | alternate ]#\",\n\
    \"-webkit-animation-duration\"            : \"<time>#\",\n\
    \"-webkit-animation-fill-mode\"           : \"[ none | forwards | backwards | both ]#\",\n\
    \"-webkit-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\n\
    \"-webkit-animation-name\"                : \"[ none | <single-animation-name> ]#\",\n\
    \"-webkit-animation-play-state\"          : \"[ running | paused ]#\",\n\
\n\
    \"-o-animation-delay\"               : \"<time>#\",\n\
    \"-o-animation-direction\"           : \"[ normal | alternate ]#\",\n\
    \"-o-animation-duration\"            : \"<time>#\",\n\
    \"-o-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\n\
    \"-o-animation-name\"                : \"[ none | <single-animation-name> ]#\",\n\
    \"-o-animation-play-state\"          : \"[ running | paused ]#\",\n\
\n\
    \"appearance\"                    : \"none | auto\",\n\
    \"-moz-appearance\"               : \"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized\",\n\
    \"-ms-appearance\"                : \"none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\",\n\
    \"-webkit-appearance\"            : \"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical\",\n\
    \"-o-appearance\"                 : \"none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\",\n\
\n\
    \"azimuth\"                       : \"<azimuth>\",\n\
\n\
    //B\n\
    \"backface-visibility\"           : \"visible | hidden\",\n\
    \"background\"                    : 1,\n\
    \"background-attachment\"         : \"<attachment>#\",\n\
    \"background-clip\"               : \"<box>#\",\n\
    \"background-color\"              : \"<color>\",\n\
    \"background-image\"              : \"<bg-image>#\",\n\
    \"background-origin\"             : \"<box>#\",\n\
    \"background-position\"           : \"<bg-position>\",\n\
    \"background-repeat\"             : \"<repeat-style>#\",\n\
    \"background-size\"               : \"<bg-size>#\",\n\
    \"baseline-shift\"                : \"baseline | sub | super | <percentage> | <length>\",\n\
    \"behavior\"                      : 1,\n\
    \"binding\"                       : 1,\n\
    \"bleed\"                         : \"<length>\",\n\
    \"bookmark-label\"                : \"<content> | <attr> | <string>\",\n\
    \"bookmark-level\"                : \"none | <integer>\",\n\
    \"bookmark-state\"                : \"open | closed\",\n\
    \"bookmark-target\"               : \"none | <uri> | <attr>\",\n\
    \"border\"                        : \"<border-width> || <border-style> || <color>\",\n\
    \"border-bottom\"                 : \"<border-width> || <border-style> || <color>\",\n\
    \"border-bottom-color\"           : \"<color>\",\n\
    \"border-bottom-left-radius\"     :  \"<x-one-radius>\",\n\
    \"border-bottom-right-radius\"    :  \"<x-one-radius>\",\n\
    \"border-bottom-style\"           : \"<border-style>\",\n\
    \"border-bottom-width\"           : \"<border-width>\",\n\
    \"border-collapse\"               : \"collapse | separate\",\n\
    \"border-color\"                  : \"<color>{1,4}\",\n\
    \"border-image\"                  : 1,\n\
    \"border-image-outset\"           : \"[ <length> | <number> ]{1,4}\",\n\
    \"border-image-repeat\"           : \"[ stretch | repeat | round ]{1,2}\",\n\
    \"border-image-slice\"            : \"<border-image-slice>\",\n\
    \"border-image-source\"           : \"<image> | none\",\n\
    \"border-image-width\"            : \"[ <length> | <percentage> | <number> | auto ]{1,4}\",\n\
    \"border-left\"                   : \"<border-width> || <border-style> || <color>\",\n\
    \"border-left-color\"             : \"<color>\",\n\
    \"border-left-style\"             : \"<border-style>\",\n\
    \"border-left-width\"             : \"<border-width>\",\n\
    \"border-radius\"                 : \"<border-radius>\",\n\
    \"border-right\"                  : \"<border-width> || <border-style> || <color>\",\n\
    \"border-right-color\"            : \"<color>\",\n\
    \"border-right-style\"            : \"<border-style>\",\n\
    \"border-right-width\"            : \"<border-width>\",\n\
    \"border-spacing\"                : \"<length>{1,2}\",\n\
    \"border-style\"                  : \"<border-style>{1,4}\",\n\
    \"border-top\"                    : \"<border-width> || <border-style> || <color>\",\n\
    \"border-top-color\"              : \"<color>\",\n\
    \"border-top-left-radius\"        : \"<x-one-radius>\",\n\
    \"border-top-right-radius\"       : \"<x-one-radius>\",\n\
    \"border-top-style\"              : \"<border-style>\",\n\
    \"border-top-width\"              : \"<border-width>\",\n\
    \"border-width\"                  : \"<border-width>{1,4}\",\n\
    \"bottom\"                        : \"<margin-width>\",\n\
    \"-moz-box-align\"                : \"start | end | center | baseline | stretch\",\n\
    \"-moz-box-decoration-break\"     : \"slice | clone\",\n\
    \"-moz-box-direction\"            : \"normal | reverse\",\n\
    \"-moz-box-flex\"                 : \"<number>\",\n\
    \"-moz-box-flex-group\"           : \"<integer>\",\n\
    \"-moz-box-lines\"                : \"single | multiple\",\n\
    \"-moz-box-ordinal-group\"        : \"<integer>\",\n\
    \"-moz-box-orient\"               : \"horizontal | vertical | inline-axis | block-axis\",\n\
    \"-moz-box-pack\"                 : \"start | end | center | justify\",\n\
    \"-o-box-decoration-break\"       : \"slice | clone\",\n\
    \"-webkit-box-align\"             : \"start | end | center | baseline | stretch\",\n\
    \"-webkit-box-decoration-break\"  : \"slice | clone\",\n\
    \"-webkit-box-direction\"         : \"normal | reverse\",\n\
    \"-webkit-box-flex\"              : \"<number>\",\n\
    \"-webkit-box-flex-group\"        : \"<integer>\",\n\
    \"-webkit-box-lines\"             : \"single | multiple\",\n\
    \"-webkit-box-ordinal-group\"     : \"<integer>\",\n\
    \"-webkit-box-orient\"            : \"horizontal | vertical | inline-axis | block-axis\",\n\
    \"-webkit-box-pack\"              : \"start | end | center | justify\",\n\
    \"box-decoration-break\"          : \"slice | clone\",\n\
    \"box-shadow\"                    : \"<box-shadow>\",\n\
    \"box-sizing\"                    : \"content-box | border-box\",\n\
    \"break-after\"                   : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\n\
    \"break-before\"                  : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\n\
    \"break-inside\"                  : \"auto | avoid | avoid-page | avoid-column\",\n\
\n\
    //C\n\
    \"caption-side\"                  : \"top | bottom\",\n\
    \"clear\"                         : \"none | right | left | both\",\n\
    \"clip\"                          : \"<shape> | auto\",\n\
    \"-webkit-clip-path\"             : \"<clip-source> | <clip-path> | none\",\n\
    \"clip-path\"                     : \"<clip-source> | <clip-path> | none\",\n\
    \"clip-rule\"                     : \"nonzero | evenodd\",\n\
    \"color\"                         : \"<color>\",\n\
    \"color-interpolation\"           : \"auto | sRGB | linearRGB\",\n\
    \"color-interpolation-filters\"   : \"auto | sRGB | linearRGB\",\n\
    \"color-profile\"                 : 1,\n\
    \"color-rendering\"               : \"auto | optimizeSpeed | optimizeQuality\",\n\
    \"column-count\"                  : \"<integer> | auto\",                      //https://www.w3.org/TR/css3-multicol/\n\
    \"column-fill\"                   : \"auto | balance\",\n\
    \"column-gap\"                    : \"<length> | normal\",\n\
    \"column-rule\"                   : \"<border-width> || <border-style> || <color>\",\n\
    \"column-rule-color\"             : \"<color>\",\n\
    \"column-rule-style\"             : \"<border-style>\",\n\
    \"column-rule-width\"             : \"<border-width>\",\n\
    \"column-span\"                   : \"none | all\",\n\
    \"column-width\"                  : \"<length> | auto\",\n\
    \"columns\"                       : 1,\n\
    \"content\"                       : 1,\n\
    \"counter-increment\"             : 1,\n\
    \"counter-reset\"                 : 1,\n\
    \"crop\"                          : \"<shape> | auto\",\n\
    \"cue\"                           : \"cue-after | cue-before\",\n\
    \"cue-after\"                     : 1,\n\
    \"cue-before\"                    : 1,\n\
    \"cursor\"                        : 1,\n\
\n\
    //D\n\
    \"direction\"                     : \"ltr | rtl\",\n\
    \"display\"                       : \"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex\",\n\
    \"dominant-baseline\"             : \"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\",\n\
    \"drop-initial-after-adjust\"     : \"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>\",\n\
    \"drop-initial-after-align\"      : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n\
    \"drop-initial-before-adjust\"    : \"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>\",\n\
    \"drop-initial-before-align\"     : \"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n\
    \"drop-initial-size\"             : \"auto | line | <length> | <percentage>\",\n\
    \"drop-initial-value\"            : \"<integer>\",\n\
\n\
    //E\n\
    \"elevation\"                     : \"<angle> | below | level | above | higher | lower\",\n\
    \"empty-cells\"                   : \"show | hide\",\n\
    \"enable-background\"             : 1,\n\
\n\
    //F\n\
    \"fill\"                          : \"<paint>\",\n\
    \"fill-opacity\"                  : \"<opacity-value>\",\n\
    \"fill-rule\"                     : \"nonzero | evenodd\",\n\
    \"filter\"                        : \"<filter-function-list> | none\",\n\
    \"fit\"                           : \"fill | hidden | meet | slice\",\n\
    \"fit-position\"                  : 1,\n\
    \"flex\"                          : \"<flex>\",\n\
    \"flex-basis\"                    : \"<width>\",\n\
    \"flex-direction\"                : \"row | row-reverse | column | column-reverse\",\n\
    \"flex-flow\"                     : \"<flex-direction> || <flex-wrap>\",\n\
    \"flex-grow\"                     : \"<number>\",\n\
    \"flex-shrink\"                   : \"<number>\",\n\
    \"flex-wrap\"                     : \"nowrap | wrap | wrap-reverse\",\n\
    \"-webkit-flex\"                  : \"<flex>\",\n\
    \"-webkit-flex-basis\"            : \"<width>\",\n\
    \"-webkit-flex-direction\"        : \"row | row-reverse | column | column-reverse\",\n\
    \"-webkit-flex-flow\"             : \"<flex-direction> || <flex-wrap>\",\n\
    \"-webkit-flex-grow\"             : \"<number>\",\n\
    \"-webkit-flex-shrink\"           : \"<number>\",\n\
    \"-webkit-flex-wrap\"             : \"nowrap | wrap | wrap-reverse\",\n\
    \"-ms-flex\"                      : \"<flex>\",\n\
    \"-ms-flex-align\"                : \"start | end | center | stretch | baseline\",\n\
    \"-ms-flex-direction\"            : \"row | row-reverse | column | column-reverse\",\n\
    \"-ms-flex-order\"                : \"<number>\",\n\
    \"-ms-flex-pack\"                 : \"start | end | center | justify\",\n\
    \"-ms-flex-wrap\"                 : \"nowrap | wrap | wrap-reverse\",\n\
    \"float\"                         : \"left | right | none\",\n\
    \"float-offset\"                  : 1,\n\
    \"flood-color\"                   : 1,\n\
    \"flood-opacity\"                 : \"<opacity-value>\",\n\
    \"font\"                          : \"<font-shorthand> | caption | icon | menu | message-box | small-caption | status-bar\",\n\
    \"font-family\"                   : \"<font-family>\",\n\
    \"font-feature-settings\"         : \"<feature-tag-value> | normal\",\n\
    \"font-kerning\"                  : \"auto | normal | none\",\n\
    \"font-size\"                     : \"<font-size>\",\n\
    \"font-size-adjust\"              : \"<number> | none\",\n\
    \"font-stretch\"                  : \"<font-stretch>\",\n\
    \"font-style\"                    : \"<font-style>\",\n\
    \"font-variant\"                  : \"<font-variant> | normal | none\",\n\
    \"font-variant-alternates\"       : \"<font-variant-alternates> | normal\",\n\
    \"font-variant-caps\"             : \"<font-variant-caps> | normal\",\n\
    \"font-variant-east-asian\"       : \"<font-variant-east-asian> | normal\",\n\
    \"font-variant-ligatures\"        : \"<font-variant-ligatures> | normal | none\",\n\
    \"font-variant-numeric\"          : \"<font-variant-numeric> | normal\",\n\
    \"font-variant-position\"         : \"normal | sub | super\",\n\
    \"font-weight\"                   : \"<font-weight>\",\n\
\n\
    //G\n\
    \"glyph-orientation-horizontal\"  : \"<glyph-angle>\",\n\
    \"glyph-orientation-vertical\"    : \"auto | <glyph-angle>\",\n\
    \"grid\"                          : 1,\n\
    \"grid-area\"                     : 1,\n\
    \"grid-auto-columns\"             : 1,\n\
    \"grid-auto-flow\"                : 1,\n\
    \"grid-auto-position\"            : 1,\n\
    \"grid-auto-rows\"                : 1,\n\
    \"grid-cell-stacking\"            : \"columns | rows | layer\",\n\
    \"grid-column\"                   : 1,\n\
    \"grid-columns\"                  : 1,\n\
    \"grid-column-align\"             : \"start | end | center | stretch\",\n\
    \"grid-column-sizing\"            : 1,\n\
    \"grid-column-start\"             : 1,\n\
    \"grid-column-end\"               : 1,\n\
    \"grid-column-span\"              : \"<integer>\",\n\
    \"grid-flow\"                     : \"none | rows | columns\",\n\
    \"grid-layer\"                    : \"<integer>\",\n\
    \"grid-row\"                      : 1,\n\
    \"grid-rows\"                     : 1,\n\
    \"grid-row-align\"                : \"start | end | center | stretch\",\n\
    \"grid-row-start\"                : 1,\n\
    \"grid-row-end\"                  : 1,\n\
    \"grid-row-span\"                 : \"<integer>\",\n\
    \"grid-row-sizing\"               : 1,\n\
    \"grid-template\"                 : 1,\n\
    \"grid-template-areas\"           : 1,\n\
    \"grid-template-columns\"         : 1,\n\
    \"grid-template-rows\"            : 1,\n\
\n\
    //H\n\
    \"hanging-punctuation\"           : 1,\n\
    \"height\"                        : \"<margin-width> | <content-sizing>\",\n\
    \"hyphenate-after\"               : \"<integer> | auto\",\n\
    \"hyphenate-before\"              : \"<integer> | auto\",\n\
    \"hyphenate-character\"           : \"<string> | auto\",\n\
    \"hyphenate-lines\"               : \"no-limit | <integer>\",\n\
    \"hyphenate-resource\"            : 1,\n\
    \"hyphens\"                       : \"none | manual | auto\",\n\
\n\
    //I\n\
    \"icon\"                          : 1,\n\
    \"image-orientation\"             : \"angle | auto\",\n\
    \"image-rendering\"               : \"auto | optimizeSpeed | optimizeQuality\",\n\
    \"image-resolution\"              : 1,\n\
    \"ime-mode\"                      : \"auto | normal | active | inactive | disabled\",\n\
    \"inline-box-align\"              : \"last | <integer>\",\n\
\n\
    //J\n\
    \"justify-content\"               : \"flex-start | flex-end | center | space-between | space-around\",\n\
    \"-webkit-justify-content\"       : \"flex-start | flex-end | center | space-between | space-around\",\n\
\n\
    //K\n\
    \"kerning\"                       : \"auto | <length>\",\n\
\n\
    //L\n\
    \"left\"                          : \"<margin-width>\",\n\
    \"letter-spacing\"                : \"<length> | normal\",\n\
    \"line-height\"                   : \"<line-height>\",\n\
    \"line-break\"                    : \"auto | loose | normal | strict\",\n\
    \"line-stacking\"                 : 1,\n\
    \"line-stacking-ruby\"            : \"exclude-ruby | include-ruby\",\n\
    \"line-stacking-shift\"           : \"consider-shifts | disregard-shifts\",\n\
    \"line-stacking-strategy\"        : \"inline-line-height | block-line-height | max-height | grid-height\",\n\
    \"list-style\"                    : 1,\n\
    \"list-style-image\"              : \"<uri> | none\",\n\
    \"list-style-position\"           : \"inside | outside\",\n\
    \"list-style-type\"               : \"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none\",\n\
\n\
    //M\n\
    \"margin\"                        : \"<margin-width>{1,4}\",\n\
    \"margin-bottom\"                 : \"<margin-width>\",\n\
    \"margin-left\"                   : \"<margin-width>\",\n\
    \"margin-right\"                  : \"<margin-width>\",\n\
    \"margin-top\"                    : \"<margin-width>\",\n\
    \"mark\"                          : 1,\n\
    \"mark-after\"                    : 1,\n\
    \"mark-before\"                   : 1,\n\
    \"marker\"                        : 1,\n\
    \"marker-end\"                    : 1,\n\
    \"marker-mid\"                    : 1,\n\
    \"marker-start\"                  : 1,\n\
    \"marks\"                         : 1,\n\
    \"marquee-direction\"             : 1,\n\
    \"marquee-play-count\"            : 1,\n\
    \"marquee-speed\"                 : 1,\n\
    \"marquee-style\"                 : 1,\n\
    \"mask\"                          : 1,\n\
    \"max-height\"                    : \"<length> | <percentage> | <content-sizing> | none\",\n\
    \"max-width\"                     : \"<length> | <percentage> | <content-sizing> | none\",\n\
    \"min-height\"                    : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats\",\n\
    \"min-width\"                     : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats\",\n\
    \"move-to\"                       : 1,\n\
\n\
    //N\n\
    \"nav-down\"                      : 1,\n\
    \"nav-index\"                     : 1,\n\
    \"nav-left\"                      : 1,\n\
    \"nav-right\"                     : 1,\n\
    \"nav-up\"                        : 1,\n\
\n\
    //O\n\
    \"object-fit\"                    : \"fill | contain | cover | none | scale-down\",\n\
    \"object-position\"               : \"<position>\",\n\
    \"opacity\"                       : \"<opacity-value>\",\n\
    \"order\"                         : \"<integer>\",\n\
    \"-webkit-order\"                 : \"<integer>\",\n\
    \"orphans\"                       : \"<integer>\",\n\
    \"outline\"                       : 1,\n\
    \"outline-color\"                 : \"<color> | invert\",\n\
    \"outline-offset\"                : 1,\n\
    \"outline-style\"                 : \"<border-style>\",\n\
    \"outline-width\"                 : \"<border-width>\",\n\
    \"overflow\"                      : \"visible | hidden | scroll | auto\",\n\
    \"overflow-style\"                : 1,\n\
    \"overflow-wrap\"                 : \"normal | break-word\",\n\
    \"overflow-x\"                    : 1,\n\
    \"overflow-y\"                    : 1,\n\
\n\
    //P\n\
    \"padding\"                       : \"<padding-width>{1,4}\",\n\
    \"padding-bottom\"                : \"<padding-width>\",\n\
    \"padding-left\"                  : \"<padding-width>\",\n\
    \"padding-right\"                 : \"<padding-width>\",\n\
    \"padding-top\"                   : \"<padding-width>\",\n\
    \"page\"                          : 1,\n\
    \"page-break-after\"              : \"auto | always | avoid | left | right\",\n\
    \"page-break-before\"             : \"auto | always | avoid | left | right\",\n\
    \"page-break-inside\"             : \"auto | avoid\",\n\
    \"page-policy\"                   : 1,\n\
    \"pause\"                         : 1,\n\
    \"pause-after\"                   : 1,\n\
    \"pause-before\"                  : 1,\n\
    \"perspective\"                   : 1,\n\
    \"perspective-origin\"            : 1,\n\
    \"phonemes\"                      : 1,\n\
    \"pitch\"                         : 1,\n\
    \"pitch-range\"                   : 1,\n\
    \"play-during\"                   : 1,\n\
    \"pointer-events\"                : \"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all\",\n\
    \"position\"                      : \"static | relative | absolute | fixed\",\n\
    \"presentation-level\"            : 1,\n\
    \"punctuation-trim\"              : 1,\n\
\n\
    //Q\n\
    \"quotes\"                        : 1,\n\
\n\
    //R\n\
    \"rendering-intent\"              : 1,\n\
    \"resize\"                        : 1,\n\
    \"rest\"                          : 1,\n\
    \"rest-after\"                    : 1,\n\
    \"rest-before\"                   : 1,\n\
    \"richness\"                      : 1,\n\
    \"right\"                         : \"<margin-width>\",\n\
    \"rotation\"                      : 1,\n\
    \"rotation-point\"                : 1,\n\
    \"ruby-align\"                    : 1,\n\
    \"ruby-overhang\"                 : 1,\n\
    \"ruby-position\"                 : 1,\n\
    \"ruby-span\"                     : 1,\n\
\n\
    //S\n\
    \"shape-rendering\"               : \"auto | optimizeSpeed | crispEdges | geometricPrecision\",\n\
    \"size\"                          : 1,\n\
    \"speak\"                         : \"normal | none | spell-out\",\n\
    \"speak-header\"                  : \"once | always\",\n\
    \"speak-numeral\"                 : \"digits | continuous\",\n\
    \"speak-punctuation\"             : \"code | none\",\n\
    \"speech-rate\"                   : 1,\n\
    \"src\"                           : 1,\n\
    \"stop-color\"                    : 1,\n\
    \"stop-opacity\"                  : \"<opacity-value>\",\n\
    \"stress\"                        : 1,\n\
    \"string-set\"                    : 1,\n\
    \"stroke\"                        : \"<paint>\",\n\
    \"stroke-dasharray\"              : \"none | <dasharray>\",\n\
    \"stroke-dashoffset\"             : \"<percentage> | <length>\",\n\
    \"stroke-linecap\"                : \"butt | round | square\",\n\
    \"stroke-linejoin\"               : \"miter | round | bevel\",\n\
    \"stroke-miterlimit\"             : \"<miterlimit>\",\n\
    \"stroke-opacity\"                : \"<opacity-value>\",\n\
    \"stroke-width\"                  : \"<percentage> | <length>\",\n\
\n\
    \"table-layout\"                  : \"auto | fixed\",\n\
    \"tab-size\"                      : \"<integer> | <length>\",\n\
    \"target\"                        : 1,\n\
    \"target-name\"                   : 1,\n\
    \"target-new\"                    : 1,\n\
    \"target-position\"               : 1,\n\
    \"text-align\"                    : \"left | right | center | justify | match-parent | start | end\",\n\
    \"text-align-last\"               : 1,\n\
    \"text-anchor\"                   : \"start | middle | end\",\n\
    \"text-decoration\"               : \"<text-decoration-line> || <text-decoration-style> || <text-decoration-color>\",\n\
    \"text-decoration-color\"         : \"<text-decoration-color>\",\n\
    \"text-decoration-line\"          : \"<text-decoration-line>\",\n\
    \"text-decoration-style\"         : \"<text-decoration-style>\",\n\
    \"text-emphasis\"                 : 1,\n\
    \"text-height\"                   : 1,\n\
    \"text-indent\"                   : \"<length> | <percentage>\",\n\
    \"text-justify\"                  : \"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\",\n\
    \"text-outline\"                  : 1,\n\
    \"text-overflow\"                 : 1,\n\
    \"text-rendering\"                : \"auto | optimizeSpeed | optimizeLegibility | geometricPrecision\",\n\
    \"text-shadow\"                   : 1,\n\
    \"text-transform\"                : \"capitalize | uppercase | lowercase | none\",\n\
    \"text-wrap\"                     : \"normal | none | avoid\",\n\
    \"top\"                           : \"<margin-width>\",\n\
    \"-ms-touch-action\"              : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\n\
    \"touch-action\"                  : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\n\
    \"transform\"                     : 1,\n\
    \"transform-origin\"              : 1,\n\
    \"transform-style\"               : 1,\n\
    \"transition\"                    : 1,\n\
    \"transition-delay\"              : 1,\n\
    \"transition-duration\"           : 1,\n\
    \"transition-property\"           : 1,\n\
    \"transition-timing-function\"    : 1,\n\
\n\
    //U\n\
    \"unicode-bidi\"                  : \"normal | embed | isolate | bidi-override | isolate-override | plaintext\",\n\
    \"user-modify\"                   : \"read-only | read-write | write-only\",\n\
    \"user-select\"                   : \"none | text | toggle | element | elements | all\",\n\
\n\
    //V\n\
    \"vertical-align\"                : \"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>\",\n\
    \"visibility\"                    : \"visible | hidden | collapse\",\n\
    \"voice-balance\"                 : 1,\n\
    \"voice-duration\"                : 1,\n\
    \"voice-family\"                  : 1,\n\
    \"voice-pitch\"                   : 1,\n\
    \"voice-pitch-range\"             : 1,\n\
    \"voice-rate\"                    : 1,\n\
    \"voice-stress\"                  : 1,\n\
    \"voice-volume\"                  : 1,\n\
    \"volume\"                        : 1,\n\
\n\
    //W\n\
    \"white-space\"                   : \"normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\",   // https://perishablepress.com/wrapping-content/\n\
    \"white-space-collapse\"          : 1,\n\
    \"widows\"                        : \"<integer>\",\n\
    \"width\"                         : \"<length> | <percentage> | <content-sizing> | auto\",\n\
    \"will-change\"                   : \"<will-change>\",\n\
    \"word-break\"                    : \"normal | keep-all | break-all\",\n\
    \"word-spacing\"                  : \"<length> | normal\",\n\
    \"word-wrap\"                     : \"normal | break-word\",\n\
    \"writing-mode\"                  : \"horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb\",\n\
\n\
    //Z\n\
    \"z-index\"                       : \"<integer> | auto\",\n\
    \"zoom\"                          : \"<number> | <percentage> | normal\"\n\
};\n\
},{}],8:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = PropertyName;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a selector combinator (whitespace, +, >).\n\
 * @namespace parserlib.css\n\
 * @class PropertyName\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {String} text The text representation of the unit.\n\
 * @param {String} hack The type of IE hack applied (\"*\", \"_\", or null).\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function PropertyName(text, hack, line, col) {\n\
\n\
    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);\n\
\n\
    /**\n\
     * The type of IE hack applied (\"*\", \"_\", or null).\n\
     * @type String\n\
     * @property hack\n\
     */\n\
    this.hack = hack;\n\
}\n\
\n\
PropertyName.prototype = new SyntaxUnit();\n\
PropertyName.prototype.constructor = PropertyName;\n\
PropertyName.prototype.toString = function() {\n\
    return (this.hack ? this.hack : \"\") + this.text;\n\
};\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],9:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = PropertyValue;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a single part of a CSS property value, meaning that it represents\n\
 * just everything single part between \":\" and \";\". If there are multiple values\n\
 * separated by commas, this type represents just one of the values.\n\
 * @param {String[]} parts An array of value parts making up this value.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 * @namespace parserlib.css\n\
 * @class PropertyValue\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 */\n\
function PropertyValue(parts, line, col) {\n\
\n\
    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.PROPERTY_VALUE_TYPE);\n\
\n\
    /**\n\
     * The parts that make up the selector.\n\
     * @type Array\n\
     * @property parts\n\
     */\n\
    this.parts = parts;\n\
}\n\
\n\
PropertyValue.prototype = new SyntaxUnit();\n\
PropertyValue.prototype.constructor = PropertyValue;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],10:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = PropertyValueIterator;\n\
\n\
/**\n\
 * A utility class that allows for easy iteration over the various parts of a\n\
 * property value.\n\
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.\n\
 * @namespace parserlib.css\n\
 * @class PropertyValueIterator\n\
 * @constructor\n\
 */\n\
function PropertyValueIterator(value) {\n\
\n\
    /**\n\
     * Iterator value\n\
     * @type int\n\
     * @property _i\n\
     * @private\n\
     */\n\
    this._i = 0;\n\
\n\
    /**\n\
     * The parts that make up the value.\n\
     * @type Array\n\
     * @property _parts\n\
     * @private\n\
     */\n\
    this._parts = value.parts;\n\
\n\
    /**\n\
     * Keeps track of bookmarks along the way.\n\
     * @type Array\n\
     * @property _marks\n\
     * @private\n\
     */\n\
    this._marks = [];\n\
\n\
    /**\n\
     * Holds the original property value.\n\
     * @type parserlib.css.PropertyValue\n\
     * @property value\n\
     */\n\
    this.value = value;\n\
}\n\
\n\
/**\n\
 * Returns the total number of parts in the value.\n\
 * @return {int} The total number of parts in the value.\n\
 * @method count\n\
 */\n\
PropertyValueIterator.prototype.count = function() {\n\
    return this._parts.length;\n\
};\n\
\n\
/**\n\
 * Indicates if the iterator is positioned at the first item.\n\
 * @return {Boolean} True if positioned at first item, false if not.\n\
 * @method isFirst\n\
 */\n\
PropertyValueIterator.prototype.isFirst = function() {\n\
    return this._i === 0;\n\
};\n\
\n\
/**\n\
 * Indicates if there are more parts of the property value.\n\
 * @return {Boolean} True if there are more parts, false if not.\n\
 * @method hasNext\n\
 */\n\
PropertyValueIterator.prototype.hasNext = function() {\n\
    return this._i < this._parts.length;\n\
};\n\
\n\
/**\n\
 * Marks the current spot in the iteration so it can be restored to\n\
 * later on.\n\
 * @return {void}\n\
 * @method mark\n\
 */\n\
PropertyValueIterator.prototype.mark = function() {\n\
    this._marks.push(this._i);\n\
};\n\
\n\
/**\n\
 * Returns the next part of the property value or null if there is no next\n\
 * part. Does not move the internal counter forward.\n\
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\n\
 * part.\n\
 * @method peek\n\
 */\n\
PropertyValueIterator.prototype.peek = function(count) {\n\
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;\n\
};\n\
\n\
/**\n\
 * Returns the next part of the property value or null if there is no next\n\
 * part.\n\
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\n\
 * part.\n\
 * @method next\n\
 */\n\
PropertyValueIterator.prototype.next = function() {\n\
    return this.hasNext() ? this._parts[this._i++] : null;\n\
};\n\
\n\
/**\n\
 * Returns the previous part of the property value or null if there is no\n\
 * previous part.\n\
 * @return {parserlib.css.PropertyValuePart} The previous part of the\n\
 * property value or null if there is no previous part.\n\
 * @method previous\n\
 */\n\
PropertyValueIterator.prototype.previous = function() {\n\
    return this._i > 0 ? this._parts[--this._i] : null;\n\
};\n\
\n\
/**\n\
 * Restores the last saved bookmark.\n\
 * @return {void}\n\
 * @method restore\n\
 */\n\
PropertyValueIterator.prototype.restore = function() {\n\
    if (this._marks.length) {\n\
        this._i = this._marks.pop();\n\
    }\n\
};\n\
\n\
/**\n\
 * Drops the last saved bookmark.\n\
 * @return {void}\n\
 * @method drop\n\
 */\n\
PropertyValueIterator.prototype.drop = function() {\n\
    this._marks.pop();\n\
};\n\
},{}],11:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = PropertyValuePart;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Colors = require(\"./Colors\");\n\
var Parser = require(\"./Parser\");\n\
var Tokens = require(\"./Tokens\");\n\
\n\
/**\n\
 * Represents a single part of a CSS property value, meaning that it represents\n\
 * just one part of the data between \":\" and \";\".\n\
 * @param {String} text The text representation of the unit.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 * @namespace parserlib.css\n\
 * @class PropertyValuePart\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 */\n\
function PropertyValuePart(text, line, col, optionalHint) {\n\
    var hint = optionalHint || {};\n\
\n\
    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);\n\
\n\
    /**\n\
     * Indicates the type of value unit.\n\
     * @type String\n\
     * @property type\n\
     */\n\
    this.type = \"unknown\";\n\
\n\
    //figure out what type of data it is\n\
\n\
    var temp;\n\
\n\
    //it is a measurement?\n\
    if (/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text)) {  //dimension\n\
        this.type = \"dimension\";\n\
        this.value = +RegExp.$1;\n\
        this.units = RegExp.$2;\n\
\n\
        //try to narrow down\n\
        switch (this.units.toLowerCase()) {\n\
\n\
            case \"em\":\n\
            case \"rem\":\n\
            case \"ex\":\n\
            case \"px\":\n\
            case \"cm\":\n\
            case \"mm\":\n\
            case \"in\":\n\
            case \"pt\":\n\
            case \"pc\":\n\
            case \"ch\":\n\
            case \"vh\":\n\
            case \"vw\":\n\
            case \"vmax\":\n\
            case \"vmin\":\n\
                this.type = \"length\";\n\
                break;\n\
\n\
            case \"fr\":\n\
                this.type = \"grid\";\n\
                break;\n\
\n\
            case \"deg\":\n\
            case \"rad\":\n\
            case \"grad\":\n\
            case \"turn\":\n\
                this.type = \"angle\";\n\
                break;\n\
\n\
            case \"ms\":\n\
            case \"s\":\n\
                this.type = \"time\";\n\
                break;\n\
\n\
            case \"hz\":\n\
            case \"khz\":\n\
                this.type = \"frequency\";\n\
                break;\n\
\n\
            case \"dpi\":\n\
            case \"dpcm\":\n\
                this.type = \"resolution\";\n\
                break;\n\
\n\
            //default\n\
        }\n\
    } else if (/^([+\\-]?[\\d\\.]+)%$/i.test(text)) {  //percentage\n\
        this.type = \"percentage\";\n\
        this.value = +RegExp.$1;\n\
    } else if (/^([+\\-]?\\d+)$/i.test(text)) {  //integer\n\
        this.type = \"integer\";\n\
        this.value = +RegExp.$1;\n\
    } else if (/^([+\\-]?[\\d\\.]+)$/i.test(text)) {  //number\n\
        this.type = \"number\";\n\
        this.value = +RegExp.$1;\n\
    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor\n\
        this.type = \"color\";\n\
        temp = RegExp.$1;\n\
        if (temp.length === 3) {\n\
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);\n\
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);\n\
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);\n\
        } else {\n\
            this.red    = parseInt(temp.substring(0, 2), 16);\n\
            this.green  = parseInt(temp.substring(2, 4), 16);\n\
            this.blue   = parseInt(temp.substring(4, 6), 16);\n\
        }\n\
    } else if (/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)) { //rgb() color with absolute numbers\n\
        this.type   = \"color\";\n\
        this.red    = +RegExp.$1;\n\
        this.green  = +RegExp.$2;\n\
        this.blue   = +RegExp.$3;\n\
    } else if (/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)) { //rgb() color with percentages\n\
        this.type   = \"color\";\n\
        this.red    = +RegExp.$1 * 255 / 100;\n\
        this.green  = +RegExp.$2 * 255 / 100;\n\
        this.blue   = +RegExp.$3 * 255 / 100;\n\
    } else if (/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //rgba() color with absolute numbers\n\
        this.type   = \"color\";\n\
        this.red    = +RegExp.$1;\n\
        this.green  = +RegExp.$2;\n\
        this.blue   = +RegExp.$3;\n\
        this.alpha  = +RegExp.$4;\n\
    } else if (/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //rgba() color with percentages\n\
        this.type   = \"color\";\n\
        this.red    = +RegExp.$1 * 255 / 100;\n\
        this.green  = +RegExp.$2 * 255 / 100;\n\
        this.blue   = +RegExp.$3 * 255 / 100;\n\
        this.alpha  = +RegExp.$4;\n\
    } else if (/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)) { //hsl()\n\
        this.type   = \"color\";\n\
        this.hue    = +RegExp.$1;\n\
        this.saturation = +RegExp.$2 / 100;\n\
        this.lightness  = +RegExp.$3 / 100;\n\
    } else if (/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //hsla() color with percentages\n\
        this.type   = \"color\";\n\
        this.hue    = +RegExp.$1;\n\
        this.saturation = +RegExp.$2 / 100;\n\
        this.lightness  = +RegExp.$3 / 100;\n\
        this.alpha  = +RegExp.$4;\n\
    } else if (/^url\\((\"([^\\\\\"]|\\\\.)*\")\\)/i.test(text)) { //URI\n\
        // generated by TokenStream.readURI, so always double-quoted.\n\
        this.type   = \"uri\";\n\
        this.uri    = PropertyValuePart.parseString(RegExp.$1);\n\
    } else if (/^([^\\(]+)\\(/i.test(text)) {\n\
        this.type   = \"function\";\n\
        this.name   = RegExp.$1;\n\
        this.value  = text;\n\
    } else if (/^\"([^\\n\\r\\f\\\\\"]|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*\"/i.test(text)) {    //double-quoted string\n\
        this.type   = \"string\";\n\
        this.value  = PropertyValuePart.parseString(text);\n\
    } else if (/^'([^\\n\\r\\f\\\\']|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*'/i.test(text)) {    //single-quoted string\n\
        this.type   = \"string\";\n\
        this.value  = PropertyValuePart.parseString(text);\n\
    } else if (Colors[text.toLowerCase()]) {  //named color\n\
        this.type   = \"color\";\n\
        temp        = Colors[text.toLowerCase()].substring(1);\n\
        this.red    = parseInt(temp.substring(0, 2), 16);\n\
        this.green  = parseInt(temp.substring(2, 4), 16);\n\
        this.blue   = parseInt(temp.substring(4, 6), 16);\n\
    } else if (/^[,\\/]$/.test(text)) {\n\
        this.type   = \"operator\";\n\
        this.value  = text;\n\
    } else if (/^-?[a-z_\\u00A0-\\uFFFF][a-z0-9\\-_\\u00A0-\\uFFFF]*$/i.test(text)) {\n\
        this.type   = \"identifier\";\n\
        this.value  = text;\n\
    }\n\
\n\
    // There can be ambiguity with escape sequences in identifiers, as\n\
    // well as with \"color\" parts which are also \"identifiers\", so record\n\
    // an explicit hint when the token generating this PropertyValuePart\n\
    // was an identifier.\n\
    this.wasIdent = Boolean(hint.ident);\n\
}\n\
\n\
PropertyValuePart.prototype = new SyntaxUnit();\n\
PropertyValuePart.prototype.constructor = PropertyValuePart;\n\
\n\
/**\n\
 * Helper method to parse a CSS string.\n\
 */\n\
PropertyValuePart.parseString = function(str) {\n\
    str = str.slice(1, -1); // Strip surrounding single/double quotes\n\
    var replacer = function(match, esc) {\n\
        if (/^(\\n|\\r\\n|\\r|\\f)$/.test(esc)) {\n\
            return \"\";\n\
        }\n\
        var m = /^[0-9a-f]{1,6}/i.exec(esc);\n\
        if (m) {\n\
            var codePoint = parseInt(m[0], 16);\n\
            if (String.fromCodePoint) {\n\
                return String.fromCodePoint(codePoint);\n\
            } else {\n\
                // XXX No support for surrogates on old JavaScript engines.\n\
                return String.fromCharCode(codePoint);\n\
            }\n\
        }\n\
        return esc;\n\
    };\n\
    return str.replace(/\\\\(\\r\\n|[^\\r0-9a-f]|[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)/ig,\n\
                       replacer);\n\
};\n\
\n\
/**\n\
 * Helper method to serialize a CSS string.\n\
 */\n\
PropertyValuePart.serializeString = function(value) {\n\
    var replacer = function(match, c) {\n\
        if (c === \"\\\"\") {\n\
            return \"\\\\\" + c;\n\
        }\n\
        var cp = String.codePointAt ? String.codePointAt(0) :\n\
            // We only escape non-surrogate chars, so using charCodeAt\n\
            // is harmless here.\n\
            String.charCodeAt(0);\n\
        return \"\\\\\" + cp.toString(16) + \" \";\n\
    };\n\
    return \"\\\"\" + value.replace(/[\"\\r\\n\\f]/g, replacer) + \"\\\"\";\n\
};\n\
\n\
/**\n\
 * Create a new syntax unit based solely on the given token.\n\
 * Convenience method for creating a new syntax unit when\n\
 * it represents a single token instead of multiple.\n\
 * @param {Object} token The token object to represent.\n\
 * @return {parserlib.css.PropertyValuePart} The object representing the token.\n\
 * @static\n\
 * @method fromToken\n\
 */\n\
PropertyValuePart.fromToken = function(token) {\n\
    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {\n\
        // Tokens can have escaped characters that would fool the type\n\
        // identification in the PropertyValuePart constructor, so pass\n\
        // in a hint if this was an identifier.\n\
        ident: token.type === Tokens.IDENT\n\
    });\n\
    return part;\n\
};\n\
},{\"../util/SyntaxUnit\":26,\"./Colors\":1,\"./Parser\":6,\"./Tokens\":18}],12:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
var Pseudos = module.exports = {\n\
    __proto__:       null,\n\
    \":first-letter\": 1,\n\
    \":first-line\":   1,\n\
    \":before\":       1,\n\
    \":after\":        1\n\
};\n\
\n\
Pseudos.ELEMENT = 1;\n\
Pseudos.CLASS = 2;\n\
\n\
Pseudos.isElement = function(pseudo) {\n\
    return pseudo.indexOf(\"::\") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;\n\
};\n\
},{}],13:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = Selector;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
var Specificity = require(\"./Specificity\");\n\
\n\
/**\n\
 * Represents an entire single selector, including all parts but not\n\
 * including multiple selectors (those separated by commas).\n\
 * @namespace parserlib.css\n\
 * @class Selector\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {Array} parts Array of selectors parts making up this selector.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function Selector(parts, line, col) {\n\
\n\
    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.SELECTOR_TYPE);\n\
\n\
    /**\n\
     * The parts that make up the selector.\n\
     * @type Array\n\
     * @property parts\n\
     */\n\
    this.parts = parts;\n\
\n\
    /**\n\
     * The specificity of the selector.\n\
     * @type parserlib.css.Specificity\n\
     * @property specificity\n\
     */\n\
    this.specificity = Specificity.calculate(this);\n\
}\n\
\n\
Selector.prototype = new SyntaxUnit();\n\
Selector.prototype.constructor = Selector;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6,\"./Specificity\":16}],14:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = SelectorPart;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a single part of a selector string, meaning a single set of\n\
 * element name and modifiers. This does not include combinators such as\n\
 * spaces, +, >, etc.\n\
 * @namespace parserlib.css\n\
 * @class SelectorPart\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {String} elementName The element name in the selector or null\n\
 *      if there is no element name.\n\
 * @param {Array} modifiers Array of individual modifiers for the element.\n\
 *      May be empty if there are none.\n\
 * @param {String} text The text representation of the unit.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function SelectorPart(elementName, modifiers, text, line, col) {\n\
\n\
    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);\n\
\n\
    /**\n\
     * The tag name of the element to which this part\n\
     * of the selector affects.\n\
     * @type String\n\
     * @property elementName\n\
     */\n\
    this.elementName = elementName;\n\
\n\
    /**\n\
     * The parts that come after the element name, such as class names, IDs,\n\
     * pseudo classes/elements, etc.\n\
     * @type Array\n\
     * @property modifiers\n\
     */\n\
    this.modifiers = modifiers;\n\
}\n\
\n\
SelectorPart.prototype = new SyntaxUnit();\n\
SelectorPart.prototype.constructor = SelectorPart;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],15:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = SelectorSubPart;\n\
\n\
var SyntaxUnit = require(\"../util/SyntaxUnit\");\n\
\n\
var Parser = require(\"./Parser\");\n\
\n\
/**\n\
 * Represents a selector modifier string, meaning a class name, element name,\n\
 * element ID, pseudo rule, etc.\n\
 * @namespace parserlib.css\n\
 * @class SelectorSubPart\n\
 * @extends parserlib.util.SyntaxUnit\n\
 * @constructor\n\
 * @param {String} text The text representation of the unit.\n\
 * @param {String} type The type of selector modifier.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function SelectorSubPart(text, type, line, col) {\n\
\n\
    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);\n\
\n\
    /**\n\
     * The type of modifier.\n\
     * @type String\n\
     * @property type\n\
     */\n\
    this.type = type;\n\
\n\
    /**\n\
     * Some subparts have arguments, this represents them.\n\
     * @type Array\n\
     * @property args\n\
     */\n\
    this.args = [];\n\
}\n\
\n\
SelectorSubPart.prototype = new SyntaxUnit();\n\
SelectorSubPart.prototype.constructor = SelectorSubPart;\n\
},{\"../util/SyntaxUnit\":26,\"./Parser\":6}],16:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = Specificity;\n\
\n\
var Pseudos = require(\"./Pseudos\");\n\
var SelectorPart = require(\"./SelectorPart\");\n\
\n\
/**\n\
 * Represents a selector's specificity.\n\
 * @namespace parserlib.css\n\
 * @class Specificity\n\
 * @constructor\n\
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles\n\
 * @param {int} b Number of ID selectors\n\
 * @param {int} c Number of classes and pseudo classes\n\
 * @param {int} d Number of element names and pseudo elements\n\
 */\n\
function Specificity(a, b, c, d) {\n\
    this.a = a;\n\
    this.b = b;\n\
    this.c = c;\n\
    this.d = d;\n\
}\n\
\n\
Specificity.prototype = {\n\
    constructor: Specificity,\n\
\n\
    /**\n\
     * Compare this specificity to another.\n\
     * @param {Specificity} other The other specificity to compare to.\n\
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\n\
     * @method compare\n\
     */\n\
    compare: function(other) {\n\
        var comps = [\"a\", \"b\", \"c\", \"d\"],\n\
            i, len;\n\
\n\
        for (i=0, len=comps.length; i < len; i++) {\n\
            if (this[comps[i]] < other[comps[i]]) {\n\
                return -1;\n\
            } else if (this[comps[i]] > other[comps[i]]) {\n\
                return 1;\n\
            }\n\
        }\n\
\n\
        return 0;\n\
    },\n\
\n\
    /**\n\
     * Creates a numeric value for the specificity.\n\
     * @return {int} The numeric value for the specificity.\n\
     * @method valueOf\n\
     */\n\
    valueOf: function() {\n\
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;\n\
    },\n\
\n\
    /**\n\
     * Returns a string representation for specificity.\n\
     * @return {String} The string representation of specificity.\n\
     * @method toString\n\
     */\n\
    toString: function() {\n\
        return this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d;\n\
    }\n\
};\n\
\n\
/**\n\
 * Calculates the specificity of the given selector.\n\
 * @param {parserlib.css.Selector} The selector to calculate specificity for.\n\
 * @return {parserlib.css.Specificity} The specificity of the selector.\n\
 * @static\n\
 * @method calculate\n\
 */\n\
Specificity.calculate = function(selector) {\n\
\n\
    var i, len,\n\
        part,\n\
        b=0, c=0, d=0;\n\
\n\
    function updateValues(part) {\n\
\n\
        var i, j, len, num,\n\
            elementName = part.elementName ? part.elementName.text : \"\",\n\
            modifier;\n\
\n\
        if (elementName && elementName.charAt(elementName.length-1) !== \"*\") {\n\
            d++;\n\
        }\n\
\n\
        for (i=0, len=part.modifiers.length; i < len; i++) {\n\
            modifier = part.modifiers[i];\n\
            switch (modifier.type) {\n\
                case \"class\":\n\
                case \"attribute\":\n\
                    c++;\n\
                    break;\n\
\n\
                case \"id\":\n\
                    b++;\n\
                    break;\n\
\n\
                case \"pseudo\":\n\
                    if (Pseudos.isElement(modifier.text)) {\n\
                        d++;\n\
                    } else {\n\
                        c++;\n\
                    }\n\
                    break;\n\
\n\
                case \"not\":\n\
                    for (j=0, num=modifier.args.length; j < num; j++) {\n\
                        updateValues(modifier.args[j]);\n\
                    }\n\
            }\n\
        }\n\
    }\n\
\n\
    for (i=0, len=selector.parts.length; i < len; i++) {\n\
        part = selector.parts[i];\n\
\n\
        if (part instanceof SelectorPart) {\n\
            updateValues(part);\n\
        }\n\
    }\n\
\n\
    return new Specificity(0, b, c, d);\n\
};\n\
},{\"./Pseudos\":12,\"./SelectorPart\":14}],17:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = TokenStream;\n\
\n\
var TokenStreamBase = require(\"../util/TokenStreamBase\");\n\
\n\
var PropertyValuePart = require(\"./PropertyValuePart\");\n\
var Tokens = require(\"./Tokens\");\n\
\n\
var h = /^[0-9a-fA-F]$/,\n\
    nonascii = /^[\\u00A0-\\uFFFF]$/,\n\
    nl = /\\n|\\r\\n|\\r|\\f/,\n\
    whitespace = /\\u0009|\\u000a|\\u000c|\\u000d|\\u0020/;\n\
\n\
//-----------------------------------------------------------------------------\n\
// Helper functions\n\
//-----------------------------------------------------------------------------\n\
\n\
\n\
function isHexDigit(c) {\n\
    return c !== null && h.test(c);\n\
}\n\
\n\
function isDigit(c) {\n\
    return c !== null && /\\d/.test(c);\n\
}\n\
\n\
function isWhitespace(c) {\n\
    return c !== null && whitespace.test(c);\n\
}\n\
\n\
function isNewLine(c) {\n\
    return c !== null && nl.test(c);\n\
}\n\
\n\
function isNameStart(c) {\n\
    return c !== null && /[a-z_\\u00A0-\\uFFFF\\\\]/i.test(c);\n\
}\n\
\n\
function isNameChar(c) {\n\
    return c !== null && (isNameStart(c) || /[0-9\\-\\\\]/.test(c));\n\
}\n\
\n\
function isIdentStart(c) {\n\
    return c !== null && (isNameStart(c) || /\\-\\\\/.test(c));\n\
}\n\
\n\
function mix(receiver, supplier) {\n\
    for (var prop in supplier) {\n\
        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {\n\
            receiver[prop] = supplier[prop];\n\
        }\n\
    }\n\
    return receiver;\n\
}\n\
\n\
//-----------------------------------------------------------------------------\n\
// CSS Token Stream\n\
//-----------------------------------------------------------------------------\n\
\n\
\n\
/**\n\
 * A token stream that produces CSS tokens.\n\
 * @param {String|Reader} input The source of text to tokenize.\n\
 * @constructor\n\
 * @class TokenStream\n\
 * @namespace parserlib.css\n\
 */\n\
function TokenStream(input) {\n\
    TokenStreamBase.call(this, input, Tokens);\n\
}\n\
\n\
TokenStream.prototype = mix(new TokenStreamBase(), {\n\
\n\
    /**\n\
     * Overrides the TokenStreamBase method of the same name\n\
     * to produce CSS tokens.\n\
     * @return {Object} A token object representing the next token.\n\
     * @method _getToken\n\
     * @private\n\
     */\n\
    _getToken: function() {\n\
\n\
        var c,\n\
            reader = this._reader,\n\
            token   = null,\n\
            startLine   = reader.getLine(),\n\
            startCol    = reader.getCol();\n\
\n\
        c = reader.read();\n\
\n\
\n\
        while (c) {\n\
            switch (c) {\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - COMMENT\n\
                 * - SLASH\n\
                 * - CHAR\n\
                 */\n\
                case \"/\":\n\
\n\
                    if (reader.peek() === \"*\") {\n\
                        token = this.commentToken(c, startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - DASHMATCH\n\
                 * - INCLUDES\n\
                 * - PREFIXMATCH\n\
                 * - SUFFIXMATCH\n\
                 * - SUBSTRINGMATCH\n\
                 * - CHAR\n\
                 */\n\
                case \"|\":\n\
                case \"~\":\n\
                case \"^\":\n\
                case \"$\":\n\
                case \"*\":\n\
                    if (reader.peek() === \"=\") {\n\
                        token = this.comparisonToken(c, startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - STRING\n\
                 * - INVALID\n\
                 */\n\
                case \"\\\"\":\n\
                case \"'\":\n\
                    token = this.stringToken(c, startLine, startCol);\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - HASH\n\
                 * - CHAR\n\
                 */\n\
                case \"#\":\n\
                    if (isNameChar(reader.peek())) {\n\
                        token = this.hashToken(c, startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - DOT\n\
                 * - NUMBER\n\
                 * - DIMENSION\n\
                 * - PERCENTAGE\n\
                 */\n\
                case \".\":\n\
                    if (isDigit(reader.peek())) {\n\
                        token = this.numberToken(c, startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - CDC\n\
                 * - MINUS\n\
                 * - NUMBER\n\
                 * - DIMENSION\n\
                 * - PERCENTAGE\n\
                 */\n\
                case \"-\":\n\
                    if (reader.peek() === \"-\") {  //could be closing HTML-style comment\n\
                        token = this.htmlCommentEndToken(c, startLine, startCol);\n\
                    } else if (isNameStart(reader.peek())) {\n\
                        token = this.identOrFunctionToken(c, startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - IMPORTANT_SYM\n\
                 * - CHAR\n\
                 */\n\
                case \"!\":\n\
                    token = this.importantToken(c, startLine, startCol);\n\
                    break;\n\
\n\
                /*\n\
                 * Any at-keyword or CHAR\n\
                 */\n\
                case \"@\":\n\
                    token = this.atRuleToken(c, startLine, startCol);\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - NOT\n\
                 * - CHAR\n\
                 */\n\
                case \":\":\n\
                    token = this.notToken(c, startLine, startCol);\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - CDO\n\
                 * - CHAR\n\
                 */\n\
                case \"<\":\n\
                    token = this.htmlCommentStartToken(c, startLine, startCol);\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - IDENT\n\
                 * - CHAR\n\
                 */\n\
                case \"\\\\\":\n\
                    if (/[^\\r\\n\\f]/.test(reader.peek())) {\n\
                        token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);\n\
                    } else {\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
                    break;\n\
\n\
                /*\n\
                 * Potential tokens:\n\
                 * - UNICODE_RANGE\n\
                 * - URL\n\
                 * - CHAR\n\
                 */\n\
                case \"U\":\n\
                case \"u\":\n\
                    if (reader.peek() === \"+\") {\n\
                        token = this.unicodeRangeToken(c, startLine, startCol);\n\
                        break;\n\
                    }\n\
                    /* falls through */\n\
                default:\n\
\n\
                    /*\n\
                     * Potential tokens:\n\
                     * - NUMBER\n\
                     * - DIMENSION\n\
                     * - LENGTH\n\
                     * - FREQ\n\
                     * - TIME\n\
                     * - EMS\n\
                     * - EXS\n\
                     * - ANGLE\n\
                     */\n\
                    if (isDigit(c)) {\n\
                        token = this.numberToken(c, startLine, startCol);\n\
                    } else\n\
\n\
                    /*\n\
                     * Potential tokens:\n\
                     * - S\n\
                     */\n\
                    if (isWhitespace(c)) {\n\
                        token = this.whitespaceToken(c, startLine, startCol);\n\
                    } else\n\
\n\
                    /*\n\
                     * Potential tokens:\n\
                     * - IDENT\n\
                     */\n\
                    if (isIdentStart(c)) {\n\
                        token = this.identOrFunctionToken(c, startLine, startCol);\n\
                    } else {\n\
                       /*\n\
                        * Potential tokens:\n\
                        * - CHAR\n\
                        * - PLUS\n\
                        */\n\
                        token = this.charToken(c, startLine, startCol);\n\
                    }\n\
            }\n\
\n\
            //make sure this token is wanted\n\
            //TODO: check channel\n\
            break;\n\
        }\n\
\n\
        if (!token && c === null) {\n\
            token = this.createToken(Tokens.EOF, null, startLine, startCol);\n\
        }\n\
\n\
        return token;\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Methods to create tokens\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Produces a token based on available data and the current\n\
     * reader position information. This method is called by other\n\
     * private methods to create tokens and is never called directly.\n\
     * @param {int} tt The token type.\n\
     * @param {String} value The text value of the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @param {Object} options (Optional) Specifies a channel property\n\
     *      to indicate that a different channel should be scanned\n\
     *      and/or a hide property indicating that the token should\n\
     *      be hidden.\n\
     * @return {Object} A token object.\n\
     * @method createToken\n\
     */\n\
    createToken: function(tt, value, startLine, startCol, options) {\n\
        var reader = this._reader;\n\
        options = options || {};\n\
\n\
        return {\n\
            value:      value,\n\
            type:       tt,\n\
            channel:    options.channel,\n\
            endChar:    options.endChar,\n\
            hide:       options.hide || false,\n\
            startLine:  startLine,\n\
            startCol:   startCol,\n\
            endLine:    reader.getLine(),\n\
            endCol:     reader.getCol()\n\
        };\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Methods to create specific tokens\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Produces a token for any at-rule. If the at-rule is unknown, then\n\
     * the token is for a single \"@\" character.\n\
     * @param {String} first The first character for the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method atRuleToken\n\
     */\n\
    atRuleToken: function(first, startLine, startCol) {\n\
        var rule    = first,\n\
            reader  = this._reader,\n\
            tt      = Tokens.CHAR,\n\
            ident;\n\
\n\
        /*\n\
         * First, mark where we are. There are only four @ rules,\n\
         * so anything else is really just an invalid token.\n\
         * Basically, if this doesn't match one of the known @\n\
         * rules, just return '@' as an unknown token and allow\n\
         * parsing to continue after that point.\n\
         */\n\
        reader.mark();\n\
\n\
        //try to find the at-keyword\n\
        ident = this.readName();\n\
        rule = first + ident;\n\
        tt = Tokens.type(rule.toLowerCase());\n\
\n\
        //if it's not valid, use the first character only and reset the reader\n\
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {\n\
            if (rule.length > 1) {\n\
                tt = Tokens.UNKNOWN_SYM;\n\
            } else {\n\
                tt = Tokens.CHAR;\n\
                rule = first;\n\
                reader.reset();\n\
            }\n\
        }\n\
\n\
        return this.createToken(tt, rule, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a character token based on the given character\n\
     * and location in the stream. If there's a special (non-standard)\n\
     * token name, this is used; otherwise CHAR is used.\n\
     * @param {String} c The character for the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method charToken\n\
     */\n\
    charToken: function(c, startLine, startCol) {\n\
        var tt = Tokens.type(c);\n\
        var opts = {};\n\
\n\
        if (tt === -1) {\n\
            tt = Tokens.CHAR;\n\
        } else {\n\
            opts.endChar = Tokens[tt].endChar;\n\
        }\n\
\n\
        return this.createToken(tt, c, startLine, startCol, opts);\n\
    },\n\
\n\
    /**\n\
     * Produces a character token based on the given character\n\
     * and location in the stream. If there's a special (non-standard)\n\
     * token name, this is used; otherwise CHAR is used.\n\
     * @param {String} first The first character for the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method commentToken\n\
     */\n\
    commentToken: function(first, startLine, startCol) {\n\
        var comment = this.readComment(first);\n\
\n\
        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a comparison token based on the given character\n\
     * and location in the stream. The next character must be\n\
     * read and is already known to be an equals sign.\n\
     * @param {String} c The character for the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method comparisonToken\n\
     */\n\
    comparisonToken: function(c, startLine, startCol) {\n\
        var reader  = this._reader,\n\
            comparison  = c + reader.read(),\n\
            tt      = Tokens.type(comparison) || Tokens.CHAR;\n\
\n\
        return this.createToken(tt, comparison, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a hash token based on the specified information. The\n\
     * first character provided is the pound sign (#) and then this\n\
     * method reads a name afterward.\n\
     * @param {String} first The first character (#) in the hash name.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method hashToken\n\
     */\n\
    hashToken: function(first, startLine, startCol) {\n\
        var name    = this.readName(first);\n\
\n\
        return this.createToken(Tokens.HASH, name, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a CDO or CHAR token based on the specified information. The\n\
     * first character is provided and the rest is read by the function to determine\n\
     * the correct token to create.\n\
     * @param {String} first The first character in the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method htmlCommentStartToken\n\
     */\n\
    htmlCommentStartToken: function(first, startLine, startCol) {\n\
        var reader      = this._reader,\n\
            text        = first;\n\
\n\
        reader.mark();\n\
        text += reader.readCount(3);\n\
\n\
        if (text === \"<!--\") {\n\
            return this.createToken(Tokens.CDO, text, startLine, startCol);\n\
        } else {\n\
            reader.reset();\n\
            return this.charToken(first, startLine, startCol);\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Produces a CDC or CHAR token based on the specified information. The\n\
     * first character is provided and the rest is read by the function to determine\n\
     * the correct token to create.\n\
     * @param {String} first The first character in the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method htmlCommentEndToken\n\
     */\n\
    htmlCommentEndToken: function(first, startLine, startCol) {\n\
        var reader      = this._reader,\n\
            text        = first;\n\
\n\
        reader.mark();\n\
        text += reader.readCount(2);\n\
\n\
        if (text === \"-->\") {\n\
            return this.createToken(Tokens.CDC, text, startLine, startCol);\n\
        } else {\n\
            reader.reset();\n\
            return this.charToken(first, startLine, startCol);\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Produces an IDENT or FUNCTION token based on the specified information. The\n\
     * first character is provided and the rest is read by the function to determine\n\
     * the correct token to create.\n\
     * @param {String} first The first character in the identifier.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method identOrFunctionToken\n\
     */\n\
    identOrFunctionToken: function(first, startLine, startCol) {\n\
        var reader  = this._reader,\n\
            ident   = this.readName(first),\n\
            tt      = Tokens.IDENT,\n\
            uriFns  = [\"url(\", \"url-prefix(\", \"domain(\"],\n\
            uri;\n\
\n\
        //if there's a left paren immediately after, it's a URI or function\n\
        if (reader.peek() === \"(\") {\n\
            ident += reader.read();\n\
            if (uriFns.indexOf(ident.toLowerCase()) > -1) {\n\
                reader.mark();\n\
                uri = this.readURI(ident);\n\
                if (uri === null) {\n\
                    //didn't find a valid URL or there's no closing paren\n\
                    reader.reset();\n\
                    tt = Tokens.FUNCTION;\n\
                } else {\n\
                    tt = Tokens.URI;\n\
                    ident = uri;\n\
                }\n\
            } else {\n\
                tt = Tokens.FUNCTION;\n\
            }\n\
        } else if (reader.peek() === \":\") {  //might be an IE function\n\
\n\
            //IE-specific functions always being with progid:\n\
            if (ident.toLowerCase() === \"progid\") {\n\
                ident += reader.readTo(\"(\");\n\
                tt = Tokens.IE_FUNCTION;\n\
            }\n\
        }\n\
\n\
        return this.createToken(tt, ident, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The\n\
     * first character is provided and the rest is read by the function to determine\n\
     * the correct token to create.\n\
     * @param {String} first The first character in the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method importantToken\n\
     */\n\
    importantToken: function(first, startLine, startCol) {\n\
        var reader      = this._reader,\n\
            important   = first,\n\
            tt          = Tokens.CHAR,\n\
            temp,\n\
            c;\n\
\n\
        reader.mark();\n\
        c = reader.read();\n\
\n\
        while (c) {\n\
\n\
            //there can be a comment in here\n\
            if (c === \"/\") {\n\
\n\
                //if the next character isn't a star, then this isn't a valid !important token\n\
                if (reader.peek() !== \"*\") {\n\
                    break;\n\
                } else {\n\
                    temp = this.readComment(c);\n\
                    if (temp === \"\") {    //broken!\n\
                        break;\n\
                    }\n\
                }\n\
            } else if (isWhitespace(c)) {\n\
                important += c + this.readWhitespace();\n\
            } else if (/i/i.test(c)) {\n\
                temp = reader.readCount(8);\n\
                if (/mportant/i.test(temp)) {\n\
                    important += c + temp;\n\
                    tt = Tokens.IMPORTANT_SYM;\n\
                }\n\
                break;  //we're done\n\
            } else {\n\
                break;\n\
            }\n\
\n\
            c = reader.read();\n\
        }\n\
\n\
        if (tt === Tokens.CHAR) {\n\
            reader.reset();\n\
            return this.charToken(first, startLine, startCol);\n\
        } else {\n\
            return this.createToken(tt, important, startLine, startCol);\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Produces a NOT or CHAR token based on the specified information. The\n\
     * first character is provided and the rest is read by the function to determine\n\
     * the correct token to create.\n\
     * @param {String} first The first character in the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method notToken\n\
     */\n\
    notToken: function(first, startLine, startCol) {\n\
        var reader      = this._reader,\n\
            text        = first;\n\
\n\
        reader.mark();\n\
        text += reader.readCount(4);\n\
\n\
        if (text.toLowerCase() === \":not(\") {\n\
            return this.createToken(Tokens.NOT, text, startLine, startCol);\n\
        } else {\n\
            reader.reset();\n\
            return this.charToken(first, startLine, startCol);\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Produces a number token based on the given character\n\
     * and location in the stream. This may return a token of\n\
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,\n\
     * or PERCENTAGE.\n\
     * @param {String} first The first character for the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method numberToken\n\
     */\n\
    numberToken: function(first, startLine, startCol) {\n\
        var reader  = this._reader,\n\
            value   = this.readNumber(first),\n\
            ident,\n\
            tt      = Tokens.NUMBER,\n\
            c       = reader.peek();\n\
\n\
        if (isIdentStart(c)) {\n\
            ident = this.readName(reader.read());\n\
            value += ident;\n\
\n\
            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {\n\
                tt = Tokens.LENGTH;\n\
            } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {\n\
                tt = Tokens.ANGLE;\n\
            } else if (/^ms$|^s$/i.test(ident)) {\n\
                tt = Tokens.TIME;\n\
            } else if (/^hz$|^khz$/i.test(ident)) {\n\
                tt = Tokens.FREQ;\n\
            } else if (/^dpi$|^dpcm$/i.test(ident)) {\n\
                tt = Tokens.RESOLUTION;\n\
            } else {\n\
                tt = Tokens.DIMENSION;\n\
            }\n\
        } else if (c === \"%\") {\n\
            value += reader.read();\n\
            tt = Tokens.PERCENTAGE;\n\
        }\n\
\n\
        return this.createToken(tt, value, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a string token based on the given character\n\
     * and location in the stream. Since strings may be indicated\n\
     * by single or double quotes, a failure to match starting\n\
     * and ending quotes results in an INVALID token being generated.\n\
     * The first character in the string is passed in and then\n\
     * the rest are read up to and including the final quotation mark.\n\
     * @param {String} first The first character in the string.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method stringToken\n\
     */\n\
    stringToken: function(first, startLine, startCol) {\n\
        var delim   = first,\n\
            string  = first,\n\
            reader  = this._reader,\n\
            tt      = Tokens.STRING,\n\
            c       = reader.read(),\n\
            i;\n\
\n\
        while (c) {\n\
            string += c;\n\
\n\
            if (c === \"\\\\\") {\n\
                c = reader.read();\n\
                if (c === null) {\n\
                    break; // premature EOF after backslash\n\
                } else if (/[^\\r\\n\\f0-9a-f]/i.test(c)) {\n\
                    // single-character escape\n\
                    string += c;\n\
                } else {\n\
                    // read up to six hex digits\n\
                    for (i=0; isHexDigit(c) && i<6; i++) {\n\
                        string += c;\n\
                        c = reader.read();\n\
                    }\n\
                    // swallow trailing newline or space\n\
                    if (c === \"\\r\" && reader.peek() === \"\\n\") {\n\
                        string += c;\n\
                        c = reader.read();\n\
                    }\n\
                    if (isWhitespace(c)) {\n\
                        string += c;\n\
                    } else {\n\
                        // This character is null or not part of the escape;\n\
                        // jump back to the top to process it.\n\
                        continue;\n\
                    }\n\
                }\n\
            } else if (c === delim) {\n\
                break; // delimiter found.\n\
            } else if (isNewLine(reader.peek())) {\n\
                // newline without an escapement: it's an invalid string\n\
                tt = Tokens.INVALID;\n\
                break;\n\
            }\n\
            c = reader.read();\n\
        }\n\
\n\
        //if c is null, that means we're out of input and the string was never closed\n\
        if (c === null) {\n\
            tt = Tokens.INVALID;\n\
        }\n\
\n\
        return this.createToken(tt, string, startLine, startCol);\n\
    },\n\
\n\
    unicodeRangeToken: function(first, startLine, startCol) {\n\
        var reader  = this._reader,\n\
            value   = first,\n\
            temp,\n\
            tt      = Tokens.CHAR;\n\
\n\
        //then it should be a unicode range\n\
        if (reader.peek() === \"+\") {\n\
            reader.mark();\n\
            value += reader.read();\n\
            value += this.readUnicodeRangePart(true);\n\
\n\
            //ensure there's an actual unicode range here\n\
            if (value.length === 2) {\n\
                reader.reset();\n\
            } else {\n\
\n\
                tt = Tokens.UNICODE_RANGE;\n\
\n\
                //if there's a ? in the first part, there can't be a second part\n\
                if (value.indexOf(\"?\") === -1) {\n\
\n\
                    if (reader.peek() === \"-\") {\n\
                        reader.mark();\n\
                        temp = reader.read();\n\
                        temp += this.readUnicodeRangePart(false);\n\
\n\
                        //if there's not another value, back up and just take the first\n\
                        if (temp.length === 1) {\n\
                            reader.reset();\n\
                        } else {\n\
                            value += temp;\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        return this.createToken(tt, value, startLine, startCol);\n\
    },\n\
\n\
    /**\n\
     * Produces a S token based on the specified information. Since whitespace\n\
     * may have multiple characters, this consumes all whitespace characters\n\
     * into a single token.\n\
     * @param {String} first The first character in the token.\n\
     * @param {int} startLine The beginning line for the character.\n\
     * @param {int} startCol The beginning column for the character.\n\
     * @return {Object} A token object.\n\
     * @method whitespaceToken\n\
     */\n\
    whitespaceToken: function(first, startLine, startCol) {\n\
        var value   = first + this.readWhitespace();\n\
        return this.createToken(Tokens.S, value, startLine, startCol);\n\
    },\n\
\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Methods to read values from the string stream\n\
    //-------------------------------------------------------------------------\n\
\n\
    readUnicodeRangePart: function(allowQuestionMark) {\n\
        var reader  = this._reader,\n\
            part = \"\",\n\
            c       = reader.peek();\n\
\n\
        //first read hex digits\n\
        while (isHexDigit(c) && part.length < 6) {\n\
            reader.read();\n\
            part += c;\n\
            c = reader.peek();\n\
        }\n\
\n\
        //then read question marks if allowed\n\
        if (allowQuestionMark) {\n\
            while (c === \"?\" && part.length < 6) {\n\
                reader.read();\n\
                part += c;\n\
                c = reader.peek();\n\
            }\n\
        }\n\
\n\
        //there can't be any other characters after this point\n\
\n\
        return part;\n\
    },\n\
\n\
    readWhitespace: function() {\n\
        var reader  = this._reader,\n\
            whitespace = \"\",\n\
            c       = reader.peek();\n\
\n\
        while (isWhitespace(c)) {\n\
            reader.read();\n\
            whitespace += c;\n\
            c = reader.peek();\n\
        }\n\
\n\
        return whitespace;\n\
    },\n\
    readNumber: function(first) {\n\
        var reader  = this._reader,\n\
            number  = first,\n\
            hasDot  = (first === \".\"),\n\
            c       = reader.peek();\n\
\n\
\n\
        while (c) {\n\
            if (isDigit(c)) {\n\
                number += reader.read();\n\
            } else if (c === \".\") {\n\
                if (hasDot) {\n\
                    break;\n\
                } else {\n\
                    hasDot = true;\n\
                    number += reader.read();\n\
                }\n\
            } else {\n\
                break;\n\
            }\n\
\n\
            c = reader.peek();\n\
        }\n\
\n\
        return number;\n\
    },\n\
\n\
    // returns null w/o resetting reader if string is invalid.\n\
    readString: function() {\n\
        var token = this.stringToken(this._reader.read(), 0, 0);\n\
        return token.type === Tokens.INVALID ? null : token.value;\n\
    },\n\
\n\
    // returns null w/o resetting reader if URI is invalid.\n\
    readURI: function(first) {\n\
        var reader  = this._reader,\n\
            uri     = first,\n\
            inner   = \"\",\n\
            c       = reader.peek();\n\
\n\
        //skip whitespace before\n\
        while (c && isWhitespace(c)) {\n\
            reader.read();\n\
            c = reader.peek();\n\
        }\n\
\n\
        //it's a string\n\
        if (c === \"'\" || c === \"\\\"\") {\n\
            inner = this.readString();\n\
            if (inner !== null) {\n\
                inner = PropertyValuePart.parseString(inner);\n\
            }\n\
        } else {\n\
            inner = this.readUnquotedURL();\n\
        }\n\
\n\
        c = reader.peek();\n\
\n\
        //skip whitespace after\n\
        while (c && isWhitespace(c)) {\n\
            reader.read();\n\
            c = reader.peek();\n\
        }\n\
\n\
        //if there was no inner value or the next character isn't closing paren, it's not a URI\n\
        if (inner === null || c !== \")\") {\n\
            uri = null;\n\
        } else {\n\
            // Ensure argument to URL is always double-quoted\n\
            // (This simplifies later processing in PropertyValuePart.)\n\
            uri += PropertyValuePart.serializeString(inner) + reader.read();\n\
        }\n\
\n\
        return uri;\n\
    },\n\
    // This method never fails, although it may return an empty string.\n\
    readUnquotedURL: function(first) {\n\
        var reader  = this._reader,\n\
            url     = first || \"\",\n\
            c;\n\
\n\
        for (c = reader.peek(); c; c = reader.peek()) {\n\
            // Note that the grammar at\n\
            // https://www.w3.org/TR/CSS2/grammar.html#scanner\n\
            // incorrectly includes the backslash character in the\n\
            // `url` production, although it is correctly omitted in\n\
            // the `baduri1` production.\n\
            if (nonascii.test(c) || /^[\\-!#$%&*-\\[\\]-~]$/.test(c)) {\n\
                url += c;\n\
                reader.read();\n\
            } else if (c === \"\\\\\") {\n\
                if (/^[^\\r\\n\\f]$/.test(reader.peek(2))) {\n\
                    url += this.readEscape(reader.read(), true);\n\
                } else {\n\
                    break; // bad escape sequence.\n\
                }\n\
            } else {\n\
                break; // bad character\n\
            }\n\
        }\n\
\n\
        return url;\n\
    },\n\
\n\
    readName: function(first) {\n\
        var reader  = this._reader,\n\
            ident   = first || \"\",\n\
            c;\n\
\n\
        for (c = reader.peek(); c; c = reader.peek()) {\n\
            if (c === \"\\\\\") {\n\
                if (/^[^\\r\\n\\f]$/.test(reader.peek(2))) {\n\
                    ident += this.readEscape(reader.read(), true);\n\
                } else {\n\
                    // Bad escape sequence.\n\
                    break;\n\
                }\n\
            } else if (isNameChar(c)) {\n\
                ident += reader.read();\n\
            } else {\n\
                break;\n\
            }\n\
        }\n\
\n\
        return ident;\n\
    },\n\
\n\
    readEscape: function(first, unescape) {\n\
        var reader  = this._reader,\n\
            cssEscape = first || \"\",\n\
            i       = 0,\n\
            c       = reader.peek();\n\
\n\
        if (isHexDigit(c)) {\n\
            do {\n\
                cssEscape += reader.read();\n\
                c = reader.peek();\n\
            } while (c && isHexDigit(c) && ++i < 6);\n\
        }\n\
\n\
        if (cssEscape.length === 1) {\n\
            if (/^[^\\r\\n\\f0-9a-f]$/.test(c)) {\n\
                reader.read();\n\
                if (unescape) {\n\
                    return c;\n\
                }\n\
            } else {\n\
                // We should never get here (readName won't call readEscape\n\
                // if the escape sequence is bad).\n\
                throw new Error(\"Bad escape sequence.\");\n\
            }\n\
        } else if (c === \"\\r\") {\n\
            reader.read();\n\
            if (reader.peek() === \"\\n\") {\n\
                c += reader.read();\n\
            }\n\
        } else if (/^[ \\t\\n\\f]$/.test(c)) {\n\
            reader.read();\n\
        } else {\n\
            c = \"\";\n\
        }\n\
\n\
        if (unescape) {\n\
            var cp = parseInt(cssEscape.slice(first.length), 16);\n\
            return String.fromCodePoint ? String.fromCodePoint(cp) :\n\
                String.fromCharCode(cp);\n\
        }\n\
        return cssEscape + c;\n\
    },\n\
\n\
    readComment: function(first) {\n\
        var reader  = this._reader,\n\
            comment = first || \"\",\n\
            c       = reader.read();\n\
\n\
        if (c === \"*\") {\n\
            while (c) {\n\
                comment += c;\n\
\n\
                //look for end of comment\n\
                if (comment.length > 2 && c === \"*\" && reader.peek() === \"/\") {\n\
                    comment += reader.read();\n\
                    break;\n\
                }\n\
\n\
                c = reader.read();\n\
            }\n\
\n\
            return comment;\n\
        } else {\n\
            return \"\";\n\
        }\n\
    }\n\
});\n\
},{\"../util/TokenStreamBase\":27,\"./PropertyValuePart\":11,\"./Tokens\":18}],18:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
var Tokens = module.exports = [\n\
\n\
    /*\n\
     * The following token names are defined in CSS3 Grammar: https://www.w3.org/TR/css3-syntax/#lexical\n\
     */\n\
\n\
    // HTML-style comments\n\
    { name: \"CDO\" },\n\
    { name: \"CDC\" },\n\
\n\
    // ignorables\n\
    { name: \"S\", whitespace: true/*, channel: \"ws\"*/ },\n\
    { name: \"COMMENT\", comment: true, hide: true, channel: \"comment\" },\n\
\n\
    // attribute equality\n\
    { name: \"INCLUDES\", text: \"~=\" },\n\
    { name: \"DASHMATCH\", text: \"|=\" },\n\
    { name: \"PREFIXMATCH\", text: \"^=\" },\n\
    { name: \"SUFFIXMATCH\", text: \"$=\" },\n\
    { name: \"SUBSTRINGMATCH\", text: \"*=\" },\n\
\n\
    // identifier types\n\
    { name: \"STRING\" },\n\
    { name: \"IDENT\" },\n\
    { name: \"HASH\" },\n\
\n\
    // at-keywords\n\
    { name: \"IMPORT_SYM\", text: \"@import\" },\n\
    { name: \"PAGE_SYM\", text: \"@page\" },\n\
    { name: \"MEDIA_SYM\", text: \"@media\" },\n\
    { name: \"FONT_FACE_SYM\", text: \"@font-face\" },\n\
    { name: \"CHARSET_SYM\", text: \"@charset\" },\n\
    { name: \"NAMESPACE_SYM\", text: \"@namespace\" },\n\
    { name: \"SUPPORTS_SYM\", text: \"@supports\" },\n\
    { name: \"VIEWPORT_SYM\", text: [\"@viewport\", \"@-ms-viewport\", \"@-o-viewport\"] },\n\
    { name: \"DOCUMENT_SYM\", text: [\"@document\", \"@-moz-document\"] },\n\
    { name: \"UNKNOWN_SYM\" },\n\
    //{ name: \"ATKEYWORD\"},\n\
\n\
    // CSS3 animations\n\
    { name: \"KEYFRAMES_SYM\", text: [ \"@keyframes\", \"@-webkit-keyframes\", \"@-moz-keyframes\", \"@-o-keyframes\" ] },\n\
\n\
    // important symbol\n\
    { name: \"IMPORTANT_SYM\" },\n\
\n\
    // measurements\n\
    { name: \"LENGTH\" },\n\
    { name: \"ANGLE\" },\n\
    { name: \"TIME\" },\n\
    { name: \"FREQ\" },\n\
    { name: \"DIMENSION\" },\n\
    { name: \"PERCENTAGE\" },\n\
    { name: \"NUMBER\" },\n\
\n\
    // functions\n\
    { name: \"URI\" },\n\
    { name: \"FUNCTION\" },\n\
\n\
    // Unicode ranges\n\
    { name: \"UNICODE_RANGE\" },\n\
\n\
    /*\n\
     * The following token names are defined in CSS3 Selectors: https://www.w3.org/TR/css3-selectors/#selector-syntax\n\
     */\n\
\n\
    // invalid string\n\
    { name: \"INVALID\" },\n\
\n\
    // combinators\n\
    { name: \"PLUS\", text: \"+\" },\n\
    { name: \"GREATER\", text: \">\" },\n\
    { name: \"COMMA\", text: \",\" },\n\
    { name: \"TILDE\", text: \"~\" },\n\
\n\
    // modifier\n\
    { name: \"NOT\" },\n\
\n\
    /*\n\
     * Defined in CSS3 Paged Media\n\
     */\n\
    { name: \"TOPLEFTCORNER_SYM\", text: \"@top-left-corner\" },\n\
    { name: \"TOPLEFT_SYM\", text: \"@top-left\" },\n\
    { name: \"TOPCENTER_SYM\", text: \"@top-center\" },\n\
    { name: \"TOPRIGHT_SYM\", text: \"@top-right\" },\n\
    { name: \"TOPRIGHTCORNER_SYM\", text: \"@top-right-corner\" },\n\
    { name: \"BOTTOMLEFTCORNER_SYM\", text: \"@bottom-left-corner\" },\n\
    { name: \"BOTTOMLEFT_SYM\", text: \"@bottom-left\" },\n\
    { name: \"BOTTOMCENTER_SYM\", text: \"@bottom-center\" },\n\
    { name: \"BOTTOMRIGHT_SYM\", text: \"@bottom-right\" },\n\
    { name: \"BOTTOMRIGHTCORNER_SYM\", text: \"@bottom-right-corner\" },\n\
    { name: \"LEFTTOP_SYM\", text: \"@left-top\" },\n\
    { name: \"LEFTMIDDLE_SYM\", text: \"@left-middle\" },\n\
    { name: \"LEFTBOTTOM_SYM\", text: \"@left-bottom\" },\n\
    { name: \"RIGHTTOP_SYM\", text: \"@right-top\" },\n\
    { name: \"RIGHTMIDDLE_SYM\", text: \"@right-middle\" },\n\
    { name: \"RIGHTBOTTOM_SYM\", text: \"@right-bottom\" },\n\
\n\
    /*\n\
     * The following token names are defined in CSS3 Media Queries: https://www.w3.org/TR/css3-mediaqueries/#syntax\n\
     */\n\
    /*{ name: \"MEDIA_ONLY\", state: \"media\"},\n\
    { name: \"MEDIA_NOT\", state: \"media\"},\n\
    { name: \"MEDIA_AND\", state: \"media\"},*/\n\
    { name: \"RESOLUTION\", state: \"media\" },\n\
\n\
    /*\n\
     * The following token names are not defined in any CSS specification but are used by the lexer.\n\
     */\n\
\n\
    // not a real token, but useful for stupid IE filters\n\
    { name: \"IE_FUNCTION\" },\n\
\n\
    // part of CSS3 grammar but not the Flex code\n\
    { name: \"CHAR\" },\n\
\n\
    // TODO: Needed?\n\
    // Not defined as tokens, but might as well be\n\
    {\n\
        name: \"PIPE\",\n\
        text: \"|\"\n\
    },\n\
    {\n\
        name: \"SLASH\",\n\
        text: \"/\"\n\
    },\n\
    {\n\
        name: \"MINUS\",\n\
        text: \"-\"\n\
    },\n\
    {\n\
        name: \"STAR\",\n\
        text: \"*\"\n\
    },\n\
\n\
    {\n\
        name: \"LBRACE\",\n\
        endChar: \"}\",\n\
        text: \"{\"\n\
    },\n\
    {\n\
        name: \"RBRACE\",\n\
        text: \"}\"\n\
    },\n\
    {\n\
        name: \"LBRACKET\",\n\
        endChar: \"]\",\n\
        text: \"[\"\n\
    },\n\
    {\n\
        name: \"RBRACKET\",\n\
        text: \"]\"\n\
    },\n\
    {\n\
        name: \"EQUALS\",\n\
        text: \"=\"\n\
    },\n\
    {\n\
        name: \"COLON\",\n\
        text: \":\"\n\
    },\n\
    {\n\
        name: \"SEMICOLON\",\n\
        text: \";\"\n\
    },\n\
    {\n\
        name: \"LPAREN\",\n\
        endChar: \")\",\n\
        text: \"(\"\n\
    },\n\
    {\n\
        name: \"RPAREN\",\n\
        text: \")\"\n\
    },\n\
    {\n\
        name: \"DOT\",\n\
        text: \".\"\n\
    }\n\
];\n\
\n\
(function() {\n\
    var nameMap = [],\n\
        typeMap = Object.create(null);\n\
\n\
    Tokens.UNKNOWN = -1;\n\
    Tokens.unshift({ name:\"EOF\" });\n\
    for (var i=0, len = Tokens.length; i < len; i++) {\n\
        nameMap.push(Tokens[i].name);\n\
        Tokens[Tokens[i].name] = i;\n\
        if (Tokens[i].text) {\n\
            if (Tokens[i].text instanceof Array) {\n\
                for (var j=0; j < Tokens[i].text.length; j++) {\n\
                    typeMap[Tokens[i].text[j]] = i;\n\
                }\n\
            } else {\n\
                typeMap[Tokens[i].text] = i;\n\
            }\n\
        }\n\
    }\n\
\n\
    Tokens.name = function(tt) {\n\
        return nameMap[tt];\n\
    };\n\
\n\
    Tokens.type = function(c) {\n\
        return typeMap[c] || -1;\n\
    };\n\
})();\n\
},{}],19:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
/* exported Validation */\n\
\n\
var Matcher = require(\"./Matcher\");\n\
var Properties = require(\"./Properties\");\n\
var ValidationTypes = require(\"./ValidationTypes\");\n\
var ValidationError = require(\"./ValidationError\");\n\
var PropertyValueIterator = require(\"./PropertyValueIterator\");\n\
\n\
var Validation = module.exports = {\n\
\n\
    validate: function(property, value) {\n\
\n\
        //normalize name\n\
        var name        = property.toString().toLowerCase(),\n\
            expression  = new PropertyValueIterator(value),\n\
            spec        = Properties[name],\n\
            part;\n\
\n\
        if (!spec) {\n\
            if (name.indexOf(\"-\") !== 0) {    //vendor prefixed are ok\n\
                throw new ValidationError(\"Unknown property '\" + property + \"'.\", property.line, property.col);\n\
            }\n\
        } else if (typeof spec !== \"number\") {\n\
\n\
            // All properties accept some CSS-wide values.\n\
            // https://drafts.csswg.org/css-values-3/#common-keywords\n\
            if (ValidationTypes.isAny(expression, \"inherit | initial | unset\")) {\n\
                if (expression.hasNext()) {\n\
                    part = expression.next();\n\
                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n\
                }\n\
                return;\n\
            }\n\
\n\
            // Property-specific validation.\n\
            this.singleProperty(spec, expression);\n\
        }\n\
    },\n\
\n\
    singleProperty: function(types, expression) {\n\
\n\
        var result      = false,\n\
            value       = expression.value,\n\
            part;\n\
\n\
        result = Matcher.parse(types).match(expression);\n\
\n\
        if (!result) {\n\
            if (expression.hasNext() && !expression.isFirst()) {\n\
                part = expression.peek();\n\
                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n\
            } else {\n\
                throw new ValidationError(\"Expected (\" + ValidationTypes.describe(types) + \") but found '\" + value + \"'.\", value.line, value.col);\n\
            }\n\
        } else if (expression.hasNext()) {\n\
            part = expression.next();\n\
            throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n\
        }\n\
    }\n\
};\n\
},{\"./Matcher\":3,\"./Properties\":7,\"./PropertyValueIterator\":10,\"./ValidationError\":20,\"./ValidationTypes\":21}],20:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = ValidationError;\n\
\n\
/**\n\
 * Type to use when a validation error occurs.\n\
 * @class ValidationError\n\
 * @namespace parserlib.util\n\
 * @constructor\n\
 * @param {String} message The error message.\n\
 * @param {int} line The line at which the error occurred.\n\
 * @param {int} col The column at which the error occurred.\n\
 */\n\
function ValidationError(message, line, col) {\n\
\n\
    /**\n\
     * The column at which the error occurred.\n\
     * @type int\n\
     * @property col\n\
     */\n\
    this.col = col;\n\
\n\
    /**\n\
     * The line at which the error occurred.\n\
     * @type int\n\
     * @property line\n\
     */\n\
    this.line = line;\n\
\n\
    /**\n\
     * The text representation of the unit.\n\
     * @type String\n\
     * @property text\n\
     */\n\
    this.message = message;\n\
}\n\
\n\
//inherit from Error\n\
ValidationError.prototype = new Error();\n\
},{}],21:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
var ValidationTypes = module.exports;\n\
\n\
var Matcher = require(\"./Matcher\");\n\
\n\
function copy(to, from) {\n\
    Object.keys(from).forEach(function(prop) {\n\
        to[prop] = from[prop];\n\
    });\n\
}\n\
copy(ValidationTypes, {\n\
\n\
    isLiteral: function (part, literals) {\n\
        var text = part.text.toString().toLowerCase(),\n\
            args = literals.split(\" | \"),\n\
            i, len, found = false;\n\
\n\
        for (i=0, len=args.length; i < len && !found; i++) {\n\
            if (args[i].charAt(0) === \"<\") {\n\
                found = this.simple[args[i]](part);\n\
            } else if (args[i].slice(-2) === \"()\") {\n\
                found = (part.type === \"function\" &&\n\
                         part.name === args[i].slice(0, -2));\n\
            } else if (text === args[i].toLowerCase()) {\n\
                found = true;\n\
            }\n\
        }\n\
\n\
        return found;\n\
    },\n\
\n\
    isSimple: function(type) {\n\
        return Boolean(this.simple[type]);\n\
    },\n\
\n\
    isComplex: function(type) {\n\
        return Boolean(this.complex[type]);\n\
    },\n\
\n\
    describe: function(type) {\n\
        if (this.complex[type] instanceof Matcher) {\n\
            return this.complex[type].toString(0);\n\
        }\n\
        return type;\n\
    },\n\
\n\
    /**\n\
     * Determines if the next part(s) of the given expression\n\
     * are any of the given types.\n\
     */\n\
    isAny: function (expression, types) {\n\
        var args = types.split(\" | \"),\n\
            i, len, found = false;\n\
\n\
        for (i=0, len=args.length; i < len && !found && expression.hasNext(); i++) {\n\
            found = this.isType(expression, args[i]);\n\
        }\n\
\n\
        return found;\n\
    },\n\
\n\
    /**\n\
     * Determines if the next part(s) of the given expression\n\
     * are one of a group.\n\
     */\n\
    isAnyOfGroup: function(expression, types) {\n\
        var args = types.split(\" || \"),\n\
            i, len, found = false;\n\
\n\
        for (i=0, len=args.length; i < len && !found; i++) {\n\
            found = this.isType(expression, args[i]);\n\
        }\n\
\n\
        return found ? args[i-1] : false;\n\
    },\n\
\n\
    /**\n\
     * Determines if the next part(s) of the given expression\n\
     * are of a given type.\n\
     */\n\
    isType: function (expression, type) {\n\
        var part = expression.peek(),\n\
            result = false;\n\
\n\
        if (type.charAt(0) !== \"<\") {\n\
            result = this.isLiteral(part, type);\n\
            if (result) {\n\
                expression.next();\n\
            }\n\
        } else if (this.simple[type]) {\n\
            result = this.simple[type](part);\n\
            if (result) {\n\
                expression.next();\n\
            }\n\
        } else if (this.complex[type] instanceof Matcher) {\n\
            result = this.complex[type].match(expression);\n\
        } else {\n\
            result = this.complex[type](expression);\n\
        }\n\
\n\
        return result;\n\
    },\n\
\n\
\n\
    simple: {\n\
        __proto__: null,\n\
\n\
        \"<absolute-size>\":\n\
            \"xx-small | x-small | small | medium | large | x-large | xx-large\",\n\
\n\
        \"<animateable-feature>\":\n\
            \"scroll-position | contents | <animateable-feature-name>\",\n\
\n\
        \"<animateable-feature-name>\": function(part) {\n\
            return this[\"<ident>\"](part) &&\n\
                !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);\n\
        },\n\
\n\
        \"<angle>\": function(part) {\n\
            return part.type === \"angle\";\n\
        },\n\
\n\
        \"<attachment>\": \"scroll | fixed | local\",\n\
\n\
        \"<attr>\": \"attr()\",\n\
\n\
        // inset() = inset( <shape-arg>{1,4} [round <border-radius>]? )\n\
        // circle() = circle( [<shape-radius>]? [at <position>]? )\n\
        // ellipse() = ellipse( [<shape-radius>{2}]? [at <position>]? )\n\
        // polygon() = polygon( [<fill-rule>,]? [<shape-arg> <shape-arg>]# )\n\
        \"<basic-shape>\": \"inset() | circle() | ellipse() | polygon()\",\n\
\n\
        \"<bg-image>\": \"<image> | <gradient> | none\",\n\
\n\
        \"<border-style>\":\n\
            \"none | hidden | dotted | dashed | solid | double | groove | \" +\n\
            \"ridge | inset | outset\",\n\
\n\
        \"<border-width>\": \"<length> | thin | medium | thick\",\n\
\n\
        \"<box>\": \"padding-box | border-box | content-box\",\n\
\n\
        \"<clip-source>\": \"<uri>\",\n\
\n\
        \"<color>\": function(part) {\n\
            return part.type === \"color\" || String(part) === \"transparent\" || String(part) === \"currentColor\";\n\
        },\n\
\n\
        // The SVG <color> spec doesn't include \"currentColor\" or \"transparent\" as a color.\n\
        \"<color-svg>\": function(part) {\n\
            return part.type === \"color\";\n\
        },\n\
\n\
        \"<content>\": \"content()\",\n\
\n\
        // https://www.w3.org/TR/css3-sizing/#width-height-keywords\n\
        \"<content-sizing>\":\n\
            \"fill-available | -moz-available | -webkit-fill-available | \" +\n\
            \"max-content | -moz-max-content | -webkit-max-content | \" +\n\
            \"min-content | -moz-min-content | -webkit-min-content | \" +\n\
            \"fit-content | -moz-fit-content | -webkit-fit-content\",\n\
\n\
        \"<feature-tag-value>\": function(part) {\n\
            return part.type === \"function\" && /^[A-Z0-9]{4}$/i.test(part);\n\
        },\n\
\n\
        // custom() isn't actually in the spec\n\
        \"<filter-function>\":\n\
            \"blur() | brightness() | contrast() | custom() | \" +\n\
            \"drop-shadow() | grayscale() | hue-rotate() | invert() | \" +\n\
            \"opacity() | saturate() | sepia()\",\n\
\n\
        \"<flex-basis>\": \"<width>\",\n\
\n\
        \"<flex-direction>\": \"row | row-reverse | column | column-reverse\",\n\
\n\
        \"<flex-grow>\": \"<number>\",\n\
\n\
        \"<flex-shrink>\": \"<number>\",\n\
\n\
        \"<flex-wrap>\": \"nowrap | wrap | wrap-reverse\",\n\
\n\
        \"<font-size>\":\n\
            \"<absolute-size> | <relative-size> | <length> | <percentage>\",\n\
\n\
        \"<font-stretch>\":\n\
            \"normal | ultra-condensed | extra-condensed | condensed | \" +\n\
            \"semi-condensed | semi-expanded | expanded | extra-expanded | \" +\n\
            \"ultra-expanded\",\n\
\n\
        \"<font-style>\": \"normal | italic | oblique\",\n\
\n\
        \"<font-variant-caps>\":\n\
            \"small-caps | all-small-caps | petite-caps | all-petite-caps | \" +\n\
            \"unicase | titling-caps\",\n\
\n\
        \"<font-variant-css21>\": \"normal | small-caps\",\n\
\n\
        \"<font-weight>\":\n\
            \"normal | bold | bolder | lighter | \" +\n\
            \"100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\",\n\
\n\
        \"<generic-family>\":\n\
            \"serif | sans-serif | cursive | fantasy | monospace\",\n\
\n\
        \"<geometry-box>\": \"<shape-box> | fill-box | stroke-box | view-box\",\n\
\n\
        \"<glyph-angle>\": function(part) {\n\
            return part.type === \"angle\" && part.units === \"deg\";\n\
        },\n\
\n\
        \"<gradient>\": function(part) {\n\
            return part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part);\n\
        },\n\
\n\
        \"<icccolor>\":\n\
            \"cielab() | cielch() | cielchab() | \" +\n\
            \"icc-color() | icc-named-color()\",\n\
\n\
        //any identifier\n\
        \"<ident>\": function(part) {\n\
            return part.type === \"identifier\" || part.wasIdent;\n\
        },\n\
\n\
        \"<ident-not-generic-family>\": function(part) {\n\
            return this[\"<ident>\"](part) && !this[\"<generic-family>\"](part);\n\
        },\n\
\n\
        \"<image>\": \"<uri>\",\n\
\n\
        \"<integer>\": function(part) {\n\
            return part.type === \"integer\";\n\
        },\n\
\n\
        \"<length>\": function(part) {\n\
            if (part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)) {\n\
                return true;\n\
            } else {\n\
                return part.type === \"length\" || part.type === \"number\" || part.type === \"integer\" || String(part) === \"0\";\n\
            }\n\
        },\n\
\n\
        \"<line>\": function(part) {\n\
            return part.type === \"integer\";\n\
        },\n\
\n\
        \"<line-height>\": \"<number> | <length> | <percentage> | normal\",\n\
\n\
        \"<margin-width>\": \"<length> | <percentage> | auto\",\n\
\n\
        \"<miterlimit>\": function(part) {\n\
            return this[\"<number>\"](part) && part.value >= 1;\n\
        },\n\
\n\
        \"<nonnegative-length-or-percentage>\": function(part) {\n\
            return (this[\"<length>\"](part) || this[\"<percentage>\"](part)) &&\n\
                (String(part) === \"0\" || part.type === \"function\" || (part.value) >= 0);\n\
        },\n\
\n\
        \"<nonnegative-number-or-percentage>\": function(part) {\n\
            return (this[\"<number>\"](part) || this[\"<percentage>\"](part)) &&\n\
                (String(part) === \"0\" || part.type === \"function\" || (part.value) >= 0);\n\
        },\n\
\n\
        \"<number>\": function(part) {\n\
            return part.type === \"number\" || this[\"<integer>\"](part);\n\
        },\n\
\n\
        \"<opacity-value>\": function(part) {\n\
            return this[\"<number>\"](part) && part.value >= 0 && part.value <= 1;\n\
        },\n\
\n\
        \"<padding-width>\": \"<nonnegative-length-or-percentage>\",\n\
\n\
        \"<percentage>\": function(part) {\n\
            return part.type === \"percentage\" || String(part) === \"0\";\n\
        },\n\
\n\
        \"<relative-size>\": \"smaller | larger\",\n\
\n\
        \"<shape>\": \"rect() | inset-rect()\",\n\
\n\
        \"<shape-box>\": \"<box> | margin-box\",\n\
\n\
        \"<single-animation-direction>\":\n\
            \"normal | reverse | alternate | alternate-reverse\",\n\
\n\
        \"<single-animation-name>\": function(part) {\n\
            return this[\"<ident>\"](part) &&\n\
                /^-?[a-z_][-a-z0-9_]+$/i.test(part) &&\n\
                !/^(none|unset|initial|inherit)$/i.test(part);\n\
        },\n\
\n\
        \"<string>\": function(part) {\n\
            return part.type === \"string\";\n\
        },\n\
\n\
        \"<time>\": function(part) {\n\
            return part.type === \"time\";\n\
        },\n\
\n\
        \"<uri>\": function(part) {\n\
            return part.type === \"uri\";\n\
        },\n\
\n\
        \"<width>\": \"<margin-width>\"\n\
    },\n\
\n\
    complex: {\n\
        __proto__: null,\n\
\n\
        \"<azimuth>\":\n\
            \"<angle>\" +\n\
            \" | \" +\n\
            \"[ [ left-side | far-left | left | center-left | center | \" +\n\
            \"center-right | right | far-right | right-side ] || behind ]\" +\n\
            \" | \"+\n\
            \"leftwards | rightwards\",\n\
\n\
        \"<bg-position>\": \"<position>#\",\n\
\n\
        \"<bg-size>\":\n\
            \"[ <length> | <percentage> | auto ]{1,2} | cover | contain\",\n\
\n\
        \"<border-image-slice>\":\n\
        // [<number> | <percentage>]{1,4} && fill?\n\
        // *but* fill can appear between any of the numbers\n\
        Matcher.many([true /* first element is required */],\n\
                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\n\
                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\n\
                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\n\
                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\n\
                     \"fill\"),\n\
\n\
        \"<border-radius>\":\n\
            \"<nonnegative-length-or-percentage>{1,4} \" +\n\
            \"[ / <nonnegative-length-or-percentage>{1,4} ]?\",\n\
\n\
        \"<box-shadow>\": \"none | <shadow>#\",\n\
\n\
        \"<clip-path>\": \"<basic-shape> || <geometry-box>\",\n\
\n\
        \"<dasharray>\":\n\
        // \"list of comma and/or white space separated <length>s and\n\
        // <percentage>s\".  There is a non-negative constraint.\n\
        Matcher.cast(\"<nonnegative-length-or-percentage>\")\n\
            .braces(1, Infinity, \"#\", Matcher.cast(\",\").question()),\n\
\n\
        \"<family-name>\":\n\
            // <string> | <IDENT>+\n\
            \"<string> | <ident-not-generic-family> <ident>*\",\n\
\n\
        \"<filter-function-list>\": \"[ <filter-function> | <uri> ]+\",\n\
\n\
        // https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property\n\
        \"<flex>\":\n\
            \"none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]\",\n\
\n\
        \"<font-family>\": \"[ <generic-family> | <family-name> ]#\",\n\
\n\
        \"<font-shorthand>\":\n\
            \"[ <font-style> || <font-variant-css21> || \" +\n\
            \"<font-weight> || <font-stretch> ]? <font-size> \" +\n\
            \"[ / <line-height> ]? <font-family>\",\n\
\n\
        \"<font-variant-alternates>\":\n\
            // stylistic(<feature-value-name>)\n\
            \"stylistic() || \" +\n\
            \"historical-forms || \" +\n\
            // styleset(<feature-value-name> #)\n\
            \"styleset() || \" +\n\
            // character-variant(<feature-value-name> #)\n\
            \"character-variant() || \" +\n\
            // swash(<feature-value-name>)\n\
            \"swash() || \" +\n\
            // ornaments(<feature-value-name>)\n\
            \"ornaments() || \" +\n\
            // annotation(<feature-value-name>)\n\
            \"annotation()\",\n\
\n\
        \"<font-variant-ligatures>\":\n\
            // <common-lig-values>\n\
            \"[ common-ligatures | no-common-ligatures ] || \" +\n\
            // <discretionary-lig-values>\n\
            \"[ discretionary-ligatures | no-discretionary-ligatures ] || \" +\n\
            // <historical-lig-values>\n\
            \"[ historical-ligatures | no-historical-ligatures ] || \" +\n\
            // <contextual-alt-values>\n\
            \"[ contextual | no-contextual ]\",\n\
\n\
        \"<font-variant-numeric>\":\n\
            // <numeric-figure-values>\n\
            \"[ lining-nums | oldstyle-nums ] || \" +\n\
            // <numeric-spacing-values>\n\
            \"[ proportional-nums | tabular-nums ] || \" +\n\
            // <numeric-fraction-values>\n\
            \"[ diagonal-fractions | stacked-fractions ] || \" +\n\
            \"ordinal || slashed-zero\",\n\
\n\
        \"<font-variant-east-asian>\":\n\
            // <east-asian-variant-values>\n\
            \"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || \" +\n\
            // <east-asian-width-values>\n\
            \"[ full-width | proportional-width ] || \" +\n\
            \"ruby\",\n\
\n\
        // Note that <color> here is \"as defined in the SVG spec\", which\n\
        // is more restrictive that the <color> defined in the CSS spec.\n\
        // none | currentColor | <color> [<icccolor>]? |\n\
        // <funciri> [ none | currentColor | <color> [<icccolor>]? ]?\n\
        \"<paint>\": \"<paint-basic> | <uri> <paint-basic>?\",\n\
\n\
        // Helper definition for <paint> above.\n\
        \"<paint-basic>\": \"none | currentColor | <color-svg> <icccolor>?\",\n\
\n\
        \"<position>\":\n\
            // Because our `alt` combinator is ordered, we need to test these\n\
            // in order from longest possible match to shortest.\n\
            \"[ center | [ left | right ] [ <percentage> | <length> ]? ] && \" +\n\
            \"[ center | [ top | bottom ] [ <percentage> | <length> ]? ]\" +\n\
            \" | \" +\n\
            \"[ left | center | right | <percentage> | <length> ] \" +\n\
            \"[ top | center | bottom | <percentage> | <length> ]\" +\n\
            \" | \" +\n\
            \"[ left | center | right | top | bottom | <percentage> | <length> ]\",\n\
\n\
        \"<repeat-style>\":\n\
            \"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}\",\n\
\n\
        \"<shadow>\":\n\
        //inset? && [ <length>{2,4} && <color>? ]\n\
        Matcher.many([true /* length is required */],\n\
                     Matcher.cast(\"<length>\").braces(2, 4), \"inset\", \"<color>\"),\n\
\n\
        \"<text-decoration-color>\":\n\
           \"<color>\",\n\
\n\
        \"<text-decoration-line>\":\n\
            \"none | [ underline || overline || line-through || blink ]\",\n\
\n\
        \"<text-decoration-style>\":\n\
            \"solid | double | dotted | dashed | wavy\",\n\
\n\
        \"<will-change>\":\n\
            \"auto | <animateable-feature>#\",\n\
\n\
        \"<x-one-radius>\":\n\
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?\n\
            \"[ <length> | <percentage> ]{1,2}\"\n\
    }\n\
});\n\
\n\
Object.keys(ValidationTypes.simple).forEach(function(nt) {\n\
    var rule = ValidationTypes.simple[nt];\n\
    if (typeof rule === \"string\") {\n\
        ValidationTypes.simple[nt] = function(part) {\n\
            return ValidationTypes.isLiteral(part, rule);\n\
        };\n\
    }\n\
});\n\
\n\
Object.keys(ValidationTypes.complex).forEach(function(nt) {\n\
    var rule = ValidationTypes.complex[nt];\n\
    if (typeof rule === \"string\") {\n\
        ValidationTypes.complex[nt] = Matcher.parse(rule);\n\
    }\n\
});\n\
\n\
// Because this is defined relative to other complex validation types,\n\
// we need to define it *after* the rest of the types are initialized.\n\
ValidationTypes.complex[\"<font-variant>\"] =\n\
    Matcher.oror({ expand: \"<font-variant-ligatures>\" },\n\
                 { expand: \"<font-variant-alternates>\" },\n\
                 \"<font-variant-caps>\",\n\
                 { expand: \"<font-variant-numeric>\" },\n\
                 { expand: \"<font-variant-east-asian>\" });\n\
},{\"./Matcher\":3}],22:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = {\n\
    Colors            : require(\"./Colors\"),\n\
    Combinator        : require(\"./Combinator\"),\n\
    Parser            : require(\"./Parser\"),\n\
    PropertyName      : require(\"./PropertyName\"),\n\
    PropertyValue     : require(\"./PropertyValue\"),\n\
    PropertyValuePart : require(\"./PropertyValuePart\"),\n\
    Matcher           : require(\"./Matcher\"),\n\
    MediaFeature      : require(\"./MediaFeature\"),\n\
    MediaQuery        : require(\"./MediaQuery\"),\n\
    Selector          : require(\"./Selector\"),\n\
    SelectorPart      : require(\"./SelectorPart\"),\n\
    SelectorSubPart   : require(\"./SelectorSubPart\"),\n\
    Specificity       : require(\"./Specificity\"),\n\
    TokenStream       : require(\"./TokenStream\"),\n\
    Tokens            : require(\"./Tokens\"),\n\
    ValidationError   : require(\"./ValidationError\")\n\
};\n\
},{\"./Colors\":1,\"./Combinator\":2,\"./Matcher\":3,\"./MediaFeature\":4,\"./MediaQuery\":5,\"./Parser\":6,\"./PropertyName\":8,\"./PropertyValue\":9,\"./PropertyValuePart\":11,\"./Selector\":13,\"./SelectorPart\":14,\"./SelectorSubPart\":15,\"./Specificity\":16,\"./TokenStream\":17,\"./Tokens\":18,\"./ValidationError\":20}],23:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = EventTarget;\n\
\n\
/**\n\
 * A generic base to inherit from for any object\n\
 * that needs event handling.\n\
 * @class EventTarget\n\
 * @constructor\n\
 */\n\
function EventTarget() {\n\
\n\
    /**\n\
     * The array of listeners for various events.\n\
     * @type Object\n\
     * @property _listeners\n\
     * @private\n\
     */\n\
    this._listeners = Object.create(null);\n\
}\n\
\n\
EventTarget.prototype = {\n\
\n\
    //restore constructor\n\
    constructor: EventTarget,\n\
\n\
    /**\n\
     * Adds a listener for a given event type.\n\
     * @param {String} type The type of event to add a listener for.\n\
     * @param {Function} listener The function to call when the event occurs.\n\
     * @return {void}\n\
     * @method addListener\n\
     */\n\
    addListener: function(type, listener) {\n\
        if (!this._listeners[type]) {\n\
            this._listeners[type] = [];\n\
        }\n\
\n\
        this._listeners[type].push(listener);\n\
    },\n\
\n\
    /**\n\
     * Fires an event based on the passed-in object.\n\
     * @param {Object|String} event An object with at least a 'type' attribute\n\
     *      or a string indicating the event name.\n\
     * @return {void}\n\
     * @method fire\n\
     */\n\
    fire: function(event) {\n\
        if (typeof event === \"string\") {\n\
            event = { type: event };\n\
        }\n\
        if (typeof event.target !== \"undefined\") {\n\
            event.target = this;\n\
        }\n\
\n\
        if (typeof event.type === \"undefined\") {\n\
            throw new Error(\"Event object missing 'type' property.\");\n\
        }\n\
\n\
        if (this._listeners[event.type]) {\n\
\n\
            //create a copy of the array and use that so listeners can't chane\n\
            var listeners = this._listeners[event.type].concat();\n\
            for (var i=0, len=listeners.length; i < len; i++) {\n\
                listeners[i].call(this, event);\n\
            }\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Removes a listener for a given event type.\n\
     * @param {String} type The type of event to remove a listener from.\n\
     * @param {Function} listener The function to remove from the event.\n\
     * @return {void}\n\
     * @method removeListener\n\
     */\n\
    removeListener: function(type, listener) {\n\
        if (this._listeners[type]) {\n\
            var listeners = this._listeners[type];\n\
            for (var i=0, len=listeners.length; i < len; i++) {\n\
                if (listeners[i] === listener) {\n\
                    listeners.splice(i, 1);\n\
                    break;\n\
                }\n\
            }\n\
        }\n\
    }\n\
};\n\
},{}],24:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = StringReader;\n\
\n\
/**\n\
 * Convenient way to read through strings.\n\
 * @namespace parserlib.util\n\
 * @class StringReader\n\
 * @constructor\n\
 * @param {String} text The text to read.\n\
 */\n\
function StringReader(text) {\n\
\n\
    /**\n\
     * The input text with line endings normalized.\n\
     * @property _input\n\
     * @type String\n\
     * @private\n\
     */\n\
    this._input = text.replace(/(\\r\\n?|\\n)/g, \"\\n\");\n\
\n\
\n\
    /**\n\
     * The row for the character to be read next.\n\
     * @property _line\n\
     * @type int\n\
     * @private\n\
     */\n\
    this._line = 1;\n\
\n\
\n\
    /**\n\
     * The column for the character to be read next.\n\
     * @property _col\n\
     * @type int\n\
     * @private\n\
     */\n\
    this._col = 1;\n\
\n\
    /**\n\
     * The index of the character in the input to be read next.\n\
     * @property _cursor\n\
     * @type int\n\
     * @private\n\
     */\n\
    this._cursor = 0;\n\
}\n\
\n\
StringReader.prototype = {\n\
\n\
    // restore constructor\n\
    constructor: StringReader,\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Position info\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Returns the column of the character to be read next.\n\
     * @return {int} The column of the character to be read next.\n\
     * @method getCol\n\
     */\n\
    getCol: function() {\n\
        return this._col;\n\
    },\n\
\n\
    /**\n\
     * Returns the row of the character to be read next.\n\
     * @return {int} The row of the character to be read next.\n\
     * @method getLine\n\
     */\n\
    getLine: function() {\n\
        return this._line;\n\
    },\n\
\n\
    /**\n\
     * Determines if you're at the end of the input.\n\
     * @return {Boolean} True if there's no more input, false otherwise.\n\
     * @method eof\n\
     */\n\
    eof: function() {\n\
        return this._cursor === this._input.length;\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Basic reading\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Reads the next character without advancing the cursor.\n\
     * @param {int} count How many characters to look ahead (default is 1).\n\
     * @return {String} The next character or null if there is no next character.\n\
     * @method peek\n\
     */\n\
    peek: function(count) {\n\
        var c = null;\n\
        count = typeof count === \"undefined\" ? 1 : count;\n\
\n\
        // if we're not at the end of the input...\n\
        if (this._cursor < this._input.length) {\n\
\n\
            // get character and increment cursor and column\n\
            c = this._input.charAt(this._cursor + count - 1);\n\
        }\n\
\n\
        return c;\n\
    },\n\
\n\
    /**\n\
     * Reads the next character from the input and adjusts the row and column\n\
     * accordingly.\n\
     * @return {String} The next character or null if there is no next character.\n\
     * @method read\n\
     */\n\
    read: function() {\n\
        var c = null;\n\
\n\
        // if we're not at the end of the input...\n\
        if (this._cursor < this._input.length) {\n\
\n\
            // if the last character was a newline, increment row count\n\
            // and reset column count\n\
            if (this._input.charAt(this._cursor) === \"\\n\") {\n\
                this._line++;\n\
                this._col=1;\n\
            } else {\n\
                this._col++;\n\
            }\n\
\n\
            // get character and increment cursor and column\n\
            c = this._input.charAt(this._cursor++);\n\
        }\n\
\n\
        return c;\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Misc\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Saves the current location so it can be returned to later.\n\
     * @method mark\n\
     * @return {void}\n\
     */\n\
    mark: function() {\n\
        this._bookmark = {\n\
            cursor: this._cursor,\n\
            line:   this._line,\n\
            col:    this._col\n\
        };\n\
    },\n\
\n\
    reset: function() {\n\
        if (this._bookmark) {\n\
            this._cursor = this._bookmark.cursor;\n\
            this._line = this._bookmark.line;\n\
            this._col = this._bookmark.col;\n\
            delete this._bookmark;\n\
        }\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Advanced reading\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Reads up to and including the given string. Throws an error if that\n\
     * string is not found.\n\
     * @param {String} pattern The string to read.\n\
     * @return {String} The string when it is found.\n\
     * @throws Error when the string pattern is not found.\n\
     * @method readTo\n\
     */\n\
    readTo: function(pattern) {\n\
\n\
        var buffer = \"\",\n\
            c;\n\
\n\
        /*\n\
         * First, buffer must be the same length as the pattern.\n\
         * Then, buffer must end with the pattern or else reach the\n\
         * end of the input.\n\
         */\n\
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {\n\
            c = this.read();\n\
            if (c) {\n\
                buffer += c;\n\
            } else {\n\
                throw new Error(\"Expected \\\"\" + pattern + \"\\\" at line \" + this._line  + \", col \" + this._col + \".\");\n\
            }\n\
        }\n\
\n\
        return buffer;\n\
    },\n\
\n\
    /**\n\
     * Reads characters while each character causes the given\n\
     * filter function to return true. The function is passed\n\
     * in each character and either returns true to continue\n\
     * reading or false to stop.\n\
     * @param {Function} filter The function to read on each character.\n\
     * @return {String} The string made up of all characters that passed the\n\
     *      filter check.\n\
     * @method readWhile\n\
     */\n\
    readWhile: function(filter) {\n\
\n\
        var buffer = \"\",\n\
            c = this.peek();\n\
\n\
        while (c !== null && filter(c)) {\n\
            buffer += this.read();\n\
            c = this.peek();\n\
        }\n\
\n\
        return buffer;\n\
    },\n\
\n\
    /**\n\
     * Reads characters that match either text or a regular expression and\n\
     * returns those characters. If a match is found, the row and column\n\
     * are adjusted; if no match is found, the reader's state is unchanged.\n\
     * reading or false to stop.\n\
     * @param {String|RegExp} matcher If a string, then the literal string\n\
     *      value is searched for. If a regular expression, then any string\n\
     *      matching the pattern is search for.\n\
     * @return {String} The string made up of all characters that matched or\n\
     *      null if there was no match.\n\
     * @method readMatch\n\
     */\n\
    readMatch: function(matcher) {\n\
\n\
        var source = this._input.substring(this._cursor),\n\
            value = null;\n\
\n\
        // if it's a string, just do a straight match\n\
        if (typeof matcher === \"string\") {\n\
            if (source.slice(0, matcher.length) === matcher) {\n\
                value = this.readCount(matcher.length);\n\
            }\n\
        } else if (matcher instanceof RegExp) {\n\
            if (matcher.test(source)) {\n\
                value = this.readCount(RegExp.lastMatch.length);\n\
            }\n\
        }\n\
\n\
        return value;\n\
    },\n\
\n\
\n\
    /**\n\
     * Reads a given number of characters. If the end of the input is reached,\n\
     * it reads only the remaining characters and does not throw an error.\n\
     * @param {int} count The number of characters to read.\n\
     * @return {String} The string made up the read characters.\n\
     * @method readCount\n\
     */\n\
    readCount: function(count) {\n\
        var buffer = \"\";\n\
\n\
        while (count--) {\n\
            buffer += this.read();\n\
        }\n\
\n\
        return buffer;\n\
    }\n\
};\n\
},{}],25:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = SyntaxError;\n\
\n\
/**\n\
 * Type to use when a syntax error occurs.\n\
 * @class SyntaxError\n\
 * @namespace parserlib.util\n\
 * @constructor\n\
 * @param {String} message The error message.\n\
 * @param {int} line The line at which the error occurred.\n\
 * @param {int} col The column at which the error occurred.\n\
 */\n\
function SyntaxError(message, line, col) {\n\
    Error.call(this);\n\
    this.name = this.constructor.name;\n\
\n\
    /**\n\
     * The column at which the error occurred.\n\
     * @type int\n\
     * @property col\n\
     */\n\
    this.col = col;\n\
\n\
    /**\n\
     * The line at which the error occurred.\n\
     * @type int\n\
     * @property line\n\
     */\n\
    this.line = line;\n\
\n\
    /**\n\
     * The text representation of the unit.\n\
     * @type String\n\
     * @property text\n\
     */\n\
    this.message = message;\n\
}\n\
\n\
//inherit from Error\n\
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line\n\
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line\n\
},{}],26:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = SyntaxUnit;\n\
\n\
/**\n\
 * Base type to represent a single syntactic unit.\n\
 * @class SyntaxUnit\n\
 * @namespace parserlib.util\n\
 * @constructor\n\
 * @param {String} text The text of the unit.\n\
 * @param {int} line The line of text on which the unit resides.\n\
 * @param {int} col The column of text on which the unit resides.\n\
 */\n\
function SyntaxUnit(text, line, col, type) {\n\
\n\
\n\
    /**\n\
     * The column of text on which the unit resides.\n\
     * @type int\n\
     * @property col\n\
     */\n\
    this.col = col;\n\
\n\
    /**\n\
     * The line of text on which the unit resides.\n\
     * @type int\n\
     * @property line\n\
     */\n\
    this.line = line;\n\
\n\
    /**\n\
     * The text representation of the unit.\n\
     * @type String\n\
     * @property text\n\
     */\n\
    this.text = text;\n\
\n\
    /**\n\
     * The type of syntax unit.\n\
     * @type int\n\
     * @property type\n\
     */\n\
    this.type = type;\n\
}\n\
\n\
/**\n\
 * Create a new syntax unit based solely on the given token.\n\
 * Convenience method for creating a new syntax unit when\n\
 * it represents a single token instead of multiple.\n\
 * @param {Object} token The token object to represent.\n\
 * @return {parserlib.util.SyntaxUnit} The object representing the token.\n\
 * @static\n\
 * @method fromToken\n\
 */\n\
SyntaxUnit.fromToken = function(token) {\n\
    return new SyntaxUnit(token.value, token.startLine, token.startCol);\n\
};\n\
\n\
SyntaxUnit.prototype = {\n\
\n\
    //restore constructor\n\
    constructor: SyntaxUnit,\n\
\n\
    /**\n\
     * Returns the text representation of the unit.\n\
     * @return {String} The text representation of the unit.\n\
     * @method valueOf\n\
     */\n\
    valueOf: function() {\n\
        return this.toString();\n\
    },\n\
\n\
    /**\n\
     * Returns the text representation of the unit.\n\
     * @return {String} The text representation of the unit.\n\
     * @method toString\n\
     */\n\
    toString: function() {\n\
        return this.text;\n\
    }\n\
};\n\
},{}],27:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = TokenStreamBase;\n\
\n\
var StringReader = require(\"./StringReader\");\n\
var SyntaxError = require(\"./SyntaxError\");\n\
\n\
/**\n\
 * Generic TokenStream providing base functionality.\n\
 * @class TokenStreamBase\n\
 * @namespace parserlib.util\n\
 * @constructor\n\
 * @param {String|StringReader} input The text to tokenize or a reader from\n\
 *      which to read the input.\n\
 */\n\
function TokenStreamBase(input, tokenData) {\n\
\n\
    /**\n\
     * The string reader for easy access to the text.\n\
     * @type StringReader\n\
     * @property _reader\n\
     * @private\n\
     */\n\
    this._reader = new StringReader(input ? input.toString() : \"\");\n\
\n\
    /**\n\
     * Token object for the last consumed token.\n\
     * @type Token\n\
     * @property _token\n\
     * @private\n\
     */\n\
    this._token = null;\n\
\n\
    /**\n\
     * The array of token information.\n\
     * @type Array\n\
     * @property _tokenData\n\
     * @private\n\
     */\n\
    this._tokenData = tokenData;\n\
\n\
    /**\n\
     * Lookahead token buffer.\n\
     * @type Array\n\
     * @property _lt\n\
     * @private\n\
     */\n\
    this._lt = [];\n\
\n\
    /**\n\
     * Lookahead token buffer index.\n\
     * @type int\n\
     * @property _ltIndex\n\
     * @private\n\
     */\n\
    this._ltIndex = 0;\n\
\n\
    this._ltIndexCache = [];\n\
}\n\
\n\
/**\n\
 * Accepts an array of token information and outputs\n\
 * an array of token data containing key-value mappings\n\
 * and matching functions that the TokenStream needs.\n\
 * @param {Array} tokens An array of token descriptors.\n\
 * @return {Array} An array of processed token data.\n\
 * @method createTokenData\n\
 * @static\n\
 */\n\
TokenStreamBase.createTokenData = function(tokens) {\n\
\n\
    var nameMap     = [],\n\
        typeMap     = Object.create(null),\n\
        tokenData     = tokens.concat([]),\n\
        i            = 0,\n\
        len            = tokenData.length+1;\n\
\n\
    tokenData.UNKNOWN = -1;\n\
    tokenData.unshift({ name:\"EOF\" });\n\
\n\
    for (; i < len; i++) {\n\
        nameMap.push(tokenData[i].name);\n\
        tokenData[tokenData[i].name] = i;\n\
        if (tokenData[i].text) {\n\
            typeMap[tokenData[i].text] = i;\n\
        }\n\
    }\n\
\n\
    tokenData.name = function(tt) {\n\
        return nameMap[tt];\n\
    };\n\
\n\
    tokenData.type = function(c) {\n\
        return typeMap[c];\n\
    };\n\
\n\
    return tokenData;\n\
};\n\
\n\
TokenStreamBase.prototype = {\n\
\n\
    //restore constructor\n\
    constructor: TokenStreamBase,\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Matching methods\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Determines if the next token matches the given token type.\n\
     * If so, that token is consumed; if not, the token is placed\n\
     * back onto the token stream. You can pass in any number of\n\
     * token types and this will return true if any of the token\n\
     * types is found.\n\
     * @param {int|int[]} tokenTypes Either a single token type or an array of\n\
     *      token types that the next token might be. If an array is passed,\n\
     *      it's assumed that the token can be any of these.\n\
     * @param {variant} channel (Optional) The channel to read from. If not\n\
     *      provided, reads from the default (unnamed) channel.\n\
     * @return {Boolean} True if the token type matches, false if not.\n\
     * @method match\n\
     */\n\
    match: function(tokenTypes, channel) {\n\
\n\
        //always convert to an array, makes things easier\n\
        if (!(tokenTypes instanceof Array)) {\n\
            tokenTypes = [tokenTypes];\n\
        }\n\
\n\
        var tt  = this.get(channel),\n\
            i   = 0,\n\
            len = tokenTypes.length;\n\
\n\
        while (i < len) {\n\
            if (tt === tokenTypes[i++]) {\n\
                return true;\n\
            }\n\
        }\n\
\n\
        //no match found, put the token back\n\
        this.unget();\n\
        return false;\n\
    },\n\
\n\
    /**\n\
     * Determines if the next token matches the given token type.\n\
     * If so, that token is consumed; if not, an error is thrown.\n\
     * @param {int|int[]} tokenTypes Either a single token type or an array of\n\
     *      token types that the next token should be. If an array is passed,\n\
     *      it's assumed that the token must be one of these.\n\
     * @return {void}\n\
     * @method mustMatch\n\
     */\n\
    mustMatch: function(tokenTypes) {\n\
\n\
        var token;\n\
\n\
        //always convert to an array, makes things easier\n\
        if (!(tokenTypes instanceof Array)) {\n\
            tokenTypes = [tokenTypes];\n\
        }\n\
\n\
        if (!this.match.apply(this, arguments)) {\n\
            token = this.LT(1);\n\
            throw new SyntaxError(\"Expected \" + this._tokenData[tokenTypes[0]].name +\n\
                \" at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n\
        }\n\
    },\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Consuming methods\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Keeps reading from the token stream until either one of the specified\n\
     * token types is found or until the end of the input is reached.\n\
     * @param {int|int[]} tokenTypes Either a single token type or an array of\n\
     *      token types that the next token should be. If an array is passed,\n\
     *      it's assumed that the token must be one of these.\n\
     * @param {variant} channel (Optional) The channel to read from. If not\n\
     *      provided, reads from the default (unnamed) channel.\n\
     * @return {void}\n\
     * @method advance\n\
     */\n\
    advance: function(tokenTypes, channel) {\n\
\n\
        while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {\n\
            this.get();\n\
        }\n\
\n\
        return this.LA(0);\n\
    },\n\
\n\
    /**\n\
     * Consumes the next token from the token stream.\n\
     * @return {int} The token type of the token that was just consumed.\n\
     * @method get\n\
     */\n\
    get: function(channel) {\n\
\n\
        var tokenInfo   = this._tokenData,\n\
            i           =0,\n\
            token,\n\
            info;\n\
\n\
        //check the lookahead buffer first\n\
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {\n\
\n\
            i++;\n\
            this._token = this._lt[this._ltIndex++];\n\
            info = tokenInfo[this._token.type];\n\
\n\
            //obey channels logic\n\
            while ((info.channel !== undefined && channel !== info.channel) &&\n\
                    this._ltIndex < this._lt.length) {\n\
                this._token = this._lt[this._ltIndex++];\n\
                info = tokenInfo[this._token.type];\n\
                i++;\n\
            }\n\
\n\
            //here be dragons\n\
            if ((info.channel === undefined || channel === info.channel) &&\n\
                    this._ltIndex <= this._lt.length) {\n\
                this._ltIndexCache.push(i);\n\
                return this._token.type;\n\
            }\n\
        }\n\
\n\
        //call token retriever method\n\
        token = this._getToken();\n\
\n\
        //if it should be hidden, don't save a token\n\
        if (token.type > -1 && !tokenInfo[token.type].hide) {\n\
\n\
            //apply token channel\n\
            token.channel = tokenInfo[token.type].channel;\n\
\n\
            //save for later\n\
            this._token = token;\n\
            this._lt.push(token);\n\
\n\
            //save space that will be moved (must be done before array is truncated)\n\
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);\n\
\n\
            //keep the buffer under 5 items\n\
            if (this._lt.length > 5) {\n\
                this._lt.shift();\n\
            }\n\
\n\
            //also keep the shift buffer under 5 items\n\
            if (this._ltIndexCache.length > 5) {\n\
                this._ltIndexCache.shift();\n\
            }\n\
\n\
            //update lookahead index\n\
            this._ltIndex = this._lt.length;\n\
        }\n\
\n\
        /*\n\
         * Skip to the next token if:\n\
         * 1. The token type is marked as hidden.\n\
         * 2. The token type has a channel specified and it isn't the current channel.\n\
         */\n\
        info = tokenInfo[token.type];\n\
        if (info &&\n\
                (info.hide ||\n\
                (info.channel !== undefined && channel !== info.channel))) {\n\
            return this.get(channel);\n\
        } else {\n\
            //return just the type\n\
            return token.type;\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Looks ahead a certain number of tokens and returns the token type at\n\
     * that position. This will throw an error if you lookahead past the\n\
     * end of input, past the size of the lookahead buffer, or back past\n\
     * the first token in the lookahead buffer.\n\
     * @param {int} The index of the token type to retrieve. 0 for the\n\
     *      current token, 1 for the next, -1 for the previous, etc.\n\
     * @return {int} The token type of the token in the given position.\n\
     * @method LA\n\
     */\n\
    LA: function(index) {\n\
        var total = index,\n\
            tt;\n\
        if (index > 0) {\n\
            //TODO: Store 5 somewhere\n\
            if (index > 5) {\n\
                throw new Error(\"Too much lookahead.\");\n\
            }\n\
\n\
            //get all those tokens\n\
            while (total) {\n\
                tt = this.get();\n\
                total--;\n\
            }\n\
\n\
            //unget all those tokens\n\
            while (total < index) {\n\
                this.unget();\n\
                total++;\n\
            }\n\
        } else if (index < 0) {\n\
\n\
            if (this._lt[this._ltIndex+index]) {\n\
                tt = this._lt[this._ltIndex+index].type;\n\
            } else {\n\
                throw new Error(\"Too much lookbehind.\");\n\
            }\n\
        } else {\n\
            tt = this._token.type;\n\
        }\n\
\n\
        return tt;\n\
    },\n\
\n\
    /**\n\
     * Looks ahead a certain number of tokens and returns the token at\n\
     * that position. This will throw an error if you lookahead past the\n\
     * end of input, past the size of the lookahead buffer, or back past\n\
     * the first token in the lookahead buffer.\n\
     * @param {int} The index of the token type to retrieve. 0 for the\n\
     *      current token, 1 for the next, -1 for the previous, etc.\n\
     * @return {Object} The token of the token in the given position.\n\
     * @method LA\n\
     */\n\
    LT: function(index) {\n\
\n\
        //lookahead first to prime the token buffer\n\
        this.LA(index);\n\
\n\
        //now find the token, subtract one because _ltIndex is already at the next index\n\
        return this._lt[this._ltIndex+index-1];\n\
    },\n\
\n\
    /**\n\
     * Returns the token type for the next token in the stream without\n\
     * consuming it.\n\
     * @return {int} The token type of the next token in the stream.\n\
     * @method peek\n\
     */\n\
    peek: function() {\n\
        return this.LA(1);\n\
    },\n\
\n\
    /**\n\
     * Returns the actual token object for the last consumed token.\n\
     * @return {Token} The token object for the last consumed token.\n\
     * @method token\n\
     */\n\
    token: function() {\n\
        return this._token;\n\
    },\n\
\n\
    /**\n\
     * Returns the name of the token for the given token type.\n\
     * @param {int} tokenType The type of token to get the name of.\n\
     * @return {String} The name of the token or \"UNKNOWN_TOKEN\" for any\n\
     *      invalid token type.\n\
     * @method tokenName\n\
     */\n\
    tokenName: function(tokenType) {\n\
        if (tokenType < 0 || tokenType > this._tokenData.length) {\n\
            return \"UNKNOWN_TOKEN\";\n\
        } else {\n\
            return this._tokenData[tokenType].name;\n\
        }\n\
    },\n\
\n\
    /**\n\
     * Returns the token type value for the given token name.\n\
     * @param {String} tokenName The name of the token whose value should be returned.\n\
     * @return {int} The token type value for the given token name or -1\n\
     *      for an unknown token.\n\
     * @method tokenName\n\
     */\n\
    tokenType: function(tokenName) {\n\
        return this._tokenData[tokenName] || -1;\n\
    },\n\
\n\
    /**\n\
     * Returns the last consumed token to the token stream.\n\
     * @method unget\n\
     */\n\
    unget: function() {\n\
        //if (this._ltIndex > -1) {\n\
        if (this._ltIndexCache.length) {\n\
            this._ltIndex -= this._ltIndexCache.pop();//--;\n\
            this._token = this._lt[this._ltIndex - 1];\n\
        } else {\n\
            throw new Error(\"Too much lookahead.\");\n\
        }\n\
    }\n\
};\n\
},{\"./StringReader\":24,\"./SyntaxError\":25}],28:[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = {\n\
    StringReader    : require(\"./StringReader\"),\n\
    SyntaxError     : require(\"./SyntaxError\"),\n\
    SyntaxUnit      : require(\"./SyntaxUnit\"),\n\
    EventTarget     : require(\"./EventTarget\"),\n\
    TokenStreamBase : require(\"./TokenStreamBase\")\n\
};\n\
},{\"./EventTarget\":23,\"./StringReader\":24,\"./SyntaxError\":25,\"./SyntaxUnit\":26,\"./TokenStreamBase\":27}],\"parserlib\":[function(require,module,exports){\n\
\"use strict\";\n\
\n\
module.exports = {\n\
    css  : require(\"./css\"),\n\
    util : require(\"./util\")\n\
};\n\
},{\"./css\":22,\"./util\":28}]},{},[]);\n\
\n\
return require('parserlib');\n\
})();\n\
var clone = (function() {\n\
'use strict';\n\
\n\
function _instanceof(obj, type) {\n\
  return type != null && obj instanceof type;\n\
}\n\
\n\
var nativeMap;\n\
try {\n\
  nativeMap = Map;\n\
} catch(_) {\n\
  // maybe a reference error because no `Map`. Give it a dummy value that no\n\
  // value will ever be an instanceof.\n\
  nativeMap = function() {};\n\
}\n\
\n\
var nativeSet;\n\
try {\n\
  nativeSet = Set;\n\
} catch(_) {\n\
  nativeSet = function() {};\n\
}\n\
\n\
var nativePromise;\n\
try {\n\
  nativePromise = Promise;\n\
} catch(_) {\n\
  nativePromise = function() {};\n\
}\n\
\n\
/**\n\
 * Clones (copies) an Object using deep copying.\n\
 *\n\
 * This function supports circular references by default, but if you are certain\n\
 * there are no circular references in your object, you can save some CPU time\n\
 * by calling clone(obj, false).\n\
 *\n\
 * Caution: if `circular` is false and `parent` contains circular references,\n\
 * your program may enter an infinite loop and crash.\n\
 *\n\
 * @param `parent` - the object to be cloned\n\
 * @param `circular` - set to true if the object to be cloned may contain\n\
 *    circular references. (optional - true by default)\n\
 * @param `depth` - set to a number if the object is only to be cloned to\n\
 *    a particular depth. (optional - defaults to Infinity)\n\
 * @param `prototype` - sets the prototype to be used when cloning an object.\n\
 *    (optional - defaults to parent prototype).\n\
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n\
 *    should be cloned as well. Non-enumerable properties on the prototype\n\
 *    chain will be ignored. (optional - false by default)\n\
*/\n\
function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n\
  if (typeof circular === 'object') {\n\
    depth = circular.depth;\n\
    prototype = circular.prototype;\n\
    includeNonEnumerable = circular.includeNonEnumerable;\n\
    circular = circular.circular;\n\
  }\n\
  // maintain two arrays for circular references, where corresponding parents\n\
  // and children have the same index\n\
  var allParents = [];\n\
  var allChildren = [];\n\
\n\
  var useBuffer = typeof Buffer != 'undefined';\n\
\n\
  if (typeof circular == 'undefined')\n\
    circular = true;\n\
\n\
  if (typeof depth == 'undefined')\n\
    depth = Infinity;\n\
\n\
  // recurse this function so we don't reset allParents and allChildren\n\
  function _clone(parent, depth) {\n\
    // cloning null always returns null\n\
    if (parent === null)\n\
      return null;\n\
\n\
    if (depth === 0)\n\
      return parent;\n\
\n\
    var child;\n\
    var proto;\n\
    if (typeof parent != 'object') {\n\
      return parent;\n\
    }\n\
\n\
    if (_instanceof(parent, nativeMap)) {\n\
      child = new nativeMap();\n\
    } else if (_instanceof(parent, nativeSet)) {\n\
      child = new nativeSet();\n\
    } else if (_instanceof(parent, nativePromise)) {\n\
      child = new nativePromise(function (resolve, reject) {\n\
        parent.then(function(value) {\n\
          resolve(_clone(value, depth - 1));\n\
        }, function(err) {\n\
          reject(_clone(err, depth - 1));\n\
        });\n\
      });\n\
    } else if (clone.__isArray(parent)) {\n\
      child = [];\n\
    } else if (clone.__isRegExp(parent)) {\n\
      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\
    } else if (clone.__isDate(parent)) {\n\
      child = new Date(parent.getTime());\n\
    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\
      child = new Buffer(parent.length);\n\
      parent.copy(child);\n\
      return child;\n\
    } else if (_instanceof(parent, Error)) {\n\
      child = Object.create(parent);\n\
    } else {\n\
      if (typeof prototype == 'undefined') {\n\
        proto = Object.getPrototypeOf(parent);\n\
        child = Object.create(proto);\n\
      }\n\
      else {\n\
        child = Object.create(prototype);\n\
        proto = prototype;\n\
      }\n\
    }\n\
\n\
    if (circular) {\n\
      var index = allParents.indexOf(parent);\n\
\n\
      if (index != -1) {\n\
        return allChildren[index];\n\
      }\n\
      allParents.push(parent);\n\
      allChildren.push(child);\n\
    }\n\
\n\
    if (_instanceof(parent, nativeMap)) {\n\
      parent.forEach(function(value, key) {\n\
        var keyChild = _clone(key, depth - 1);\n\
        var valueChild = _clone(value, depth - 1);\n\
        child.set(keyChild, valueChild);\n\
      });\n\
    }\n\
    if (_instanceof(parent, nativeSet)) {\n\
      parent.forEach(function(value) {\n\
        var entryChild = _clone(value, depth - 1);\n\
        child.add(entryChild);\n\
      });\n\
    }\n\
\n\
    for (var i in parent) {\n\
      var attrs;\n\
      if (proto) {\n\
        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\
      }\n\
\n\
      if (attrs && attrs.set == null) {\n\
        continue;\n\
      }\n\
      child[i] = _clone(parent[i], depth - 1);\n\
    }\n\
\n\
    if (Object.getOwnPropertySymbols) {\n\
      var symbols = Object.getOwnPropertySymbols(parent);\n\
      for (var i = 0; i < symbols.length; i++) {\n\
        // Don't need to worry about cloning a symbol because it is a primitive,\n\
        // like a number or string.\n\
        var symbol = symbols[i];\n\
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n\
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n\
          continue;\n\
        }\n\
        child[symbol] = _clone(parent[symbol], depth - 1);\n\
        if (!descriptor.enumerable) {\n\
          Object.defineProperty(child, symbol, {\n\
            enumerable: false\n\
          });\n\
        }\n\
      }\n\
    }\n\
\n\
    if (includeNonEnumerable) {\n\
      var allPropertyNames = Object.getOwnPropertyNames(parent);\n\
      for (var i = 0; i < allPropertyNames.length; i++) {\n\
        var propertyName = allPropertyNames[i];\n\
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n\
        if (descriptor && descriptor.enumerable) {\n\
          continue;\n\
        }\n\
        child[propertyName] = _clone(parent[propertyName], depth - 1);\n\
        Object.defineProperty(child, propertyName, {\n\
          enumerable: false\n\
        });\n\
      }\n\
    }\n\
\n\
    return child;\n\
  }\n\
\n\
  return _clone(parent, depth);\n\
}\n\
\n\
/**\n\
 * Simple flat clone using prototype, accepts only objects, usefull for property\n\
 * override on FLAT configuration object (no nested props).\n\
 *\n\
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\
 * works.\n\
 */\n\
clone.clonePrototype = function clonePrototype(parent) {\n\
  if (parent === null)\n\
    return null;\n\
\n\
  var c = function () {};\n\
  c.prototype = parent;\n\
  return new c();\n\
};\n\
\n\
// private utility functions\n\
\n\
function __objToStr(o) {\n\
  return Object.prototype.toString.call(o);\n\
}\n\
clone.__objToStr = __objToStr;\n\
\n\
function __isDate(o) {\n\
  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\
}\n\
clone.__isDate = __isDate;\n\
\n\
function __isArray(o) {\n\
  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\
}\n\
clone.__isArray = __isArray;\n\
\n\
function __isRegExp(o) {\n\
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\
}\n\
clone.__isRegExp = __isRegExp;\n\
\n\
function __getRegExpFlags(re) {\n\
  var flags = '';\n\
  if (re.global) flags += 'g';\n\
  if (re.ignoreCase) flags += 'i';\n\
  if (re.multiline) flags += 'm';\n\
  return flags;\n\
}\n\
clone.__getRegExpFlags = __getRegExpFlags;\n\
\n\
return clone;\n\
})();\n\
\n\
if (typeof module === 'object' && module.exports) {\n\
  module.exports = clone;\n\
}\n\
\n\
/**\n\
 * Main CSSLint object.\n\
 * @class CSSLint\n\
 * @static\n\
 * @extends parserlib.util.EventTarget\n\
 */\n\
\n\
/* global parserlib, clone, Reporter */\n\
/* exported CSSLint */\n\
\n\
var CSSLint = (function() {\n\
    \"use strict\";\n\
\n\
    var rules           = [],\n\
        formatters      = [],\n\
        embeddedRuleset = /\\/\\*\\s*csslint([^\\*]*)\\*\\//,\n\
        api             = new parserlib.util.EventTarget();\n\
\n\
    api.version = \"1.0.5\";\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Rule Management\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Adds a new rule to the engine.\n\
     * @param {Object} rule The rule to add.\n\
     * @method addRule\n\
     */\n\
    api.addRule = function(rule) {\n\
        rules.push(rule);\n\
        rules[rule.id] = rule;\n\
    };\n\
\n\
    /**\n\
     * Clears all rule from the engine.\n\
     * @method clearRules\n\
     */\n\
    api.clearRules = function() {\n\
        rules = [];\n\
    };\n\
\n\
    /**\n\
     * Returns the rule objects.\n\
     * @return An array of rule objects.\n\
     * @method getRules\n\
     */\n\
    api.getRules = function() {\n\
        return [].concat(rules).sort(function(a, b) {\n\
            return a.id > b.id ? 1 : 0;\n\
        });\n\
    };\n\
\n\
    /**\n\
     * Returns a ruleset configuration object with all current rules.\n\
     * @return A ruleset object.\n\
     * @method getRuleset\n\
     */\n\
    api.getRuleset = function() {\n\
        var ruleset = {},\n\
            i = 0,\n\
            len = rules.length;\n\
\n\
        while (i < len) {\n\
            ruleset[rules[i++].id] = 1;    // by default, everything is a warning\n\
        }\n\
\n\
        return ruleset;\n\
    };\n\
\n\
    /**\n\
     * Returns a ruleset object based on embedded rules.\n\
     * @param {String} text A string of css containing embedded rules.\n\
     * @param {Object} ruleset A ruleset object to modify.\n\
     * @return {Object} A ruleset object.\n\
     * @method getEmbeddedRuleset\n\
     */\n\
    function applyEmbeddedRuleset(text, ruleset) {\n\
        var valueMap,\n\
            embedded = text && text.match(embeddedRuleset),\n\
            rules = embedded && embedded[1];\n\
\n\
        if (rules) {\n\
            valueMap = {\n\
                \"true\": 2,  // true is error\n\
                \"\": 1,      // blank is warning\n\
                \"false\": 0, // false is ignore\n\
\n\
                \"2\": 2,     // explicit error\n\
                \"1\": 1,     // explicit warning\n\
                \"0\": 0      // explicit ignore\n\
            };\n\
\n\
            rules.toLowerCase().split(\",\").forEach(function(rule) {\n\
                var pair = rule.split(\":\"),\n\
                    property = pair[0] || \"\",\n\
                    value = pair[1] || \"\";\n\
\n\
                ruleset[property.trim()] = valueMap[value.trim()];\n\
            });\n\
        }\n\
\n\
        return ruleset;\n\
    }\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Formatters\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Adds a new formatter to the engine.\n\
     * @param {Object} formatter The formatter to add.\n\
     * @method addFormatter\n\
     */\n\
    api.addFormatter = function(formatter) {\n\
        // formatters.push(formatter);\n\
        formatters[formatter.id] = formatter;\n\
    };\n\
\n\
    /**\n\
     * Retrieves a formatter for use.\n\
     * @param {String} formatId The name of the format to retrieve.\n\
     * @return {Object} The formatter or undefined.\n\
     * @method getFormatter\n\
     */\n\
    api.getFormatter = function(formatId) {\n\
        return formatters[formatId];\n\
    };\n\
\n\
    /**\n\
     * Formats the results in a particular format for a single file.\n\
     * @param {Object} result The results returned from CSSLint.verify().\n\
     * @param {String} filename The filename for which the results apply.\n\
     * @param {String} formatId The name of the formatter to use.\n\
     * @param {Object} options (Optional) for special output handling.\n\
     * @return {String} A formatted string for the results.\n\
     * @method format\n\
     */\n\
    api.format = function(results, filename, formatId, options) {\n\
        var formatter = api.getFormatter(formatId),\n\
            result = null;\n\
\n\
        if (formatter) {\n\
            result = formatter.startFormat();\n\
            result += formatter.formatResults(results, filename, options || {});\n\
            result += formatter.endFormat();\n\
        }\n\
\n\
        return result;\n\
    };\n\
\n\
    /**\n\
     * Indicates if the given format is supported.\n\
     * @param {String} formatId The ID of the format to check.\n\
     * @return {Boolean} True if the format exists, false if not.\n\
     * @method hasFormat\n\
     */\n\
    api.hasFormat = function(formatId) {\n\
        return formatters.hasOwnProperty(formatId);\n\
    };\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Verification\n\
    //-------------------------------------------------------------------------\n\
\n\
    /**\n\
     * Starts the verification process for the given CSS text.\n\
     * @param {String} text The CSS text to verify.\n\
     * @param {Object} ruleset (Optional) List of rules to apply. If null, then\n\
     *      all rules are used. If a rule has a value of 1 then it's a warning,\n\
     *      a value of 2 means it's an error.\n\
     * @return {Object} Results of the verification.\n\
     * @method verify\n\
     */\n\
    api.verify = function(text, ruleset) {\n\
\n\
        var i = 0,\n\
            reporter,\n\
            lines,\n\
            allow = {},\n\
            ignore = [],\n\
            report,\n\
            parser = new parserlib.css.Parser({\n\
                starHack: true,\n\
                ieFilters: true,\n\
                underscoreHack: true,\n\
                strict: false\n\
            });\n\
\n\
        // normalize line endings\n\
        lines = text.replace(/\\n\\r?/g, \"$split$\").split(\"$split$\");\n\
\n\
        // find 'allow' comments\n\
        CSSLint.Util.forEach(lines, function (line, lineno) {\n\
            var allowLine = line && line.match(/\\/\\*[ \\t]*csslint[ \\t]+allow:[ \\t]*([^\\*]*)\\*\\//i),\n\
                allowRules = allowLine && allowLine[1],\n\
                allowRuleset = {};\n\
\n\
            if (allowRules) {\n\
                allowRules.toLowerCase().split(\",\").forEach(function(allowRule) {\n\
                    allowRuleset[allowRule.trim()] = true;\n\
                });\n\
                if (Object.keys(allowRuleset).length > 0) {\n\
                    allow[lineno + 1] = allowRuleset;\n\
                }\n\
            }\n\
        });\n\
\n\
        var ignoreStart = null,\n\
            ignoreEnd = null;\n\
        CSSLint.Util.forEach(lines, function (line, lineno) {\n\
            // Keep oldest, \"unclosest\" ignore:start\n\
            if (ignoreStart === null && line.match(/\\/\\*[ \\t]*csslint[ \\t]+ignore:start[ \\t]*\\*\\//i)) {\n\
                ignoreStart = lineno;\n\
            }\n\
\n\
            if (line.match(/\\/\\*[ \\t]*csslint[ \\t]+ignore:end[ \\t]*\\*\\//i)) {\n\
                ignoreEnd = lineno;\n\
            }\n\
\n\
            if (ignoreStart !== null && ignoreEnd !== null) {\n\
                ignore.push([ignoreStart, ignoreEnd]);\n\
                ignoreStart = ignoreEnd = null;\n\
            }\n\
        });\n\
\n\
        // Close remaining ignore block, if any\n\
        if (ignoreStart !== null) {\n\
            ignore.push([ignoreStart, lines.length]);\n\
        }\n\
\n\
        if (!ruleset) {\n\
            ruleset = api.getRuleset();\n\
        }\n\
\n\
        if (embeddedRuleset.test(text)) {\n\
            // defensively copy so that caller's version does not get modified\n\
            ruleset = clone(ruleset);\n\
            ruleset = applyEmbeddedRuleset(text, ruleset);\n\
        }\n\
\n\
        reporter = new Reporter(lines, ruleset, allow, ignore);\n\
\n\
        ruleset.errors = 2;       // always report parsing errors as errors\n\
        for (i in ruleset) {\n\
            if (ruleset.hasOwnProperty(i) && ruleset[i]) {\n\
                if (rules[i]) {\n\
                    rules[i].init(parser, reporter);\n\
                }\n\
            }\n\
        }\n\
\n\
\n\
        // capture most horrible error type\n\
        try {\n\
            parser.parse(text);\n\
        } catch (ex) {\n\
            reporter.error(\"Fatal error, cannot continue: \" + ex.message, ex.line, ex.col, {});\n\
        }\n\
\n\
        report = {\n\
            messages    : reporter.messages,\n\
            stats       : reporter.stats,\n\
            ruleset     : reporter.ruleset,\n\
            allow       : reporter.allow,\n\
            ignore      : reporter.ignore\n\
        };\n\
\n\
        // sort by line numbers, rollups at the bottom\n\
        report.messages.sort(function (a, b) {\n\
            if (a.rollup && !b.rollup) {\n\
                return 1;\n\
            } else if (!a.rollup && b.rollup) {\n\
                return -1;\n\
            } else {\n\
                return a.line - b.line;\n\
            }\n\
        });\n\
\n\
        return report;\n\
    };\n\
\n\
    //-------------------------------------------------------------------------\n\
    // Publish the API\n\
    //-------------------------------------------------------------------------\n\
\n\
    return api;\n\
})();\n\
\n\
/**\n\
 * An instance of Report is used to report results of the\n\
 * verification back to the main API.\n\
 * @class Reporter\n\
 * @constructor\n\
 * @param {String[]} lines The text lines of the source.\n\
 * @param {Object} ruleset The set of rules to work with, including if\n\
 *      they are errors or warnings.\n\
 * @param {Object} explicitly allowed lines\n\
 * @param {[][]} ingore list of line ranges to be ignored\n\
 */\n\
function Reporter(lines, ruleset, allow, ignore) {\n\
    \"use strict\";\n\
\n\
    /**\n\
     * List of messages being reported.\n\
     * @property messages\n\
     * @type String[]\n\
     */\n\
    this.messages = [];\n\
\n\
    /**\n\
     * List of statistics being reported.\n\
     * @property stats\n\
     * @type String[]\n\
     */\n\
    this.stats = [];\n\
\n\
    /**\n\
     * Lines of code being reported on. Used to provide contextual information\n\
     * for messages.\n\
     * @property lines\n\
     * @type String[]\n\
     */\n\
    this.lines = lines;\n\
\n\
    /**\n\
     * Information about the rules. Used to determine whether an issue is an\n\
     * error or warning.\n\
     * @property ruleset\n\
     * @type Object\n\
     */\n\
    this.ruleset = ruleset;\n\
\n\
    /**\n\
     * Lines with specific rule messages to leave out of the report.\n\
     * @property allow\n\
     * @type Object\n\
     */\n\
    this.allow = allow;\n\
    if (!this.allow) {\n\
        this.allow = {};\n\
    }\n\
\n\
    /**\n\
     * Linesets not to include in the report.\n\
     * @property ignore\n\
     * @type [][]\n\
     */\n\
    this.ignore = ignore;\n\
    if (!this.ignore) {\n\
        this.ignore = [];\n\
    }\n\
}\n\
\n\
Reporter.prototype = {\n\
\n\
    // restore constructor\n\
    constructor: Reporter,\n\
\n\
    /**\n\
     * Report an error.\n\
     * @param {String} message The message to store.\n\
     * @param {int} line The line number.\n\
     * @param {int} col The column number.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method error\n\
     */\n\
    error: function(message, line, col, rule) {\n\
        \"use strict\";\n\
        this.messages.push({\n\
            type    : \"error\",\n\
            line    : line,\n\
            col     : col,\n\
            message : message,\n\
            evidence: this.lines[line-1],\n\
            rule    : rule || {}\n\
        });\n\
    },\n\
\n\
    /**\n\
     * Report an warning.\n\
     * @param {String} message The message to store.\n\
     * @param {int} line The line number.\n\
     * @param {int} col The column number.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method warn\n\
     * @deprecated Use report instead.\n\
     */\n\
    warn: function(message, line, col, rule) {\n\
        \"use strict\";\n\
        this.report(message, line, col, rule);\n\
    },\n\
\n\
    /**\n\
     * Report an issue.\n\
     * @param {String} message The message to store.\n\
     * @param {int} line The line number.\n\
     * @param {int} col The column number.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method report\n\
     */\n\
    report: function(message, line, col, rule) {\n\
        \"use strict\";\n\
\n\
        // Check if rule violation should be allowed\n\
        if (this.allow.hasOwnProperty(line) && this.allow[line].hasOwnProperty(rule.id)) {\n\
            return;\n\
        }\n\
\n\
        var ignore = false;\n\
        CSSLint.Util.forEach(this.ignore, function (range) {\n\
            if (range[0] <= line && line <= range[1]) {\n\
                ignore = true;\n\
            }\n\
        });\n\
        if (ignore) {\n\
            return;\n\
        }\n\
\n\
        this.messages.push({\n\
            type    : this.ruleset[rule.id] === 2 ? \"error\" : \"warning\",\n\
            line    : line,\n\
            col     : col,\n\
            message : message,\n\
            evidence: this.lines[line-1],\n\
            rule    : rule\n\
        });\n\
    },\n\
\n\
    /**\n\
     * Report some informational text.\n\
     * @param {String} message The message to store.\n\
     * @param {int} line The line number.\n\
     * @param {int} col The column number.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method info\n\
     */\n\
    info: function(message, line, col, rule) {\n\
        \"use strict\";\n\
        this.messages.push({\n\
            type    : \"info\",\n\
            line    : line,\n\
            col     : col,\n\
            message : message,\n\
            evidence: this.lines[line-1],\n\
            rule    : rule\n\
        });\n\
    },\n\
\n\
    /**\n\
     * Report some rollup error information.\n\
     * @param {String} message The message to store.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method rollupError\n\
     */\n\
    rollupError: function(message, rule) {\n\
        \"use strict\";\n\
        this.messages.push({\n\
            type    : \"error\",\n\
            rollup  : true,\n\
            message : message,\n\
            rule    : rule\n\
        });\n\
    },\n\
\n\
    /**\n\
     * Report some rollup warning information.\n\
     * @param {String} message The message to store.\n\
     * @param {Object} rule The rule this message relates to.\n\
     * @method rollupWarn\n\
     */\n\
    rollupWarn: function(message, rule) {\n\
        \"use strict\";\n\
        this.messages.push({\n\
            type    : \"warning\",\n\
            rollup  : true,\n\
            message : message,\n\
            rule    : rule\n\
        });\n\
    },\n\
\n\
    /**\n\
     * Report a statistic.\n\
     * @param {String} name The name of the stat to store.\n\
     * @param {Variant} value The value of the stat.\n\
     * @method stat\n\
     */\n\
    stat: function(name, value) {\n\
        \"use strict\";\n\
        this.stats[name] = value;\n\
    }\n\
};\n\
\n\
// expose for testing purposes\n\
CSSLint._Reporter = Reporter;\n\
\n\
/*\n\
 * Utility functions that make life easier.\n\
 */\n\
CSSLint.Util = {\n\
    /*\n\
     * Adds all properties from supplier onto receiver,\n\
     * overwriting if the same name already exists on\n\
     * receiver.\n\
     * @param {Object} The object to receive the properties.\n\
     * @param {Object} The object to provide the properties.\n\
     * @return {Object} The receiver\n\
     */\n\
    mix: function(receiver, supplier) {\n\
        \"use strict\";\n\
        var prop;\n\
\n\
        for (prop in supplier) {\n\
            if (supplier.hasOwnProperty(prop)) {\n\
                receiver[prop] = supplier[prop];\n\
            }\n\
        }\n\
\n\
        return prop;\n\
    },\n\
\n\
    /*\n\
     * Polyfill for array indexOf() method.\n\
     * @param {Array} values The array to search.\n\
     * @param {Variant} value The value to search for.\n\
     * @return {int} The index of the value if found, -1 if not.\n\
     */\n\
    indexOf: function(values, value) {\n\
        \"use strict\";\n\
        if (values.indexOf) {\n\
            return values.indexOf(value);\n\
        } else {\n\
            for (var i=0, len=values.length; i < len; i++) {\n\
                if (values[i] === value) {\n\
                    return i;\n\
                }\n\
            }\n\
            return -1;\n\
        }\n\
    },\n\
\n\
    /*\n\
     * Polyfill for array forEach() method.\n\
     * @param {Array} values The array to operate on.\n\
     * @param {Function} func The function to call on each item.\n\
     * @return {void}\n\
     */\n\
    forEach: function(values, func) {\n\
        \"use strict\";\n\
        if (values.forEach) {\n\
            return values.forEach(func);\n\
        } else {\n\
            for (var i=0, len=values.length; i < len; i++) {\n\
                func(values[i], i, values);\n\
            }\n\
        }\n\
    }\n\
};\n\
\n\
/*\n\
 * Rule: Don't use adjoining classes (.foo.bar).\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"adjoining-classes\",\n\
    name: \"Disallow adjoining classes\",\n\
    desc: \"Don't use adjoining classes.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-adjoining-classes\",\n\
    browsers: \"IE6\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                modifier,\n\
                classCount,\n\
                i, j, k;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
                for (j=0; j < selector.parts.length; j++) {\n\
                    part = selector.parts[j];\n\
                    if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                        classCount = 0;\n\
                        for (k=0; k < part.modifiers.length; k++) {\n\
                            modifier = part.modifiers[k];\n\
                            if (modifier.type === \"class\") {\n\
                                classCount++;\n\
                            }\n\
                            if (classCount > 1){\n\
                                reporter.report(\"Adjoining classes: \"+selectors[i].text, part.line, part.col, rule);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use width or height when using padding or border.\n\
 */\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"box-model\",\n\
    name: \"Beware of broken box size\",\n\
    desc: \"Don't use width or height when using padding or border.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            widthProperties = {\n\
                border: 1,\n\
                \"border-left\": 1,\n\
                \"border-right\": 1,\n\
                padding: 1,\n\
                \"padding-left\": 1,\n\
                \"padding-right\": 1\n\
            },\n\
            heightProperties = {\n\
                border: 1,\n\
                \"border-bottom\": 1,\n\
                \"border-top\": 1,\n\
                padding: 1,\n\
                \"padding-bottom\": 1,\n\
                \"padding-top\": 1\n\
            },\n\
            properties,\n\
            boxSizing = false;\n\
\n\
        function startRule() {\n\
            properties = {};\n\
            boxSizing = false;\n\
        }\n\
\n\
        function endRule() {\n\
            var prop, value;\n\
\n\
            if (!boxSizing) {\n\
                if (properties.height) {\n\
                    for (prop in heightProperties) {\n\
                        if (heightProperties.hasOwnProperty(prop) && properties[prop]) {\n\
                            value = properties[prop].value;\n\
                            // special case for padding\n\
                            if (!(prop === \"padding\" && value.parts.length === 2 && value.parts[0].value === 0)) {\n\
                                reporter.report(\"Using height with \" + prop + \" can sometimes make elements larger than you expect.\", properties[prop].line, properties[prop].col, rule);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
\n\
                if (properties.width) {\n\
                    for (prop in widthProperties) {\n\
                        if (widthProperties.hasOwnProperty(prop) && properties[prop]) {\n\
                            value = properties[prop].value;\n\
\n\
                            if (!(prop === \"padding\" && value.parts.length === 2 && value.parts[1].value === 0)) {\n\
                                reporter.report(\"Using width with \" + prop + \" can sometimes make elements larger than you expect.\", properties[prop].line, properties[prop].col, rule);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text.toLowerCase();\n\
\n\
            if (heightProperties[name] || widthProperties[name]) {\n\
                if (!/^0\\S*$/.test(event.value) && !(name === \"border\" && event.value.toString() === \"none\")) {\n\
                    properties[name] = {\n\
                        line: event.property.line,\n\
                        col: event.property.col,\n\
                        value: event.value\n\
                    };\n\
                }\n\
            } else {\n\
                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)) {\n\
                    properties[name] = 1;\n\
                } else if (name === \"box-sizing\") {\n\
                    boxSizing = true;\n\
                }\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
        parser.addListener(\"endpage\", endRule);\n\
        parser.addListener(\"endpagemargin\", endRule);\n\
        parser.addListener(\"endkeyframerule\", endRule);\n\
        parser.addListener(\"endviewport\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: box-sizing doesn't work in IE6 and IE7.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"box-sizing\",\n\
    name: \"Disallow use of box-sizing\",\n\
    desc: \"The box-sizing properties isn't supported in IE6 and IE7.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-box-sizing\",\n\
    browsers: \"IE6, IE7\",\n\
    tags: [\"Compatibility\"],\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text.toLowerCase();\n\
\n\
            if (name === \"box-sizing\") {\n\
                reporter.report(\"The box-sizing property isn't supported in IE6 and IE7.\", event.line, event.col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Use the bulletproof @font-face syntax to avoid 404's in old IE\n\
 * (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"bulletproof-font-face\",\n\
    name: \"Use the bulletproof @font-face syntax\",\n\
    desc: \"Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Bulletproof-font-face\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            fontFaceRule = false,\n\
            firstSrc = true,\n\
            ruleFailed = false,\n\
            line, col;\n\
\n\
        // Mark the start of a @font-face declaration so we only test properties inside it\n\
        parser.addListener(\"startfontface\", function() {\n\
            fontFaceRule = true;\n\
        });\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            // If we aren't inside an @font-face declaration then just return\n\
            if (!fontFaceRule) {\n\
                return;\n\
            }\n\
\n\
            var propertyName = event.property.toString().toLowerCase(),\n\
                value = event.value.toString();\n\
\n\
            // Set the line and col numbers for use in the endfontface listener\n\
            line = event.line;\n\
            col = event.col;\n\
\n\
            // This is the property that we care about, we can ignore the rest\n\
            if (propertyName === \"src\") {\n\
                var regex = /^\\s?url\\(['\"].+\\.eot\\?.*['\"]\\)\\s*format\\(['\"]embedded-opentype['\"]\\).*$/i;\n\
\n\
                // We need to handle the advanced syntax with two src properties\n\
                if (!value.match(regex) && firstSrc) {\n\
                    ruleFailed = true;\n\
                    firstSrc = false;\n\
                } else if (value.match(regex) && !firstSrc) {\n\
                    ruleFailed = false;\n\
                }\n\
            }\n\
        });\n\
\n\
        // Back to normal rules that we don't need to test\n\
        parser.addListener(\"endfontface\", function() {\n\
            fontFaceRule = false;\n\
\n\
            if (ruleFailed) {\n\
                reporter.report(\"@font-face declaration doesn't follow the fontspring bulletproof syntax.\", line, col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Include all compatible vendor prefixes to reach a wider\n\
 * range of users.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"compatible-vendor-prefixes\",\n\
    name: \"Require compatible vendor prefixes\",\n\
    desc: \"Include all compatible vendor prefixes to reach a wider range of users.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-compatible-vendor-prefixes\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function (parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            compatiblePrefixes,\n\
            properties,\n\
            prop,\n\
            variations,\n\
            prefixed,\n\
            i,\n\
            len,\n\
            inKeyFrame = false,\n\
            arrayPush = Array.prototype.push,\n\
            applyTo = [];\n\
\n\
        // See http://peter.sh/experiments/vendor-prefixed-css-property-overview/ for details\n\
        compatiblePrefixes = {\n\
            \"animation\"                  : \"webkit\",\n\
            \"animation-delay\"            : \"webkit\",\n\
            \"animation-direction\"        : \"webkit\",\n\
            \"animation-duration\"         : \"webkit\",\n\
            \"animation-fill-mode\"        : \"webkit\",\n\
            \"animation-iteration-count\"  : \"webkit\",\n\
            \"animation-name\"             : \"webkit\",\n\
            \"animation-play-state\"       : \"webkit\",\n\
            \"animation-timing-function\"  : \"webkit\",\n\
            \"appearance\"                 : \"webkit moz\",\n\
            \"border-end\"                 : \"webkit moz\",\n\
            \"border-end-color\"           : \"webkit moz\",\n\
            \"border-end-style\"           : \"webkit moz\",\n\
            \"border-end-width\"           : \"webkit moz\",\n\
            \"border-image\"               : \"webkit moz o\",\n\
            \"border-radius\"              : \"webkit\",\n\
            \"border-start\"               : \"webkit moz\",\n\
            \"border-start-color\"         : \"webkit moz\",\n\
            \"border-start-style\"         : \"webkit moz\",\n\
            \"border-start-width\"         : \"webkit moz\",\n\
            \"box-align\"                  : \"webkit moz\",\n\
            \"box-direction\"              : \"webkit moz\",\n\
            \"box-flex\"                   : \"webkit moz\",\n\
            \"box-lines\"                  : \"webkit\",\n\
            \"box-ordinal-group\"          : \"webkit moz\",\n\
            \"box-orient\"                 : \"webkit moz\",\n\
            \"box-pack\"                   : \"webkit moz\",\n\
            \"box-sizing\"                 : \"\",\n\
            \"box-shadow\"                 : \"\",\n\
            \"column-count\"               : \"webkit moz ms\",\n\
            \"column-gap\"                 : \"webkit moz ms\",\n\
            \"column-rule\"                : \"webkit moz ms\",\n\
            \"column-rule-color\"          : \"webkit moz ms\",\n\
            \"column-rule-style\"          : \"webkit moz ms\",\n\
            \"column-rule-width\"          : \"webkit moz ms\",\n\
            \"column-width\"               : \"webkit moz ms\",\n\
            \"flex\"                       : \"webkit ms\",\n\
            \"flex-basis\"                 : \"webkit\",\n\
            \"flex-direction\"             : \"webkit ms\",\n\
            \"flex-flow\"                  : \"webkit\",\n\
            \"flex-grow\"                  : \"webkit\",\n\
            \"flex-shrink\"                : \"webkit\",\n\
            \"hyphens\"                    : \"epub moz\",\n\
            \"line-break\"                 : \"webkit ms\",\n\
            \"margin-end\"                 : \"webkit moz\",\n\
            \"margin-start\"               : \"webkit moz\",\n\
            \"marquee-speed\"              : \"webkit wap\",\n\
            \"marquee-style\"              : \"webkit wap\",\n\
            \"padding-end\"                : \"webkit moz\",\n\
            \"padding-start\"              : \"webkit moz\",\n\
            \"tab-size\"                   : \"moz o\",\n\
            \"text-size-adjust\"           : \"webkit ms\",\n\
            \"transform\"                  : \"webkit ms\",\n\
            \"transform-origin\"           : \"webkit ms\",\n\
            \"transition\"                 : \"\",\n\
            \"transition-delay\"           : \"\",\n\
            \"transition-duration\"        : \"\",\n\
            \"transition-property\"        : \"\",\n\
            \"transition-timing-function\" : \"\",\n\
            \"user-modify\"                : \"webkit moz\",\n\
            \"user-select\"                : \"webkit moz ms\",\n\
            \"word-break\"                 : \"epub ms\",\n\
            \"writing-mode\"               : \"epub ms\"\n\
        };\n\
\n\
\n\
        for (prop in compatiblePrefixes) {\n\
            if (compatiblePrefixes.hasOwnProperty(prop)) {\n\
                variations = [];\n\
                prefixed = compatiblePrefixes[prop].split(\" \");\n\
                for (i = 0, len = prefixed.length; i < len; i++) {\n\
                    variations.push(\"-\" + prefixed[i] + \"-\" + prop);\n\
                }\n\
                compatiblePrefixes[prop] = variations;\n\
                arrayPush.apply(applyTo, variations);\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", function () {\n\
            properties = [];\n\
        });\n\
\n\
        parser.addListener(\"startkeyframes\", function (event) {\n\
            inKeyFrame = event.prefix || true;\n\
        });\n\
\n\
        parser.addListener(\"endkeyframes\", function () {\n\
            inKeyFrame = false;\n\
        });\n\
\n\
        parser.addListener(\"property\", function (event) {\n\
            var name = event.property;\n\
            if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {\n\
\n\
                // e.g., -moz-transform is okay to be alone in @-moz-keyframes\n\
                if (!inKeyFrame || typeof inKeyFrame !== \"string\" ||\n\
                        name.text.indexOf(\"-\" + inKeyFrame + \"-\") !== 0) {\n\
                    properties.push(name);\n\
                }\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", function () {\n\
            if (!properties.length) {\n\
                return;\n\
            }\n\
\n\
            var propertyGroups = {},\n\
                i,\n\
                len,\n\
                name,\n\
                prop,\n\
                variations,\n\
                value,\n\
                full,\n\
                actual,\n\
                item,\n\
                propertiesSpecified;\n\
\n\
            for (i = 0, len = properties.length; i < len; i++) {\n\
                name = properties[i];\n\
\n\
                for (prop in compatiblePrefixes) {\n\
                    if (compatiblePrefixes.hasOwnProperty(prop)) {\n\
                        variations = compatiblePrefixes[prop];\n\
                        if (CSSLint.Util.indexOf(variations, name.text) > -1) {\n\
                            if (!propertyGroups[prop]) {\n\
                                propertyGroups[prop] = {\n\
                                    full: variations.slice(0),\n\
                                    actual: [],\n\
                                    actualNodes: []\n\
                                };\n\
                            }\n\
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {\n\
                                propertyGroups[prop].actual.push(name.text);\n\
                                propertyGroups[prop].actualNodes.push(name);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
\n\
            for (prop in propertyGroups) {\n\
                if (propertyGroups.hasOwnProperty(prop)) {\n\
                    value = propertyGroups[prop];\n\
                    full = value.full;\n\
                    actual = value.actual;\n\
\n\
                    if (full.length > actual.length) {\n\
                        for (i = 0, len = full.length; i < len; i++) {\n\
                            item = full[i];\n\
                            if (CSSLint.Util.indexOf(actual, item) === -1) {\n\
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(\" and \") : actual.join(\", \");\n\
                                reporter.report(\"The property \" + item + \" is compatible with \" + propertiesSpecified + \" and should be included as well.\", value.actualNodes[0].line, value.actualNodes[0].col, rule);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Certain properties don't play well with certain display values.\n\
 * - float should not be used with inline-block\n\
 * - height, width, margin-top, margin-bottom, float should not be used with inline\n\
 * - vertical-align should not be used with block\n\
 * - margin, float should not be used with table-*\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"display-property-grouping\",\n\
    name: \"Require properties appropriate for display\",\n\
    desc: \"Certain properties shouldn't be used with certain display property values.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-properties-appropriate-for-display\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        var propertiesToCheck = {\n\
                display: 1,\n\
                \"float\": \"none\",\n\
                height: 1,\n\
                width: 1,\n\
                margin: 1,\n\
                \"margin-left\": 1,\n\
                \"margin-right\": 1,\n\
                \"margin-bottom\": 1,\n\
                \"margin-top\": 1,\n\
                padding: 1,\n\
                \"padding-left\": 1,\n\
                \"padding-right\": 1,\n\
                \"padding-bottom\": 1,\n\
                \"padding-top\": 1,\n\
                \"vertical-align\": 1\n\
            },\n\
            properties;\n\
\n\
        function reportProperty(name, display, msg) {\n\
            if (properties[name]) {\n\
                if (typeof propertiesToCheck[name] !== \"string\" || properties[name].value.toLowerCase() !== propertiesToCheck[name]) {\n\
                    reporter.report(msg || name + \" can't be used with display: \" + display + \".\", properties[name].line, properties[name].col, rule);\n\
                }\n\
            }\n\
        }\n\
\n\
        function startRule() {\n\
            properties = {};\n\
        }\n\
\n\
        function endRule() {\n\
\n\
            var display = properties.display ? properties.display.value : null;\n\
            if (display) {\n\
                switch (display) {\n\
\n\
                    case \"inline\":\n\
                        // height, width, margin-top, margin-bottom, float should not be used with inline\n\
                        reportProperty(\"height\", display);\n\
                        reportProperty(\"width\", display);\n\
                        reportProperty(\"margin\", display);\n\
                        reportProperty(\"margin-top\", display);\n\
                        reportProperty(\"margin-bottom\", display);\n\
                        reportProperty(\"float\", display, \"display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).\");\n\
                        break;\n\
\n\
                    case \"block\":\n\
                        // vertical-align should not be used with block\n\
                        reportProperty(\"vertical-align\", display);\n\
                        break;\n\
\n\
                    case \"inline-block\":\n\
                        // float should not be used with inline-block\n\
                        reportProperty(\"float\", display);\n\
                        break;\n\
\n\
                    default:\n\
                        // margin, float should not be used with table\n\
                        if (display.indexOf(\"table-\") === 0) {\n\
                            reportProperty(\"margin\", display);\n\
                            reportProperty(\"margin-left\", display);\n\
                            reportProperty(\"margin-right\", display);\n\
                            reportProperty(\"margin-top\", display);\n\
                            reportProperty(\"margin-bottom\", display);\n\
                            reportProperty(\"float\", display);\n\
                        }\n\
\n\
                        // otherwise do nothing\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text.toLowerCase();\n\
\n\
            if (propertiesToCheck[name]) {\n\
                properties[name] = {\n\
                    value: event.value.text,\n\
                    line: event.property.line,\n\
                    col: event.property.col\n\
                };\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
        parser.addListener(\"endkeyframerule\", endRule);\n\
        parser.addListener(\"endpagemargin\", endRule);\n\
        parser.addListener(\"endpage\", endRule);\n\
        parser.addListener(\"endviewport\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Disallow duplicate background-images (using url).\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"duplicate-background-images\",\n\
    name: \"Disallow duplicate background images\",\n\
    desc: \"Every background-image should be unique. Use a common class for e.g. sprites.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-background-images\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            stack = {};\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text,\n\
                value = event.value,\n\
                i, len;\n\
\n\
            if (name.match(/background/i)) {\n\
                for (i=0, len=value.parts.length; i < len; i++) {\n\
                    if (value.parts[i].type === \"uri\") {\n\
                        if (typeof stack[value.parts[i].uri] === \"undefined\") {\n\
                            stack[value.parts[i].uri] = event;\n\
                        } else {\n\
                            reporter.report(\"Background image '\" + value.parts[i].uri + \"' was used multiple times, first declared at line \" + stack[value.parts[i].uri].line + \", col \" + stack[value.parts[i].uri].col + \".\", event.line, event.col, rule);\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Duplicate properties must appear one after the other. If an already-defined\n\
 * property appears somewhere else in the rule, then it's likely an error.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"duplicate-properties\",\n\
    name: \"Disallow duplicate properties\",\n\
    desc: \"Duplicate properties must appear one after the other.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-properties\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            properties,\n\
            lastProperty;\n\
\n\
        function startRule() {\n\
            properties = {};\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var property = event.property,\n\
                name = property.text.toLowerCase();\n\
\n\
            if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)) {\n\
                reporter.report(\"Duplicate property '\" + event.property + \"' found.\", event.line, event.col, rule);\n\
            }\n\
\n\
            properties[name] = event.value.text;\n\
            lastProperty = name;\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Style rules without any properties defined should be removed.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"empty-rules\",\n\
    name: \"Disallow empty rules\",\n\
    desc: \"Rules without any properties specified should be removed.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-empty-rules\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            count = 0;\n\
\n\
        parser.addListener(\"startrule\", function() {\n\
            count=0;\n\
        });\n\
\n\
        parser.addListener(\"property\", function() {\n\
            count++;\n\
        });\n\
\n\
        parser.addListener(\"endrule\", function(event) {\n\
            var selectors = event.selectors;\n\
            if (count === 0) {\n\
                reporter.report(\"Rule is empty.\", selectors[0].line, selectors[0].col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: There should be no syntax errors. (Duh.)\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"errors\",\n\
    name: \"Parsing Errors\",\n\
    desc: \"This rule looks for recoverable syntax errors.\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"error\", function(event) {\n\
            reporter.error(event.message, event.line, event.col, rule);\n\
        });\n\
    }\n\
});\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"fallback-colors\",\n\
    name: \"Require fallback colors\",\n\
    desc: \"For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-fallback-colors\",\n\
    browsers: \"IE6,IE7,IE8\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            lastProperty,\n\
            propertiesToCheck = {\n\
                color: 1,\n\
                background: 1,\n\
                \"border-color\": 1,\n\
                \"border-top-color\": 1,\n\
                \"border-right-color\": 1,\n\
                \"border-bottom-color\": 1,\n\
                \"border-left-color\": 1,\n\
                border: 1,\n\
                \"border-top\": 1,\n\
                \"border-right\": 1,\n\
                \"border-bottom\": 1,\n\
                \"border-left\": 1,\n\
                \"background-color\": 1\n\
            };\n\
\n\
        function startRule() {\n\
            lastProperty = null;\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var property = event.property,\n\
                name = property.text.toLowerCase(),\n\
                parts = event.value.parts,\n\
                i = 0,\n\
                colorType = \"\",\n\
                len = parts.length;\n\
\n\
            if (propertiesToCheck[name]) {\n\
                while (i < len) {\n\
                    if (parts[i].type === \"color\") {\n\
                        if (\"alpha\" in parts[i] || \"hue\" in parts[i]) {\n\
\n\
                            if (/([^\\)]+)\\(/.test(parts[i])) {\n\
                                colorType = RegExp.$1.toUpperCase();\n\
                            }\n\
\n\
                            if (!lastProperty || (lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== \"compat\")) {\n\
                                reporter.report(\"Fallback \" + name + \" (hex or RGB) should precede \" + colorType + \" \" + name + \".\", event.line, event.col, rule);\n\
                            }\n\
                        } else {\n\
                            event.colorType = \"compat\";\n\
                        }\n\
                    }\n\
\n\
                    i++;\n\
                }\n\
            }\n\
\n\
            lastProperty = event;\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: You shouldn't use more than 10 floats. If you do, there's probably\n\
 * room for some abstraction.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"floats\",\n\
    name: \"Disallow too many floats\",\n\
    desc: \"This rule tests if the float property is used too many times\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-too-many-floats\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
        var count = 0;\n\
\n\
        // count how many times \"float\" is used\n\
        parser.addListener(\"property\", function(event) {\n\
            if (event.property.text.toLowerCase() === \"float\" &&\n\
                    event.value.text.toLowerCase() !== \"none\") {\n\
                count++;\n\
            }\n\
        });\n\
\n\
        // report the results\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            reporter.stat(\"floats\", count);\n\
            if (count >= 10) {\n\
                reporter.rollupWarn(\"Too many floats (\" + count + \"), you're probably using them for layout. Consider using a grid system instead.\", rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Avoid too many @font-face declarations in the same stylesheet.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"font-faces\",\n\
    name: \"Don't use too many web fonts\",\n\
    desc: \"Too many different web fonts in the same stylesheet.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-web-fonts\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            count = 0;\n\
\n\
\n\
        parser.addListener(\"startfontface\", function() {\n\
            count++;\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            if (count > 5) {\n\
                reporter.rollupWarn(\"Too many @font-face declarations (\" + count + \").\", rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: You shouldn't need more than 9 font-size declarations.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"font-sizes\",\n\
    name: \"Disallow too many font sizes\",\n\
    desc: \"Checks the number of font-size declarations.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-font-size-declarations\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            count = 0;\n\
\n\
        // check for use of \"font-size\"\n\
        parser.addListener(\"property\", function(event) {\n\
            if (event.property.toString() === \"font-size\") {\n\
                count++;\n\
            }\n\
        });\n\
\n\
        // report the results\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            reporter.stat(\"font-sizes\", count);\n\
            if (count >= 10) {\n\
                reporter.rollupWarn(\"Too many font-size declarations (\" + count + \"), abstraction needed.\", rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: When using a vendor-prefixed gradient, make sure to use them all.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"gradients\",\n\
    name: \"Require all gradient definitions\",\n\
    desc: \"When using a vendor-prefixed gradient, make sure to use them all.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-all-gradient-definitions\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            gradients;\n\
\n\
        parser.addListener(\"startrule\", function() {\n\
            gradients = {\n\
                moz: 0,\n\
                webkit: 0,\n\
                oldWebkit: 0,\n\
                o: 0\n\
            };\n\
        });\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
\n\
            if (/\\-(moz|o|webkit)(?:\\-(?:linear|radial))\\-gradient/i.test(event.value)) {\n\
                gradients[RegExp.$1] = 1;\n\
            } else if (/\\-webkit\\-gradient/i.test(event.value)) {\n\
                gradients.oldWebkit = 1;\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", function(event) {\n\
            var missing = [];\n\
\n\
            if (!gradients.moz) {\n\
                missing.push(\"Firefox 3.6+\");\n\
            }\n\
\n\
            if (!gradients.webkit) {\n\
                missing.push(\"Webkit (Safari 5+, Chrome)\");\n\
            }\n\
\n\
            if (!gradients.oldWebkit) {\n\
                missing.push(\"Old Webkit (Safari 4+, Chrome)\");\n\
            }\n\
\n\
            if (!gradients.o) {\n\
                missing.push(\"Opera 11.1+\");\n\
            }\n\
\n\
            if (missing.length && missing.length < 4) {\n\
                reporter.report(\"Missing vendor-prefixed CSS gradients for \" + missing.join(\", \") + \".\", event.selectors[0].line, event.selectors[0].col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use IDs for selectors.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"ids\",\n\
    name: \"Disallow IDs in selectors\",\n\
    desc: \"Selectors should not contain IDs.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                modifier,\n\
                idCount,\n\
                i, j, k;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
                idCount = 0;\n\
\n\
                for (j=0; j < selector.parts.length; j++) {\n\
                    part = selector.parts[j];\n\
                    if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                        for (k=0; k < part.modifiers.length; k++) {\n\
                            modifier = part.modifiers[k];\n\
                            if (modifier.type === \"id\") {\n\
                                idCount++;\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
\n\
                if (idCount === 1) {\n\
                    reporter.report(\"Don't use IDs in selectors.\", selector.line, selector.col, rule);\n\
                } else if (idCount > 1) {\n\
                    reporter.report(idCount + \" IDs in the selector, really?\", selector.line, selector.col, rule);\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: IE6-9 supports up to 31 stylesheet import.\n\
 * Reference:\n\
 * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"import-ie-limit\",\n\
    name: \"@import limit on IE6-IE9\",\n\
    desc: \"IE6-9 supports up to 31 @import per stylesheet\",\n\
    browsers: \"IE6, IE7, IE8, IE9\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            MAX_IMPORT_COUNT = 31,\n\
            count = 0;\n\
\n\
        function startPage() {\n\
            count = 0;\n\
        }\n\
\n\
        parser.addListener(\"startpage\", startPage);\n\
\n\
        parser.addListener(\"import\", function() {\n\
            count++;\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            if (count > MAX_IMPORT_COUNT) {\n\
                reporter.rollupError(\n\
                    \"Too many @import rules (\" + count + \"). IE6-9 supports up to 31 import per stylesheet.\",\n\
                    rule\n\
                );\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use @import, use <link> instead.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"import\",\n\
    name: \"Disallow @import\",\n\
    desc: \"Don't use @import, use <link> instead.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-%40import\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"import\", function(event) {\n\
            reporter.report(\"@import prevents parallel downloads, use <link> instead.\", event.line, event.col, rule);\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Make sure !important is not overused, this could lead to specificity\n\
 * war. Display a warning on !important declarations, an error if it's\n\
 * used more at least 10 times.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"important\",\n\
    name: \"Disallow !important\",\n\
    desc: \"Be careful when using !important declaration\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-%21important\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            count = 0;\n\
\n\
        // warn that important is used and increment the declaration counter\n\
        parser.addListener(\"property\", function(event) {\n\
            if (event.important === true) {\n\
                count++;\n\
                reporter.report(\"Use of !important\", event.line, event.col, rule);\n\
            }\n\
        });\n\
\n\
        // if there are more than 10, show an error\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            reporter.stat(\"important\", count);\n\
            if (count >= 10) {\n\
                reporter.rollupWarn(\"Too many !important declarations (\" + count + \"), try to use less than 10 to avoid specificity issues.\", rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Properties should be known (listed in CSS3 specification) or\n\
 * be a vendor-prefixed property.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"known-properties\",\n\
    name: \"Require use of known properties\",\n\
    desc: \"Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-use-of-known-properties\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
\n\
            // the check is handled entirely by the parser-lib (https://github.com/nzakas/parser-lib)\n\
            if (event.invalid) {\n\
                reporter.report(event.invalid.message, event.line, event.col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: All properties should be in alphabetical order.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"order-alphabetical\",\n\
    name: \"Alphabetical order\",\n\
    desc: \"Assure properties are in alphabetical order\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            properties;\n\
\n\
        var startRule = function () {\n\
            properties = [];\n\
        };\n\
\n\
        var endRule = function(event) {\n\
            var currentProperties = properties.join(\",\"),\n\
                expectedProperties = properties.sort().join(\",\");\n\
\n\
            if (currentProperties !== expectedProperties) {\n\
                reporter.report(\"Rule doesn't have all its properties in alphabetical order.\", event.line, event.col, rule);\n\
            }\n\
        };\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text,\n\
                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, \"\");\n\
\n\
            properties.push(lowerCasePrefixLessName);\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
        parser.addListener(\"endpage\", endRule);\n\
        parser.addListener(\"endpagemargin\", endRule);\n\
        parser.addListener(\"endkeyframerule\", endRule);\n\
        parser.addListener(\"endviewport\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: outline: none or outline: 0 should only be used in a :focus rule\n\
 *       and only if there are other properties in the same rule.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"outline-none\",\n\
    name: \"Disallow outline: none\",\n\
    desc: \"Use of outline: none or outline: 0 should be limited to :focus rules.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-outline%3Anone\",\n\
    browsers: \"All\",\n\
    tags: [\"Accessibility\"],\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            lastRule;\n\
\n\
        function startRule(event) {\n\
            if (event.selectors) {\n\
                lastRule = {\n\
                    line: event.line,\n\
                    col: event.col,\n\
                    selectors: event.selectors,\n\
                    propCount: 0,\n\
                    outline: false\n\
                };\n\
            } else {\n\
                lastRule = null;\n\
            }\n\
        }\n\
\n\
        function endRule() {\n\
            if (lastRule) {\n\
                if (lastRule.outline) {\n\
                    if (lastRule.selectors.toString().toLowerCase().indexOf(\":focus\") === -1) {\n\
                        reporter.report(\"Outlines should only be modified using :focus.\", lastRule.line, lastRule.col, rule);\n\
                    } else if (lastRule.propCount === 1) {\n\
                        reporter.report(\"Outlines shouldn't be hidden unless other visual changes are made.\", lastRule.line, lastRule.col, rule);\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text.toLowerCase(),\n\
                value = event.value;\n\
\n\
            if (lastRule) {\n\
                lastRule.propCount++;\n\
                if (name === \"outline\" && (value.toString() === \"none\" || value.toString() === \"0\")) {\n\
                    lastRule.outline = true;\n\
                }\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
        parser.addListener(\"endpage\", endRule);\n\
        parser.addListener(\"endpagemargin\", endRule);\n\
        parser.addListener(\"endkeyframerule\", endRule);\n\
        parser.addListener(\"endviewport\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use classes or IDs with elements (a.foo or a#foo).\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"overqualified-elements\",\n\
    name: \"Disallow overqualified elements\",\n\
    desc: \"Don't use classes or IDs with elements (a.foo or a#foo).\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-overqualified-elements\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            classes = {};\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                modifier,\n\
                i, j, k;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
\n\
                for (j=0; j < selector.parts.length; j++) {\n\
                    part = selector.parts[j];\n\
                    if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                        for (k=0; k < part.modifiers.length; k++) {\n\
                            modifier = part.modifiers[k];\n\
                            if (part.elementName && modifier.type === \"id\") {\n\
                                reporter.report(\"Element (\" + part + \") is overqualified, just use \" + modifier + \" without element name.\", part.line, part.col, rule);\n\
                            } else if (modifier.type === \"class\") {\n\
\n\
                                if (!classes[modifier]) {\n\
                                    classes[modifier] = [];\n\
                                }\n\
                                classes[modifier].push({\n\
                                    modifier: modifier,\n\
                                    part: part\n\
                                });\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
\n\
            var prop;\n\
            for (prop in classes) {\n\
                if (classes.hasOwnProperty(prop)) {\n\
\n\
                    // one use means that this is overqualified\n\
                    if (classes[prop].length === 1 && classes[prop][0].part.elementName) {\n\
                        reporter.report(\"Element (\" + classes[prop][0].part + \") is overqualified, just use \" + classes[prop][0].modifier + \" without element name.\", classes[prop][0].part.line, classes[prop][0].part.col, rule);\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
CSSLint.addRule({\n\
  id: \"performant-transitions\",\n\
  name: \"Allow only performant transisitons\",\n\
  desc: \"Only allow transitions that trigger compositing for performant, 60fps transformations.\",\n\
  url: \"\",\n\
  browsers: \"All\",\n\
\n\
  init: function(parser, reporter){\n\
    \"use strict\";\n\
    var rule = this;\n\
\n\
    var transitionProperties = [\"transition-property\", \"transition\", \"-webkit-transition\", \"-o-transition\"];\n\
    var allowedTransitions = [/-webkit-transform/g, /-ms-transform/g, /transform/g, /opacity/g];\n\
\n\
    parser.addListener(\"property\", function(event) {\n\
      var propertyName    = event.property.toString().toLowerCase(),\n\
          propertyValue           = event.value.toString(),\n\
          line            = event.line,\n\
          col             = event.col;\n\
\n\
      var values = propertyValue.split(\",\");\n\
      if (transitionProperties.indexOf(propertyName) !== -1) {\n\
        var reportValues = values.filter(function(value) {\n\
          var didMatch = [];\n\
          for (var i = 0; i < allowedTransitions.length; i++) {\n\
            if(value.match(allowedTransitions[i])) {\n\
              didMatch.push(i);\n\
            }\n\
          }\n\
          return didMatch.length === 0;\n\
        });\n\
        if(reportValues.length > 0) {\n\
            reporter.report(\"Unexpected transition property '\"+reportValues.join(\",\").trim()+\"'\", line, col, rule);\n\
        }\n\
      }\n\
    });\n\
  }\n\
});\n\
\n\
/*\n\
 * Rule: Headings (h1-h6) should not be qualified (namespaced).\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"qualified-headings\",\n\
    name: \"Disallow qualified headings\",\n\
    desc: \"Headings should not be qualified (namespaced).\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-qualified-headings\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                i, j;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
\n\
                for (j=0; j < selector.parts.length; j++) {\n\
                    part = selector.parts[j];\n\
                    if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0) {\n\
                            reporter.report(\"Heading (\" + part.elementName + \") should not be qualified.\", part.line, part.col, rule);\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Selectors that look like regular expressions are slow and should be avoided.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"regex-selectors\",\n\
    name: \"Disallow selectors that look like regexs\",\n\
    desc: \"Selectors that look like regular expressions are slow and should be avoided.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-selectors-that-look-like-regular-expressions\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                modifier,\n\
                i, j, k;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
                for (j=0; j < selector.parts.length; j++) {\n\
                    part = selector.parts[j];\n\
                    if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                        for (k=0; k < part.modifiers.length; k++) {\n\
                            modifier = part.modifiers[k];\n\
                            if (modifier.type === \"attribute\") {\n\
                                if (/([~\\|\\^\\$\\*]=)/.test(modifier)) {\n\
                                    reporter.report(\"Attribute selectors with \" + RegExp.$1 + \" are slow!\", modifier.line, modifier.col, rule);\n\
                                }\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Total number of rules should not exceed x.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"rules-count\",\n\
    name: \"Rules Count\",\n\
    desc: \"Track how many rules there are.\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var count = 0;\n\
\n\
        // count each rule\n\
        parser.addListener(\"startrule\", function() {\n\
            count++;\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            reporter.stat(\"rule-count\", count);\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Warn people with approaching the IE 4095 limit\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"selector-max-approaching\",\n\
    name: \"Warn when approaching the 4095 selector limit for IE\",\n\
    desc: \"Will warn when selector count is >= 3800 selectors.\",\n\
    browsers: \"IE\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this, count = 0;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            count += event.selectors.length;\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            if (count >= 3800) {\n\
                reporter.report(\"You have \" + count + \" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\", 0, 0, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Warn people past the IE 4095 limit\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"selector-max\",\n\
    name: \"Error when past the 4095 selector limit for IE\",\n\
    desc: \"Will error when selector count is > 4095.\",\n\
    browsers: \"IE\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this, count = 0;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            count += event.selectors.length;\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            if (count > 4095) {\n\
                reporter.report(\"You have \" + count + \" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\", 0, 0, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Avoid new-line characters in selectors.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"selector-newline\",\n\
    name: \"Disallow new-line characters in selectors\",\n\
    desc: \"New-line characters in selectors are usually a forgotten comma and not a descendant combinator.\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        function startRule(event) {\n\
            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,\n\
                selectors = event.selectors;\n\
\n\
            for (i = 0, len = selectors.length; i < len; i++) {\n\
                selector = selectors[i];\n\
                for (p = 0, pLen = selector.parts.length; p < pLen; p++) {\n\
                    for (n = p + 1; n < pLen; n++) {\n\
                        part = selector.parts[p];\n\
                        part2 = selector.parts[n];\n\
                        type = part.type;\n\
                        currentLine = part.line;\n\
                        nextLine = part2.line;\n\
\n\
                        if (type === \"descendant\" && nextLine > currentLine) {\n\
                            reporter.report(\"newline character found in selector (forgot a comma?)\", currentLine, selectors[i].parts[0].col, rule);\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Use shorthand properties where possible.\n\
 *\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"shorthand\",\n\
    name: \"Require shorthand properties\",\n\
    desc: \"Use shorthand properties where possible.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-shorthand-properties\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            prop, i, len,\n\
            propertiesToCheck = {},\n\
            properties,\n\
            mapping = {\n\
                \"margin\": [\n\
                    \"margin-top\",\n\
                    \"margin-bottom\",\n\
                    \"margin-left\",\n\
                    \"margin-right\"\n\
                ],\n\
                \"padding\": [\n\
                    \"padding-top\",\n\
                    \"padding-bottom\",\n\
                    \"padding-left\",\n\
                    \"padding-right\"\n\
                ]\n\
            };\n\
\n\
        // initialize propertiesToCheck\n\
        for (prop in mapping) {\n\
            if (mapping.hasOwnProperty(prop)) {\n\
                for (i=0, len=mapping[prop].length; i < len; i++) {\n\
                    propertiesToCheck[mapping[prop][i]] = prop;\n\
                }\n\
            }\n\
        }\n\
\n\
        function startRule() {\n\
            properties = {};\n\
        }\n\
\n\
        // event handler for end of rules\n\
        function endRule(event) {\n\
\n\
            var prop, i, len, total;\n\
\n\
            // check which properties this rule has\n\
            for (prop in mapping) {\n\
                if (mapping.hasOwnProperty(prop)) {\n\
                    total=0;\n\
\n\
                    for (i=0, len=mapping[prop].length; i < len; i++) {\n\
                        total += properties[mapping[prop][i]] ? 1 : 0;\n\
                    }\n\
\n\
                    if (total === mapping[prop].length) {\n\
                        reporter.report(\"The properties \" + mapping[prop].join(\", \") + \" can be replaced by \" + prop + \".\", event.line, event.col, rule);\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
\n\
        // check for use of \"font-size\"\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.toString().toLowerCase();\n\
\n\
            if (propertiesToCheck[name]) {\n\
                properties[name] = 1;\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use properties with a star prefix.\n\
 *\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"star-property-hack\",\n\
    name: \"Disallow properties with a star prefix\",\n\
    desc: \"Checks for the star property hack (targets IE6/7)\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-star-hack\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        // check if property name starts with \"*\"\n\
        parser.addListener(\"property\", function(event) {\n\
            var property = event.property;\n\
\n\
            if (property.hack === \"*\") {\n\
                reporter.report(\"Property with star prefix found.\", event.property.line, event.property.col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use text-indent for image replacement if you need to support rtl.\n\
 *\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"text-indent\",\n\
    name: \"Disallow negative text-indent\",\n\
    desc: \"Checks for text indent less than -99px\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-negative-text-indent\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            textIndent,\n\
            direction;\n\
\n\
\n\
        function startRule() {\n\
            textIndent = false;\n\
            direction = \"inherit\";\n\
        }\n\
\n\
        // event handler for end of rules\n\
        function endRule() {\n\
            if (textIndent && direction !== \"ltr\") {\n\
                reporter.report(\"Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.\", textIndent.line, textIndent.col, rule);\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
\n\
        // check for use of \"font-size\"\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.toString().toLowerCase(),\n\
                value = event.value;\n\
\n\
            if (name === \"text-indent\" && value.parts[0].value < -99) {\n\
                textIndent = event.property;\n\
            } else if (name === \"direction\" && value.toString() === \"ltr\") {\n\
                direction = \"ltr\";\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use properties with a underscore prefix.\n\
 *\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"underscore-property-hack\",\n\
    name: \"Disallow properties with an underscore prefix\",\n\
    desc: \"Checks for the underscore property hack (targets IE6)\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-underscore-hack\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        // check if property name starts with \"_\"\n\
        parser.addListener(\"property\", function(event) {\n\
            var property = event.property;\n\
\n\
            if (property.hack === \"_\") {\n\
                reporter.report(\"Property with underscore prefix found.\", event.property.line, event.property.col, rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Headings (h1-h6) should be defined only once.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"unique-headings\",\n\
    name: \"Headings should only be defined once\",\n\
    desc: \"Headings should be defined only once.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Headings-should-only-be-defined-once\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        var headings = {\n\
            h1: 0,\n\
            h2: 0,\n\
            h3: 0,\n\
            h4: 0,\n\
            h5: 0,\n\
            h6: 0\n\
        };\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                pseudo,\n\
                i, j;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
                part = selector.parts[selector.parts.length-1];\n\
\n\
                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())) {\n\
\n\
                    for (j=0; j < part.modifiers.length; j++) {\n\
                        if (part.modifiers[j].type === \"pseudo\") {\n\
                            pseudo = true;\n\
                            break;\n\
                        }\n\
                    }\n\
\n\
                    if (!pseudo) {\n\
                        headings[RegExp.$1]++;\n\
                        if (headings[RegExp.$1] > 1) {\n\
                            reporter.report(\"Heading (\" + part.elementName + \") has already been defined.\", part.line, part.col, rule);\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
\n\
        parser.addListener(\"endstylesheet\", function() {\n\
            var prop,\n\
                messages = [];\n\
\n\
            for (prop in headings) {\n\
                if (headings.hasOwnProperty(prop)) {\n\
                    if (headings[prop] > 1) {\n\
                        messages.push(headings[prop] + \" \" + prop + \"s\");\n\
                    }\n\
                }\n\
            }\n\
\n\
            if (messages.length) {\n\
                reporter.rollupWarn(\"You have \" + messages.join(\", \") + \" defined in this stylesheet.\", rule);\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use universal selector because it's slow.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"universal-selector\",\n\
    name: \"Disallow universal selector\",\n\
    desc: \"The universal selector (*) is known to be slow.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-universal-selector\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
            var selectors = event.selectors,\n\
                selector,\n\
                part,\n\
                i;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
\n\
                part = selector.parts[selector.parts.length-1];\n\
                if (part.elementName === \"*\") {\n\
                    reporter.report(rule.desc, part.line, part.col, rule);\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: Don't use unqualified attribute selectors because they're just like universal selectors.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"unqualified-attributes\",\n\
    name: \"Disallow unqualified attribute selectors\",\n\
    desc: \"Unqualified attribute selectors are known to be slow.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-unqualified-attribute-selectors\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
\n\
        var rule = this;\n\
\n\
        parser.addListener(\"startrule\", function(event) {\n\
\n\
            var selectors = event.selectors,\n\
                selectorContainsClassOrId = false,\n\
                selector,\n\
                part,\n\
                modifier,\n\
                i, k;\n\
\n\
            for (i=0; i < selectors.length; i++) {\n\
                selector = selectors[i];\n\
\n\
                part = selector.parts[selector.parts.length-1];\n\
                if (part.type === parser.SELECTOR_PART_TYPE) {\n\
                    for (k=0; k < part.modifiers.length; k++) {\n\
                        modifier = part.modifiers[k];\n\
\n\
                        if (modifier.type === \"class\" || modifier.type === \"id\") {\n\
                            selectorContainsClassOrId = true;\n\
                            break;\n\
                        }\n\
                    }\n\
\n\
                    if (!selectorContainsClassOrId) {\n\
                        for (k=0; k < part.modifiers.length; k++) {\n\
                            modifier = part.modifiers[k];\n\
                            if (modifier.type === \"attribute\" && (!part.elementName || part.elementName === \"*\")) {\n\
                                reporter.report(rule.desc, part.line, part.col, rule);\n\
                            }\n\
                        }\n\
                    }\n\
                }\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: When using a vendor-prefixed property, make sure to\n\
 * include the standard one.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"vendor-prefix\",\n\
    name: \"Require standard property with vendor prefix\",\n\
    desc: \"When using a vendor-prefixed property, make sure to include the standard one.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Require-standard-property-with-vendor-prefix\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this,\n\
            properties,\n\
            num,\n\
            propertiesToCheck = {\n\
                \"-webkit-border-radius\": \"border-radius\",\n\
                \"-webkit-border-top-left-radius\": \"border-top-left-radius\",\n\
                \"-webkit-border-top-right-radius\": \"border-top-right-radius\",\n\
                \"-webkit-border-bottom-left-radius\": \"border-bottom-left-radius\",\n\
                \"-webkit-border-bottom-right-radius\": \"border-bottom-right-radius\",\n\
\n\
                \"-o-border-radius\": \"border-radius\",\n\
                \"-o-border-top-left-radius\": \"border-top-left-radius\",\n\
                \"-o-border-top-right-radius\": \"border-top-right-radius\",\n\
                \"-o-border-bottom-left-radius\": \"border-bottom-left-radius\",\n\
                \"-o-border-bottom-right-radius\": \"border-bottom-right-radius\",\n\
\n\
                \"-moz-border-radius\": \"border-radius\",\n\
                \"-moz-border-radius-topleft\": \"border-top-left-radius\",\n\
                \"-moz-border-radius-topright\": \"border-top-right-radius\",\n\
                \"-moz-border-radius-bottomleft\": \"border-bottom-left-radius\",\n\
                \"-moz-border-radius-bottomright\": \"border-bottom-right-radius\",\n\
\n\
                \"-moz-column-count\": \"column-count\",\n\
                \"-webkit-column-count\": \"column-count\",\n\
\n\
                \"-moz-column-gap\": \"column-gap\",\n\
                \"-webkit-column-gap\": \"column-gap\",\n\
\n\
                \"-moz-column-rule\": \"column-rule\",\n\
                \"-webkit-column-rule\": \"column-rule\",\n\
\n\
                \"-moz-column-rule-style\": \"column-rule-style\",\n\
                \"-webkit-column-rule-style\": \"column-rule-style\",\n\
\n\
                \"-moz-column-rule-color\": \"column-rule-color\",\n\
                \"-webkit-column-rule-color\": \"column-rule-color\",\n\
\n\
                \"-moz-column-rule-width\": \"column-rule-width\",\n\
                \"-webkit-column-rule-width\": \"column-rule-width\",\n\
\n\
                \"-moz-column-width\": \"column-width\",\n\
                \"-webkit-column-width\": \"column-width\",\n\
\n\
                \"-webkit-column-span\": \"column-span\",\n\
                \"-webkit-columns\": \"columns\",\n\
\n\
                \"-moz-box-shadow\": \"box-shadow\",\n\
                \"-webkit-box-shadow\": \"box-shadow\",\n\
\n\
                \"-moz-transform\": \"transform\",\n\
                \"-webkit-transform\": \"transform\",\n\
                \"-o-transform\": \"transform\",\n\
                \"-ms-transform\": \"transform\",\n\
\n\
                \"-moz-transform-origin\": \"transform-origin\",\n\
                \"-webkit-transform-origin\": \"transform-origin\",\n\
                \"-o-transform-origin\": \"transform-origin\",\n\
                \"-ms-transform-origin\": \"transform-origin\",\n\
\n\
                \"-moz-box-sizing\": \"box-sizing\",\n\
                \"-webkit-box-sizing\": \"box-sizing\"\n\
            };\n\
\n\
        // event handler for beginning of rules\n\
        function startRule() {\n\
            properties = {};\n\
            num = 1;\n\
        }\n\
\n\
        // event handler for end of rules\n\
        function endRule() {\n\
            var prop,\n\
                i,\n\
                len,\n\
                needed,\n\
                actual,\n\
                needsStandard = [];\n\
\n\
            for (prop in properties) {\n\
                if (propertiesToCheck[prop]) {\n\
                    needsStandard.push({\n\
                        actual: prop,\n\
                        needed: propertiesToCheck[prop]\n\
                    });\n\
                }\n\
            }\n\
\n\
            for (i=0, len=needsStandard.length; i < len; i++) {\n\
                needed = needsStandard[i].needed;\n\
                actual = needsStandard[i].actual;\n\
\n\
                if (!properties[needed]) {\n\
                    reporter.report(\"Missing standard property '\" + needed + \"' to go along with '\" + actual + \"'.\", properties[actual][0].name.line, properties[actual][0].name.col, rule);\n\
                } else {\n\
                    // make sure standard property is last\n\
                    if (properties[needed][0].pos < properties[actual][0].pos) {\n\
                        reporter.report(\"Standard property '\" + needed + \"' should come after vendor-prefixed property '\" + actual + \"'.\", properties[actual][0].name.line, properties[actual][0].name.col, rule);\n\
                    }\n\
                }\n\
            }\n\
        }\n\
\n\
        parser.addListener(\"startrule\", startRule);\n\
        parser.addListener(\"startfontface\", startRule);\n\
        parser.addListener(\"startpage\", startRule);\n\
        parser.addListener(\"startpagemargin\", startRule);\n\
        parser.addListener(\"startkeyframerule\", startRule);\n\
        parser.addListener(\"startviewport\", startRule);\n\
\n\
        parser.addListener(\"property\", function(event) {\n\
            var name = event.property.text.toLowerCase();\n\
\n\
            if (!properties[name]) {\n\
                properties[name] = [];\n\
            }\n\
\n\
            properties[name].push({\n\
                name: event.property,\n\
                value: event.value,\n\
                pos: num++\n\
            });\n\
        });\n\
\n\
        parser.addListener(\"endrule\", endRule);\n\
        parser.addListener(\"endfontface\", endRule);\n\
        parser.addListener(\"endpage\", endRule);\n\
        parser.addListener(\"endpagemargin\", endRule);\n\
        parser.addListener(\"endkeyframerule\", endRule);\n\
        parser.addListener(\"endviewport\", endRule);\n\
    }\n\
});\n\
\n\
/*\n\
 * Rule: You don't need to specify units when a value is 0.\n\
 */\n\
\n\
CSSLint.addRule({\n\
\n\
    // rule information\n\
    id: \"zero-units\",\n\
    name: \"Disallow units for 0 values\",\n\
    desc: \"You don't need to specify units when a value is 0.\",\n\
    url: \"https://github.com/CSSLint/csslint/wiki/Disallow-units-for-zero-values\",\n\
    browsers: \"All\",\n\
\n\
    // initialization\n\
    init: function(parser, reporter) {\n\
        \"use strict\";\n\
        var rule = this;\n\
\n\
        // count how many times \"float\" is used\n\
        parser.addListener(\"property\", function(event) {\n\
            var parts = event.value.parts,\n\
                i = 0,\n\
                len = parts.length;\n\
\n\
            while (i < len) {\n\
                if ((parts[i].units || parts[i].type === \"percentage\") && parts[i].value === 0 && parts[i].type !== \"time\") {\n\
                    reporter.report(\"Values of 0 shouldn't have units specified.\", parts[i].line, parts[i].col, rule);\n\
                }\n\
                i++;\n\
            }\n\
        });\n\
    }\n\
});\n\
\n\
(function() {\n\
    \"use strict\";\n\
\n\
    /**\n\
     * Replace special characters before write to output.\n\
     *\n\
     * Rules:\n\
     *  - single quotes is the escape sequence for double-quotes\n\
     *  - &amp; is the escape sequence for &\n\
     *  - &lt; is the escape sequence for <\n\
     *  - &gt; is the escape sequence for >\n\
     *\n\
     * @param {String} message to escape\n\
     * @return escaped message as {String}\n\
     */\n\
    var xmlEscape = function(str) {\n\
        if (!str || str.constructor !== String) {\n\
            return \"\";\n\
        }\n\
\n\
        return str.replace(/[\"&><]/g, function(match) {\n\
            switch (match) {\n\
                case \"\\\"\":\n\
                    return \"&quot;\";\n\
                case \"&\":\n\
                    return \"&amp;\";\n\
                case \"<\":\n\
                    return \"&lt;\";\n\
                case \">\":\n\
                    return \"&gt;\";\n\
            }\n\
        });\n\
    };\n\
\n\
    CSSLint.addFormatter({\n\
        // format information\n\
        id: \"checkstyle-xml\",\n\
        name: \"Checkstyle XML format\",\n\
\n\
        /**\n\
         * Return opening root XML tag.\n\
         * @return {String} to prepend before all results\n\
         */\n\
        startFormat: function() {\n\
            return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><checkstyle>\";\n\
        },\n\
\n\
        /**\n\
         * Return closing root XML tag.\n\
         * @return {String} to append after all results\n\
         */\n\
        endFormat: function() {\n\
            return \"</checkstyle>\";\n\
        },\n\
\n\
        /**\n\
         * Returns message when there is a file read error.\n\
         * @param {String} filename The name of the file that caused the error.\n\
         * @param {String} message The error message\n\
         * @return {String} The error message.\n\
         */\n\
        readError: function(filename, message) {\n\
            return \"<file name=\\\"\" + xmlEscape(filename) + \"\\\"><error line=\\\"0\\\" column=\\\"0\\\" severty=\\\"error\\\" message=\\\"\" + xmlEscape(message) + \"\\\"></error></file>\";\n\
        },\n\
\n\
        /**\n\
         * Given CSS Lint results for a file, return output for this format.\n\
         * @param results {Object} with error and warning messages\n\
         * @param filename {String} relative file path\n\
         * @param options {Object} (UNUSED for now) specifies special handling of output\n\
         * @return {String} output for results\n\
         */\n\
        formatResults: function(results, filename/*, options*/) {\n\
            var messages = results.messages,\n\
                output = [];\n\
\n\
            /**\n\
             * Generate a source string for a rule.\n\
             * Checkstyle source strings usually resemble Java class names e.g\n\
             * net.csslint.SomeRuleName\n\
             * @param {Object} rule\n\
             * @return rule source as {String}\n\
             */\n\
            var generateSource = function(rule) {\n\
                if (!rule || !(\"name\" in rule)) {\n\
                    return \"\";\n\
                }\n\
                return \"net.csslint.\" + rule.name.replace(/\\s/g, \"\");\n\
            };\n\
\n\
\n\
            if (messages.length > 0) {\n\
                output.push(\"<file name=\\\"\"+filename+\"\\\">\");\n\
                CSSLint.Util.forEach(messages, function (message) {\n\
                    // ignore rollups for now\n\
                    if (!message.rollup) {\n\
                        output.push(\"<error line=\\\"\" + message.line + \"\\\" column=\\\"\" + message.col + \"\\\" severity=\\\"\" + message.type + \"\\\"\" +\n\
                          \" message=\\\"\" + xmlEscape(message.message) + \"\\\" source=\\\"\" + generateSource(message.rule) +\"\\\"/>\");\n\
                    }\n\
                });\n\
                output.push(\"</file>\");\n\
            }\n\
\n\
            return output.join(\"\");\n\
        }\n\
    });\n\
}());\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"compact\",\n\
    name: \"Compact, 'porcelain' format\",\n\
\n\
    /**\n\
     * Return content to be printed before all file results.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        return \"\";\n\
    },\n\
\n\
    /**\n\
     * Return content to be printed after all file results.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        return \"\";\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path\n\
     * @param options {Object} (Optional) specifies special handling of output\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename, options) {\n\
        \"use strict\";\n\
        var messages = results.messages,\n\
            output = \"\";\n\
        options = options || {};\n\
\n\
        /**\n\
         * Capitalize and return given string.\n\
         * @param str {String} to capitalize\n\
         * @return {String} capitalized\n\
         */\n\
        var capitalize = function(str) {\n\
            return str.charAt(0).toUpperCase() + str.slice(1);\n\
        };\n\
\n\
        if (messages.length === 0) {\n\
            return options.quiet ? \"\" : filename + \": Lint Free!\";\n\
        }\n\
\n\
        CSSLint.Util.forEach(messages, function(message) {\n\
            if (message.rollup) {\n\
                output += filename + \": \" + capitalize(message.type) + \" - \" + message.message + \" (\" + message.rule.id + \")\\n\";\n\
            } else {\n\
                output += filename + \": line \" + message.line +\n\
                    \", col \" + message.col + \", \" + capitalize(message.type) + \" - \" + message.message + \" (\" + message.rule.id + \")\\n\";\n\
            }\n\
        });\n\
\n\
        return output;\n\
    }\n\
});\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"csslint-xml\",\n\
    name: \"CSSLint XML format\",\n\
\n\
    /**\n\
     * Return opening root XML tag.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><csslint>\";\n\
    },\n\
\n\
    /**\n\
     * Return closing root XML tag.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        return \"</csslint>\";\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path\n\
     * @param options {Object} (UNUSED for now) specifies special handling of output\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename/*, options*/) {\n\
        \"use strict\";\n\
        var messages = results.messages,\n\
            output = [];\n\
\n\
        /**\n\
         * Replace special characters before write to output.\n\
         *\n\
         * Rules:\n\
         *  - single quotes is the escape sequence for double-quotes\n\
         *  - &amp; is the escape sequence for &\n\
         *  - &lt; is the escape sequence for <\n\
         *  - &gt; is the escape sequence for >\n\
         *\n\
         * @param {String} message to escape\n\
         * @return escaped message as {String}\n\
         */\n\
        var escapeSpecialCharacters = function(str) {\n\
            if (!str || str.constructor !== String) {\n\
                return \"\";\n\
            }\n\
            return str.replace(/\"/g, \"'\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\
        };\n\
\n\
        if (messages.length > 0) {\n\
            output.push(\"<file name=\\\"\"+filename+\"\\\">\");\n\
            CSSLint.Util.forEach(messages, function (message) {\n\
                if (message.rollup) {\n\
                    output.push(\"<issue severity=\\\"\" + message.type + \"\\\" reason=\\\"\" + escapeSpecialCharacters(message.message) + \"\\\" evidence=\\\"\" + escapeSpecialCharacters(message.evidence) + \"\\\"/>\");\n\
                } else {\n\
                    output.push(\"<issue line=\\\"\" + message.line + \"\\\" char=\\\"\" + message.col + \"\\\" severity=\\\"\" + message.type + \"\\\"\" +\n\
                        \" reason=\\\"\" + escapeSpecialCharacters(message.message) + \"\\\" evidence=\\\"\" + escapeSpecialCharacters(message.evidence) + \"\\\"/>\");\n\
                }\n\
            });\n\
            output.push(\"</file>\");\n\
        }\n\
\n\
        return output.join(\"\");\n\
    }\n\
});\n\
\n\
/* globals JSON: true */\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"json\",\n\
    name: \"JSON\",\n\
\n\
    /**\n\
     * Return content to be printed before all file results.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        this.json = [];\n\
        return \"\";\n\
    },\n\
\n\
    /**\n\
     * Return content to be printed after all file results.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        var ret = \"\";\n\
        if (this.json.length > 0) {\n\
            if (this.json.length === 1) {\n\
                ret = JSON.stringify(this.json[0]);\n\
            } else {\n\
                ret = JSON.stringify(this.json);\n\
            }\n\
        }\n\
        return ret;\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path (Unused)\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename, options) {\n\
        \"use strict\";\n\
        if (results.messages.length > 0 || !options.quiet) {\n\
            this.json.push({\n\
                filename: filename,\n\
                messages: results.messages,\n\
                stats: results.stats\n\
            });\n\
        }\n\
        return \"\";\n\
    }\n\
});\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"junit-xml\",\n\
    name: \"JUNIT XML format\",\n\
\n\
    /**\n\
     * Return opening root XML tag.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><testsuites>\";\n\
    },\n\
\n\
    /**\n\
     * Return closing root XML tag.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        return \"</testsuites>\";\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path\n\
     * @param options {Object} (UNUSED for now) specifies special handling of output\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename/*, options*/) {\n\
        \"use strict\";\n\
\n\
        var messages = results.messages,\n\
            output = [],\n\
            tests = {\n\
                \"error\": 0,\n\
                \"failure\": 0\n\
            };\n\
\n\
        /**\n\
         * Generate a source string for a rule.\n\
         * JUNIT source strings usually resemble Java class names e.g\n\
         * net.csslint.SomeRuleName\n\
         * @param {Object} rule\n\
         * @return rule source as {String}\n\
         */\n\
        var generateSource = function(rule) {\n\
            if (!rule || !(\"name\" in rule)) {\n\
                return \"\";\n\
            }\n\
            return \"net.csslint.\" + rule.name.replace(/\\s/g, \"\");\n\
        };\n\
\n\
        /**\n\
         * Replace special characters before write to output.\n\
         *\n\
         * Rules:\n\
         *  - single quotes is the escape sequence for double-quotes\n\
         *  - &lt; is the escape sequence for <\n\
         *  - &gt; is the escape sequence for >\n\
         *\n\
         * @param {String} message to escape\n\
         * @return escaped message as {String}\n\
         */\n\
        var escapeSpecialCharacters = function(str) {\n\
\n\
            if (!str || str.constructor !== String) {\n\
                return \"\";\n\
            }\n\
\n\
            return str.replace(/\"/g, \"'\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\
        };\n\
\n\
        if (messages.length > 0) {\n\
\n\
            messages.forEach(function (message) {\n\
\n\
                // since junit has no warning class\n\
                // all issues as errors\n\
                var type = message.type === \"warning\" ? \"error\" : message.type;\n\
\n\
                // ignore rollups for now\n\
                if (!message.rollup) {\n\
\n\
                    // build the test case separately, once joined\n\
                    // we'll add it to a custom array filtered by type\n\
                    output.push(\"<testcase time=\\\"0\\\" name=\\\"\" + generateSource(message.rule) + \"\\\">\");\n\
                    output.push(\"<\" + type + \" message=\\\"\" + escapeSpecialCharacters(message.message) + \"\\\"><![CDATA[\" + message.line + \":\" + message.col + \":\" + escapeSpecialCharacters(message.evidence) + \"]]></\" + type + \">\");\n\
                    output.push(\"</testcase>\");\n\
\n\
                    tests[type] += 1;\n\
                }\n\
            });\n\
\n\
            output.unshift(\"<testsuite time=\\\"0\\\" tests=\\\"\" + messages.length + \"\\\" skipped=\\\"0\\\" errors=\\\"\" + tests.error + \"\\\" failures=\\\"\" + tests.failure + \"\\\" package=\\\"net.csslint\\\" name=\\\"\" + filename + \"\\\">\");\n\
            output.push(\"</testsuite>\");\n\
        }\n\
\n\
        return output.join(\"\");\n\
    }\n\
});\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"lint-xml\",\n\
    name: \"Lint XML format\",\n\
\n\
    /**\n\
     * Return opening root XML tag.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        return \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><lint>\";\n\
    },\n\
\n\
    /**\n\
     * Return closing root XML tag.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        return \"</lint>\";\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path\n\
     * @param options {Object} (UNUSED for now) specifies special handling of output\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename/*, options*/) {\n\
        \"use strict\";\n\
        var messages = results.messages,\n\
            output = [];\n\
\n\
        /**\n\
         * Replace special characters before write to output.\n\
         *\n\
         * Rules:\n\
         *  - single quotes is the escape sequence for double-quotes\n\
         *  - &amp; is the escape sequence for &\n\
         *  - &lt; is the escape sequence for <\n\
         *  - &gt; is the escape sequence for >\n\
         *\n\
         * @param {String} message to escape\n\
         * @return escaped message as {String}\n\
         */\n\
        var escapeSpecialCharacters = function(str) {\n\
            if (!str || str.constructor !== String) {\n\
                return \"\";\n\
            }\n\
            return str.replace(/\"/g, \"'\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\
        };\n\
\n\
        if (messages.length > 0) {\n\
\n\
            output.push(\"<file name=\\\"\"+filename+\"\\\">\");\n\
            CSSLint.Util.forEach(messages, function (message) {\n\
                if (message.rollup) {\n\
                    output.push(\"<issue severity=\\\"\" + message.type + \"\\\" reason=\\\"\" + escapeSpecialCharacters(message.message) + \"\\\" evidence=\\\"\" + escapeSpecialCharacters(message.evidence) + \"\\\"/>\");\n\
                } else {\n\
                    var rule = \"\";\n\
                    if (message.rule && message.rule.id) {\n\
                        rule = \"rule=\\\"\" + escapeSpecialCharacters(message.rule.id) + \"\\\" \";\n\
                    }\n\
                    output.push(\"<issue \" + rule + \"line=\\\"\" + message.line + \"\\\" char=\\\"\" + message.col + \"\\\" severity=\\\"\" + message.type + \"\\\"\" +\n\
                        \" reason=\\\"\" + escapeSpecialCharacters(message.message) + \"\\\" evidence=\\\"\" + escapeSpecialCharacters(message.evidence) + \"\\\"/>\");\n\
                }\n\
            });\n\
            output.push(\"</file>\");\n\
        }\n\
\n\
        return output.join(\"\");\n\
    }\n\
});\n\
\n\
CSSLint.addFormatter({\n\
    // format information\n\
    id: \"text\",\n\
    name: \"Plain Text\",\n\
\n\
    /**\n\
     * Return content to be printed before all file results.\n\
     * @return {String} to prepend before all results\n\
     */\n\
    startFormat: function() {\n\
        \"use strict\";\n\
        return \"\";\n\
    },\n\
\n\
    /**\n\
     * Return content to be printed after all file results.\n\
     * @return {String} to append after all results\n\
     */\n\
    endFormat: function() {\n\
        \"use strict\";\n\
        return \"\";\n\
    },\n\
\n\
    /**\n\
     * Given CSS Lint results for a file, return output for this format.\n\
     * @param results {Object} with error and warning messages\n\
     * @param filename {String} relative file path\n\
     * @param options {Object} (Optional) specifies special handling of output\n\
     * @return {String} output for results\n\
     */\n\
    formatResults: function(results, filename, options) {\n\
        \"use strict\";\n\
        var messages = results.messages,\n\
            output = \"\";\n\
        options = options || {};\n\
\n\
        if (messages.length === 0) {\n\
            return options.quiet ? \"\" : \"\\n\\ncsslint: No errors in \" + filename + \".\";\n\
        }\n\
\n\
        output = \"\\n\\ncsslint: There \";\n\
        if (messages.length === 1) {\n\
            output += \"is 1 problem\";\n\
        } else {\n\
            output += \"are \" + messages.length + \" problems\";\n\
        }\n\
        output += \" in \" + filename + \".\";\n\
\n\
        var pos = filename.lastIndexOf(\"/\"),\n\
            shortFilename = filename;\n\
\n\
        if (pos === -1) {\n\
            pos = filename.lastIndexOf(\"\\\\\");\n\
        }\n\
        if (pos > -1) {\n\
            shortFilename = filename.substring(pos+1);\n\
        }\n\
\n\
        CSSLint.Util.forEach(messages, function (message, i) {\n\
            output = output + \"\\n\\n\" + shortFilename;\n\
            if (message.rollup) {\n\
                output += \"\\n\" + (i+1) + \": \" + message.type;\n\
                output += \"\\n\" + message.message;\n\
            } else {\n\
                output += \"\\n\" + (i+1) + \": \" + message.type + \" at line \" + message.line + \", col \" + message.col;\n\
                output += \"\\n\" + message.message;\n\
                output += \"\\n\" + message.evidence;\n\
            }\n\
        });\n\
\n\
        return output;\n\
    }\n\
});\n\
\n\
return CSSLint;\n\
})();\n\
\n\
\n\
/*\n\
repo https://github.com/douglascrockford/JSLint/tree/bca8b225a376352899d634442802b241fee8b97b\n\
committed 2020-11-06T17:58:13Z\n\
*/\n\
\n\
\n\
/*\n\
file https://github.com/douglascrockford/JSLint/blob/bca8b225a376352899d634442802b241fee8b97b/jslint.js\n\
*/\n\
// jslint.js\n\
// 2020-11-06\n\
// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\
\n\
// Permission is hereby granted, free of charge, to any person obtaining a copy\n\
// of this software and associated documentation files (the \"Software\"), to deal\n\
// in the Software without restriction, including without limitation the rights\n\
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
// copies of the Software, and to permit persons to whom the Software is\n\
// furnished to do so, subject to the following conditions:\n\
\n\
// The above copyright notice and this permission notice shall be included in\n\
// all copies or substantial portions of the Software.\n\
\n\
// The Software shall be used for Good, not Evil.\n\
\n\
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\
// SOFTWARE.\n\
\n\
// jslint(source, option_object, global_array) is a function that takes 3\n\
// arguments. The second two arguments are optional.\n\
\n\
//      source          A text to analyze, a string or an array of strings.\n\
//      option_object   An object whose keys correspond to option names.\n\
//      global_array    An array of strings containing global variables that\n\
//                      the file is allowed readonly access.\n\
\n\
// jslint returns an object containing its results. The object contains a lot\n\
// of valuable information. It can be used to generate reports. The object\n\
// contains:\n\
\n\
//      directives: an array of directive comment tokens.\n\
//      edition: the version of JSLint that did the analysis.\n\
//      exports: the names exported from the module.\n\
//      froms: an array of strings representing each of the imports.\n\
//      functions: an array of objects that represent all of the functions\n\
//              declared in the file.\n\
//      global: an object representing the global object. Its .context property\n\
//              is an object containing a property for each global variable.\n\
//      id: \"(JSLint)\"\n\
//      json: true if the file is a JSON text.\n\
//      lines: an array of strings, the source.\n\
//      module: true if an import or export statement was used.\n\
//      ok: true if no warnings were generated. This is what you want.\n\
//      option: the option argument.\n\
//      property: a property object.\n\
//      stop: true if JSLint was unable to finish. You don't want this.\n\
//      tokens: an array of objects representing the tokens in the file.\n\
//      tree: the token objects arranged in a tree.\n\
//      warnings: an array of warning objects. A warning object can contain:\n\
//          name: \"JSLintError\"\n\
//          column: A column number in the file.\n\
//          line: A line number in the file.\n\
//          code: A warning code string.\n\
//          message: The warning message string.\n\
//          a: Exhibit A.\n\
//          b: Exhibit B.\n\
//          c: Exhibit C.\n\
//          d: Exhibit D.\n\
\n\
// jslint works in several phases. In any of these phases, errors might be\n\
// found. Sometimes JSLint is able to recover from an error and continue\n\
// parsing. In some cases, it cannot and will stop early. If that should happen,\n\
// repair your code and try again.\n\
\n\
// Phases:\n\
\n\
//      1. If the source is a single string, split it into an array of strings.\n\
//      2. Turn the source into an array of tokens.\n\
//      3. Furcate the tokens into a parse tree.\n\
//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n\
//          recursive traversal. Each node may be processed on the way down\n\
//          (preaction) and on the way up (postaction).\n\
//      5. Check the whitespace between the tokens.\n\
\n\
// jslint can also examine JSON text. It decides that a file is JSON text if\n\
// the first token is \"[\" or \"{\". Processing of JSON text is much simpler than\n\
// the processing of JavaScript programs. Only the first three phases are\n\
// required.\n\
\n\
// WARNING: JSLint will hurt your feelings.\n\
\n\
// hack-jslint - property\n\
let line_ignore;\n\
let lines_extra;\n\
/*\\property\n\
    a, and, arity, assign, b, bad_assignment_a, bad_directive_a, bad_get,\n\
    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,\n\
    body, browser, c, calls, catch, charCodeAt, closer, closure, code, column,\n\
    concat, constant, context, convert, couch, create, d, dead, default, devel,\n\
    directive, directives, disrupt, dot, duplicate_a, edition, ellipsis, else,\n\
    empty_block, eval, every, expected_a, expected_a_at_b_c,\n\
    expected_a_b, expected_a_b_from_c_d, expected_a_before_b,\n\
    expected_a_next_at_b, expected_digits_after_a, expected_four_digits,\n\
    expected_identifier_a, expected_line_break_a_b, expected_regexp_factor_a,\n\
    expected_space_a_b, expected_statements_a, expected_string_a,\n\
    expected_type_string_a, exports, expression, extra, finally, flag, for,\n\
    forEach, free, freeze, freeze_exports, from, froms, fud, fudge,\n\
    function_in_loop, functions, g, getset, global, i, id, identifier, import,\n\
    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,\n\
    label, label_a, lbp, led, length, level, line, lines, live, long, loop, m,\n\
    margin, match, message, misplaced_a, misplaced_directive_a, missing_browser,\n\
    missing_m, module, naked_block, name, names, nested_comment, new, node,\n\
    not_label_a, nr, nud, number_isNaN, ok, open, opening, option,\n\
    out_of_scope_a, parameters, parent, pop, property, push, quote, raw,\n\
    redefinition_a_b, replace, required_a_optional_b, reserved_a, role, search,\n\
    shebang, signature, single, slice, some, sort, split, startsWith, statement,\n\
    stop, subscript_a, switch, test, this, thru, toString, todo_comment,\n\
    tokens, too_long, too_many_digits, tree, try, type, u, unclosed_comment,\n\
    unclosed_mega, unclosed_string, undeclared_a, unexpected_a,\n\
    unexpected_a_after_b, unexpected_a_before_b, unexpected_at_top_level_a,\n\
    unexpected_char_a, unexpected_comment, unexpected_directive_a,\n\
    unexpected_expression_a, unexpected_label_a, unexpected_parens,\n\
    unexpected_space_a_b, unexpected_statement_a, unexpected_trailing_space,\n\
    unexpected_typeof_a, uninitialized_a, unreachable_a,\n\
    unregistered_property_a, unused_a, use_double, use_open, use_spaces,\n\
    used, value, var_loop, var_switch, variable, warning, warnings,\n\
    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,\n\
    wrap_condition, wrap_immediate, wrap_parameter, wrap_regexp, wrap_unary,\n\
    wrapped, writable, y\n\
*/\n\
\n\
function empty() {\n\
\n\
// The empty function produces a new empty object that inherits nothing. This is\n\
// much better than '{}' because confusions around accidental method names like\n\
// 'constructor' are completely avoided.\n\
\n\
    return Object.create(null);\n\
}\n\
\n\
function populate(array, object = empty(), value = true) {\n\
\n\
// Augment an object by taking property names from an array of strings.\n\
\n\
    array.forEach(function (name) {\n\
        object[name] = value;\n\
    });\n\
    return object;\n\
}\n\
\n\
const allowed_option = {\n\
    // hack-jslint - allowed_option extra\n\
    debug: true,\n\
    nomen: true,\n\
    throw_error: true,\n\
\n\
// These are the options that are recognized in the option object or that may\n\
// appear in a /*jslint*/ directive. Most options will have a boolean value,\n\
// usually true. Some options will also predefine some number of global\n\
// variables.\n\
\n\
    bitwise: true,\n\
    browser: [\n\
        \"caches\", \"CharacterData\", \"clearInterval\", \"clearTimeout\", \"document\",\n\
        \"DocumentType\", \"DOMException\", \"Element\", \"Event\", \"event\", \"fetch\",\n\
        \"FileReader\", \"FontFace\", \"FormData\", \"history\", \"IntersectionObserver\",\n\
        \"localStorage\", \"location\", \"MutationObserver\", \"name\", \"navigator\",\n\
        \"screen\", \"sessionStorage\", \"setInterval\", \"setTimeout\", \"Storage\",\n\
        \"TextDecoder\", \"TextEncoder\", \"URL\", \"window\", \"Worker\",\n\
        \"XMLHttpRequest\"\n\
    ],\n\
    couch: [\n\
        \"emit\", \"getRow\", \"isArray\", \"log\", \"provides\", \"registerType\",\n\
        \"require\", \"send\", \"start\", \"sum\", \"toJSON\"\n\
    ],\n\
    convert: true,\n\
    devel: [\n\
        \"alert\", \"confirm\", \"console\", \"prompt\"\n\
    ],\n\
    eval: true,\n\
    for: true,\n\
    fudge: true,\n\
    getset: true,\n\
    long: true,\n\
    node: [\n\
        \"Buffer\", \"clearImmediate\", \"clearInterval\", \"clearTimeout\",\n\
        \"console\", \"exports\", \"module\", \"process\", \"require\",\n\
        \"setImmediate\", \"setInterval\", \"setTimeout\", \"TextDecoder\",\n\
        \"TextEncoder\", \"URL\", \"URLSearchParams\", \"__dirname\", \"__filename\"\n\
    ],\n\
    single: true,\n\
    this: true,\n\
    white: true\n\
};\n\
\n\
const anticondition = populate([\n\
    \"?\", \"~\", \"&\", \"|\", \"^\", \"<<\", \">>\", \">>>\", \"+\", \"-\", \"*\", \"/\", \"%\",\n\
    \"typeof\", \"(number)\", \"(string)\"\n\
]);\n\
\n\
// These are the bitwise operators.\n\
\n\
const bitwiseop = populate([\n\
    \"~\", \"^\", \"^=\", \"&\", \"&=\", \"|\", \"|=\", \"<<\", \"<<=\", \">>\", \">>=\",\n\
    \">>>\", \">>>=\"\n\
]);\n\
\n\
const escapeable = populate([\n\
    \"\\\\\", \"/\", \"`\", \"b\", \"f\", \"n\", \"r\", \"t\"\n\
]);\n\
\n\
const opener = {\n\
\n\
// The open and close pairs.\n\
\n\
    \"(\": \")\",       // paren\n\
    \"[\": \"]\",       // bracket\n\
    \"{\": \"}\",       // brace\n\
    \"${\": \"}\"       // mega\n\
};\n\
\n\
// The relational operators.\n\
\n\
const relationop = populate([\n\
    \"!=\", \"!==\", \"==\", \"===\", \"<\", \"<=\", \">\", \">=\"\n\
]);\n\
\n\
// This is the set of infix operators that require a space on each side.\n\
\n\
const spaceop = populate([\n\
    \"!=\", \"!==\", \"%\", \"%=\", \"&\", \"&=\", \"&&\", \"*\", \"*=\", \"+=\", \"-=\", \"/\",\n\
    \"/=\", \"<\", \"<=\", \"<<\", \"<<=\", \"=\", \"==\", \"===\", \"=>\", \">\", \">=\",\n\
    \">>\", \">>=\", \">>>\", \">>>=\", \"^\", \"^=\", \"|\", \"|=\", \"||\"\n\
]);\n\
\n\
const standard = [\n\
\n\
// These are the globals that are provided by the language standard.\n\
\n\
    \"Array\", \"ArrayBuffer\", \"Boolean\", \"DataView\", \"Date\", \"decodeURI\",\n\
    \"decodeURIComponent\", \"encodeURI\", \"encodeURIComponent\", \"Error\",\n\
    \"EvalError\", \"Float32Array\", \"Float64Array\", \"Generator\",\n\
    \"GeneratorFunction\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Intl\",\n\
    \"JSON\", \"Map\", \"Math\", \"Number\", \"Object\", \"parseInt\", \"parseFloat\",\n\
    \"Promise\", \"Proxy\", \"RangeError\", \"ReferenceError\", \"Reflect\", \"RegExp\",\n\
    \"Set\", \"String\", \"Symbol\", \"SyntaxError\", \"System\", \"TypeError\",\n\
    \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\",\n\
    \"URIError\", \"WeakMap\", \"WeakSet\"\n\
];\n\
\n\
const bundle = {\n\
\n\
// The bundle contains the raw text messages that are generated by jslint. It\n\
// seems that they are all error messages and warnings. There are no \"Atta\n\
// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n\
// or encouragement. This relentless negativity can undermine self-esteem and\n\
// wound the inner child. But if you accept it as sound advice rather than as\n\
// personal criticism, it can make your programs better.\n\
\n\
    and: \"The '&&' subexpression should be wrapped in parens.\",\n\
    bad_assignment_a: \"Bad assignment to '{a}'.\",\n\
    bad_directive_a: \"Bad directive '{a}'.\",\n\
    bad_get: \"A get function takes no parameters.\",\n\
    bad_module_name_a: \"Bad module name '{a}'.\",\n\
    bad_option_a: \"Bad option '{a}'.\",\n\
    bad_property_a: \"Bad property name '{a}'.\",\n\
    bad_set: \"A set function takes one parameter.\",\n\
    duplicate_a: \"Duplicate '{a}'.\",\n\
    empty_block: \"Empty block.\",\n\
    expected_a: \"Expected '{a}'.\",\n\
    expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n\
    expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n\
    expected_a_b_from_c_d: (\n\
        \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\"\n\
    ),\n\
    expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n\
    expected_a_next_at_b: \"Expected '{a}' at column {b} on the next line.\",\n\
    expected_digits_after_a: \"Expected digits after '{a}'.\",\n\
    expected_four_digits: \"Expected four digits after '\\\\u'.\",\n\
    expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n\
    expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n\
    expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n\
    expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n\
    expected_statements_a: \"Expected statements before '{a}'.\",\n\
    expected_string_a: \"Expected a string and instead saw '{a}'.\",\n\
    expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n\
    freeze_exports: (\n\
        \"Expected 'Object.freeze('. All export values should be frozen.\"\n\
    ),\n\
    function_in_loop: \"Don't make functions within a loop.\",\n\
    infix_in: (\n\
        \"Unexpected 'in'. Compare with undefined, \"\n\
        + \"or use the hasOwnProperty method instead.\"\n\
    ),\n\
    label_a: \"'{a}' is a statement label.\",\n\
    misplaced_a: \"Place '{a}' at the outermost level.\",\n\
    misplaced_directive_a: (\n\
        \"Place the '/*{a}*/' directive before the first statement.\"\n\
    ),\n\
    missing_browser: \"/*global*/ requires the Assume a browser option.\",\n\
    missing_m: \"Expected 'm' flag on a multiline regular expression.\",\n\
    naked_block: \"Naked block.\",\n\
    nested_comment: \"Nested comment.\",\n\
    not_label_a: \"'{a}' is not a label.\",\n\
    number_isNaN: \"Use Number.isNaN function to compare with NaN.\",\n\
    out_of_scope_a: \"'{a}' is out of scope.\",\n\
    redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n\
    required_a_optional_b: (\n\
        \"Required parameter '{a}' after optional parameter '{b}'.\"\n\
    ),\n\
    reserved_a: \"Reserved name '{a}'.\",\n\
    subscript_a: \"['{a}'] is better written in dot notation.\",\n\
    todo_comment: \"Unexpected TODO comment.\",\n\
    too_long: \"Line is longer than 80 characters.\",\n\
    too_many_digits: \"Too many digits.\",\n\
    unclosed_comment: \"Unclosed comment.\",\n\
    unclosed_mega: \"Unclosed mega literal.\",\n\
    unclosed_string: \"Unclosed string.\",\n\
    undeclared_a: \"Undeclared '{a}'.\",\n\
    unexpected_a: \"Unexpected '{a}'.\",\n\
    unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n\
    unexpected_a_before_b: \"Unexpected '{a}' before '{b}'.\",\n\
    unexpected_at_top_level_a: \"Expected '{a}' to be in a function.\",\n\
    unexpected_char_a: \"Unexpected character '{a}'.\",\n\
    unexpected_comment: \"Unexpected comment.\",\n\
    unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n\
    unexpected_expression_a: (\n\
        \"Unexpected expression '{a}' in statement position.\"\n\
    ),\n\
    unexpected_label_a: \"Unexpected label '{a}'.\",\n\
    unexpected_parens: \"Don't wrap function literals in parens.\",\n\
    unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n\
    unexpected_statement_a: (\n\
        \"Unexpected statement '{a}' in expression position.\"\n\
    ),\n\
    unexpected_trailing_space: \"Unexpected trailing space.\",\n\
    unexpected_typeof_a: (\n\
        \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\"\n\
    ),\n\
    uninitialized_a: \"Uninitialized '{a}'.\",\n\
    unreachable_a: \"Unreachable '{a}'.\",\n\
    unregistered_property_a: \"Unregistered property name '{a}'.\",\n\
    unused_a: \"Unused '{a}'.\",\n\
    use_double: \"Use double quotes, not single quotes.\",\n\
    use_open: (\n\
        \"Wrap a ternary expression in parens, \"\n\
        + \"with a line break after the left paren.\"\n\
    ),\n\
    use_spaces: \"Use spaces, not tabs.\",\n\
    var_loop: \"Don't declare variables in a loop.\",\n\
    var_switch: \"Don't declare variables in a switch.\",\n\
    weird_condition_a: \"Weird condition '{a}'.\",\n\
    weird_expression_a: \"Weird expression '{a}'.\",\n\
    weird_loop: \"Weird loop.\",\n\
    weird_relation_a: \"Weird relation '{a}'.\",\n\
    wrap_condition: \"Wrap the condition in parens.\",\n\
    wrap_immediate: (\n\
        \"Wrap an immediate function invocation in parentheses to assist \"\n\
        + \"the reader in understanding that the expression is the result \"\n\
        + \"of a function, and not the function itself.\"\n\
    ),\n\
    wrap_parameter: \"Wrap the parameter in parens.\",\n\
    wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n\
    wrap_unary: \"Wrap the unary expression in parens.\"\n\
};\n\
\n\
// Regular expression literals:\n\
\n\
function tag_regexp(strings) {\n\
    return new RegExp(strings.raw[0].replace(/\\s/g, \"\"));\n\
}\n\
\n\
// supplant {variables}\n\
const rx_supplant = /\\{([^{}]*)\\}/g;\n\
// carriage return, carriage return linefeed, or linefeed\n\
const rx_crlf = tag_regexp `\n\
      \\n\n\
    | \\r \\n?\n\
`;\n\
// identifier\n\
const rx_identifier = tag_regexp ` ^(\n\
    [ a-z A-Z _ $ ]\n\
    [ a-z A-Z 0-9 _ $ ]*\n\
)$`;\n\
const rx_module = tag_regexp ` ^ [ a-z A-Z 0-9 _ $ : . @ \\- \\/ ]+ $ `;\n\
const rx_bad_property = tag_regexp `\n\
    ^_\n\
  | \\$\n\
  | Sync $\n\
  | _ $\n\
`;\n\
// star slash\n\
const rx_star_slash = tag_regexp ` \\* \\/ `;\n\
// slash star\n\
const rx_slash_star = tag_regexp ` \\/ \\* `;\n\
// slash star or ending slash\n\
const rx_slash_star_or_slash = tag_regexp ` \\/ \\* | \\/ $ `;\n\
// uncompleted work comment\n\
const rx_todo = tag_regexp ` \\b (?:\n\
    todo\n\
  | TO \\s? DO\n\
  | HACK\n\
) \\b `;\n\
// tab\n\
const rx_tab = /\\t/g;\n\
// directive\n\
const rx_directive = tag_regexp ` ^ (\n\
    jslint\n\
  | property\n\
  | global\n\
) \\s+ ( .* ) $ `;\n\
const rx_directive_part = tag_regexp ` ^ (\n\
    [ a-z A-Z $ _ ] [ a-z A-Z 0-9 $ _ ]*\n\
) (?:\n\
    : \\s* ( true | false )\n\
)? ,? \\s* ( .* ) $ `;\n\
// token\n\
const rx_token = tag_regexp ` ^ (\n\
    (\\s+)\n\
  | (\n\
      [ a-z A-Z _ $ ]\n\
      [ a-z A-Z 0-9 _ $ ]*\n\
    )\n\
  | [\n\
      ( ) { } \\[ \\] , : ; ' \" ~ \\`\n\
  ]\n\
  | \\? [ ? . ]?\n\
  | = (?:\n\
        = =?\n\
      | >\n\
    )?\n\
  | \\.+\n\
  | \\* [ * \\/ = ]?\n\
  | \\/ [ * \\/ ]?\n\
  | \\+ [ = + ]?\n\
  | - [ = \\- ]?\n\
  | [ \\^ % ] =?\n\
  | & [ & = ]?\n\
  | \\| [ | = ]?\n\
  | >{1,3} =?\n\
  | < <? =?\n\
  | ! (?:\n\
        !\n\
      | = =?\n\
    )?\n\
  | (\n\
        0 n?\n\
      | [ 1-9 ] [ 0-9 ]* n?\n\
    )\n\
) ( .* ) $ `;\n\
// hack-jslint - bigint\n\
const rx_digits = /^[0-9]*n?/;\n\
const rx_hexs = /^[0-9A-F]*n?/i;\n\
const rx_octals = /^[0-7]*n?/;\n\
const rx_bits = /^[01]*n?/;\n\
// mega\n\
const rx_mega = /[`\\\\]|\\$\\{/;\n\
// JSON number\n\
const rx_JSON_number = tag_regexp ` ^\n\
    -?\n\
    (?: 0 | [ 1-9 ] \\d* )\n\
    (?: \\. \\d* )?\n\
    (?: [ e E ] [ \\- + ]? \\d+ )?\n\
$ `;\n\
// initial cap\n\
const rx_cap = /^[A-Z]/;\n\
\n\
function is_letter(string) {\n\
    return (\n\
        (string >= \"a\" && string <= \"z\\uffff\")\n\
        || (string >= \"A\" && string <= \"Z\\uffff\")\n\
    );\n\
}\n\
\n\
function supplant(string, object) {\n\
    return string.replace(rx_supplant, function (found, filling) {\n\
        const replacement = object[filling];\n\
        return (\n\
            replacement !== undefined\n\
            ? replacement\n\
            : found\n\
        );\n\
    });\n\
}\n\
\n\
let anon;               // The guessed name for anonymous functions.\n\
let blockage;           // The current block.\n\
let block_stack;        // The stack of blocks.\n\
let declared_globals;   // The object containing the global declarations.\n\
let directives;         // The directive comments.\n\
let directive_mode;     // true if directives are still allowed.\n\
let early_stop;         // true if JSLint cannot finish.\n\
let exports;            // The exported names and values.\n\
let froms;              // The array collecting all import-from strings.\n\
let fudge;              // true if the natural numbers start with 1.\n\
let functionage;        // The current function.\n\
let functions;          // The array containing all of the functions.\n\
let global;             // The global object; the outermost context.\n\
let json_mode;          // true if parsing JSON.\n\
let lines;              // The array containing source lines.\n\
let mega_mode;          // true if currently parsing a megastring literal.\n\
let module_mode;        // true if import or export was used.\n\
let next_token;         // The next token to be examined in the parse.\n\
let option;             // The options parameter.\n\
let property;           // The object containing the tallied property names.\n\
let shebang;            // true if a #! was seen on the first line.\n\
let stack;              // The stack of functions.\n\
let syntax;             // The object containing the parser.\n\
let token;              // The current token being examined in the parse.\n\
let token_nr;           // The number of the next token.\n\
let tokens;             // The array of tokens.\n\
let tenure;             // The predefined property registry.\n\
let tree;               // The abstract parse tree.\n\
let var_mode;           // \"var\" if using var; \"let\" if using let.\n\
let warnings;           // The array collecting all generated warnings.\n\
\n\
// Error reportage functions:\n\
\n\
function artifact(the_token) {\n\
\n\
// Return a string representing an artifact.\n\
\n\
    if (the_token === undefined) {\n\
        the_token = next_token;\n\
    }\n\
    return (\n\
        (the_token.id === \"(string)\" || the_token.id === \"(number)\")\n\
        ? String(the_token.value)\n\
        : the_token.id\n\
    );\n\
}\n\
\n\
function artifact_line(the_token) {\n\
\n\
// Return the fudged line number of an artifact.\n\
\n\
    if (the_token === undefined) {\n\
        the_token = next_token;\n\
    }\n\
    return the_token.line + fudge;\n\
}\n\
\n\
function artifact_column(the_token) {\n\
\n\
// Return the fudged column number of an artifact.\n\
\n\
    if (the_token === undefined) {\n\
        the_token = next_token;\n\
    }\n\
    return the_token.from + fudge;\n\
}\n\
\n\
function warn_at(code, line, column, a, b, c, d) {\n\
\n\
// Report an error at some line and column of the program. The warning object\n\
// resembles an exception.\n\
\n\
    const warning = {         // ~~\n\
        name: \"JSLintError\",\n\
        column,\n\
        line,\n\
        code\n\
    };\n\
    if (a !== undefined) {\n\
        warning.a = a;\n\
    }\n\
    if (b !== undefined) {\n\
        warning.b = b;\n\
    }\n\
    if (c !== undefined) {\n\
        warning.c = c;\n\
    }\n\
    if (d !== undefined) {\n\
        warning.d = d;\n\
    }\n\
    warning.message = supplant(bundle[code] || code, warning);\n\
    // hack-jslint - line_ignore\n\
    Object.assign(warning, lines_extra[warning.line]);\n\
    if (warning.ignore) {\n\
        return;\n\
    }\n\
    // hack-jslint - debug warning\n\
    if (option.debug) {\n\
        warning.stack = warning.stack || new Error().stack;\n\
    }\n\
    warnings.push(warning);\n\
    return warning;\n\
}\n\
\n\
function stop_at(code, line, column, a, b, c, d) {\n\
\n\
// Same as warn_at, except that it stops the analysis.\n\
\n\
    throw warn_at(code, line, column, a, b, c, d);\n\
}\n\
\n\
function warn(code, the_token, a, b, c, d) {\n\
\n\
// Same as warn_at, except the warning will be associated with a specific token.\n\
// If there is already a warning on this token, suppress the new one. It is\n\
// likely that the first warning will be the most meaningful.\n\
\n\
    if (the_token === undefined) {\n\
        the_token = next_token;\n\
    }\n\
    if (the_token.warning === undefined) {\n\
        the_token.warning = warn_at(\n\
            code,\n\
            the_token.line,\n\
            the_token.from,\n\
            a || artifact(the_token),\n\
            b,\n\
            c,\n\
            d\n\
        );\n\
        return the_token.warning;\n\
    }\n\
}\n\
\n\
function stop(code, the_token, a, b, c, d) {\n\
\n\
// Similar to warn and stop_at. If the token already had a warning, that\n\
// warning will be replaced with this new one. It is likely that the stopping\n\
// warning will be the more meaningful.\n\
\n\
    if (the_token === undefined) {\n\
        the_token = next_token;\n\
    }\n\
    delete the_token.warning;\n\
    throw warn(code, the_token, a, b, c, d);\n\
}\n\
\n\
// Tokenize:\n\
\n\
function tokenize(source) {\n\
\n\
// tokenize takes a source and produces from it an array of token objects.\n\
// JavaScript is notoriously difficult to tokenize because of the horrible\n\
// interactions between automatic semicolon insertion, regular expression\n\
// literals, and now megastring literals. JSLint benefits from eliminating\n\
// automatic semicolon insertion and nested megastring literals, which allows\n\
// full tokenization to precede parsing.\n\
\n\
// If the source is not an array, then it is split into lines at the\n\
// carriage return/linefeed.\n\
\n\
    lines = (\n\
        Array.isArray(source)\n\
        ? source\n\
        : source.split(rx_crlf)\n\
    );\n\
    tokens = [];\n\
\n\
    let char;                   // a popular character\n\
    let column = 0;             // the column number of the next character\n\
    let first;                  // the first token\n\
    let from;                   // the starting column number of the token\n\
    let line = -1;              // the line number of the next character\n\
    let nr = 0;                 // the next token number\n\
    let previous = global;      // the previous token including comments\n\
    let prior = global;         // the previous token excluding comments\n\
    let mega_from;              // the starting column of megastring\n\
    let mega_line;              // the starting line of megastring\n\
    let regexp_seen;            // regular expression literal seen on this line\n\
    let snippet;                // a piece of string\n\
    let source_line = \"\";       // the remaining line source string\n\
    let whole_line = \"\";        // the whole line source string\n\
\n\
    if (lines[0].startsWith(\"#!\")) {\n\
        line = 0;\n\
        shebang = true;\n\
    }\n\
\n\
    function next_line() {\n\
\n\
// Put the next line of source in source_line. If the line contains tabs,\n\
// replace them with spaces and give a warning. Also warn if the line contains\n\
// unsafe characters or is too damn long.\n\
\n\
        let at;\n\
        if (\n\
            !option.long\n\
            && whole_line.length > 80\n\
            && !json_mode\n\
            && first\n\
            && !regexp_seen\n\
            // hack-jslint - ignore too_long url\n\
            && !(\n\
                option.modeUtility2\n\
                && (\n\
                    /^\\s*?(?:\\/\\/(?:!!\\u0020|\\u0020https:\\/\\/)|(?:\\S+?\\u0020)?(?:https:\\/\\/|this\\u0020.*?\\u0020package\\u0020will\\u0020))/m\n\
                ).test(whole_line)\n\
            )\n\
        ) {\n\
            warn_at(\"too_long\", line, 80);\n\
        }\n\
        column = 0;\n\
        line += 1;\n\
        regexp_seen = false;\n\
        source_line = lines[line];\n\
        whole_line = source_line || \"\";\n\
        if (source_line !== undefined) {\n\
            // hack-jslint - source_line\n\
            let line_extra;\n\
            let match;\n\
            line_extra = {};\n\
            line_extra.line = line;\n\
            line_extra.source = source_line;\n\
            lines_extra[line] = line_extra;\n\
            match = (\n\
                source_line.match(\n\
                    /^\\/\\*\\u0020jslint\\u0020(ignore:start|ignore:end|utility2:true)\\u0020\\*\\/$/m\n\
                )\n\
                || source_line.slice(-50).match(\n\
                    /\\u0020\\/\\/\\u0020jslint\\u0020(ignore:line)$/m\n\
                )\n\
            );\n\
            switch (match && match[1]) {\n\
            case \"ignore:end\":\n\
                line_ignore = undefined;\n\
                break;\n\
            case \"ignore:line\":\n\
                line_ignore = \"line\";\n\
                break;\n\
            case \"ignore:start\":\n\
                line_ignore = true;\n\
                break;\n\
            case \"utility2:true\":\n\
                option.bitwise = true;\n\
                option.browser = true;\n\
                option.debug = true;\n\
                option.node = true;\n\
                option.nomen = true;\n\
                option.this = true;\n\
                option.modeUtility2 = true;\n\
                [].concat(\n\
                    allowed_option.browser,\n\
                    allowed_option.node,\n\
                    \"global\",\n\
                    \"globalThis\"\n\
                ).forEach(function (key) {\n\
                    declared_globals[key] = false;\n\
                });\n\
                break;\n\
            }\n\
            line_extra.ignore = line_ignore;\n\
            switch (line_ignore) {\n\
            case \"line\":\n\
                line_ignore = undefined;\n\
                break;\n\
            case true:\n\
                source_line = \"\";\n\
                break;\n\
            }\n\
            at = source_line.search(rx_tab);\n\
            if (at >= 0) {\n\
                if (!option.white) {\n\
                    warn_at(\"use_spaces\", line, at + 1);\n\
                }\n\
                source_line = source_line.replace(rx_tab, \" \");\n\
            }\n\
            if (!option.white && source_line.slice(-1) === \" \") {\n\
                warn_at(\n\
                    \"unexpected_trailing_space\",\n\
                    line,\n\
                    source_line.length - 1\n\
                );\n\
            }\n\
        }\n\
        return source_line;\n\
    }\n\
\n\
// Most tokens, including the identifiers, operators, and punctuators, can be\n\
// found with a regular expression. Regular expressions cannot correctly match\n\
// regular expression literals, so we will match those the hard way. String\n\
// literals and number literals can be matched by regular expressions, but they\n\
// don't provide good warnings. The functions snip, next_char, back_char,\n\
// some_digits, and escape help in the parsing of literals.\n\
\n\
    function snip() {\n\
\n\
// Remove the last character from snippet.\n\
\n\
        snippet = snippet.slice(0, -1);\n\
    }\n\
\n\
    function next_char(match) {\n\
\n\
// Get the next character from the source line. Remove it from the source_line,\n\
// and append it to the snippet. Optionally check that the previous character\n\
// matched an expected value.\n\
\n\
        if (match !== undefined && char !== match) {\n\
            return stop_at(\n\
                (\n\
                    char === \"\"\n\
                    ? \"expected_a\"\n\
                    : \"expected_a_b\"\n\
                ),\n\
                line,\n\
                column - 1,\n\
                match,\n\
                char\n\
            );\n\
        }\n\
        if (source_line) {\n\
            char = source_line[0];\n\
            source_line = source_line.slice(1);\n\
            snippet += char;\n\
        } else {\n\
            char = \"\";\n\
            snippet += \" \";\n\
        }\n\
        column += 1;\n\
        return char;\n\
    }\n\
\n\
    function back_char() {\n\
\n\
// Back up one character by moving a character from the end of the snippet to\n\
// the front of the source_line.\n\
\n\
        if (snippet) {\n\
            char = snippet.slice(-1);\n\
            source_line = char + source_line;\n\
            column -= 1;\n\
            snip();\n\
        } else {\n\
            char = \"\";\n\
        }\n\
        return char;\n\
    }\n\
\n\
    function some_digits(rx, quiet) {\n\
        const digits = source_line.match(rx)[0];\n\
        const length = digits.length;\n\
        if (!quiet && length === 0) {\n\
            warn_at(\"expected_digits_after_a\", line, column, snippet);\n\
        }\n\
        column += length;\n\
        source_line = source_line.slice(length);\n\
        snippet += digits;\n\
        next_char();\n\
        return length;\n\
    }\n\
\n\
    function escape(extra) {\n\
        next_char(\"\\\\\");\n\
        if (escapeable[char] === true) {\n\
            return next_char();\n\
        }\n\
        if (char === \"\") {\n\
            return stop_at(\"unclosed_string\", line, column);\n\
        }\n\
        if (char === \"u\") {\n\
            if (next_char(\"u\") === \"{\") {\n\
                if (json_mode) {\n\
                    warn_at(\"unexpected_a\", line, column - 1, char);\n\
                }\n\
                if (some_digits(rx_hexs) > 5) {\n\
                    warn_at(\"too_many_digits\", line, column - 1);\n\
                }\n\
                if (next_char() !== \"}\") {\n\
                    stop_at(\"expected_a_before_b\", line, column, \"}\", char);\n\
                }\n\
                return next_char();\n\
            }\n\
            back_char();\n\
            if (some_digits(rx_hexs, true) < 4) {\n\
                warn_at(\"expected_four_digits\", line, column - 1);\n\
            }\n\
            return;\n\
        }\n\
        if (extra && extra.indexOf(char) >= 0) {\n\
            return next_char();\n\
        }\n\
        warn_at(\"unexpected_a_before_b\", line, column - 2, \"\\\\\", char);\n\
    }\n\
\n\
    function make(id, value, identifier) {\n\
\n\
// Make the token object and append it to the tokens list.\n\
\n\
        const the_token = {\n\
            from,\n\
            id,\n\
            identifier: Boolean(identifier),\n\
            line,\n\
            nr,\n\
            thru: column\n\
        };\n\
        tokens[nr] = the_token;\n\
        nr += 1;\n\
\n\
// Directives must appear before the first statement.\n\
\n\
        if (id !== \"(comment)\" && id !== \";\") {\n\
            directive_mode = false;\n\
        }\n\
\n\
// If the token is to have a value, give it one.\n\
\n\
        if (value !== undefined) {\n\
            the_token.value = value;\n\
        }\n\
\n\
// If this token is an identifier that touches a preceding number, or\n\
// a \"/\", comment, or regular expression literal that touches a preceding\n\
// comment or regular expression literal, then give a missing space warning.\n\
// This warning is not suppressed by option.white.\n\
\n\
        if (\n\
            previous.line === line\n\
            && previous.thru === from\n\
            && (id === \"(comment)\" || id === \"(regexp)\" || id === \"/\")\n\
            && (previous.id === \"(comment)\" || previous.id === \"(regexp)\")\n\
        ) {\n\
            warn(\n\
                \"expected_space_a_b\",\n\
                the_token,\n\
                artifact(previous),\n\
                artifact(the_token)\n\
            );\n\
        }\n\
        if (previous.id === \".\" && id === \"(number)\") {\n\
            warn(\"expected_a_before_b\", previous, \"0\", \".\");\n\
        }\n\
        if (prior.id === \".\" && the_token.identifier) {\n\
            the_token.dot = true;\n\
        }\n\
\n\
// The previous token is used to detect adjacency problems.\n\
\n\
        previous = the_token;\n\
\n\
// The prior token is a previous token that was not a comment. The prior token\n\
// is used to disambiguate \"/\", which can mean division or regular expression\n\
// literal.\n\
\n\
        if (previous.id !== \"(comment)\") {\n\
            prior = previous;\n\
        }\n\
        return the_token;\n\
    }\n\
\n\
    function parse_directive(the_comment, body) {\n\
\n\
// JSLint recognizes three directives that can be encoded in comments. This\n\
// function processes one item, and calls itself recursively to process the\n\
// next one.\n\
\n\
        const result = body.match(rx_directive_part);\n\
        if (result) {\n\
            let allowed;\n\
            const name = result[1];\n\
            const value = result[2];\n\
            if (the_comment.directive === \"jslint\") {\n\
                allowed = allowed_option[name];\n\
                if (\n\
                    typeof allowed === \"boolean\"\n\
                    || typeof allowed === \"object\"\n\
                ) {\n\
                    if (\n\
                        value === \"\"\n\
                        || value === \"true\"\n\
                        || value === undefined\n\
                    ) {\n\
                        option[name] = true;\n\
                        if (Array.isArray(allowed)) {\n\
                            populate(allowed, declared_globals, false);\n\
                        }\n\
                    } else if (value === \"false\") {\n\
                        option[name] = false;\n\
                    } else {\n\
                        warn(\"bad_option_a\", the_comment, name + \":\" + value);\n\
                    }\n\
                } else {\n\
                    warn(\"bad_option_a\", the_comment, name);\n\
                }\n\
            } else if (the_comment.directive === \"property\") {\n\
                if (tenure === undefined) {\n\
                    tenure = empty();\n\
                }\n\
                tenure[name] = true;\n\
            } else if (the_comment.directive === \"global\") {\n\
                if (value) {\n\
                    warn(\"bad_option_a\", the_comment, name + \":\" + value);\n\
                }\n\
                declared_globals[name] = false;\n\
                module_mode = the_comment;\n\
            }\n\
            return parse_directive(the_comment, result[3]);\n\
        }\n\
        if (body) {\n\
            return stop(\"bad_directive_a\", the_comment, body);\n\
        }\n\
    }\n\
\n\
    function comment(snippet) {\n\
\n\
// Make a comment object. Comments are not allowed in JSON text. Comments can\n\
// include directives and notices of incompletion.\n\
\n\
        const the_comment = make(\"(comment)\", snippet);\n\
        if (Array.isArray(snippet)) {\n\
            snippet = snippet.join(\" \");\n\
        }\n\
        if (!option.devel && rx_todo.test(snippet)) {\n\
            warn(\"todo_comment\", the_comment);\n\
        }\n\
        const result = snippet.match(rx_directive);\n\
        if (result) {\n\
            if (!directive_mode) {\n\
                warn_at(\"misplaced_directive_a\", line, from, result[1]);\n\
            } else {\n\
                the_comment.directive = result[1];\n\
                parse_directive(the_comment, result[2]);\n\
            }\n\
            directives.push(the_comment);\n\
        }\n\
        return the_comment;\n\
    }\n\
\n\
    function regexp() {\n\
\n\
// Parse a regular expression literal.\n\
\n\
        let multi_mode = false;\n\
        let result;\n\
        let value;\n\
        regexp_seen = true;\n\
\n\
        function quantifier() {\n\
\n\
// Match an optional quantifier.\n\
\n\
            if (char === \"?\" || char === \"*\" || char === \"+\") {\n\
                next_char();\n\
            } else if (char === \"{\") {\n\
                if (some_digits(rx_digits, true) === 0) {\n\
                    warn_at(\"expected_a_before_b\", line, column, \"0\", \",\");\n\
                }\n\
                if (char === \",\") {\n\
                    some_digits(rx_digits, true);\n\
                }\n\
                next_char(\"}\");\n\
            } else {\n\
                return;\n\
            }\n\
            if (char === \"?\") {\n\
                next_char(\"?\");\n\
            }\n\
        }\n\
\n\
        function subklass() {\n\
\n\
// Match a character in a character class.\n\
\n\
            if (char === \"\\\\\") {\n\
                escape(\"BbDdSsWw-[]^\");\n\
                return true;\n\
            }\n\
            if (\n\
                char === \"\"\n\
                || char === \"[\"\n\
                || char === \"]\"\n\
                || char === \"/\"\n\
                || char === \"^\"\n\
                || char === \"-\"\n\
            ) {\n\
                return false;\n\
            }\n\
            if (char === \" \") {\n\
                warn_at(\"expected_a_b\", line, column, \"\\\\u0020\", \" \");\n\
            } else if (char === \"`\" && mega_mode) {\n\
                warn_at(\"unexpected_a\", line, column, \"`\");\n\
            }\n\
            next_char();\n\
            return true;\n\
        }\n\
\n\
        function ranges() {\n\
\n\
// Match a range of subclasses.\n\
\n\
            if (subklass()) {\n\
                if (char === \"-\") {\n\
                    next_char(\"-\");\n\
                    if (!subklass()) {\n\
                        return stop_at(\n\
                            \"unexpected_a\",\n\
                            line,\n\
                            column - 1,\n\
                            \"-\"\n\
                        );\n\
                    }\n\
                }\n\
                return ranges();\n\
            }\n\
        }\n\
\n\
        function klass() {\n\
\n\
// Match a class.\n\
\n\
            next_char(\"[\");\n\
            if (char === \"^\") {\n\
                next_char(\"^\");\n\
            }\n\
            (function classy() {\n\
                ranges();\n\
                if (char !== \"]\" && char !== \"\") {\n\
                    warn_at(\n\
                        \"expected_a_before_b\",\n\
                        line,\n\
                        column,\n\
                        \"\\\\\",\n\
                        char\n\
                    );\n\
                    next_char();\n\
                    return classy();\n\
                }\n\
            }());\n\
            next_char(\"]\");\n\
        }\n\
\n\
        function choice() {\n\
\n\
            function group() {\n\
\n\
// Match a group that starts with left paren.\n\
\n\
                next_char(\"(\");\n\
                if (char === \"?\") {\n\
                    next_char(\"?\");\n\
                    if (char === \"=\" || char === \"!\") {\n\
                        next_char();\n\
                    } else {\n\
                        next_char(\":\");\n\
                    }\n\
                } else if (char === \":\") {\n\
                    warn_at(\"expected_a_before_b\", line, column, \"?\", \":\");\n\
                }\n\
                choice();\n\
                next_char(\")\");\n\
            }\n\
\n\
            function factor() {\n\
                if (\n\
                    char === \"\"\n\
                    || char === \"/\"\n\
                    || char === \"]\"\n\
                    || char === \")\"\n\
                ) {\n\
                    return false;\n\
                }\n\
                if (char === \"(\") {\n\
                    group();\n\
                    return true;\n\
                }\n\
                if (char === \"[\") {\n\
                    klass();\n\
                    return true;\n\
                }\n\
                if (char === \"\\\\\") {\n\
                    escape(\"BbDdSsWw^${}[]():=!.|*+?\");\n\
                    return true;\n\
                }\n\
                if (\n\
                    char === \"?\"\n\
                    || char === \"+\"\n\
                    || char === \"*\"\n\
                    || char === \"}\"\n\
                    || char === \"{\"\n\
                ) {\n\
                    warn_at(\n\
                        \"expected_a_before_b\",\n\
                        line,\n\
                        column - 1,\n\
                        \"\\\\\",\n\
                        char\n\
                    );\n\
                } else if (char === \"`\") {\n\
                    if (mega_mode) {\n\
                        warn_at(\"unexpected_a\", line, column - 1, \"`\");\n\
                    }\n\
                } else if (char === \" \") {\n\
                    warn_at(\n\
                        \"expected_a_b\",\n\
                        line,\n\
                        column - 1,\n\
                        \"\\\\s\",\n\
                        \" \"\n\
                    );\n\
                } else if (char === \"$\") {\n\
                    if (source_line[0] !== \"/\") {\n\
                        multi_mode = true;\n\
                    }\n\
                } else if (char === \"^\") {\n\
                    if (snippet !== \"^\") {\n\
                        multi_mode = true;\n\
                    }\n\
                }\n\
                next_char();\n\
                return true;\n\
            }\n\
\n\
            function sequence(follow) {\n\
                if (factor()) {\n\
                    quantifier();\n\
                    return sequence(true);\n\
                }\n\
                if (!follow) {\n\
                    warn_at(\"expected_regexp_factor_a\", line, column, char);\n\
                }\n\
            }\n\
\n\
// Match a choice (a sequence that can be followed by | and another choice).\n\
\n\
            sequence();\n\
            if (char === \"|\") {\n\
                next_char(\"|\");\n\
                return choice();\n\
            }\n\
        }\n\
\n\
// Scan the regexp literal. Give a warning if the first character is = because\n\
// /= looks like a division assignment operator.\n\
\n\
        snippet = \"\";\n\
        next_char();\n\
        if (char === \"=\") {\n\
            warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \"=\");\n\
        }\n\
        choice();\n\
\n\
// Make sure there is a closing slash.\n\
\n\
        snip();\n\
        value = snippet;\n\
        next_char(\"/\");\n\
\n\
// Process dangling flag letters.\n\
\n\
        const allowed = {\n\
            g: true,\n\
            i: true,\n\
            m: true,\n\
            u: true,\n\
            y: true\n\
        };\n\
        const flag = empty();\n\
        (function make_flag() {\n\
            if (is_letter(char)) {\n\
                if (allowed[char] !== true) {\n\
                    warn_at(\"unexpected_a\", line, column, char);\n\
                }\n\
                allowed[char] = false;\n\
                flag[char] = true;\n\
                next_char();\n\
                return make_flag();\n\
            }\n\
        }());\n\
        back_char();\n\
        if (char === \"/\" || char === \"*\") {\n\
            return stop_at(\"unexpected_a\", line, from, char);\n\
        }\n\
        result = make(\"(regexp)\", char);\n\
        result.flag = flag;\n\
        result.value = value;\n\
        if (multi_mode && !flag.m) {\n\
            warn_at(\"missing_m\", line, column);\n\
        }\n\
        return result;\n\
    }\n\
\n\
    function string(quote) {\n\
\n\
// Make a string token.\n\
\n\
        let the_token;\n\
        snippet = \"\";\n\
        next_char();\n\
\n\
        return (function next() {\n\
            if (char === quote) {\n\
                snip();\n\
                the_token = make(\"(string)\", snippet);\n\
                the_token.quote = quote;\n\
                return the_token;\n\
            }\n\
            if (char === \"\") {\n\
                return stop_at(\"unclosed_string\", line, column);\n\
            }\n\
            if (char === \"\\\\\") {\n\
                escape(quote);\n\
            } else if (char === \"`\") {\n\
                if (mega_mode) {\n\
                    warn_at(\"unexpected_a\", line, column, \"`\");\n\
                }\n\
                next_char(\"`\");\n\
            } else {\n\
                next_char();\n\
            }\n\
            return next();\n\
        }());\n\
    }\n\
\n\
    function frack() {\n\
        if (char === \".\") {\n\
            some_digits(rx_digits);\n\
        }\n\
        if (char === \"E\" || char === \"e\") {\n\
            next_char();\n\
            if (char !== \"+\" && char !== \"-\") {\n\
                back_char();\n\
            }\n\
            some_digits(rx_digits);\n\
        }\n\
    }\n\
\n\
    function number() {\n\
        if (snippet === \"0\") {\n\
            next_char();\n\
            if (char === \".\") {\n\
                frack();\n\
            } else if (char === \"b\") {\n\
                some_digits(rx_bits);\n\
            } else if (char === \"o\") {\n\
                some_digits(rx_octals);\n\
            } else if (char === \"x\") {\n\
                some_digits(rx_hexs);\n\
            }\n\
        } else {\n\
            next_char();\n\
            frack();\n\
        }\n\
\n\
// If the next character after a number is a digit or letter, then something\n\
// unexpected is going on.\n\
\n\
        if (\n\
            (char >= \"0\" && char <= \"9\")\n\
            || (char >= \"a\" && char <= \"z\")\n\
            || (char >= \"A\" && char <= \"Z\")\n\
        ) {\n\
            return stop_at(\n\
                \"unexpected_a_after_b\",\n\
                line,\n\
                column - 1,\n\
                snippet.slice(-1),\n\
                snippet.slice(0, -1)\n\
            );\n\
        }\n\
        back_char();\n\
        return make(\"(number)\", snippet);\n\
    }\n\
\n\
    function lex() {\n\
        let array;\n\
        let i = 0;\n\
        let j = 0;\n\
        let last;\n\
        let result;\n\
        let the_token;\n\
\n\
// This should properly be a tail recursive function, but sadly, conformant\n\
// implementations of ES6 are still rare. This is the ideal code:\n\
\n\
//      if (!source_line) {\n\
//          source_line = next_line();\n\
//          from = 0;\n\
//          return (\n\
//              source_line === undefined\n\
//              ? (\n\
//                  mega_mode\n\
//                  ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n\
//                  : make(\"(end)\")\n\
//              )\n\
//              : lex()\n\
//          );\n\
//      }\n\
\n\
// Unfortunately, incompetent JavaScript engines will sometimes fail to execute\n\
// it correctly. So for now, we do it the old fashioned way.\n\
\n\
        while (!source_line) {\n\
            source_line = next_line();\n\
            from = 0;\n\
            if (source_line === undefined) {\n\
                return (\n\
                    mega_mode\n\
                    ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n\
                    : make(\"(end)\")\n\
                );\n\
            }\n\
        }\n\
\n\
        from = column;\n\
        result = source_line.match(rx_token);\n\
\n\
// result[1] token\n\
// result[2] whitespace\n\
// result[3] identifier\n\
// result[4] number\n\
// result[5] rest\n\
\n\
        if (!result) {\n\
            return stop_at(\n\
                \"unexpected_char_a\",\n\
                line,\n\
                column,\n\
                source_line[0]\n\
            );\n\
        }\n\
\n\
        snippet = result[1];\n\
        column += snippet.length;\n\
        source_line = result[5];\n\
\n\
// Whitespace was matched. Call lex again to get more.\n\
\n\
        if (result[2]) {\n\
            return lex();\n\
        }\n\
\n\
// The token is an identifier.\n\
\n\
        if (result[3]) {\n\
            return make(snippet, undefined, true);\n\
        }\n\
\n\
// The token is a number.\n\
\n\
        if (result[4]) {\n\
            return number(snippet);\n\
        }\n\
\n\
// The token is a string.\n\
\n\
        if (snippet === \"\\\"\") {\n\
            return string(snippet);\n\
        }\n\
        if (snippet === \"'\") {\n\
            if (!option.single) {\n\
                warn_at(\"use_double\", line, column);\n\
            }\n\
            return string(snippet);\n\
        }\n\
\n\
// The token is a megastring. We don't allow any kind of mega nesting.\n\
\n\
        if (snippet === \"`\") {\n\
            if (mega_mode) {\n\
                return stop_at(\"expected_a_b\", line, column, \"}\", \"`\");\n\
            }\n\
            snippet = \"\";\n\
            mega_from = from;\n\
            mega_line = line;\n\
            mega_mode = true;\n\
\n\
// Parsing a mega literal is tricky. First make a ` token.\n\
\n\
            make(\"`\");\n\
            from += 1;\n\
\n\
// Then loop, building up a string, possibly from many lines, until seeing\n\
// the end of file, a closing `, or a ${ indicting an expression within the\n\
// string.\n\
\n\
            (function part() {\n\
                const at = source_line.search(rx_mega);\n\
\n\
// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\
\n\
                if (at < 0) {\n\
                    snippet += source_line + \"\\n\";\n\
                    return (\n\
                        next_line() === undefined\n\
                        ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n\
                        : part()\n\
                    );\n\
                }\n\
                snippet += source_line.slice(0, at);\n\
                column += at;\n\
                source_line = source_line.slice(at);\n\
                if (source_line[0] === \"\\\\\") {\n\
                    snippet += source_line.slice(0, 2);\n\
                    source_line = source_line.slice(2);\n\
                    column += 2;\n\
                    return part();\n\
                }\n\
\n\
// if either ` or ${ was found, then the preceding joins the snippet to become\n\
// a string token.\n\
\n\
                make(\"(string)\", snippet).quote = \"`\";\n\
                snippet = \"\";\n\
\n\
// If ${, then make tokens that will become part of an expression until\n\
// a } token is made.\n\
\n\
                if (source_line[0] === \"$\") {\n\
                    column += 2;\n\
                    make(\"${\");\n\
                    source_line = source_line.slice(2);\n\
                    (function expr() {\n\
                        const id = lex().id;\n\
                        if (id === \"{\") {\n\
                            return stop_at(\n\
                                \"expected_a_b\",\n\
                                line,\n\
                                column,\n\
                                \"}\",\n\
                                \"{\"\n\
                            );\n\
                        }\n\
                        if (id !== \"}\") {\n\
                            return expr();\n\
                        }\n\
                    }());\n\
                    return part();\n\
                }\n\
            }());\n\
            source_line = source_line.slice(1);\n\
            column += 1;\n\
            mega_mode = false;\n\
            return make(\"`\");\n\
        }\n\
\n\
// The token is a // comment.\n\
\n\
        if (snippet === \"//\") {\n\
            snippet = source_line;\n\
            source_line = \"\";\n\
            the_token = comment(snippet);\n\
            if (mega_mode) {\n\
                warn(\"unexpected_comment\", the_token, \"`\");\n\
            }\n\
            return the_token;\n\
        }\n\
\n\
// The token is a /* comment.\n\
\n\
        if (snippet === \"/*\") {\n\
            array = [];\n\
            if (source_line[0] === \"/\") {\n\
                warn_at(\"unexpected_a\", line, column + i, \"/\");\n\
            }\n\
            (function next() {\n\
                if (source_line > \"\") {\n\
                    i = source_line.search(rx_star_slash);\n\
                    if (i >= 0) {\n\
                        return;\n\
                    }\n\
                    j = source_line.search(rx_slash_star);\n\
                    if (j >= 0) {\n\
                        warn_at(\"nested_comment\", line, column + j);\n\
                    }\n\
                }\n\
                array.push(source_line);\n\
                source_line = next_line();\n\
                if (source_line === undefined) {\n\
                    return stop_at(\"unclosed_comment\", line, column);\n\
                }\n\
                return next();\n\
            }());\n\
            snippet = source_line.slice(0, i);\n\
            j = snippet.search(rx_slash_star_or_slash);\n\
            if (j >= 0) {\n\
                warn_at(\"nested_comment\", line, column + j);\n\
            }\n\
            array.push(snippet);\n\
            column += i + 2;\n\
            source_line = source_line.slice(i + 2);\n\
            return comment(array);\n\
        }\n\
\n\
// The token is a slash.\n\
\n\
        if (snippet === \"/\") {\n\
\n\
// The / can be a division operator or the beginning of a regular expression\n\
// literal. It is not possible to know which without doing a complete parse.\n\
// We want to complete the tokenization before we begin to parse, so we will\n\
// estimate. This estimator can fail in some cases. For example, it cannot\n\
// know if \"}\" is ending a block or ending an object literal, so it can\n\
// behave incorrectly in that case; it is not meaningful to divide an\n\
// object, so it is likely that we can get away with it. We avoided the worst\n\
// cases by eliminating automatic semicolon insertion.\n\
\n\
            if (prior.identifier) {\n\
                if (!prior.dot) {\n\
                    if (prior.id === \"return\") {\n\
                        return regexp();\n\
                    }\n\
                    if (\n\
                        prior.id === \"(begin)\"\n\
                        || prior.id === \"case\"\n\
                        || prior.id === \"delete\"\n\
                        || prior.id === \"in\"\n\
                        || prior.id === \"instanceof\"\n\
                        || prior.id === \"new\"\n\
                        || prior.id === \"typeof\"\n\
                        || prior.id === \"void\"\n\
                        || prior.id === \"yield\"\n\
                    ) {\n\
                        the_token = regexp();\n\
                        return stop(\"unexpected_a\", the_token);\n\
                    }\n\
                }\n\
            } else {\n\
                last = prior.id[prior.id.length - 1];\n\
                if (\"(,=:?[\".indexOf(last) >= 0) {\n\
                    return regexp();\n\
                }\n\
                if (\"!&|{};~+-*%/^<>\".indexOf(last) >= 0) {\n\
                    the_token = regexp();\n\
                    warn(\"wrap_regexp\", the_token);\n\
                    return the_token;\n\
                }\n\
            }\n\
            if (source_line[0] === \"=\") {\n\
                column += 1;\n\
                source_line = source_line.slice(1);\n\
                snippet = \"/=\";\n\
                warn_at(\"unexpected_a\", line, column, \"/=\");\n\
            }\n\
        }\n\
        return make(snippet);\n\
    }\n\
\n\
    first = lex();\n\
    json_mode = first.id === \"{\" || first.id === \"[\";\n\
\n\
// This loop will be replaced with a recursive call to lex when ES6 has been\n\
// finished and widely deployed and adopted.\n\
\n\
    while (true) {\n\
        if (lex().id === \"(end)\") {\n\
            break;\n\
        }\n\
    }\n\
}\n\
\n\
// Parsing:\n\
\n\
// Parsing weaves the tokens into an abstract syntax tree. During that process,\n\
// a token may be given any of these properties:\n\
\n\
//      arity       string\n\
//      label       identifier\n\
//      name        identifier\n\
//      expression  expressions\n\
//      block       statements\n\
//      else        statements (else, default, catch)\n\
\n\
// Specialized tokens may have additional properties.\n\
\n\
function survey(name) {\n\
    let id = name.id;\n\
\n\
// Tally the property name. If it is a string, only tally strings that conform\n\
// to the identifier rules.\n\
\n\
    if (id === \"(string)\") {\n\
        id = name.value;\n\
        if (!rx_identifier.test(id)) {\n\
            return id;\n\
        }\n\
    } else if (id === \"`\") {\n\
        if (name.value.length === 1) {\n\
            id = name.value[0].value;\n\
            if (!rx_identifier.test(id)) {\n\
                return id;\n\
            }\n\
        }\n\
    } else if (!name.identifier) {\n\
        return stop(\"expected_identifier_a\", name);\n\
    }\n\
\n\
// If we have seen this name before, increment its count.\n\
\n\
    if (typeof property[id] === \"number\") {\n\
        property[id] += 1;\n\
\n\
// If this is the first time seeing this property name, and if there is a\n\
// tenure list, then it must be on the list. Otherwise, it must conform to\n\
// the rules for good property names.\n\
    } else {\n\
        if (tenure !== undefined) {\n\
            if (tenure[id] !== true) {\n\
                warn(\"unregistered_property_a\", name);\n\
            }\n\
        } else {\n\
            // hack-jslint - nomen\n\
            if (!option.nomen && name.identifier && rx_bad_property.test(id)) {\n\
                warn(\"bad_property_a\", name);\n\
            }\n\
        }\n\
        property[id] = 1;\n\
    }\n\
    return id;\n\
}\n\
\n\
function dispense() {\n\
\n\
// Deliver the next token, skipping the comments.\n\
\n\
    const cadet = tokens[token_nr];\n\
    token_nr += 1;\n\
    // hack-jslint - advance token async/await to next_token by context\n\
    const next_cadet = tokens[token_nr] || {};\n\
    if (next_cadet.identifier && (\n\
        cadet.id === \"await\"\n\
        || (cadet.id === \"async\" && next_cadet.id === \"function\")\n\
    )) {\n\
        cadet.id = next_cadet.id;\n\
        token_nr += 1;\n\
    }\n\
    if (cadet.id === \"(comment)\") {\n\
        if (json_mode) {\n\
            warn(\"unexpected_a\", cadet);\n\
        }\n\
        return dispense();\n\
    } else {\n\
        return cadet;\n\
    }\n\
}\n\
\n\
function lookahead() {\n\
\n\
// Look ahead one token without advancing.\n\
\n\
    const old_token_nr = token_nr;\n\
    const cadet = dispense(true);\n\
    token_nr = old_token_nr;\n\
    return cadet;\n\
}\n\
\n\
function advance(id, match) {\n\
\n\
// Produce the next token.\n\
\n\
// Attempt to give helpful names to anonymous functions.\n\
\n\
    if (token.identifier && token.id !== \"function\") {\n\
        anon = token.id;\n\
    } else if (token.id === \"(string)\" && rx_identifier.test(token.value)) {\n\
        anon = token.value;\n\
    }\n\
\n\
// Attempt to match next_token with an expected id.\n\
\n\
    if (id !== undefined && next_token.id !== id) {\n\
        return (\n\
            match === undefined\n\
            ? stop(\"expected_a_b\", next_token, id, artifact())\n\
            : stop(\n\
                \"expected_a_b_from_c_d\",\n\
                next_token,\n\
                id,\n\
                artifact(match),\n\
                artifact_line(match),\n\
                artifact(next_token)\n\
            )\n\
        );\n\
    }\n\
\n\
// Promote the tokens, skipping comments.\n\
\n\
    token = next_token;\n\
    next_token = dispense();\n\
    if (next_token.id === \"(end)\") {\n\
        token_nr -= 1;\n\
    }\n\
}\n\
\n\
// Parsing of JSON is simple:\n\
\n\
function json_value() {\n\
    let negative;\n\
    if (next_token.id === \"{\") {\n\
        return (function json_object() {\n\
            const brace = next_token;\n\
            const object = empty();\n\
            const properties = [];\n\
            brace.expression = properties;\n\
            advance(\"{\");\n\
            if (next_token.id !== \"}\") {\n\
                (function next() {\n\
                    let name;\n\
                    let value;\n\
                    if (next_token.quote !== \"\\\"\") {\n\
                        warn(\n\
                            \"unexpected_a\",\n\
                            next_token,\n\
                            next_token.quote\n\
                        );\n\
                    }\n\
                    name = next_token;\n\
                    advance(\"(string)\");\n\
                    if (object[token.value] !== undefined) {\n\
                        warn(\"duplicate_a\", token);\n\
                    } else if (token.value === \"__proto__\") {\n\
                        warn(\"bad_property_a\", token);\n\
                    } else {\n\
                        object[token.value] = token;\n\
                    }\n\
                    advance(\":\");\n\
                    value = json_value();\n\
                    value.label = name;\n\
                    properties.push(value);\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        return next();\n\
                    }\n\
                }());\n\
            }\n\
            advance(\"}\", brace);\n\
            return brace;\n\
        }());\n\
    }\n\
    if (next_token.id === \"[\") {\n\
        return (function json_array() {\n\
            const bracket = next_token;\n\
            const elements = [];\n\
            bracket.expression = elements;\n\
            advance(\"[\");\n\
            if (next_token.id !== \"]\") {\n\
                (function next() {\n\
                    elements.push(json_value());\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        return next();\n\
                    }\n\
                }());\n\
            }\n\
            advance(\"]\", bracket);\n\
            return bracket;\n\
        }());\n\
    }\n\
    if (\n\
        next_token.id === \"true\"\n\
        || next_token.id === \"false\"\n\
        || next_token.id === \"null\"\n\
    ) {\n\
        advance();\n\
        return token;\n\
    }\n\
    if (next_token.id === \"(number)\") {\n\
        if (!rx_JSON_number.test(next_token.value)) {\n\
            warn(\"unexpected_a\");\n\
        }\n\
        advance();\n\
        return token;\n\
    }\n\
    if (next_token.id === \"(string)\") {\n\
        if (next_token.quote !== \"\\\"\") {\n\
            warn(\"unexpected_a\", next_token, next_token.quote);\n\
        }\n\
        advance();\n\
        return token;\n\
    }\n\
    if (next_token.id === \"-\") {\n\
        negative = next_token;\n\
        negative.arity = \"unary\";\n\
        advance(\"-\");\n\
        advance(\"(number)\");\n\
        if (!rx_JSON_number.test(token.value)) {\n\
            warn(\"unexpected_a\", token);\n\
        }\n\
        negative.expression = token;\n\
        return negative;\n\
    }\n\
    stop(\"unexpected_a\");\n\
}\n\
\n\
// Now we parse JavaScript.\n\
\n\
function enroll(name, role, readonly) {\n\
\n\
// Enroll a name into the current function context. The role can be exception,\n\
// function, label, parameter, or variable. We look for variable redefinition\n\
// because it causes confusion.\n\
\n\
    const id = name.id;\n\
\n\
// Reserved words may not be enrolled.\n\
\n\
    if (syntax[id] !== undefined && id !== \"ignore\") {\n\
        warn(\"reserved_a\", name);\n\
    } else {\n\
\n\
// Has the name been enrolled in this context?\n\
\n\
        let earlier = functionage.context[id];\n\
        if (earlier) {\n\
            warn(\n\
                \"redefinition_a_b\",\n\
                name,\n\
                name.id,\n\
                earlier.line + fudge\n\
            );\n\
\n\
// Has the name been enrolled in an outer context?\n\
        } else {\n\
            stack.forEach(function (value) {\n\
                const item = value.context[id];\n\
                if (item !== undefined) {\n\
                    earlier = item;\n\
                }\n\
            });\n\
            if (earlier) {\n\
                if (id === \"ignore\") {\n\
                    if (earlier.role === \"variable\") {\n\
                        warn(\"unexpected_a\", name);\n\
                    }\n\
                } else {\n\
                    if (\n\
                        (\n\
                            role !== \"exception\"\n\
                            || earlier.role !== \"exception\"\n\
                        )\n\
                        && role !== \"parameter\"\n\
                        && role !== \"function\"\n\
                    ) {\n\
                        warn(\n\
                            \"redefinition_a_b\",\n\
                            name,\n\
                            name.id,\n\
                            earlier.line + fudge\n\
                        );\n\
                    }\n\
                }\n\
            }\n\
\n\
// Enroll it.\n\
\n\
            functionage.context[id] = name;\n\
            name.dead = true;\n\
            name.parent = functionage;\n\
            name.init = false;\n\
            name.role = role;\n\
            name.used = 0;\n\
            name.writable = !readonly;\n\
        }\n\
    }\n\
}\n\
\n\
function expression(rbp, initial) {\n\
\n\
// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n\
// They are elements of the parsing method called Top Down Operator Precedence.\n\
\n\
// nud     Null denotation\n\
// led     Left denotation\n\
// lbp     Left binding power\n\
// rbp     Right binding power\n\
\n\
// It processes a nud (variable, constant, prefix operator). It will then\n\
// process leds (infix operators) until the bind powers cause it to stop. It\n\
// returns the expression's parse tree.\n\
\n\
    let left;\n\
    let the_symbol;\n\
\n\
// Statements will have already advanced, so advance now only if the token is\n\
// not the first of a statement,\n\
\n\
    if (!initial) {\n\
        advance();\n\
    }\n\
    the_symbol = syntax[token.id];\n\
    if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n\
        left = the_symbol.nud();\n\
    } else if (token.identifier) {\n\
        left = token;\n\
        left.arity = \"variable\";\n\
    } else {\n\
        return stop(\"unexpected_a\", token);\n\
    }\n\
    (function right() {\n\
        the_symbol = syntax[next_token.id];\n\
        if (\n\
            the_symbol !== undefined\n\
            && the_symbol.led !== undefined\n\
            && rbp < the_symbol.lbp\n\
        ) {\n\
            advance();\n\
            left = the_symbol.led(left);\n\
            return right();\n\
        }\n\
    }());\n\
    return left;\n\
}\n\
\n\
function condition() {\n\
\n\
// Parse the condition part of a do, if, while.\n\
\n\
    const the_paren = next_token;\n\
    let the_value;\n\
    the_paren.free = true;\n\
    advance(\"(\");\n\
    the_value = expression(0);\n\
    advance(\")\");\n\
    if (the_value.wrapped === true) {\n\
        warn(\"unexpected_a\", the_paren);\n\
    }\n\
    if (anticondition[the_value.id] === true) {\n\
        warn(\"unexpected_a\", the_value);\n\
    }\n\
    return the_value;\n\
}\n\
\n\
function is_weird(thing) {\n\
    return (\n\
        thing.id === \"(regexp)\"\n\
        || thing.id === \"{\"\n\
        || thing.id === \"=>\"\n\
        || thing.id === \"function\"\n\
        || (thing.id === \"[\" && thing.arity === \"unary\")\n\
    );\n\
}\n\
\n\
function are_similar(a, b) {\n\
    if (a === b) {\n\
        return true;\n\
    }\n\
    if (Array.isArray(a)) {\n\
        return (\n\
            Array.isArray(b)\n\
            && a.length === b.length\n\
            && a.every(function (value, index) {\n\
                return are_similar(value, b[index]);\n\
            })\n\
        );\n\
    }\n\
    if (Array.isArray(b)) {\n\
        return false;\n\
    }\n\
    if (a.id === \"(number)\" && b.id === \"(number)\") {\n\
        return a.value === b.value;\n\
    }\n\
    let a_string;\n\
    let b_string;\n\
    if (a.id === \"(string)\") {\n\
        a_string = a.value;\n\
    } else if (a.id === \"`\" && a.constant) {\n\
        a_string = a.value[0];\n\
    }\n\
    if (b.id === \"(string)\") {\n\
        b_string = b.value;\n\
    } else if (b.id === \"`\" && b.constant) {\n\
        b_string = b.value[0];\n\
    }\n\
    if (typeof a_string === \"string\") {\n\
        return a_string === b_string;\n\
    }\n\
    if (is_weird(a) || is_weird(b)) {\n\
        return false;\n\
    }\n\
    if (a.arity === b.arity && a.id === b.id) {\n\
        if (a.id === \".\") {\n\
            return (\n\
                are_similar(a.expression, b.expression)\n\
                && are_similar(a.name, b.name)\n\
            );\n\
        }\n\
        if (a.arity === \"unary\") {\n\
            return are_similar(a.expression, b.expression);\n\
        }\n\
        if (a.arity === \"binary\") {\n\
            return (\n\
                a.id !== \"(\"\n\
                && are_similar(a.expression[0], b.expression[0])\n\
                && are_similar(a.expression[1], b.expression[1])\n\
            );\n\
        }\n\
        if (a.arity === \"ternary\") {\n\
            return (\n\
                are_similar(a.expression[0], b.expression[0])\n\
                && are_similar(a.expression[1], b.expression[1])\n\
                && are_similar(a.expression[2], b.expression[2])\n\
            );\n\
        }\n\
        if (a.arity === \"function\" && a.arity === \"regexp\") {\n\
            return false;\n\
        }\n\
        return true;\n\
    }\n\
    return false;\n\
}\n\
\n\
function semicolon() {\n\
\n\
// Try to match a semicolon.\n\
\n\
    if (next_token.id === \";\") {\n\
        advance(\";\");\n\
    } else {\n\
        warn_at(\n\
            \"expected_a_b\",\n\
            token.line,\n\
            token.thru,\n\
            \";\",\n\
            artifact(next_token)\n\
        );\n\
    }\n\
    anon = \"anonymous\";\n\
}\n\
\n\
function statement() {\n\
\n\
// Parse a statement. Any statement may have a label, but only four statements\n\
// have use for one. A statement can be one of the standard statements, or\n\
// an assignment expression, or an invocation expression.\n\
\n\
    let first;\n\
    let the_label;\n\
    let the_statement;\n\
    let the_symbol;\n\
    advance();\n\
    if (token.identifier && next_token.id === \":\") {\n\
        the_label = token;\n\
        if (the_label.id === \"ignore\") {\n\
            warn(\"unexpected_a\", the_label);\n\
        }\n\
        advance(\":\");\n\
        if (\n\
            next_token.id === \"do\"\n\
            || next_token.id === \"for\"\n\
            || next_token.id === \"switch\"\n\
            || next_token.id === \"while\"\n\
        ) {\n\
            enroll(the_label, \"label\", true);\n\
            the_label.init = true;\n\
            the_label.dead = false;\n\
            the_statement = statement();\n\
            the_statement.label = the_label;\n\
            the_statement.statement = true;\n\
            return the_statement;\n\
        }\n\
        advance();\n\
        warn(\"unexpected_label_a\", the_label);\n\
    }\n\
\n\
// Parse the statement.\n\
\n\
    first = token;\n\
    first.statement = true;\n\
    the_symbol = syntax[first.id];\n\
    if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n\
        the_symbol.disrupt = false;\n\
        the_symbol.statement = true;\n\
        the_statement = the_symbol.fud();\n\
    } else {\n\
\n\
// It is an expression statement.\n\
\n\
        the_statement = expression(0, true);\n\
        if (the_statement.wrapped && the_statement.id !== \"(\") {\n\
            warn(\"unexpected_a\", first);\n\
        }\n\
        semicolon();\n\
    }\n\
    if (the_label !== undefined) {\n\
        the_label.dead = true;\n\
    }\n\
    return the_statement;\n\
}\n\
\n\
function statements() {\n\
\n\
// Parse a list of statements. Give a warning if an unreachable statement\n\
// follows a disruptive statement.\n\
\n\
    const array = [];\n\
    (function next(disrupt) {\n\
        if (\n\
            next_token.id !== \"}\"\n\
            && next_token.id !== \"case\"\n\
            && next_token.id !== \"default\"\n\
            && next_token.id !== \"else\"\n\
            && next_token.id !== \"(end)\"\n\
        ) {\n\
            let a_statement = statement();\n\
            array.push(a_statement);\n\
            if (disrupt) {\n\
                warn(\"unreachable_a\", a_statement);\n\
            }\n\
            return next(a_statement.disrupt);\n\
        }\n\
    }(false));\n\
    return array;\n\
}\n\
\n\
function not_top_level(thing) {\n\
\n\
// Some features should not be at the outermost level.\n\
\n\
    if (functionage === global) {\n\
        warn(\"unexpected_at_top_level_a\", thing);\n\
    }\n\
}\n\
\n\
function top_level_only(the_thing) {\n\
\n\
// Some features must be at the most outermost level.\n\
\n\
    if (blockage !== global) {\n\
        warn(\"misplaced_a\", the_thing);\n\
    }\n\
}\n\
\n\
function block(special) {\n\
\n\
// Parse a block, a sequence of statements wrapped in braces.\n\
//  special \"body\"      The block is a function body.\n\
//          \"ignore\"    No warning on an empty block.\n\
//          \"naked\"     No advance.\n\
//          undefined   An ordinary block.\n\
\n\
    let stmts;\n\
    let the_block;\n\
    if (special !== \"naked\") {\n\
        advance(\"{\");\n\
    }\n\
    the_block = token;\n\
    the_block.arity = \"statement\";\n\
    the_block.body = special === \"body\";\n\
\n\
// Top level function bodies may include the \"use strict\" pragma.\n\
\n\
    if (\n\
        special === \"body\"\n\
        && stack.length === 1\n\
        && next_token.value === \"use strict\"\n\
    ) {\n\
        next_token.statement = true;\n\
        advance(\"(string)\");\n\
        advance(\";\");\n\
    }\n\
    stmts = statements();\n\
    the_block.block = stmts;\n\
    if (stmts.length === 0) {\n\
        if (!option.devel && special !== \"ignore\") {\n\
            warn(\"empty_block\", the_block);\n\
        }\n\
        the_block.disrupt = false;\n\
    } else {\n\
        the_block.disrupt = stmts[stmts.length - 1].disrupt;\n\
    }\n\
    advance(\"}\");\n\
    return the_block;\n\
}\n\
\n\
function mutation_check(the_thing) {\n\
\n\
// The only expressions that may be assigned to are\n\
//      e.b\n\
//      e[b]\n\
//      v\n\
//      [destructure]\n\
//      {destructure}\n\
\n\
    if (\n\
        the_thing.arity !== \"variable\"\n\
        && the_thing.id !== \".\"\n\
        && the_thing.id !== \"[\"\n\
        && the_thing.id !== \"{\"\n\
    ) {\n\
        warn(\"bad_assignment_a\", the_thing);\n\
        return false;\n\
    }\n\
    return true;\n\
}\n\
\n\
function left_check(left, right) {\n\
\n\
// Warn if the left is not one of these:\n\
//      e.b\n\
//      e[b]\n\
//      e()\n\
//      ?:\n\
//      identifier\n\
\n\
    const id = left.id;\n\
    if (\n\
        !left.identifier\n\
        && (\n\
            left.arity !== \"ternary\"\n\
            || (\n\
                !left_check(left.expression[1])\n\
                && !left_check(left.expression[2])\n\
            )\n\
        )\n\
        && (\n\
            left.arity !== \"binary\"\n\
            || (id !== \".\" && id !== \"(\" && id !== \"[\")\n\
        )\n\
    ) {\n\
        warn(\"unexpected_a\", right);\n\
        return false;\n\
    }\n\
    return true;\n\
}\n\
\n\
// These functions are used to specify the grammar of our language:\n\
\n\
function symbol(id, bp) {\n\
\n\
// Make a symbol if it does not already exist in the language's syntax.\n\
\n\
    let the_symbol = syntax[id];\n\
    if (the_symbol === undefined) {\n\
        the_symbol = empty();\n\
        the_symbol.id = id;\n\
        the_symbol.lbp = bp || 0;\n\
        syntax[id] = the_symbol;\n\
    }\n\
    return the_symbol;\n\
}\n\
\n\
function assignment(id) {\n\
\n\
// Make an assignment operator. The one true assignment is different because\n\
// its left side, when it is a variable, is not treated as an expression.\n\
// That case is special because that is when a variable gets initialized. The\n\
// other assignment operators can modify, but they cannot initialize.\n\
\n\
    const the_symbol = symbol(id, 20);\n\
    the_symbol.led = function (left) {\n\
        const the_token = token;\n\
        let right;\n\
        the_token.arity = \"assignment\";\n\
        right = expression(20 - 1);\n\
        if (id === \"=\" && left.arity === \"variable\") {\n\
            the_token.names = left;\n\
            the_token.expression = right;\n\
        } else {\n\
            the_token.expression = [left, right];\n\
        }\n\
        if (\n\
            right.arity === \"assignment\"\n\
            || right.arity === \"pre\"\n\
            || right.arity === \"post\"\n\
        ) {\n\
            warn(\"unexpected_a\", right);\n\
        }\n\
        mutation_check(left);\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function constant(id, type, value) {\n\
\n\
// Make a constant symbol.\n\
\n\
    const the_symbol = symbol(id);\n\
    the_symbol.constant = true;\n\
    the_symbol.nud = (\n\
        typeof value === \"function\"\n\
        ? value\n\
        : function () {\n\
            token.constant = true;\n\
            if (value !== undefined) {\n\
                token.value = value;\n\
            }\n\
            return token;\n\
        }\n\
    );\n\
    the_symbol.type = type;\n\
    the_symbol.value = value;\n\
    return the_symbol;\n\
}\n\
\n\
function infix(id, bp, f) {\n\
\n\
// Make an infix operator.\n\
\n\
    const the_symbol = symbol(id, bp);\n\
    the_symbol.led = function (left) {\n\
        const the_token = token;\n\
        the_token.arity = \"binary\";\n\
        if (f !== undefined) {\n\
            return f(left);\n\
        }\n\
        the_token.expression = [left, expression(bp)];\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function infixr(id, bp) {\n\
\n\
// Make a right associative infix operator.\n\
\n\
    const the_symbol = symbol(id, bp);\n\
    the_symbol.led = function (left) {\n\
        const the_token = token;\n\
        the_token.arity = \"binary\";\n\
        the_token.expression = [left, expression(bp - 1)];\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function post(id) {\n\
\n\
// Make one of the post operators.\n\
\n\
    const the_symbol = symbol(id, 150);\n\
    the_symbol.led = function (left) {\n\
        token.expression = left;\n\
        token.arity = \"post\";\n\
        mutation_check(token.expression);\n\
        return token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function pre(id) {\n\
\n\
// Make one of the pre operators.\n\
\n\
    const the_symbol = symbol(id);\n\
    the_symbol.nud = function () {\n\
        const the_token = token;\n\
        the_token.arity = \"pre\";\n\
        the_token.expression = expression(150);\n\
        mutation_check(the_token.expression);\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function prefix(id, f) {\n\
\n\
// Make a prefix operator.\n\
\n\
    const the_symbol = symbol(id);\n\
    the_symbol.nud = function () {\n\
        const the_token = token;\n\
        the_token.arity = \"unary\";\n\
        if (typeof f === \"function\") {\n\
            return f();\n\
        }\n\
        the_token.expression = expression(150);\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function stmt(id, f) {\n\
\n\
// Make a statement.\n\
\n\
    const the_symbol = symbol(id);\n\
    the_symbol.fud = function () {\n\
        token.arity = \"statement\";\n\
        return f();\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
function ternary(id1, id2) {\n\
\n\
// Make a ternary operator.\n\
\n\
    const the_symbol = symbol(id1, 30);\n\
    the_symbol.led = function (left) {\n\
        const the_token = token;\n\
        const second = expression(20);\n\
        advance(id2);\n\
        token.arity = \"ternary\";\n\
        the_token.arity = \"ternary\";\n\
        the_token.expression = [left, second, expression(10)];\n\
        if (next_token.id !== \")\") {\n\
            warn(\"use_open\", the_token);\n\
        }\n\
        return the_token;\n\
    };\n\
    return the_symbol;\n\
}\n\
\n\
// Begin defining the language.\n\
\n\
syntax = empty();\n\
\n\
symbol(\"}\");\n\
symbol(\")\");\n\
symbol(\"]\");\n\
symbol(\",\");\n\
symbol(\";\");\n\
symbol(\":\");\n\
symbol(\"*/\");\n\
symbol(\"await\");\n\
symbol(\"case\");\n\
symbol(\"catch\");\n\
symbol(\"class\");\n\
symbol(\"default\");\n\
symbol(\"else\");\n\
symbol(\"enum\");\n\
symbol(\"finally\");\n\
symbol(\"implements\");\n\
symbol(\"interface\");\n\
symbol(\"package\");\n\
symbol(\"private\");\n\
symbol(\"protected\");\n\
symbol(\"public\");\n\
symbol(\"static\");\n\
symbol(\"super\");\n\
symbol(\"void\");\n\
symbol(\"yield\");\n\
\n\
constant(\"(number)\", \"number\");\n\
constant(\"(regexp)\", \"regexp\");\n\
constant(\"(string)\", \"string\");\n\
constant(\"arguments\", \"object\", function () {\n\
    warn(\"unexpected_a\", token);\n\
    return token;\n\
});\n\
constant(\"eval\", \"function\", function () {\n\
    if (!option.eval) {\n\
        warn(\"unexpected_a\", token);\n\
    } else if (next_token.id !== \"(\") {\n\
        warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n\
    }\n\
    return token;\n\
});\n\
constant(\"false\", \"boolean\", false);\n\
constant(\"Function\", \"function\", function () {\n\
    if (!option.eval) {\n\
        warn(\"unexpected_a\", token);\n\
    } else if (next_token.id !== \"(\") {\n\
        warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n\
    }\n\
    return token;\n\
});\n\
constant(\"ignore\", \"undefined\", function () {\n\
    warn(\"unexpected_a\", token);\n\
    return token;\n\
});\n\
constant(\"Infinity\", \"number\", Infinity);\n\
constant(\"isFinite\", \"function\", function () {\n\
    warn(\"expected_a_b\", token, \"Number.isFinite\", \"isFinite\");\n\
    return token;\n\
});\n\
constant(\"isNaN\", \"function\", function () {\n\
    warn(\"number_isNaN\", token);\n\
    return token;\n\
});\n\
constant(\"NaN\", \"number\", NaN);\n\
constant(\"null\", \"null\", null);\n\
constant(\"this\", \"object\", function () {\n\
    if (!option.this) {\n\
        warn(\"unexpected_a\", token);\n\
    }\n\
    return token;\n\
});\n\
constant(\"true\", \"boolean\", true);\n\
constant(\"undefined\", \"undefined\");\n\
\n\
assignment(\"=\");\n\
assignment(\"+=\");\n\
assignment(\"-=\");\n\
assignment(\"*=\");\n\
assignment(\"/=\");\n\
assignment(\"%=\");\n\
assignment(\"&=\");\n\
assignment(\"|=\");\n\
assignment(\"^=\");\n\
assignment(\"<<=\");\n\
assignment(\">>=\");\n\
assignment(\">>>=\");\n\
\n\
infix(\"??\", 35);\n\
infix(\"||\", 40);\n\
infix(\"&&\", 50);\n\
infix(\"|\", 70);\n\
infix(\"^\", 80);\n\
infix(\"&\", 90);\n\
infix(\"==\", 100);\n\
infix(\"===\", 100);\n\
infix(\"!=\", 100);\n\
infix(\"!==\", 100);\n\
infix(\"<\", 110);\n\
infix(\">\", 110);\n\
infix(\"<=\", 110);\n\
infix(\">=\", 110);\n\
infix(\"in\", 110);\n\
infix(\"instanceof\", 110);\n\
infix(\"<<\", 120);\n\
infix(\">>\", 120);\n\
infix(\">>>\", 120);\n\
infix(\"+\", 130);\n\
infix(\"-\", 130);\n\
infix(\"*\", 140);\n\
infix(\"/\", 140);\n\
infix(\"%\", 140);\n\
infixr(\"**\", 150);\n\
infix(\"(\", 160, function (left) {\n\
    const the_paren = token;\n\
    let the_argument;\n\
    if (left.id !== \"function\") {\n\
        left_check(left, the_paren);\n\
    }\n\
    if (functionage.arity === \"statement\" && left.identifier) {\n\
        functionage.name.calls[left.id] = left;\n\
    }\n\
    the_paren.expression = [left];\n\
    if (next_token.id !== \")\") {\n\
        (function next() {\n\
            let ellipsis;\n\
            if (next_token.id === \"...\") {\n\
                ellipsis = true;\n\
                advance(\"...\");\n\
            }\n\
            the_argument = expression(10);\n\
            if (ellipsis) {\n\
                the_argument.ellipsis = true;\n\
            }\n\
            the_paren.expression.push(the_argument);\n\
            if (next_token.id === \",\") {\n\
                advance(\",\");\n\
                return next();\n\
            }\n\
        }());\n\
    }\n\
    advance(\")\", the_paren);\n\
    if (the_paren.expression.length === 2) {\n\
        the_paren.free = true;\n\
        if (the_argument.wrapped === true) {\n\
            warn(\"unexpected_a\", the_paren);\n\
        }\n\
        if (the_argument.id === \"(\") {\n\
            the_argument.wrapped = true;\n\
        }\n\
    } else {\n\
        the_paren.free = false;\n\
    }\n\
    return the_paren;\n\
});\n\
infix(\".\", 170, function (left) {\n\
    const the_token = token;\n\
    const name = next_token;\n\
    if (\n\
        (\n\
            left.id !== \"(string)\"\n\
            || (name.id !== \"indexOf\" && name.id !== \"repeat\")\n\
        )\n\
        && (\n\
            left.id !== \"[\"\n\
            || (\n\
                name.id !== \"concat\"\n\
                && name.id !== \"forEach\"\n\
                && name.id !== \"join\"\n\
                && name.id !== \"map\"\n\
            )\n\
        )\n\
        && (left.id !== \"+\" || name.id !== \"slice\")\n\
        && (\n\
            left.id !== \"(regexp)\"\n\
            || (name.id !== \"exec\" && name.id !== \"test\")\n\
        )\n\
    ) {\n\
        left_check(left, the_token);\n\
    }\n\
    if (!name.identifier) {\n\
        stop(\"expected_identifier_a\");\n\
    }\n\
    advance();\n\
    survey(name);\n\
\n\
// The property name is not an expression.\n\
\n\
    the_token.name = name;\n\
    the_token.expression = left;\n\
    return the_token;\n\
});\n\
infix(\"?.\", 170, function (left) {\n\
    const the_token = token;\n\
    const name = next_token;\n\
    if (\n\
        (\n\
            left.id !== \"(string)\"\n\
            || (name.id !== \"indexOf\" && name.id !== \"repeat\")\n\
        )\n\
        && (\n\
            left.id !== \"[\"\n\
            || (\n\
                name.id !== \"concat\"\n\
                && name.id !== \"forEach\"\n\
                && name.id !== \"join\"\n\
                && name.id !== \"map\"\n\
            )\n\
        )\n\
        && (left.id !== \"+\" || name.id !== \"slice\")\n\
        && (\n\
            left.id !== \"(regexp)\"\n\
            || (name.id !== \"exec\" && name.id !== \"test\")\n\
        )\n\
    ) {\n\
        left_check(left, the_token);\n\
    }\n\
    if (!name.identifier) {\n\
        stop(\"expected_identifier_a\");\n\
    }\n\
    advance();\n\
    survey(name);\n\
\n\
// The property name is not an expression.\n\
\n\
    the_token.name = name;\n\
    the_token.expression = left;\n\
    return the_token;\n\
});\n\
infix(\"[\", 170, function (left) {\n\
    const the_token = token;\n\
    const the_subscript = expression(0);\n\
    if (the_subscript.id === \"(string)\" || the_subscript.id === \"`\") {\n\
        const name = survey(the_subscript);\n\
        if (rx_identifier.test(name)) {\n\
            warn(\"subscript_a\", the_subscript, name);\n\
        }\n\
    }\n\
    left_check(left, the_token);\n\
    the_token.expression = [left, the_subscript];\n\
    advance(\"]\");\n\
    return the_token;\n\
});\n\
infix(\"=>\", 170, function (left) {\n\
    return stop(\"wrap_parameter\", left);\n\
});\n\
\n\
function do_tick() {\n\
    const the_tick = token;\n\
    the_tick.value = [];\n\
    the_tick.expression = [];\n\
    if (next_token.id !== \"`\") {\n\
        (function part() {\n\
            advance(\"(string)\");\n\
            the_tick.value.push(token);\n\
            if (next_token.id === \"${\") {\n\
                advance(\"${\");\n\
                the_tick.expression.push(expression(0));\n\
                advance(\"}\");\n\
                return part();\n\
            }\n\
        }());\n\
    }\n\
    advance(\"`\");\n\
    return the_tick;\n\
}\n\
\n\
infix(\"`\", 160, function (left) {\n\
    const the_tick = do_tick();\n\
    left_check(left, the_tick);\n\
    the_tick.expression = [left].concat(the_tick.expression);\n\
    return the_tick;\n\
});\n\
\n\
post(\"++\");\n\
post(\"--\");\n\
pre(\"++\");\n\
pre(\"--\");\n\
\n\
prefix(\"+\");\n\
prefix(\"-\");\n\
prefix(\"~\");\n\
prefix(\"!\");\n\
prefix(\"!!\");\n\
prefix(\"[\", function () {\n\
    const the_token = token;\n\
    the_token.expression = [];\n\
    if (next_token.id !== \"]\") {\n\
        (function next() {\n\
            let element;\n\
            let ellipsis = false;\n\
            if (next_token.id === \"...\") {\n\
                ellipsis = true;\n\
                advance(\"...\");\n\
            }\n\
            element = expression(10);\n\
            if (ellipsis) {\n\
                element.ellipsis = true;\n\
            }\n\
            the_token.expression.push(element);\n\
            if (next_token.id === \",\") {\n\
                advance(\",\");\n\
                return next();\n\
            }\n\
        }());\n\
    }\n\
    advance(\"]\");\n\
    return the_token;\n\
});\n\
prefix(\"/=\", function () {\n\
    stop(\"expected_a_b\", token, \"/\\\\=\", \"/=\");\n\
});\n\
prefix(\"=>\", function () {\n\
    return stop(\"expected_a_before_b\", token, \"()\", \"=>\");\n\
});\n\
prefix(\"new\", function () {\n\
    const the_new = token;\n\
    const right = expression(160);\n\
    if (next_token.id !== \"(\") {\n\
        warn(\"expected_a_before_b\", next_token, \"()\", artifact(next_token));\n\
    }\n\
    the_new.expression = right;\n\
    return the_new;\n\
});\n\
prefix(\"typeof\");\n\
prefix(\"void\", function () {\n\
    const the_void = token;\n\
    warn(\"unexpected_a\", the_void);\n\
    the_void.expression = expression(0);\n\
    return the_void;\n\
});\n\
\n\
function parameter_list() {\n\
    const list = [];\n\
    let optional;\n\
    const signature = [\"(\"];\n\
    if (next_token.id !== \")\" && next_token.id !== \"(end)\") {\n\
        (function parameter() {\n\
            let ellipsis = false;\n\
            let param;\n\
            if (next_token.id === \"{\") {\n\
                if (optional !== undefined) {\n\
                    warn(\n\
                        \"required_a_optional_b\",\n\
                        next_token,\n\
                        next_token.id,\n\
                        optional.id\n\
                    );\n\
                }\n\
                param = next_token;\n\
                param.names = [];\n\
                advance(\"{\");\n\
                signature.push(\"{\");\n\
                (function subparameter() {\n\
                    let subparam = next_token;\n\
                    if (!subparam.identifier) {\n\
                        return stop(\"expected_identifier_a\");\n\
                    }\n\
                    survey(subparam);\n\
                    advance();\n\
                    signature.push(subparam.id);\n\
                    if (next_token.id === \":\") {\n\
                        advance(\":\");\n\
                        advance();\n\
                        token.label = subparam;\n\
                        subparam = token;\n\
                        if (!subparam.identifier) {\n\
                            return stop(\"expected_identifier_a\");\n\
                        }\n\
                    }\n\
                    if (next_token.id === \"=\") {\n\
                        advance(\"=\");\n\
                        subparam.expression = expression();\n\
                        param.open = true;\n\
                    }\n\
                    param.names.push(subparam);\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        signature.push(\", \");\n\
                        return subparameter();\n\
                    }\n\
                }());\n\
                list.push(param);\n\
                advance(\"}\");\n\
                signature.push(\"}\");\n\
                if (next_token.id === \",\") {\n\
                    advance(\",\");\n\
                    signature.push(\", \");\n\
                    return parameter();\n\
                }\n\
            } else if (next_token.id === \"[\") {\n\
                if (optional !== undefined) {\n\
                    warn(\n\
                        \"required_a_optional_b\",\n\
                        next_token,\n\
                        next_token.id,\n\
                        optional.id\n\
                    );\n\
                }\n\
                param = next_token;\n\
                param.names = [];\n\
                advance(\"[\");\n\
                signature.push(\"[]\");\n\
                (function subparameter() {\n\
                    const subparam = next_token;\n\
                    if (!subparam.identifier) {\n\
                        return stop(\"expected_identifier_a\");\n\
                    }\n\
                    advance();\n\
                    param.names.push(subparam);\n\
                    if (next_token.id === \"=\") {\n\
                        advance(\"=\");\n\
                        subparam.expression = expression();\n\
                        param.open = true;\n\
                    }\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        return subparameter();\n\
                    }\n\
                }());\n\
                list.push(param);\n\
                advance(\"]\");\n\
                if (next_token.id === \",\") {\n\
                    advance(\",\");\n\
                    signature.push(\", \");\n\
                    return parameter();\n\
                }\n\
            } else {\n\
                if (next_token.id === \"...\") {\n\
                    ellipsis = true;\n\
                    signature.push(\"...\");\n\
                    advance(\"...\");\n\
                    if (optional !== undefined) {\n\
                        warn(\n\
                            \"required_a_optional_b\",\n\
                            next_token,\n\
                            next_token.id,\n\
                            optional.id\n\
                        );\n\
                    }\n\
                }\n\
                if (!next_token.identifier) {\n\
                    return stop(\"expected_identifier_a\");\n\
                }\n\
                param = next_token;\n\
                list.push(param);\n\
                advance();\n\
                signature.push(param.id);\n\
                if (ellipsis) {\n\
                    param.ellipsis = true;\n\
                } else {\n\
                    if (next_token.id === \"=\") {\n\
                        optional = param;\n\
                        advance(\"=\");\n\
                        param.expression = expression(0);\n\
                    } else {\n\
                        if (optional !== undefined) {\n\
                            warn(\n\
                                \"required_a_optional_b\",\n\
                                param,\n\
                                param.id,\n\
                                optional.id\n\
                            );\n\
                        }\n\
                    }\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        signature.push(\", \");\n\
                        return parameter();\n\
                    }\n\
                }\n\
            }\n\
        }());\n\
    }\n\
    advance(\")\");\n\
    signature.push(\")\");\n\
    return [list, signature.join(\"\")];\n\
}\n\
\n\
function do_function(the_function) {\n\
    let name;\n\
    if (the_function === undefined) {\n\
        the_function = token;\n\
\n\
// A function statement must have a name that will be in the parent's scope.\n\
\n\
        if (the_function.arity === \"statement\") {\n\
            if (!next_token.identifier) {\n\
                return stop(\"expected_identifier_a\", next_token);\n\
            }\n\
            name = next_token;\n\
            enroll(name, \"variable\", true);\n\
            the_function.name = name;\n\
            name.init = true;\n\
            name.calls = empty();\n\
            advance();\n\
        } else if (name === undefined) {\n\
\n\
// A function expression may have an optional name.\n\
\n\
            if (next_token.identifier) {\n\
                name = next_token;\n\
                the_function.name = name;\n\
                advance();\n\
            } else {\n\
                the_function.name = anon;\n\
            }\n\
        }\n\
    } else {\n\
        name = the_function.name;\n\
    }\n\
    the_function.level = functionage.level + 1;\n\
    if (mega_mode) {\n\
        warn(\"unexpected_a\", the_function);\n\
    }\n\
\n\
// Don't make functions in loops. It is inefficient, and it can lead to scoping\n\
// errors.\n\
\n\
    if (functionage.loop > 0) {\n\
        warn(\"function_in_loop\", the_function);\n\
    }\n\
\n\
// Give the function properties for storing its names and for observing the\n\
// depth of loops and switches.\n\
\n\
    the_function.context = empty();\n\
    the_function.finally = 0;\n\
    the_function.loop = 0;\n\
    the_function.switch = 0;\n\
    the_function.try = 0;\n\
\n\
// Push the current function context and establish a new one.\n\
\n\
    stack.push(functionage);\n\
    functions.push(the_function);\n\
    functionage = the_function;\n\
    if (the_function.arity !== \"statement\" && typeof name === \"object\") {\n\
        enroll(name, \"function\", true);\n\
        name.dead = false;\n\
        name.init = true;\n\
        name.used = 1;\n\
    }\n\
\n\
// Parse the parameter list.\n\
\n\
    advance(\"(\");\n\
    token.free = false;\n\
    token.arity = \"function\";\n\
    [functionage.parameters, functionage.signature] = parameter_list();\n\
    functionage.parameters.forEach(function enroll_parameter(name) {\n\
        if (name.identifier) {\n\
            enroll(name, \"parameter\", false);\n\
        } else {\n\
            name.names.forEach(enroll_parameter);\n\
        }\n\
    });\n\
\n\
// The function's body is a block.\n\
\n\
    the_function.block = block(\"body\");\n\
    if (\n\
        the_function.arity === \"statement\"\n\
        && next_token.line === token.line\n\
    ) {\n\
        return stop(\"unexpected_a\", next_token);\n\
    }\n\
    if (\n\
        next_token.id === \".\"\n\
        || next_token.id === \"?.\"\n\
        || next_token.id === \"[\"\n\
    ) {\n\
        warn(\"unexpected_a\");\n\
    }\n\
\n\
// Restore the previous context.\n\
\n\
    functionage = stack.pop();\n\
    return the_function;\n\
}\n\
\n\
prefix(\"function\", do_function);\n\
\n\
function fart(pl) {\n\
    advance(\"=>\");\n\
    const the_fart = token;\n\
    the_fart.arity = \"binary\";\n\
    the_fart.name = \"=>\";\n\
    the_fart.level = functionage.level + 1;\n\
    functions.push(the_fart);\n\
    if (functionage.loop > 0) {\n\
        warn(\"function_in_loop\", the_fart);\n\
    }\n\
\n\
// Give the function properties storing its names and for observing the depth\n\
// of loops and switches.\n\
\n\
    the_fart.context = empty();\n\
    the_fart.finally = 0;\n\
    the_fart.loop = 0;\n\
    the_fart.switch = 0;\n\
    the_fart.try = 0;\n\
\n\
// Push the current function context and establish a new one.\n\
\n\
    stack.push(functionage);\n\
    functionage = the_fart;\n\
    the_fart.parameters = pl[0];\n\
    the_fart.signature = pl[1];\n\
    the_fart.parameters.forEach(function (name) {\n\
        enroll(name, \"parameter\", true);\n\
    });\n\
    if (next_token.id === \"{\") {\n\
        warn(\"expected_a_b\", the_fart, \"function\", \"=>\");\n\
        the_fart.block = block(\"body\");\n\
    } else {\n\
        the_fart.expression = expression(0);\n\
    }\n\
    functionage = stack.pop();\n\
    return the_fart;\n\
}\n\
\n\
prefix(\"(\", function () {\n\
    const the_paren = token;\n\
    let the_value;\n\
    const cadet = lookahead().id;\n\
\n\
// We can distinguish between a parameter list for => and a wrapped expression\n\
// with one token of lookahead.\n\
\n\
    if (\n\
        next_token.id === \")\"\n\
        || next_token.id === \"...\"\n\
        || (next_token.identifier && (cadet === \",\" || cadet === \"=\"))\n\
    ) {\n\
        the_paren.free = false;\n\
        return fart(parameter_list());\n\
    }\n\
    the_paren.free = true;\n\
    the_value = expression(0);\n\
    if (the_value.wrapped === true) {\n\
        warn(\"unexpected_a\", the_paren);\n\
    }\n\
    the_value.wrapped = true;\n\
    advance(\")\", the_paren);\n\
    if (next_token.id === \"=>\") {\n\
        if (the_value.arity !== \"variable\") {\n\
            if (the_value.id === \"{\" || the_value.id === \"[\") {\n\
                warn(\"expected_a_before_b\", the_paren, \"function\", \"(\");\n\
                return stop(\"expected_a_b\", next_token, \"{\", \"=>\");\n\
            }\n\
            return stop(\"expected_identifier_a\", the_value);\n\
        }\n\
        the_paren.expression = [the_value];\n\
        return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n\
    }\n\
    return the_value;\n\
});\n\
prefix(\"`\", do_tick);\n\
prefix(\"{\", function () {\n\
    const the_brace = token;\n\
    const seen = empty();\n\
    the_brace.expression = [];\n\
    if (next_token.id !== \"}\") {\n\
        (function member() {\n\
            let extra;\n\
            let full;\n\
            let id;\n\
            let name = next_token;\n\
            let value;\n\
            advance();\n\
            if (\n\
                (name.id === \"get\" || name.id === \"set\")\n\
                && next_token.identifier\n\
            ) {\n\
                if (!option.getset) {\n\
                    warn(\"unexpected_a\", name);\n\
                }\n\
                extra = name.id;\n\
                full = extra + \" \" + next_token.id;\n\
                name = next_token;\n\
                advance();\n\
                id = survey(name);\n\
                if (seen[full] === true || seen[id] === true) {\n\
                    warn(\"duplicate_a\", name);\n\
                }\n\
                seen[id] = false;\n\
                seen[full] = true;\n\
            } else {\n\
                id = survey(name);\n\
                if (typeof seen[id] === \"boolean\") {\n\
                    warn(\"duplicate_a\", name);\n\
                }\n\
                seen[id] = true;\n\
            }\n\
            if (name.identifier) {\n\
                if (next_token.id === \"}\" || next_token.id === \",\") {\n\
                    if (typeof extra === \"string\") {\n\
                        advance(\"(\");\n\
                    }\n\
                    value = expression(Infinity, true);\n\
                } else if (next_token.id === \"(\") {\n\
                    value = do_function({\n\
                        arity: \"unary\",\n\
                        from: name.from,\n\
                        id: \"function\",\n\
                        line: name.line,\n\
                        name: (\n\
                            typeof extra === \"string\"\n\
                            ? extra\n\
                            : id\n\
                        ),\n\
                        thru: name.from\n\
                    });\n\
                } else {\n\
                    if (typeof extra === \"string\") {\n\
                        advance(\"(\");\n\
                    }\n\
                    let the_colon = next_token;\n\
                    advance(\":\");\n\
                    value = expression(0);\n\
                    if (value.id === name.id && value.id !== \"function\") {\n\
                        warn(\"unexpected_a\", the_colon, \": \" + name.id);\n\
                    }\n\
                }\n\
                value.label = name;\n\
                if (typeof extra === \"string\") {\n\
                    value.extra = extra;\n\
                }\n\
                the_brace.expression.push(value);\n\
            } else {\n\
                advance(\":\");\n\
                value = expression(0);\n\
                value.label = name;\n\
                the_brace.expression.push(value);\n\
            }\n\
            if (next_token.id === \",\") {\n\
                advance(\",\");\n\
                return member();\n\
            }\n\
        }());\n\
    }\n\
    advance(\"}\");\n\
    return the_brace;\n\
});\n\
\n\
stmt(\";\", function () {\n\
    warn(\"unexpected_a\", token);\n\
    return token;\n\
});\n\
stmt(\"{\", function () {\n\
    warn(\"naked_block\", token);\n\
    return block(\"naked\");\n\
});\n\
stmt(\"break\", function () {\n\
    const the_break = token;\n\
    let the_label;\n\
    if (\n\
        (functionage.loop < 1 && functionage.switch < 1)\n\
        || functionage.finally > 0\n\
    ) {\n\
        warn(\"unexpected_a\", the_break);\n\
    }\n\
    the_break.disrupt = true;\n\
    if (next_token.identifier && token.line === next_token.line) {\n\
        the_label = functionage.context[next_token.id];\n\
        if (\n\
            the_label === undefined\n\
            || the_label.role !== \"label\"\n\
            || the_label.dead\n\
        ) {\n\
            warn(\n\
                (the_label !== undefined && the_label.dead)\n\
                ? \"out_of_scope_a\"\n\
                : \"not_label_a\"\n\
            );\n\
        } else {\n\
            the_label.used += 1;\n\
        }\n\
        the_break.label = next_token;\n\
        advance();\n\
    }\n\
    advance(\";\");\n\
    return the_break;\n\
});\n\
\n\
function do_var() {\n\
    const the_statement = token;\n\
    const is_const = the_statement.id === \"const\";\n\
    the_statement.names = [];\n\
\n\
// A program may use var or let, but not both.\n\
\n\
    if (!is_const) {\n\
        if (var_mode === undefined) {\n\
            var_mode = the_statement.id;\n\
        } else if (the_statement.id !== var_mode) {\n\
            warn(\n\
                \"expected_a_b\",\n\
                the_statement,\n\
                var_mode,\n\
                the_statement.id\n\
            );\n\
        }\n\
    }\n\
\n\
// We don't expect to see variables created in switch statements.\n\
\n\
    if (functionage.switch > 0) {\n\
        warn(\"var_switch\", the_statement);\n\
    }\n\
    if (functionage.loop > 0 && the_statement.id === \"var\") {\n\
        warn(\"var_loop\", the_statement);\n\
    }\n\
    (function next() {\n\
        if (next_token.id === \"{\" && the_statement.id !== \"var\") {\n\
            const the_brace = next_token;\n\
            advance(\"{\");\n\
            (function pair() {\n\
                if (!next_token.identifier) {\n\
                    return stop(\"expected_identifier_a\", next_token);\n\
                }\n\
                const name = next_token;\n\
                survey(name);\n\
                advance();\n\
                if (next_token.id === \":\") {\n\
                    advance(\":\");\n\
                    if (!next_token.identifier) {\n\
                        return stop(\"expected_identifier_a\", next_token);\n\
                    }\n\
                    next_token.label = name;\n\
                    the_statement.names.push(next_token);\n\
                    enroll(next_token, \"variable\", is_const);\n\
                    advance();\n\
                    the_brace.open = true;\n\
                } else {\n\
                    the_statement.names.push(name);\n\
                    enroll(name, \"variable\", is_const);\n\
                }\n\
                name.dead = false;\n\
                name.init = true;\n\
                if (next_token.id === \"=\") {\n\
                    advance(\"=\");\n\
                    name.expression = expression();\n\
                    the_brace.open = true;\n\
                }\n\
                if (next_token.id === \",\") {\n\
                    advance(\",\");\n\
                    return pair();\n\
                }\n\
            }());\n\
            advance(\"}\");\n\
            advance(\"=\");\n\
            the_statement.expression = expression(0);\n\
        } else if (next_token.id === \"[\" && the_statement.id !== \"var\") {\n\
            const the_bracket = next_token;\n\
            advance(\"[\");\n\
            (function element() {\n\
                let ellipsis;\n\
                if (next_token.id === \"...\") {\n\
                    ellipsis = true;\n\
                    advance(\"...\");\n\
                }\n\
                if (!next_token.identifier) {\n\
                    return stop(\"expected_identifier_a\", next_token);\n\
                }\n\
                const name = next_token;\n\
                advance();\n\
                the_statement.names.push(name);\n\
                enroll(name, \"variable\", is_const);\n\
                name.dead = false;\n\
                name.init = true;\n\
                if (ellipsis) {\n\
                    name.ellipsis = true;\n\
                } else {\n\
                    if (next_token.id === \"=\") {\n\
                        advance(\"=\");\n\
                        name.expression = expression();\n\
                        the_bracket.open = true;\n\
                    }\n\
                    if (next_token.id === \",\") {\n\
                        advance(\",\");\n\
                        return element();\n\
                    }\n\
                }\n\
            }());\n\
            advance(\"]\");\n\
            advance(\"=\");\n\
            the_statement.expression = expression(0);\n\
        } else if (next_token.identifier) {\n\
            const name = next_token;\n\
            advance();\n\
            if (name.id === \"ignore\") {\n\
                warn(\"unexpected_a\", name);\n\
            }\n\
            enroll(name, \"variable\", is_const);\n\
            if (next_token.id === \"=\" || is_const) {\n\
                advance(\"=\");\n\
                name.dead = false;\n\
                name.init = true;\n\
                name.expression = expression(0);\n\
            }\n\
            the_statement.names.push(name);\n\
        } else {\n\
            return stop(\"expected_identifier_a\", next_token);\n\
        }\n\
    }());\n\
    semicolon();\n\
    return the_statement;\n\
}\n\
\n\
stmt(\"const\", do_var);\n\
stmt(\"continue\", function () {\n\
    const the_continue = token;\n\
    if (functionage.loop < 1 || functionage.finally > 0) {\n\
        warn(\"unexpected_a\", the_continue);\n\
    }\n\
    not_top_level(the_continue);\n\
    the_continue.disrupt = true;\n\
    warn(\"unexpected_a\", the_continue);\n\
    advance(\";\");\n\
    return the_continue;\n\
});\n\
stmt(\"debugger\", function () {\n\
    const the_debug = token;\n\
    if (!option.devel) {\n\
        warn(\"unexpected_a\", the_debug);\n\
    }\n\
    semicolon();\n\
    return the_debug;\n\
});\n\
stmt(\"delete\", function () {\n\
    const the_token = token;\n\
    const the_value = expression(0);\n\
    if (\n\
        (the_value.id !== \".\" && the_value.id !== \"[\")\n\
        || the_value.arity !== \"binary\"\n\
    ) {\n\
        stop(\"expected_a_b\", the_value, \".\", artifact(the_value));\n\
    }\n\
    the_token.expression = the_value;\n\
    semicolon();\n\
    return the_token;\n\
});\n\
stmt(\"do\", function () {\n\
    const the_do = token;\n\
    not_top_level(the_do);\n\
    functionage.loop += 1;\n\
    the_do.block = block();\n\
    advance(\"while\");\n\
    the_do.expression = condition();\n\
    semicolon();\n\
    if (the_do.block.disrupt === true) {\n\
        warn(\"weird_loop\", the_do);\n\
    }\n\
    functionage.loop -= 1;\n\
    return the_do;\n\
});\n\
stmt(\"export\", function () {\n\
    const the_export = token;\n\
    let the_id;\n\
    let the_name;\n\
    let the_thing;\n\
\n\
    function export_id() {\n\
        if (!next_token.identifier) {\n\
            stop(\"expected_identifier_a\");\n\
        }\n\
        the_id = next_token.id;\n\
        the_name = global.context[the_id];\n\
        if (the_name === undefined) {\n\
            warn(\"unexpected_a\");\n\
        } else {\n\
            the_name.used += 1;\n\
            if (exports[the_id] !== undefined) {\n\
                warn(\"duplicate_a\");\n\
            }\n\
            exports[the_id] = the_name;\n\
        }\n\
        advance();\n\
        the_export.expression.push(the_thing);\n\
    }\n\
\n\
    the_export.expression = [];\n\
    if (next_token.id === \"default\") {\n\
        if (exports.default !== undefined) {\n\
            warn(\"duplicate_a\");\n\
        }\n\
        advance(\"default\");\n\
        the_thing = expression(0);\n\
        if (\n\
            the_thing.id !== \"(\"\n\
            || the_thing.expression[0].id !== \".\"\n\
            || the_thing.expression[0].expression.id !== \"Object\"\n\
            || the_thing.expression[0].name.id !== \"freeze\"\n\
        ) {\n\
            warn(\"freeze_exports\", the_thing);\n\
        }\n\
        if (next_token.id === \";\") {\n\
            semicolon();\n\
        }\n\
        exports.default = the_thing;\n\
        the_export.expression.push(the_thing);\n\
    } else {\n\
        if (next_token.id === \"function\") {\n\
            warn(\"freeze_exports\");\n\
            the_thing = statement();\n\
            the_name = the_thing.name;\n\
            the_id = the_name.id;\n\
            the_name.used += 1;\n\
            if (exports[the_id] !== undefined) {\n\
                warn(\"duplicate_a\", the_name);\n\
            }\n\
            exports[the_id] = the_thing;\n\
            the_export.expression.push(the_thing);\n\
            the_thing.statement = false;\n\
            the_thing.arity = \"unary\";\n\
        } else if (\n\
            next_token.id === \"var\"\n\
            || next_token.id === \"let\"\n\
            || next_token.id === \"const\"\n\
        ) {\n\
            warn(\"unexpected_a\", next_token);\n\
            statement();\n\
        } else if (next_token.id === \"{\") {\n\
            advance(\"{\");\n\
            (function loop() {\n\
                export_id();\n\
                if (next_token.id === \",\") {\n\
                    advance(\",\");\n\
                    return loop();\n\
                }\n\
            }());\n\
            advance(\"}\");\n\
            semicolon();\n\
        } else {\n\
            stop(\"unexpected_a\");\n\
        }\n\
    }\n\
    module_mode = true;\n\
    return the_export;\n\
});\n\
stmt(\"for\", function () {\n\
    let first;\n\
    const the_for = token;\n\
    if (!option.for) {\n\
        warn(\"unexpected_a\", the_for);\n\
    }\n\
    not_top_level(the_for);\n\
    functionage.loop += 1;\n\
    advance(\"(\");\n\
    token.free = true;\n\
    if (next_token.id === \";\") {\n\
        return stop(\"expected_a_b\", the_for, \"while (\", \"for (;\");\n\
    }\n\
    if (\n\
        next_token.id === \"var\"\n\
        || next_token.id === \"let\"\n\
        || next_token.id === \"const\"\n\
    ) {\n\
        return stop(\"unexpected_a\");\n\
    }\n\
    first = expression(0);\n\
    if (first.id === \"in\") {\n\
        if (first.expression[0].arity !== \"variable\") {\n\
            warn(\"bad_assignment_a\", first.expression[0]);\n\
        }\n\
        the_for.name = first.expression[0];\n\
        the_for.expression = first.expression[1];\n\
        warn(\"expected_a_b\", the_for, \"Object.keys\", \"for in\");\n\
    } else {\n\
        the_for.initial = first;\n\
        advance(\";\");\n\
        the_for.expression = expression(0);\n\
        advance(\";\");\n\
        the_for.inc = expression(0);\n\
        if (the_for.inc.id === \"++\") {\n\
            warn(\"expected_a_b\", the_for.inc, \"+= 1\", \"++\");\n\
        }\n\
    }\n\
    advance(\")\");\n\
    the_for.block = block();\n\
    if (the_for.block.disrupt === true) {\n\
        warn(\"weird_loop\", the_for);\n\
    }\n\
    functionage.loop -= 1;\n\
    return the_for;\n\
});\n\
stmt(\"function\", do_function);\n\
stmt(\"if\", function () {\n\
    let the_else;\n\
    const the_if = token;\n\
    the_if.expression = condition();\n\
    the_if.block = block();\n\
    if (next_token.id === \"else\") {\n\
        advance(\"else\");\n\
        the_else = token;\n\
        the_if.else = (\n\
            next_token.id === \"if\"\n\
            ? statement()\n\
            : block()\n\
        );\n\
        if (the_if.block.disrupt === true) {\n\
            if (the_if.else.disrupt === true) {\n\
                the_if.disrupt = true;\n\
            } else {\n\
                warn(\"unexpected_a\", the_else);\n\
            }\n\
        }\n\
    }\n\
    return the_if;\n\
});\n\
stmt(\"import\", function () {\n\
    const the_import = token;\n\
    if (next_token.id === \"(\") {\n\
        the_import.arity = \"unary\";\n\
        the_import.constant = true;\n\
        the_import.statement = false;\n\
        advance(\"(\");\n\
        const string = expression(0);\n\
        if (string.id !== \"(string)\") {\n\
            warn(\"expected_string_a\", string);\n\
        }\n\
        froms.push(token.value);\n\
        advance(\")\");\n\
        advance(\".\");\n\
        advance(\"then\");\n\
        advance(\"(\");\n\
        the_import.expression = expression(0);\n\
        advance(\")\");\n\
        semicolon();\n\
        return the_import;\n\
    }\n\
    let name;\n\
    if (typeof module_mode === \"object\") {\n\
        warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n\
    }\n\
    module_mode = true;\n\
    if (next_token.identifier) {\n\
        name = next_token;\n\
        advance();\n\
        if (name.id === \"ignore\") {\n\
            warn(\"unexpected_a\", name);\n\
        }\n\
        enroll(name, \"variable\", true);\n\
        the_import.name = name;\n\
    } else {\n\
        const names = [];\n\
        advance(\"{\");\n\
        if (next_token.id !== \"}\") {\n\
            while (true) {\n\
                if (!next_token.identifier) {\n\
                    stop(\"expected_identifier_a\");\n\
                }\n\
                name = next_token;\n\
                advance();\n\
                if (name.id === \"ignore\") {\n\
                    warn(\"unexpected_a\", name);\n\
                }\n\
                enroll(name, \"variable\", true);\n\
                names.push(name);\n\
                if (next_token.id !== \",\") {\n\
                    break;\n\
                }\n\
                advance(\",\");\n\
            }\n\
        }\n\
        advance(\"}\");\n\
        the_import.name = names;\n\
    }\n\
    advance(\"from\");\n\
    advance(\"(string)\");\n\
    the_import.import = token;\n\
    if (!rx_module.test(token.value)) {\n\
        warn(\"bad_module_name_a\", token);\n\
    }\n\
    froms.push(token.value);\n\
    semicolon();\n\
    return the_import;\n\
});\n\
stmt(\"let\", do_var);\n\
stmt(\"return\", function () {\n\
    const the_return = token;\n\
    not_top_level(the_return);\n\
    if (functionage.finally > 0) {\n\
        warn(\"unexpected_a\", the_return);\n\
    }\n\
    the_return.disrupt = true;\n\
    if (next_token.id !== \";\" && the_return.line === next_token.line) {\n\
        the_return.expression = expression(10);\n\
    }\n\
    advance(\";\");\n\
    return the_return;\n\
});\n\
stmt(\"switch\", function () {\n\
    let dups = [];\n\
    let last;\n\
    let stmts;\n\
    const the_cases = [];\n\
    let the_disrupt = true;\n\
    const the_switch = token;\n\
    not_top_level(the_switch);\n\
    if (functionage.finally > 0) {\n\
        warn(\"unexpected_a\", the_switch);\n\
    }\n\
    functionage.switch += 1;\n\
    advance(\"(\");\n\
    token.free = true;\n\
    the_switch.expression = expression(0);\n\
    the_switch.block = the_cases;\n\
    advance(\")\");\n\
    advance(\"{\");\n\
    (function major() {\n\
        const the_case = next_token;\n\
        the_case.arity = \"statement\";\n\
        the_case.expression = [];\n\
        (function minor() {\n\
            advance(\"case\");\n\
            token.switch = true;\n\
            const exp = expression(0);\n\
            if (dups.some(function (thing) {\n\
                return are_similar(thing, exp);\n\
            })) {\n\
                warn(\"unexpected_a\", exp);\n\
            }\n\
            dups.push(exp);\n\
            the_case.expression.push(exp);\n\
            advance(\":\");\n\
            if (next_token.id === \"case\") {\n\
                return minor();\n\
            }\n\
        }());\n\
        stmts = statements();\n\
        if (stmts.length < 1) {\n\
            warn(\"expected_statements_a\");\n\
            return;\n\
        }\n\
        the_case.block = stmts;\n\
        the_cases.push(the_case);\n\
        last = stmts[stmts.length - 1];\n\
        if (last.disrupt) {\n\
            if (last.id === \"break\" && last.label === undefined) {\n\
                the_disrupt = false;\n\
            }\n\
        } else {\n\
            warn(\n\
                \"expected_a_before_b\",\n\
                next_token,\n\
                \"break;\",\n\
                artifact(next_token)\n\
            );\n\
        }\n\
        if (next_token.id === \"case\") {\n\
            return major();\n\
        }\n\
    }());\n\
    dups = undefined;\n\
    if (next_token.id === \"default\") {\n\
        const the_default = next_token;\n\
        advance(\"default\");\n\
        token.switch = true;\n\
        advance(\":\");\n\
        the_switch.else = statements();\n\
        if (the_switch.else.length < 1) {\n\
            warn(\"unexpected_a\", the_default);\n\
            the_disrupt = false;\n\
        } else {\n\
            const the_last = the_switch.else[the_switch.else.length - 1];\n\
            if (the_last.id === \"break\" && the_last.label === undefined) {\n\
                warn(\"unexpected_a\", the_last);\n\
                the_last.disrupt = false;\n\
            }\n\
            the_disrupt = the_disrupt && the_last.disrupt;\n\
        }\n\
    } else {\n\
        the_disrupt = false;\n\
    }\n\
    advance(\"}\", the_switch);\n\
    functionage.switch -= 1;\n\
    the_switch.disrupt = the_disrupt;\n\
    // hack-jslint - validate sorted-case-statements\n\
    let aa;\n\
    let bb;\n\
    let ii;\n\
    ii = 0;\n\
    while (ii < the_cases.length) {\n\
        aa = bb;\n\
        bb = the_cases[ii].expression[0];\n\
        if (!(\n\
            ii === 0\n\
            || (\n\
                aa.id === \"(number)\" && bb.id === \"(number)\"\n\
                && Number(aa.value) < Number(bb.value)\n\
            )\n\
            || lines[aa.line] < lines[bb.line]\n\
        )) {\n\
            warn_at(\n\
                \"Unsorted case-statements.\",\n\
                the_cases[ii].expression[0].line,\n\
                0\n\
            );\n\
            break;\n\
        }\n\
        ii += 1;\n\
    }\n\
    return the_switch;\n\
});\n\
stmt(\"throw\", function () {\n\
    const the_throw = token;\n\
    the_throw.disrupt = true;\n\
    the_throw.expression = expression(10);\n\
    semicolon();\n\
    if (functionage.try > 0) {\n\
        warn(\"unexpected_a\", the_throw);\n\
    }\n\
    return the_throw;\n\
});\n\
stmt(\"try\", function () {\n\
    let the_catch;\n\
    let the_disrupt;\n\
    const the_try = token;\n\
    if (functionage.try > 0) {\n\
        warn(\"unexpected_a\", the_try);\n\
    }\n\
    functionage.try += 1;\n\
    the_try.block = block();\n\
    the_disrupt = the_try.block.disrupt;\n\
    if (next_token.id === \"catch\") {\n\
        let ignored = \"ignore\";\n\
        the_catch = next_token;\n\
        the_try.catch = the_catch;\n\
        advance(\"catch\");\n\
        if (next_token.id === \"(\") {\n\
            advance(\"(\");\n\
            if (!next_token.identifier) {\n\
                return stop(\"expected_identifier_a\", next_token);\n\
            }\n\
            if (next_token.id !== \"ignore\") {\n\
                ignored = undefined;\n\
                the_catch.name = next_token;\n\
                enroll(next_token, \"exception\", true);\n\
            }\n\
            advance();\n\
            advance(\")\");\n\
        }\n\
        the_catch.block = block(ignored);\n\
        if (the_catch.block.disrupt !== true) {\n\
            the_disrupt = false;\n\
        }\n\
    } else {\n\
        warn(\n\
            \"expected_a_before_b\",\n\
            next_token,\n\
            \"catch\",\n\
            artifact(next_token)\n\
        );\n\
    }\n\
    if (next_token.id === \"finally\") {\n\
        functionage.finally += 1;\n\
        advance(\"finally\");\n\
        the_try.else = block();\n\
        the_disrupt = the_try.else.disrupt;\n\
        functionage.finally -= 1;\n\
    }\n\
    the_try.disrupt = the_disrupt;\n\
    functionage.try -= 1;\n\
    return the_try;\n\
});\n\
stmt(\"var\", do_var);\n\
stmt(\"while\", function () {\n\
    const the_while = token;\n\
    not_top_level(the_while);\n\
    functionage.loop += 1;\n\
    the_while.expression = condition();\n\
    the_while.block = block();\n\
    if (the_while.block.disrupt === true) {\n\
        warn(\"weird_loop\", the_while);\n\
    }\n\
    functionage.loop -= 1;\n\
    return the_while;\n\
});\n\
stmt(\"with\", function () {\n\
    stop(\"unexpected_a\", token);\n\
});\n\
\n\
ternary(\"?\", \":\");\n\
\n\
// Ambulation of the parse tree.\n\
\n\
function action(when) {\n\
\n\
// Produce a function that will register task functions that will be called as\n\
// the tree is traversed.\n\
\n\
    return function (arity, id, task) {\n\
        let a_set = when[arity];\n\
        let i_set;\n\
\n\
// The id parameter is optional. If excluded, the task will be applied to all\n\
// ids.\n\
\n\
        if (typeof id !== \"string\") {\n\
            task = id;\n\
            id = \"(all)\";\n\
        }\n\
\n\
// If this arity has no registrations yet, then create a set object to hold\n\
// them.\n\
\n\
        if (a_set === undefined) {\n\
            a_set = empty();\n\
            when[arity] = a_set;\n\
        }\n\
\n\
// If this id has no registrations yet, then create a set array to hold them.\n\
\n\
        i_set = a_set[id];\n\
        if (i_set === undefined) {\n\
            i_set = [];\n\
            a_set[id] = i_set;\n\
        }\n\
\n\
// Register the task with the arity and the id.\n\
\n\
        i_set.push(task);\n\
    };\n\
}\n\
\n\
function amble(when) {\n\
\n\
// Produce a function that will act on the tasks registered by an action\n\
// function while walking the tree.\n\
\n\
    return function (the_token) {\n\
\n\
// Given a task set that was built by an action function, run all of the\n\
// relevant tasks on the token.\n\
\n\
        let a_set = when[the_token.arity];\n\
        let i_set;\n\
\n\
// If there are tasks associated with the token's arity...\n\
\n\
        if (a_set !== undefined) {\n\
\n\
// If there are tasks associated with the token's id...\n\
\n\
            i_set = a_set[the_token.id];\n\
            if (i_set !== undefined) {\n\
                i_set.forEach(function (task) {\n\
                    return task(the_token);\n\
                });\n\
            }\n\
\n\
// If there are tasks for all ids.\n\
\n\
            i_set = a_set[\"(all)\"];\n\
            if (i_set !== undefined) {\n\
                i_set.forEach(function (task) {\n\
                    return task(the_token);\n\
                });\n\
            }\n\
        }\n\
    };\n\
}\n\
\n\
const posts = empty();\n\
const pres = empty();\n\
const preaction = action(pres);\n\
const postaction = action(posts);\n\
const preamble = amble(pres);\n\
const postamble = amble(posts);\n\
\n\
function walk_expression(thing) {\n\
    if (thing) {\n\
        if (Array.isArray(thing)) {\n\
            thing.forEach(walk_expression);\n\
        } else {\n\
            preamble(thing);\n\
            walk_expression(thing.expression);\n\
            if (thing.id === \"function\") {\n\
                walk_statement(thing.block);\n\
            }\n\
            if (thing.arity === \"pre\" || thing.arity === \"post\") {\n\
                warn(\"unexpected_a\", thing);\n\
            } else if (\n\
                thing.arity === \"statement\"\n\
                || thing.arity === \"assignment\"\n\
            ) {\n\
                warn(\"unexpected_statement_a\", thing);\n\
            }\n\
            postamble(thing);\n\
        }\n\
    }\n\
}\n\
\n\
function walk_statement(thing) {\n\
    if (thing) {\n\
        if (Array.isArray(thing)) {\n\
            thing.forEach(walk_statement);\n\
        } else {\n\
            preamble(thing);\n\
            walk_expression(thing.expression);\n\
            if (thing.arity === \"binary\") {\n\
                if (thing.id !== \"(\") {\n\
                    warn(\"unexpected_expression_a\", thing);\n\
                }\n\
            } else if (\n\
                thing.arity !== \"statement\"\n\
                && thing.arity !== \"assignment\"\n\
                && thing.id !== \"import\"\n\
            ) {\n\
                warn(\"unexpected_expression_a\", thing);\n\
            }\n\
            walk_statement(thing.block);\n\
            walk_statement(thing.else);\n\
            postamble(thing);\n\
        }\n\
    }\n\
}\n\
\n\
function lookup(thing) {\n\
    if (thing.arity === \"variable\") {\n\
\n\
// Look up the variable in the current context.\n\
\n\
        let the_variable = functionage.context[thing.id];\n\
\n\
// If it isn't local, search all the other contexts. If there are name\n\
// collisions, take the most recent.\n\
\n\
        if (the_variable === undefined) {\n\
            stack.forEach(function (outer) {\n\
                const a_variable = outer.context[thing.id];\n\
                if (\n\
                    a_variable !== undefined\n\
                    && a_variable.role !== \"label\"\n\
                ) {\n\
                    the_variable = a_variable;\n\
                }\n\
            });\n\
\n\
// If it isn't in any of those either, perhaps it is a predefined global.\n\
// If so, add it to the global context.\n\
\n\
            if (the_variable === undefined) {\n\
                if (declared_globals[thing.id] === undefined) {\n\
                    warn(\"undeclared_a\", thing);\n\
                    return;\n\
                }\n\
                the_variable = {\n\
                    dead: false,\n\
                    parent: global,\n\
                    id: thing.id,\n\
                    init: true,\n\
                    role: \"variable\",\n\
                    used: 0,\n\
                    writable: false\n\
                };\n\
                global.context[thing.id] = the_variable;\n\
            }\n\
            the_variable.closure = true;\n\
            functionage.context[thing.id] = the_variable;\n\
        } else if (the_variable.role === \"label\") {\n\
            warn(\"label_a\", thing);\n\
        }\n\
        if (\n\
            the_variable.dead\n\
            && (\n\
                the_variable.calls === undefined\n\
                || functionage.name === undefined\n\
                || the_variable.calls[functionage.name.id] === undefined\n\
            )\n\
        ) {\n\
            warn(\"out_of_scope_a\", thing);\n\
        }\n\
        return the_variable;\n\
    }\n\
}\n\
\n\
function subactivate(name) {\n\
    name.init = true;\n\
    name.dead = false;\n\
    blockage.live.push(name);\n\
}\n\
\n\
function preaction_function(thing) {\n\
    if (thing.arity === \"statement\" && blockage.body !== true) {\n\
        warn(\"unexpected_a\", thing);\n\
    }\n\
    stack.push(functionage);\n\
    block_stack.push(blockage);\n\
    functionage = thing;\n\
    blockage = thing;\n\
    thing.live = [];\n\
    if (typeof thing.name === \"object\") {\n\
        thing.name.dead = false;\n\
        thing.name.init = true;\n\
    }\n\
    if (thing.extra === \"get\") {\n\
        if (thing.parameters.length !== 0) {\n\
            warn(\"bad_get\", thing);\n\
        }\n\
    } else if (thing.extra === \"set\") {\n\
        if (thing.parameters.length !== 1) {\n\
            warn(\"bad_set\", thing);\n\
        }\n\
    }\n\
    thing.parameters.forEach(function (name) {\n\
        walk_expression(name.expression);\n\
        if (name.id === \"{\" || name.id === \"[\") {\n\
            name.names.forEach(subactivate);\n\
        } else {\n\
            name.dead = false;\n\
            name.init = true;\n\
        }\n\
    });\n\
}\n\
\n\
function bitwise_check(thing) {\n\
    if (!option.bitwise && bitwiseop[thing.id] === true) {\n\
        warn(\"unexpected_a\", thing);\n\
    }\n\
    if (\n\
        thing.id !== \"(\"\n\
        && thing.id !== \"&&\"\n\
        && thing.id !== \"||\"\n\
        && thing.id !== \"=\"\n\
        && Array.isArray(thing.expression)\n\
        && thing.expression.length === 2\n\
        && (\n\
            relationop[thing.expression[0].id] === true\n\
            || relationop[thing.expression[1].id] === true\n\
        )\n\
    ) {\n\
        warn(\"unexpected_a\", thing);\n\
    }\n\
}\n\
\n\
function pop_block() {\n\
    blockage.live.forEach(function (name) {\n\
        name.dead = true;\n\
    });\n\
    delete blockage.live;\n\
    blockage = block_stack.pop();\n\
}\n\
\n\
function activate(name) {\n\
    name.dead = false;\n\
    if (name.expression !== undefined) {\n\
        walk_expression(name.expression);\n\
        if (name.id === \"{\" || name.id === \"[\") {\n\
            name.names.forEach(subactivate);\n\
        } else {\n\
            name.init = true;\n\
        }\n\
    }\n\
    blockage.live.push(name);\n\
}\n\
\n\
function action_var(thing) {\n\
    thing.names.forEach(activate);\n\
}\n\
\n\
preaction(\"assignment\", bitwise_check);\n\
preaction(\"binary\", bitwise_check);\n\
preaction(\"binary\", function (thing) {\n\
    if (relationop[thing.id] === true) {\n\
        const left = thing.expression[0];\n\
        const right = thing.expression[1];\n\
        if (left.id === \"NaN\" || right.id === \"NaN\") {\n\
            warn(\"number_isNaN\", thing);\n\
        } else if (left.id === \"typeof\") {\n\
            if (right.id !== \"(string)\") {\n\
                if (right.id !== \"typeof\") {\n\
                    warn(\"expected_string_a\", right);\n\
                }\n\
            } else {\n\
                const value = right.value;\n\
                if (value === \"null\" || value === \"undefined\") {\n\
                    warn(\"unexpected_typeof_a\", right, value);\n\
                } else if (\n\
                    value !== \"boolean\"\n\
                    && value !== \"function\"\n\
                    && value !== \"number\"\n\
                    && value !== \"object\"\n\
                    && value !== \"string\"\n\
                    && value !== \"symbol\"\n\
                ) {\n\
                    warn(\"expected_type_string_a\", right, value);\n\
                }\n\
            }\n\
        }\n\
    }\n\
});\n\
preaction(\"binary\", \"==\", function (thing) {\n\
    warn(\"expected_a_b\", thing, \"===\", \"==\");\n\
});\n\
preaction(\"binary\", \"!=\", function (thing) {\n\
    warn(\"expected_a_b\", thing, \"!==\", \"!=\");\n\
});\n\
preaction(\"binary\", \"=>\", preaction_function);\n\
preaction(\"binary\", \"||\", function (thing) {\n\
    thing.expression.forEach(function (thang) {\n\
        if (thang.id === \"&&\" && !thang.wrapped) {\n\
            warn(\"and\", thang);\n\
        }\n\
    });\n\
});\n\
preaction(\"binary\", \"(\", function (thing) {\n\
    const left = thing.expression[0];\n\
    if (\n\
        left.identifier\n\
        && functionage.context[left.id] === undefined\n\
        && typeof functionage.name === \"object\"\n\
    ) {\n\
        const parent = functionage.name.parent;\n\
        if (parent) {\n\
            const left_variable = parent.context[left.id];\n\
            if (\n\
                left_variable !== undefined\n\
                && left_variable.dead\n\
                && left_variable.parent === parent\n\
                && left_variable.calls !== undefined\n\
                && left_variable.calls[functionage.name.id] !== undefined\n\
            ) {\n\
                left_variable.dead = false;\n\
            }\n\
        }\n\
    }\n\
});\n\
preaction(\"binary\", \"in\", function (thing) {\n\
    warn(\"infix_in\", thing);\n\
});\n\
preaction(\"binary\", \"instanceof\", function (thing) {\n\
    warn(\"unexpected_a\", thing);\n\
});\n\
preaction(\"binary\", \".\", function (thing) {\n\
    if (thing.expression.new) {\n\
        thing.new = true;\n\
    }\n\
});\n\
preaction(\"statement\", \"{\", function (thing) {\n\
    block_stack.push(blockage);\n\
    blockage = thing;\n\
    thing.live = [];\n\
});\n\
preaction(\"statement\", \"for\", function (thing) {\n\
    if (thing.name !== undefined) {\n\
        const the_variable = lookup(thing.name);\n\
        if (the_variable !== undefined) {\n\
            the_variable.init = true;\n\
            if (!the_variable.writable) {\n\
                warn(\"bad_assignment_a\", thing.name);\n\
            }\n\
        }\n\
    }\n\
    walk_statement(thing.initial);\n\
});\n\
preaction(\"statement\", \"function\", preaction_function);\n\
preaction(\"unary\", \"~\", bitwise_check);\n\
preaction(\"unary\", \"function\", preaction_function);\n\
preaction(\"variable\", function (thing) {\n\
    const the_variable = lookup(thing);\n\
    if (the_variable !== undefined) {\n\
        thing.variable = the_variable;\n\
        the_variable.used += 1;\n\
    }\n\
});\n\
\n\
function init_variable(name) {\n\
    const the_variable = lookup(name);\n\
    if (the_variable !== undefined) {\n\
        if (the_variable.writable) {\n\
            the_variable.init = true;\n\
            return;\n\
        }\n\
    }\n\
    warn(\"bad_assignment_a\", name);\n\
}\n\
\n\
postaction(\"assignment\", \"+=\", function (thing) {\n\
    let right = thing.expression[1];\n\
    if (right.constant) {\n\
        if (\n\
            right.value === \"\"\n\
            || (right.id === \"(number)\" && right.value === \"0\")\n\
            || right.id === \"(boolean)\"\n\
            || right.id === \"null\"\n\
            || right.id === \"undefined\"\n\
            || Number.isNaN(right.value)\n\
        ) {\n\
            warn(\"unexpected_a\", right);\n\
        }\n\
    }\n\
});\n\
postaction(\"assignment\", function (thing) {\n\
\n\
// Assignment using = sets the init property of a variable. No other assignment\n\
// operator can do this. A = token keeps that variable (or array of variables\n\
// in case of destructuring) in its name property.\n\
\n\
    const lvalue = thing.expression[0];\n\
    if (thing.id === \"=\") {\n\
        if (thing.names !== undefined) {\n\
            if (Array.isArray(thing.names)) {\n\
                thing.names.forEach(init_variable);\n\
            } else {\n\
                init_variable(thing.names);\n\
            }\n\
        } else {\n\
            if (lvalue.id === \"[\" || lvalue.id === \"{\") {\n\
                lvalue.expression.forEach(function (thing) {\n\
                    if (thing.variable) {\n\
                        thing.variable.init = true;\n\
                    }\n\
                });\n\
            } else if (\n\
                lvalue.id === \".\"\n\
                && thing.expression[1].id === \"undefined\"\n\
            ) {\n\
                warn(\n\
                    \"expected_a_b\",\n\
                    lvalue.expression,\n\
                    \"delete\",\n\
                    \"undefined\"\n\
                );\n\
            }\n\
        }\n\
    } else {\n\
        if (lvalue.arity === \"variable\") {\n\
            if (!lvalue.variable || lvalue.variable.writable !== true) {\n\
                warn(\"bad_assignment_a\", lvalue);\n\
            }\n\
        }\n\
        const right = syntax[thing.expression[1].id];\n\
        if (\n\
            right !== undefined\n\
            && (\n\
                right.id === \"function\"\n\
                || right.id === \"=>\"\n\
                || (\n\
                    right.constant\n\
                    && right.id !== \"(number)\"\n\
                    && (right.id !== \"(string)\" || thing.id !== \"+=\")\n\
                )\n\
            )\n\
        ) {\n\
            warn(\"unexpected_a\", thing.expression[1]);\n\
        }\n\
    }\n\
});\n\
\n\
function postaction_function(thing) {\n\
    delete functionage.finally;\n\
    delete functionage.loop;\n\
    delete functionage.switch;\n\
    delete functionage.try;\n\
    functionage = stack.pop();\n\
    if (thing.wrapped) {\n\
        warn(\"unexpected_parens\", thing);\n\
    }\n\
    return pop_block();\n\
}\n\
\n\
postaction(\"binary\", function (thing) {\n\
    let right;\n\
    if (relationop[thing.id]) {\n\
        if (\n\
            is_weird(thing.expression[0])\n\
            || is_weird(thing.expression[1])\n\
            || are_similar(thing.expression[0], thing.expression[1])\n\
            || (\n\
                thing.expression[0].constant === true\n\
                && thing.expression[1].constant === true\n\
            )\n\
        ) {\n\
            warn(\"weird_relation_a\", thing);\n\
        }\n\
    }\n\
    if (thing.id === \"+\") {\n\
        if (!option.convert) {\n\
            if (thing.expression[0].value === \"\") {\n\
                warn(\"expected_a_b\", thing, \"String(...)\", \"\\\"\\\" +\");\n\
            } else if (thing.expression[1].value === \"\") {\n\
                warn(\"expected_a_b\", thing, \"String(...)\", \"+ \\\"\\\"\");\n\
            }\n\
        }\n\
    } else if (thing.id === \"[\") {\n\
        if (thing.expression[0].id === \"window\") {\n\
            warn(\"weird_expression_a\", thing, \"window[...]\");\n\
        }\n\
        if (thing.expression[0].id === \"self\") {\n\
            warn(\"weird_expression_a\", thing, \"self[...]\");\n\
        }\n\
    } else if (thing.id === \".\" || thing.id === \"?.\") {\n\
        if (thing.expression.id === \"RegExp\") {\n\
            warn(\"weird_expression_a\", thing);\n\
        }\n\
    } else if (thing.id !== \"=>\" && thing.id !== \"(\") {\n\
        right = thing.expression[1];\n\
        if (\n\
            (thing.id === \"+\" || thing.id === \"-\")\n\
            && right.id === thing.id\n\
            && right.arity === \"unary\"\n\
            && !right.wrapped\n\
        ) {\n\
            warn(\"wrap_unary\", right);\n\
        }\n\
        if (\n\
            thing.expression[0].constant === true\n\
            && right.constant === true\n\
        ) {\n\
            thing.constant = true;\n\
        }\n\
    }\n\
});\n\
postaction(\"binary\", \"&&\", function (thing) {\n\
    if (\n\
        is_weird(thing.expression[0])\n\
        || are_similar(thing.expression[0], thing.expression[1])\n\
        || thing.expression[0].constant === true\n\
        || thing.expression[1].constant === true\n\
    ) {\n\
        warn(\"weird_condition_a\", thing);\n\
    }\n\
});\n\
postaction(\"binary\", \"||\", function (thing) {\n\
    if (\n\
        is_weird(thing.expression[0])\n\
        || are_similar(thing.expression[0], thing.expression[1])\n\
        || thing.expression[0].constant === true\n\
    ) {\n\
        warn(\"weird_condition_a\", thing);\n\
    }\n\
});\n\
postaction(\"binary\", \"=>\", postaction_function);\n\
postaction(\"binary\", \"(\", function (thing) {\n\
    let left = thing.expression[0];\n\
    let the_new;\n\
    let arg;\n\
    if (left.id === \"new\") {\n\
        the_new = left;\n\
        left = left.expression;\n\
    }\n\
    if (left.id === \"function\") {\n\
        if (!thing.wrapped) {\n\
            warn(\"wrap_immediate\", thing);\n\
        }\n\
    } else if (left.identifier) {\n\
        if (the_new !== undefined) {\n\
            if (\n\
                left.id[0] > \"Z\"\n\
                || left.id === \"Boolean\"\n\
                || left.id === \"Number\"\n\
                || left.id === \"String\"\n\
                || left.id === \"Symbol\"\n\
            ) {\n\
                warn(\"unexpected_a\", the_new);\n\
            } else if (left.id === \"Function\") {\n\
                if (!option.eval) {\n\
                    warn(\"unexpected_a\", left, \"new Function\");\n\
                }\n\
            } else if (left.id === \"Array\") {\n\
                arg = thing.expression;\n\
                if (arg.length !== 2 || arg[1].id === \"(string)\") {\n\
                    warn(\"expected_a_b\", left, \"[]\", \"new Array\");\n\
                }\n\
            } else if (left.id === \"Object\") {\n\
                warn(\n\
                    \"expected_a_b\",\n\
                    left,\n\
                    \"Object.create(null)\",\n\
                    \"new Object\"\n\
                );\n\
            }\n\
        } else {\n\
            if (\n\
                left.id[0] >= \"A\"\n\
                && left.id[0] <= \"Z\"\n\
                && left.id !== \"Boolean\"\n\
                && left.id !== \"Number\"\n\
                && left.id !== \"String\"\n\
                && left.id !== \"Symbol\"\n\
            ) {\n\
                warn(\n\
                    \"expected_a_before_b\",\n\
                    left,\n\
                    \"new\",\n\
                    artifact(left)\n\
                );\n\
            }\n\
        }\n\
    } else if (left.id === \".\") {\n\
        let cack = the_new !== undefined;\n\
        if (left.expression.id === \"Date\" && left.name.id === \"UTC\") {\n\
            cack = !cack;\n\
        }\n\
        if (rx_cap.test(left.name.id) !== cack) {\n\
            if (the_new !== undefined) {\n\
                warn(\"unexpected_a\", the_new);\n\
            } else {\n\
                warn(\n\
                    \"expected_a_before_b\",\n\
                    left.expression,\n\
                    \"new\",\n\
                    left.name.id\n\
                );\n\
            }\n\
        }\n\
        if (left.name.id === \"getTime\") {\n\
            const paren = left.expression;\n\
            if (paren.id === \"(\") {\n\
                const array = paren.expression;\n\
                if (array.length === 1) {\n\
                    const new_date = array[0];\n\
                    if (\n\
                        new_date.id === \"new\"\n\
                        && new_date.expression.id === \"Date\"\n\
                    ) {\n\
                        warn(\n\
                            \"expected_a_b\",\n\
                            new_date,\n\
                            \"Date.now()\",\n\
                            \"new Date().getTime()\"\n\
                        );\n\
                    }\n\
                }\n\
            }\n\
        }\n\
    }\n\
});\n\
postaction(\"binary\", \"[\", function (thing) {\n\
    if (thing.expression[0].id === \"RegExp\") {\n\
        warn(\"weird_expression_a\", thing);\n\
    }\n\
    if (is_weird(thing.expression[1])) {\n\
        warn(\"weird_expression_a\", thing.expression[1]);\n\
    }\n\
});\n\
postaction(\"statement\", \"{\", pop_block);\n\
postaction(\"statement\", \"const\", action_var);\n\
postaction(\"statement\", \"export\", top_level_only);\n\
postaction(\"statement\", \"for\", function (thing) {\n\
    walk_statement(thing.inc);\n\
});\n\
postaction(\"statement\", \"function\", postaction_function);\n\
postaction(\"statement\", \"import\", function (the_thing) {\n\
    const name = the_thing.name;\n\
    if (name) {\n\
        if (Array.isArray(name)) {\n\
            name.forEach(function (name) {\n\
                name.dead = false;\n\
                name.init = true;\n\
                blockage.live.push(name);\n\
            });\n\
        } else {\n\
            name.dead = false;\n\
            name.init = true;\n\
            blockage.live.push(name);\n\
        }\n\
        return top_level_only(the_thing);\n\
    }\n\
});\n\
postaction(\"statement\", \"let\", action_var);\n\
postaction(\"statement\", \"try\", function (thing) {\n\
    if (thing.catch !== undefined) {\n\
        const the_name = thing.catch.name;\n\
        if (the_name !== undefined) {\n\
            const the_variable = functionage.context[the_name.id];\n\
            the_variable.dead = false;\n\
            the_variable.init = true;\n\
        }\n\
        walk_statement(thing.catch.block);\n\
    }\n\
});\n\
postaction(\"statement\", \"var\", action_var);\n\
postaction(\"ternary\", function (thing) {\n\
    if (\n\
        is_weird(thing.expression[0])\n\
        || thing.expression[0].constant === true\n\
        || are_similar(thing.expression[1], thing.expression[2])\n\
    ) {\n\
        warn(\"unexpected_a\", thing);\n\
    } else if (are_similar(thing.expression[0], thing.expression[1])) {\n\
        warn(\"expected_a_b\", thing, \"||\", \"?\");\n\
    } else if (are_similar(thing.expression[0], thing.expression[2])) {\n\
        warn(\"expected_a_b\", thing, \"&&\", \"?\");\n\
    } else if (\n\
        thing.expression[1].id === \"true\"\n\
        && thing.expression[2].id === \"false\"\n\
    ) {\n\
        warn(\"expected_a_b\", thing, \"!!\", \"?\");\n\
    } else if (\n\
        thing.expression[1].id === \"false\"\n\
        && thing.expression[2].id === \"true\"\n\
    ) {\n\
        warn(\"expected_a_b\", thing, \"!\", \"?\");\n\
    } else if (\n\
        thing.expression[0].wrapped !== true\n\
        && (\n\
            thing.expression[0].id === \"||\"\n\
            || thing.expression[0].id === \"&&\"\n\
        )\n\
    ) {\n\
        warn(\"wrap_condition\", thing.expression[0]);\n\
    }\n\
});\n\
postaction(\"unary\", function (thing) {\n\
    if (thing.id === \"`\") {\n\
        if (thing.expression.every(function (thing) {\n\
            return thing.constant;\n\
        })) {\n\
            thing.constant = true;\n\
        }\n\
    } else if (thing.id === \"!\") {\n\
        if (thing.expression.constant === true) {\n\
            warn(\"unexpected_a\", thing);\n\
        }\n\
    } else if (thing.id === \"!!\") {\n\
        if (!option.convert) {\n\
            warn(\"expected_a_b\", thing, \"Boolean(...)\", \"!!\");\n\
        }\n\
    } else if (\n\
        thing.id !== \"[\"\n\
        && thing.id !== \"{\"\n\
        && thing.id !== \"function\"\n\
        && thing.id !== \"new\"\n\
    ) {\n\
        if (thing.expression.constant === true) {\n\
            thing.constant = true;\n\
        }\n\
    }\n\
});\n\
postaction(\"unary\", \"function\", postaction_function);\n\
postaction(\"unary\", \"+\", function (thing) {\n\
    if (!option.convert) {\n\
        warn(\"expected_a_b\", thing, \"Number(...)\", \"+\");\n\
    }\n\
    const right = thing.expression;\n\
    if (right.id === \"(\" && right.expression[0].id === \"new\") {\n\
        warn(\"unexpected_a_before_b\", thing, \"+\", \"new\");\n\
    } else if (\n\
        right.constant\n\
        || right.id === \"{\"\n\
        || (right.id === \"[\" && right.arity !== \"binary\")\n\
    ) {\n\
        warn(\"unexpected_a\", thing, \"+\");\n\
    }\n\
});\n\
\n\
function delve(the_function) {\n\
    Object.keys(the_function.context).forEach(function (id) {\n\
        if (id !== \"ignore\") {\n\
            const name = the_function.context[id];\n\
            if (name.parent === the_function) {\n\
                if (\n\
                    name.used === 0\n\
                    && (\n\
                        name.role !== \"function\"\n\
                        || name.parent.arity !== \"unary\"\n\
                    )\n\
                ) {\n\
                    warn(\"unused_a\", name);\n\
                } else if (!name.init) {\n\
                    warn(\"uninitialized_a\", name);\n\
                }\n\
            }\n\
        }\n\
    });\n\
}\n\
\n\
function uninitialized_and_unused() {\n\
\n\
// Delve into the functions looking for variables that were not initialized\n\
// or used. If the file imports or exports, then its global object is also\n\
// delved.\n\
\n\
    if (module_mode === true || option.node) {\n\
        delve(global);\n\
    }\n\
    functions.forEach(delve);\n\
}\n\
\n\
// Go through the token list, looking at usage of whitespace.\n\
\n\
function whitage() {\n\
    let closer = \"(end)\";\n\
    let free = false;\n\
    let left = global;\n\
    let margin = 0;\n\
    let nr_comments_skipped = 0;\n\
    let open = true;\n\
    let opening = true;\n\
    let right;\n\
\n\
    function pop() {\n\
        const previous = stack.pop();\n\
        closer = previous.closer;\n\
        free = previous.free;\n\
        margin = previous.margin;\n\
        open = previous.open;\n\
        opening = previous.opening;\n\
    }\n\
\n\
    function push() {\n\
        stack.push({\n\
            closer,\n\
            free,\n\
            margin,\n\
            open,\n\
            opening\n\
        });\n\
    }\n\
\n\
    function expected_at(at) {\n\
        warn(\n\
            \"expected_a_at_b_c\",\n\
            right,\n\
            artifact(right),\n\
            fudge + at,\n\
            artifact_column(right)\n\
        );\n\
    }\n\
\n\
    function at_margin(fit) {\n\
        const at = margin + fit;\n\
        // hack-jslint - exact-margin\n\
        if (right.from !== at) {\n\
            return expected_at(at);\n\
        }\n\
    }\n\
\n\
    function no_space_only() {\n\
        if (\n\
            left.id !== \"(global)\"\n\
            && left.nr + 1 === right.nr\n\
            && (\n\
                left.line !== right.line\n\
                || left.thru !== right.from\n\
            )\n\
        ) {\n\
            warn(\n\
                \"unexpected_space_a_b\",\n\
                right,\n\
                artifact(left),\n\
                artifact(right)\n\
            );\n\
        }\n\
    }\n\
\n\
    function no_space() {\n\
        if (left.line === right.line) {\n\
            if (left.thru !== right.from && nr_comments_skipped === 0) {\n\
                warn(\n\
                    \"unexpected_space_a_b\",\n\
                    right,\n\
                    artifact(left),\n\
                    artifact(right)\n\
                );\n\
            }\n\
        } else {\n\
            if (open) {\n\
                const at = (\n\
                    free\n\
                    ? margin\n\
                    : margin + 8\n\
                );\n\
                // hack-jslint - exact-margin\n\
                if (right.from !== at) {\n\
                    expected_at(at);\n\
                }\n\
            } else {\n\
                // hack-jslint - exact-margin\n\
                if (right.from !== margin + 8) {\n\
                    expected_at(margin + 8);\n\
                }\n\
            }\n\
        }\n\
    }\n\
\n\
    function one_space_only() {\n\
        if (left.line !== right.line || left.thru + 1 !== right.from) {\n\
            warn(\n\
                \"expected_space_a_b\",\n\
                right,\n\
                artifact(left),\n\
                artifact(right)\n\
            );\n\
        }\n\
    }\n\
\n\
    function one_space() {\n\
        if (left.line === right.line || !open) {\n\
            if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n\
                warn(\n\
                    \"expected_space_a_b\",\n\
                    right,\n\
                    artifact(left),\n\
                    artifact(right)\n\
                );\n\
            }\n\
        } else {\n\
            // hack-jslint - exact-margin\n\
            if (right.from !== margin) {\n\
                expected_at(margin);\n\
            }\n\
        }\n\
    }\n\
\n\
    stack = [];\n\
    tokens.forEach(function (the_token) {\n\
        right = the_token;\n\
        if (right.id === \"(comment)\" || right.id === \"(end)\") {\n\
            nr_comments_skipped += 1;\n\
        } else {\n\
\n\
// If left is an opener and right is not the closer, then push the previous\n\
// state. If the token following the opener is on the next line, then this is\n\
// an open form. If the tokens are on the same line, then it is a closed form.\n\
// Open form is more readable, with each item (statement, argument, parameter,\n\
// etc) starting on its own line. Closed form is more compact. Statement blocks\n\
// are always in open form.\n\
\n\
            const new_closer = opener[left.id];\n\
            if (typeof new_closer === \"string\") {\n\
                if (new_closer !== right.id) {\n\
                    opening = left.open || (left.line !== right.line);\n\
                    push();\n\
                    closer = new_closer;\n\
                    if (opening) {\n\
                        free = closer === \")\" && left.free;\n\
                        open = true;\n\
                        // hack-jslint - conditional-margin\n\
                        if (\n\
                            !option.modeUtility2\n\
                            || lines[right.line].startsWith(\" \")\n\
                        ) {\n\
                            margin += 4;\n\
                        }\n\
                        if (right.role === \"label\") {\n\
                            // hack-jslint - exact-margin\n\
                            if (right.from !== 0) {\n\
                                expected_at(0);\n\
                            }\n\
                        } else if (right.switch) {\n\
                            at_margin(-4);\n\
                        } else {\n\
                            at_margin(0);\n\
                        }\n\
                    } else {\n\
                        if (right.statement || right.role === \"label\") {\n\
                            warn(\n\
                                \"expected_line_break_a_b\",\n\
                                right,\n\
                                artifact(left),\n\
                                artifact(right)\n\
                            );\n\
                        }\n\
                        free = false;\n\
                        open = false;\n\
                        no_space_only();\n\
                    }\n\
                } else {\n\
\n\
// If left and right are opener and closer, then the placement of right depends\n\
// on the openness. Illegal pairs (like '{]') have already been detected.\n\
\n\
                    if (left.line === right.line) {\n\
                        no_space();\n\
                    } else {\n\
                        at_margin(0);\n\
                    }\n\
                }\n\
            } else {\n\
                if (right.statement === true) {\n\
                    if (left.id === \"else\") {\n\
                        one_space_only();\n\
                    } else {\n\
                        at_margin(0);\n\
                        open = false;\n\
                    }\n\
\n\
// If right is a closer, then pop the previous state.\n\
                } else if (right.id === closer) {\n\
                    pop();\n\
                    if (opening && right.id !== \";\") {\n\
                        at_margin(0);\n\
                    } else {\n\
                        no_space_only();\n\
                    }\n\
                } else {\n\
\n\
// Left is not an opener, and right is not a closer.\n\
// The nature of left and right will determine the space between them.\n\
\n\
// If left is ',' or ';' or right is a statement then if open,\n\
// right must go at the margin, or if closed, a space between.\n\
\n\
                    if (right.switch) {\n\
                        at_margin(-4);\n\
                    } else if (right.role === \"label\") {\n\
                        // hack-jslint - exact-margin\n\
                        if (right.from !== 0) {\n\
                            expected_at(0);\n\
                        }\n\
                    } else if (left.id === \",\") {\n\
                        if (!open || (\n\
                            (free || closer === \"]\")\n\
                            && left.line === right.line\n\
                        )) {\n\
                            one_space();\n\
                        } else {\n\
                            at_margin(0);\n\
                        }\n\
\n\
// If right is a ternary operator, line it up on the margin.\n\
                    } else if (right.arity === \"ternary\") {\n\
                        if (open) {\n\
                            at_margin(0);\n\
                        } else {\n\
                            warn(\"use_open\", right);\n\
                        }\n\
                    } else if (\n\
                        right.arity === \"binary\"\n\
                        && right.id === \"(\"\n\
                        && free\n\
                    ) {\n\
                        no_space();\n\
                    } else if (\n\
                        left.id === \".\"\n\
                        || left.id === \"?.\"\n\
                        || left.id === \"...\"\n\
                        || right.id === \",\"\n\
                        || right.id === \";\"\n\
                        || right.id === \":\"\n\
                        || (\n\
                            right.arity === \"binary\"\n\
                            && (right.id === \"(\" || right.id === \"[\")\n\
                        )\n\
                        || (\n\
                            right.arity === \"function\"\n\
                            && left.id !== \"function\"\n\
                        )\n\
                    ) {\n\
                        no_space_only();\n\
                    } else if (right.id === \".\" || right.id === \"?.\") {\n\
                        no_space_only();\n\
                    } else if (left.id === \";\") {\n\
                        if (open) {\n\
                            at_margin(0);\n\
                        }\n\
                    } else if (\n\
                        left.arity === \"ternary\"\n\
                        || left.id === \"case\"\n\
                        || left.id === \"catch\"\n\
                        || left.id === \"else\"\n\
                        || left.id === \"finally\"\n\
                        || left.id === \"while\"\n\
                        || right.id === \"catch\"\n\
                        || right.id === \"else\"\n\
                        || right.id === \"finally\"\n\
                        || (right.id === \"while\" && !right.statement)\n\
                        || (left.id === \")\" && right.id === \"{\")\n\
                    ) {\n\
                        one_space_only();\n\
                    } else if (\n\
\n\
// There is a space between left and right.\n\
\n\
                        spaceop[left.id] === true\n\
                        || spaceop[right.id] === true\n\
                        || (\n\
                            left.arity === \"binary\"\n\
                            && (left.id === \"+\" || left.id === \"-\")\n\
                        )\n\
                        || (\n\
                            right.arity === \"binary\"\n\
                            && (right.id === \"+\" || right.id === \"-\")\n\
                        )\n\
                        || left.id === \"function\"\n\
                        || left.id === \":\"\n\
                        || (\n\
                            (\n\
                                left.identifier\n\
                                || left.id === \"(string)\"\n\
                                || left.id === \"(number)\"\n\
                            )\n\
                            && (\n\
                                right.identifier\n\
                                || right.id === \"(string)\"\n\
                                || right.id === \"(number)\"\n\
                            )\n\
                        )\n\
                        || (left.arity === \"statement\" && right.id !== \";\")\n\
                    ) {\n\
                        one_space();\n\
                    } else if (left.arity === \"unary\" && left.id !== \"`\") {\n\
                        no_space_only();\n\
                    }\n\
                }\n\
            }\n\
            nr_comments_skipped = 0;\n\
            delete left.calls;\n\
            delete left.dead;\n\
            delete left.free;\n\
            delete left.init;\n\
            delete left.open;\n\
            delete left.used;\n\
            left = right;\n\
        }\n\
    });\n\
}\n\
\n\
// The jslint function itself.\n\
\n\
// hack-jslint - jslint0\n\
local.jslint0 = Object.freeze(function (\n\
    source = \"\",\n\
    option_object = empty(),\n\
    global_array = []\n\
) {\n\
    // hack-jslint - init lines_extra\n\
    line_ignore = undefined;\n\
    lines = (\n\
        Array.isArray(source)\n\
        ? source\n\
        : source.split(\n\
            /\\n|\\r\\n?/\n\
        )\n\
    );\n\
    lines_extra = lines.map(function () {\n\
        return {};\n\
    });\n\
    try {\n\
        warnings = [];\n\
        option = Object.assign(empty(), option_object);\n\
        anon = \"anonymous\";\n\
        block_stack = [];\n\
        declared_globals = empty();\n\
        directive_mode = true;\n\
        directives = [];\n\
        early_stop = true;\n\
        exports = empty();\n\
        froms = [];\n\
        fudge = (\n\
            option.fudge\n\
            ? 1\n\
            : 0\n\
        );\n\
        functions = [];\n\
        global = {\n\
            id: \"(global)\",\n\
            body: true,\n\
            context: empty(),\n\
            from: 0,\n\
            level: 0,\n\
            line: 0,\n\
            live: [],\n\
            loop: 0,\n\
            switch: 0,\n\
            thru: 0\n\
        };\n\
        blockage = global;\n\
        functionage = global;\n\
        json_mode = false;\n\
        mega_mode = false;\n\
        module_mode = false;\n\
        next_token = global;\n\
        property = empty();\n\
        shebang = false;\n\
        stack = [];\n\
        tenure = undefined;\n\
        token = global;\n\
        token_nr = 0;\n\
        var_mode = undefined;\n\
        populate(standard, declared_globals, false);\n\
        populate(global_array, declared_globals, false);\n\
        Object.keys(option).forEach(function (name) {\n\
            if (option[name] === true) {\n\
                const allowed = allowed_option[name];\n\
                if (Array.isArray(allowed)) {\n\
                    populate(allowed, declared_globals, false);\n\
                }\n\
            }\n\
        });\n\
        tokenize(source);\n\
        advance();\n\
        if (json_mode) {\n\
            tree = json_value();\n\
            advance(\"(end)\");\n\
        } else {\n\
\n\
// Because browsers encourage combining of script files, the first token might\n\
// be a semicolon to defend against a missing semicolon in the preceding file.\n\
\n\
            if (option.browser) {\n\
                if (next_token.id === \";\") {\n\
                    advance(\";\");\n\
                }\n\
            } else {\n\
\n\
// If we are not in a browser, then the file form of strict pragma may be used.\n\
\n\
                if (\n\
                    next_token.value === \"use strict\"\n\
                ) {\n\
                    advance(\"(string)\");\n\
                    advance(\";\");\n\
                }\n\
            }\n\
            tree = statements();\n\
            advance(\"(end)\");\n\
            functionage = global;\n\
            walk_statement(tree);\n\
            if (warnings.length === 0) {\n\
                uninitialized_and_unused();\n\
                if (!option.white) {\n\
                    whitage();\n\
                }\n\
            }\n\
        }\n\
        if (!option.browser) {\n\
            directives.forEach(function (comment) {\n\
                if (comment.directive === \"global\") {\n\
                    warn(\"missing_browser\", comment);\n\
                }\n\
            });\n\
        }\n\
        early_stop = false;\n\
        // hack-jslint - throw_error\n\
        if (option.throw_error) {\n\
            throw new Error();\n\
        }\n\
    } catch (e) {\n\
        // hack-jslint - early_stop\n\
        e.early_stop = true;\n\
        e.column = e.column || -1;\n\
        e.line = e.line || -1;\n\
        if (e.name !== \"JSLintError\") {\n\
            warnings.push(e);\n\
        }\n\
    }\n\
    // hack-jslint - autofix\n\
    warnings = warnings.filter(function (warning) {\n\
        let aa;\n\
        let bb;\n\
        let tmp;\n\
        if (!lines_extra[warning.line]) {\n\
            return true;\n\
        }\n\
        aa = lines_extra[warning.line].source;\n\
        warning.a = warning.a || aa.trim();\n\
        switch (option.modeAutofix && warning.code) {\n\
        // expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n\
        case \"expected_a_at_b_c\":\n\
            // autofix indent - increment\n\
            tmp = warning.b - warning.c;\n\
            if (tmp >= 0) {\n\
                bb = \" \".repeat(tmp) + aa;\n\
                break;\n\
            }\n\
            // autofix indent - decrement\n\
            tmp = -tmp;\n\
            if ((\n\
                /^\\u0020*?$/m\n\
            ).test(aa.slice(0, warning.column))) {\n\
                bb = aa.slice(tmp);\n\
                break;\n\
            }\n\
            // autofix indent - newline\n\
            bb = (\n\
                aa.slice(0, warning.column) + \"\\n\"\n\
                + \" \".repeat(warning.b) + aa.slice(warning.column)\n\
            );\n\
            break;\n\
        // expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n\
        case \"expected_a_b\":\n\
            if (\n\
                (warning.a === \"\\\\s\" || warning.a === \"\\\\u0020\")\n\
                && warning.b === \" \"\n\
            ) {\n\
                bb = (\n\
                    aa.slice(0, warning.column) + \"\\\\u0020\"\n\
                    + aa.slice(warning.column + 1)\n\
                );\n\
            }\n\
            break;\n\
        // expected_identifier_a:\n\
        // \"Expected an identifier and instead saw '{a}'.\",\n\
        case \"expected_identifier_a\":\n\
            if (\n\
                (\n\
                    /^\\d+$/m\n\
                ).test(warning.a)\n\
                && aa[warning.column + warning.a.length] === \":\"\n\
            ) {\n\
                bb = (\n\
                    aa.slice(0, warning.column) + \"\\\"\" + warning.a + \"\\\"\"\n\
                    + aa.slice(warning.column + warning.a.length)\n\
                );\n\
                break;\n\
            }\n\
            break;\n\
        // expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n\
        case \"expected_space_a_b\":\n\
            bb = (\n\
                aa.slice(0, warning.column).trimRight() + \" \"\n\
                + aa.slice(warning.column)\n\
            );\n\
            break;\n\
        // unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n\
        case \"unexpected_space_a_b\":\n\
            bb = (\n\
                aa.slice(0, warning.column).trimRight()\n\
                + aa.slice(warning.column)\n\
            );\n\
            break;\n\
        // use_double: \"Use double quotes, not single quotes.\",\n\
        case \"use_double\":\n\
            tmp = undefined;\n\
            bb = aa.slice(\n\
                0,\n\
                warning.column - 1\n\
            ) + \"\\\"\" + aa.slice(warning.column, tmp).replace((\n\
                /\\\\.|\"|'/g\n\
            ), function (match0) {\n\
                if (tmp) {\n\
                    return match0;\n\
                }\n\
                if (match0 === \"'\") {\n\
                    tmp = true;\n\
                    return \"\\\"\";\n\
                }\n\
                return (\n\
                    match0 === \"\\\"\"\n\
                    ? \"\\\\\\\"\"\n\
                    : match0[1] === \"'\"\n\
                    ? \"'\"\n\
                    : match0\n\
                );\n\
            });\n\
            break;\n\
        // use_spaces: \"Use spaces, not tabs.\",\n\
        case \"use_spaces\":\n\
            bb = aa.replace((\n\
                /^(\\u0020*?)\\t/\n\
            ), \"$1   \");\n\
            break;\n\
        }\n\
        if (bb !== undefined) {\n\
            lines_extra[warning.line].source_autofixed = bb;\n\
            return;\n\
        }\n\
        return true;\n\
    });\n\
    // hack-jslint - debug warning\n\
    warnings.some(function (warning) {\n\
        if (!option.modeUtility2) {\n\
            return true;\n\
        }\n\
        warning.option = Object.assign({}, option);\n\
        Object.keys(warning.option).forEach(function (key) {\n\
            if (typeof warning.option[key] === \"object\") {\n\
                delete warning.option[key];\n\
            }\n\
        });\n\
        return true;\n\
    });\n\
    return {\n\
        directives,\n\
        edition: \"2020-11-06\",\n\
        exports,\n\
        froms,\n\
        functions,\n\
        global,\n\
        id: \"(JSLint)\",\n\
        json: json_mode,\n\
        lines,\n\
        module: module_mode === true,\n\
        ok: warnings.length === 0 && !early_stop,\n\
        option,\n\
        property,\n\
        shebang: (\n\
            shebang\n\
            ? lines[0]\n\
            : undefined\n\
        ),\n\
        stop: early_stop,\n\
        tokens,\n\
        tree,\n\
        // hack-jslint - sort by early_stop\n\
        warnings: warnings.sort(function (a, b) {\n\
            return Boolean(b.early_stop) - Boolean(a.early_stop)\n\
            || (a.line - b.line);\n\
        }),\n\
        // hack-jslint - autofix\n\
        source_autofixed: lines_extra.map(function (element, ii) {\n\
            return element.source_autofixed || lines[ii];\n\
        }).join(\"\\n\")\n\
    };\n\
});\n\
\n\
\n\
/*\n\
file none\n\
*/\n\
local.CSSLint = CSSLint;\n\
/* jslint ignore:end */\n\
\n\
\n\
let jslintRecurse;\n\
let jslintUtility2;\n\
let stringGetLineAndCol;\n\
\n\
function jslintAutofix(code, file, opt, {fileType, globalList, iiLine}) {\n\
/*\n\
 * this function will jslint-autofix <code>\n\
 */\n\
    let code0;\n\
    let code2;\n\
    let dataList;\n\
    let ignoreList;\n\
    let ii;\n\
    let result;\n\
    let rgx1;\n\
    let rgx2;\n\
    let tmp;\n\
    // autofix-all - normalize local-function\n\
    if (\n\
        globalThis.utility2\n\
        && typeof globalThis.utility2.jslintAutofixLocalFunction\n\
        === \"function\"\n\
    ) {\n\
        code = globalThis.utility2.jslintAutofixLocalFunction(code, file);\n\
    }\n\
    // autofix-all - remove trailing-whitespace\n\
    code = code.replace((\n\
        /\\u0020+$/gm\n\
    ), \"\");\n\
    // autofix-all - remove newlines before )]}\n\
    code = code.replace((\n\
        /\\n+?(\\n\\u0020*?[)\\]}])/g\n\
    ), \"$1\");\n\
    // autofix-all - eslint - no-multiple-empty-lines\n\
    // https://github.com/eslint/eslint/blob/v7.2.0/docs/rules/no-multiple-empty-lines.md\n\
    code = code.replace((\n\
        /\\n{4,}/g\n\
    ), \"\\n\\n\\n\");\n\
    // autofix-all - recurse <script>...</script>, <style>...</style>\n\
    code = code.replace((\n\
        /(^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/\\\\n\\\\\\n(?:^.*?\\\\n\\\\\\n)*?)(';$|<\\/script>\\\\n\\\\$|<\\/style>\\\\n\\\\$)/gm\n\
    ), function (ignore, match1, match2, ii) {\n\
        return jslintRecurse(code, file + (\n\
            match2.indexOf(\"style\") >= 0\n\
            ? \".<style>.css\"\n\
            : \".<script>.js\"\n\
        ), opt, {\n\
            fileType0: \".\\\\n\\\\\",\n\
            iiEnd: ii + match1.length,\n\
            iiLine,\n\
            iiStart: ii\n\
        }) + match2;\n\
    });\n\
    switch (fileType) {\n\
    case \".css\":\n\
        break;\n\
    case \".html\":\n\
        // autofix-html - recurse <script>...</script>, <style>...</style>\n\
        code = code.replace((\n\
            /^(\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/\\n[\\S\\s]*?\\n)(<\\/(?:script|style)>)$/gm\n\
        ), function (ignore, match1, footer, ii) {\n\
            return jslintRecurse(code, file + (\n\
                footer === \"</style>\"\n\
                ? \".<style>.css\"\n\
                : \".<script>.js\"\n\
            ), opt, {\n\
                fileType0: fileType,\n\
                iiEnd: ii + match1.length,\n\
                iiLine,\n\
                iiStart: ii\n\
            }) + footer;\n\
        });\n\
        break;\n\
    case \".js\":\n\
        // de-mux - code to [code, ignoreList]\n\
        ignoreList = [];\n\
        code = code.replace((\n\
            /^\\u0020*?\\/\\*\\u0020jslint\\u0020ignore:start\\u0020\\*\\/$[\\S\\s]*?^\\/\\*\\u0020jslint\\u0020ignore:end\\u0020\\*\\/$/gm\n\
        ), function (match0) {\n\
            ignoreList.push(match0);\n\
            return \"/* jslint ignore:start:end */\";\n\
        });\n\
        // de-mux - code2 to [code2, ignoreList]\n\
        code2 = \"\";\n\
        dataList = [];\n\
        ii = 0;\n\
        rgx1 = (\n\
            /\\\\.|\\/\\*|\\*\\/|\\/\\/!!|\\/\\/|[\"'\\/`]|$/gm\n\
        );\n\
        // parse rgx\n\
        // https://github.com/douglascrockford/JSLint/blob/557afd32bcaa35480d31a86f02d3a8c06a4e5b5c/jslint.js#L1383\n\
        rgx2 = (\n\
            /(?:[^.]\\b(?:case|delete|in|instanceof|new|return|typeof|void|yield)|[!%&(*+,\\-\\/:;<=>?\\[\\^{|}~])[\\s\\u0028]*?\\/[^*\\/]/g\n\
        );\n\
        tmp = \"\";\n\
        // de-mux - shebang\n\
        code.replace((\n\
            /^#!.*/\n\
        ), function (match0) {\n\
            code2 += \"#!\";\n\
            dataList.push({\n\
                code: match0,\n\
                type: \"#_\"\n\
            });\n\
            rgx1.lastIndex = match0.length;\n\
            ii = rgx1.lastIndex;\n\
            return \"\";\n\
        });\n\
        while (rgx1.lastIndex < code.length) {\n\
            tmp = rgx1.exec(code);\n\
            switch (tmp[0]) {\n\
            case \"\":\n\
            case \"\\\"\":\n\
            case \"'\":\n\
            case \"/*\":\n\
            case \"//!!\":\n\
            case \"//\":\n\
            case \"`\":\n\
                if (tmp[0] === \"\") {\n\
                    rgx1.lastIndex += 1;\n\
                }\n\
                // de-mux - rgx /_/\n\
                rgx2.lastIndex = ii;\n\
                // normalize rgx /_*/ to /_/\n\
                if (rgx2.test(code) && rgx2.lastIndex - 2 <= tmp.index) {\n\
                    rgx1.lastIndex = rgx2.lastIndex - 1;\n\
                    tmp[0] = \"/\";\n\
                }\n\
                if (tmp[0] === \"\") {\n\
                    break;\n\
                }\n\
                // de-mux - code to [code, dataList]\n\
                code2 += code.slice(ii, rgx1.lastIndex);\n\
                ii = rgx1.lastIndex;\n\
                while (rgx1.lastIndex < code.length) {\n\
                    tmp[1] = rgx1.exec(code)[0];\n\
                    tmp[2] = tmp[0] + \"_\" + tmp[1];\n\
                    switch (tmp[2]) {\n\
                    // de-mux - false-positive rgx /_/\n\
                    case \"/_\":\n\
                        code2 += code.slice(ii, rgx1.lastIndex);\n\
                        ii = 0;\n\
                        break;\n\
                    case \"\\\"_\\\"\":\n\
                    case \"'_'\":\n\
                    case \"/*_*/\":\n\
                    case \"//!!_\":\n\
                    case \"//_\":\n\
                    case \"/_*/\":\n\
                    case \"/_/\":\n\
                    case \"`_`\":\n\
                        code2 += \"_\" + tmp[1];\n\
                        dataList.push({\n\
                            code: tmp[0] + code.slice(ii, rgx1.lastIndex),\n\
                            type: tmp[2].replace(\"/_*/\", \"/_/\")\n\
                        });\n\
                        ii = 0;\n\
                        break;\n\
                    }\n\
                    if (!ii) {\n\
                        break;\n\
                    }\n\
                    if (!tmp[1]) {\n\
                        rgx1.lastIndex += 1;\n\
                    }\n\
                }\n\
                ii = rgx1.lastIndex;\n\
                break;\n\
            }\n\
        }\n\
        code2 += code.slice(ii);\n\
        code = code2;\n\
        // normalize rgx /_*/ to /_/\n\
        code = code.replace((\n\
            /\\/_\\*\\//g\n\
        ), \"/_/\");\n\
        // autofix-js - left-align comment //_\n\
        tmp = \"\";\n\
        code = code.split(\"\\n\").reverse().map(function (line) {\n\
            return line.replace((\n\
                /^(\\u0020*)(\\/\\/_)?/\n\
            ), function (match0, match1, match2) {\n\
                if (match1 && match2) {\n\
                    return tmp + match2;\n\
                }\n\
                tmp = match1;\n\
                return match0;\n\
            });\n\
        }).reverse().join(\"\\n\");\n\
        // autofix-js-braket - normalize rgx /_/ to (/_/)\n\
        code = code.replace((\n\
            /\\/_\\/[\\w\\s]*(\\S)/g\n\
        ), function (match0, match1) {\n\
            return (\n\
                match1 === \")\"\n\
                ? match0\n\
                : match0.replace((\n\
                    /\\/_\\/\\w*/\n\
                ), \"($&)\")\n\
            );\n\
        });\n\
        // autofix-js-braket - normalize rgx (/_/) to (\\n/_/\\n)\n\
        code = code.replace((\n\
            /\\((\\/_\\/\\w*)\\)/g\n\
        ), \"(\\n    $1\\n)\");\n\
        // autofix-js-braket - normalize {... to {\\n   ...\n\
        code = code.replace((\n\
            /^(\\u0020+)(.*?(?:\\u0020\\[|\\(\\[|\\{))\\u0020*?(\\S)/gm\n\
        ), \"$1$2\\n$1    $3\");\n\
        // autofix-js-braket - normalize {\\s+} to {}\n\
        code = code.replace((\n\
            /([(\\[{])\\s*?([)\\]}])/g\n\
        ), \"$1$2\");\n\
        // autofix-js-whitespace - normalize 8-space-indent to 4-space-indent\n\
        tmp = \"\";\n\
        code = code.replace((\n\
            /^\\u0020+/gm\n\
        ), function (match0) {\n\
            if (match0.length > tmp.length + 4) {\n\
                match0 = tmp;\n\
            }\n\
            tmp = match0;\n\
            return match0;\n\
        });\n\
        code = (\"\\n\" + code + \"\\n\");\n\
        // autofix-js-whitespace - normalize comment //_... to //_\\n...\n\
        code = code.replace((\n\
            /\\/\\/_([^\\n])/g\n\
        ), \"//_\\n$1\");\n\
        // autofix-js-whitespace - normalize (function { to \\n\\n\\n(function {\n\
        code = code.replace((\n\
            /\\n+((?:\\/\\*_\\*\\/\\n|\\/\\/_\\n)*?\\(function\\u0020.*?)\\n+/g\n\
        ), \"\\n\\n\\n$1\\n\");\n\
        code = code.trim();\n\
        dataList.forEach(function (data) {\n\
            switch (data.type) {\n\
            case \"/*_*/\":\n\
                // autofix-js - comment - \"/*\" to \"\\*\"\n\
                data.code = \"/*\" + data.code.slice(2).replace((\n\
                    /\\/\\*/g\n\
                ), \"/\\\\*\");\n\
                break;\n\
            }\n\
        });\n\
        // re-mux - shebang\n\
        code = code.replace((\n\
            /^#!/\n\
        ), function () {\n\
            return dataList.shift().code;\n\
        });\n\
        // re-mux - [code, dataList] to code\n\
        code = code.replace((\n\
            /\"_\"|'_'|\\/\\*_\\*\\/|\\/\\/!!_|\\/\\/_|\\/_\\/|`_`/g\n\
        ), function (match0) {\n\
            // re-mux - defer rgx /_/\n\
            if (match0 === \"/_/\") {\n\
                dataList.push(dataList.shift());\n\
                return \"/\\u0000/\";\n\
            }\n\
            return dataList.shift().code;\n\
        });\n\
        // autofix-js - jslint autofixed code\n\
        ii = 0;\n\
        while (true) {\n\
            ii += 1;\n\
            code0 = code;\n\
            result = local.jslint0(code, opt, globalList);\n\
            code = result.source_autofixed;\n\
            if (ii >= 10 || result.stop || code0 === code) {\n\
                break;\n\
            }\n\
        }\n\
        // re-mux - rgx /_/\n\
        code = code.replace((\n\
            /\\/\\u0000\\//g\n\
        ), function () {\n\
            return dataList.shift().code;\n\
        });\n\
        // autofix-js - sort const, let, var\n\
        code = code.replace((\n\
            /(?:^\\u0020*?(?:const|let|var)\\u0020[\\w$]*?;.*?\\n)+/gm\n\
        ), function (match0) {\n\
            return match0.split(\"\\n\").slice(0, -1).sort().join(\"\\n\") + \"\\n\";\n\
        });\n\
        // re-mux - [code, ignoreList] to code\n\
        code = code.replace((\n\
            /^\\u0020*?\\/\\*\\u0020jslint\\u0020ignore:start:end\\u0020\\*\\/$/gm\n\
        ), function () {\n\
            return ignoreList.shift().trimStart();\n\
        });\n\
        break;\n\
    case \".json\":\n\
        code = JSON.stringify(local.objectDeepCopyWithKeysSorted(JSON.parse(\n\
            code\n\
        )), undefined, 4);\n\
        break;\n\
    case \".md\":\n\
        // autofix-md - recurse ```javascript...```\n\
        code = code.replace((\n\
            /^(```javascript\\n)([\\S\\s]*?\\n)```$/gm\n\
        ), function (ignore, match1, match2, ii) {\n\
            return match1 + jslintRecurse(code, (\n\
                file + \".<```javascript>.js\"\n\
            ), opt, {\n\
                fileType0: fileType,\n\
                iiEnd: ii + match1.length + match2.length,\n\
                iiLine,\n\
                iiStart: ii + match1.length\n\
            }) + \"```\";\n\
        });\n\
        break;\n\
    case \".sh\":\n\
        // autofix-sh - recurse node -e '...'\n\
        code = code.replace((\n\
            /^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/\\n[\\S\\s]*?\\n'/gm\n\
        ), function (match0, ii) {\n\
            return jslintRecurse(code, file + \".<node -e>.js\", opt, {\n\
                fileType0: fileType,\n\
                iiEnd: ii + match0.length - 1,\n\
                iiLine,\n\
                iiStart: ii\n\
            }) + \"'\";\n\
        });\n\
        break;\n\
    }\n\
    return code;\n\
}\n\
\n\
jslintRecurse = function (code, file, opt, {\n\
    fileType0,\n\
    iiEnd,\n\
    iiLine = 0,\n\
    iiStart = 0\n\
}) {\n\
/*\n\
 * this function will recursively jslint <code> for embedded code\n\
 */\n\
    let code0;\n\
    let errList;\n\
    let errMsg;\n\
    let fileType;\n\
    let globalList;\n\
    let result;\n\
    let tmp;\n\
    // init opt\n\
    local.jslintResult = {};\n\
    opt = Object.assign(local.jslintResult, opt, {\n\
        errList: [],\n\
        errMsg: \"\"\n\
    });\n\
    // init var\n\
    errList = [];\n\
    fileType = (\n\
        /\\.\\w+?$|$/m\n\
    ).exec(file)[0];\n\
    globalList = opt.globalList;\n\
    result = {};\n\
    // preserve lineno - save iiLine\n\
    iiLine += stringGetLineAndCol(code, iiStart).line;\n\
    // de-embed\n\
    code = code.slice(iiStart, iiEnd || code.length);\n\
    switch (fileType0) {\n\
    // de-embed-js - '\\\\n\\\\\\n...\\\\n\\\\\\n'\n\
    case \".\\\\n\\\\\":\n\
        // rgx - remove \\\\n\\\\\n\
        code = code.replace((\n\
            /\\\\n\\\\$|\\\\(.)/gm\n\
        ), function (ignore, match1) {\n\
            return match1 || \"\";\n\
        });\n\
        break;\n\
    // de-embed-js - '\\n...\\n'\n\
    case \".sh\":\n\
        // rgx - convert '\"'\"' to '\n\
        code = code.replace((\n\
            /'\"'\"'/g\n\
        ), \"'\");\n\
        break;\n\
    }\n\
    // init\n\
    code0 = code;\n\
    tmp = {\n\
        \".css\": (\n\
            /^\\/\\*csslint\\b|(^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/$)/m\n\
        ),\n\
        \".html\": (\n\
            /^\\/\\*csslint\\b|(^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/$)/m\n\
        ),\n\
        \".js\": (\n\
            /^\\/\\*jslint\\b|(^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/$)/m\n\
        ),\n\
        \".json\": (\n\
            /^\\s*?\\{\\s*?\"!!jslint_utility2\":\\s*?true/\n\
        ),\n\
        \".md\": (\n\
            /(^\\/\\*\\u0020jslint\\u0020utility2:true\\u0020\\*\\/$)/m\n\
        ),\n\
        \".sh\": (\n\
            /(^#\\u0020jslint\\u0020utility2:true$)/m\n\
        )\n\
    };\n\
    // jslint - .json\n\
    if (fileType === \".js\" && tmp[\".json\"].test(code.slice(0, 4096))) {\n\
        fileType = \".json\";\n\
    }\n\
    // init mode-utility2\n\
    tmp = tmp[fileType] && tmp[fileType].exec(code.slice(0, 4096));\n\
    opt.modeUtility2 = Boolean((tmp && tmp[1]) || opt.modeAutofix);\n\
    // if not modeConditional, then do not jslint\n\
    if (opt.modeConditional && !tmp) {\n\
        return code;\n\
    }\n\
    // jslint - modeAutofix\n\
    if (opt.modeAutofix) {\n\
        code = jslintAutofix(code, file, opt, {\n\
            fileType,\n\
            globalList,\n\
            iiLine\n\
        });\n\
    }\n\
    // preserve lineno - restore iiLine\n\
    code = \"\\n\".repeat(iiLine) + code;\n\
    switch (fileType) {\n\
    // jslint - .css\n\
    case \".css\":\n\
        // call csslint\n\
        result = local.CSSLint.verify(code);\n\
        // init errList\n\
        errList = result.messages.map(function (err) {\n\
            err.column = Math.max(err.col - 1, 0);\n\
            err.message = (\n\
                err.type + \" - \" + err.rule.id + \" - \" + err.message\n\
                + \"\\n    \" + err.rule.desc\n\
            );\n\
            return err;\n\
        });\n\
        break;\n\
    case \".html\":\n\
        jslintAutofix(code, file, opt, {\n\
            fileType,\n\
            globalList,\n\
            iiLine\n\
        });\n\
        break;\n\
    case \".md\":\n\
    case \".sh\":\n\
        break;\n\
    // jslint - .js\n\
    default:\n\
        // call jslint\n\
        result = local.jslint0(code, opt, globalList);\n\
        code = result.source_autofixed || code;\n\
        // init errList\n\
        errList = result.warnings.filter(function (err) {\n\
            return err && err.message;\n\
        }).map(function (err) {\n\
            err.column = err.column + 1;\n\
            err.evidence = err.source;\n\
            err.line = err.line + 1;\n\
            // debug early_stop\n\
            if (err.early_stop) {\n\
                err.message = (\n\
                    \"[JSLint was unable to finish] - \"\n\
                    + err.message\n\
                );\n\
            }\n\
            return err;\n\
        });\n\
    }\n\
    if (opt.modeUtility2) {\n\
        jslintUtility2({\n\
            code,\n\
            errList,\n\
            fileType\n\
        });\n\
    }\n\
    // jslint - print\n\
    switch (Boolean(fileType0) && fileType0) {\n\
    // re-embed-js - '\\\\n\\\\\\n...\\\\n\\\\\\n'\n\
    case \".\\\\n\\\\\":\n\
        code = code.trim();\n\
        // rgx - escape \\ to \\\\\n\
        code = code.replace((\n\
            /\\\\/g\n\
        ), \"\\\\\\\\\");\n\
        // rgx - append \\n\\\n\
        code = code.replace((\n\
            /$/gm\n\
        ), \"\\\\n\\\\\");\n\
        // rgx - escape ' to \\'\n\
        code = code.replace((\n\
            /'/g\n\
        ), \"\\\\'\");\n\
        // rgx - escape js-env to js\\-env\n\
        code = code.replace((\n\
            /\\u0020js\\u002denv\\u0020/g\n\
        ), \" js\\\\\\u002denv \");\n\
        code += \"\\n\";\n\
        break;\n\
    // re-embed-js - '\\n...\\n'\n\
    case \".sh\":\n\
        // rgx - escape ' to '\"'\"'\n\
        code = code.trim().replace((\n\
            /'/g\n\
        ), \"'\\\"'\\\"'\") + \"\\n\";\n\
        break;\n\
    case false:\n\
        code = code.trimEnd() + \"\\n\";\n\
        break;\n\
    default:\n\
        code = code.trim() + \"\\n\";\n\
    }\n\
    // autofix-save\n\
    if (\n\
        local.isEnvNode\n\
        && opt.modeAutofix\n\
        && !fileType0\n\
        && !result.stop\n\
        && code !== code0\n\
        && require(\"fs\").existsSync(file)\n\
    ) {\n\
        require(\"fs\").writeFileSync(file, code);\n\
        require(\"fs\").writeFileSync(file + \".autofix.old\", code0);\n\
        require(\"child_process\").spawnSync(\n\
            \"diff\",\n\
            [\n\
                \"-u\", file + \".autofix.old\", file\n\
            ],\n\
            {\n\
                stdio: [\n\
                    \"ignore\", 2, \"ignore\"\n\
                ]\n\
            }\n\
        );\n\
        require(\"fs\").unlinkSync(file + \".autofix.old\");\n\
        console.error(\n\
            \"\\u001b[1mjslint-autofix - modified and saved file \" + file\n\
            + \"\\u001b[22m\"\n\
        );\n\
    }\n\
    // print colorized errMsg to stderr\n\
    // https://github.com/kaizhu256/JSLint/blob/cli/cli.js#L99\n\
    errMsg = \"\";\n\
    errList.filter(function (warning) {\n\
        return warning && warning.message;\n\
    // print only first 10 warnings\n\
    }).slice(0, 10).forEach(function (err, ii) {\n\
        errMsg = errMsg || \" \\u001b[1mjslint \" + file + \"\\u001b[22m\\n\";\n\
        errMsg += (\n\
            (\"  \" + String(ii + 1)).slice(-3)\n\
            + \" \\u001b[31m\" + err.message + \"\\u001b[39m\"\n\
            + \" \\u001b[90m\\/\\/ line \" + err.line + \", column \"\n\
            + (err.column + 1)\n\
            + \"\\u001b[39m\\n\"\n\
            + (\"    \" + String(err.evidence).trim()).slice(0, 80) + \"\\n\"\n\
        );\n\
        if (!ii && err.stack && err.a !== \"debug\\u0049nline\") {\n\
            tmp = err.stack;\n\
            Object.entries(err).forEach(function ([\n\
                key, val\n\
            ]) {\n\
                if ((typeof val === \"object\" && val) || key === \"stack\") {\n\
                    delete err[key];\n\
                }\n\
            });\n\
            errMsg += (\n\
                JSON.stringify(err, undefined, 4) + \"\\n\" + tmp.trim() + \"\\n\"\n\
            );\n\
        }\n\
    });\n\
    errMsg = errMsg.trim();\n\
    if (errMsg) {\n\
        // print err to stderr\n\
        console.error(errMsg);\n\
    }\n\
    return Object.assign(local.jslintResult, opt, result, {\n\
        code,\n\
        errList,\n\
        errMsg\n\
    }).code;\n\
};\n\
\n\
jslintUtility2 = function ({code, errList, fileType}) {\n\
/*\n\
 * this function will jslint <code> with utiity2-specific rules\n\
 */\n\
    let code2;\n\
    let err;\n\
    let indent;\n\
    let previous;\n\
    // jslintUtility2 - all\n\
    code2 = code;\n\
    // ignore start to end\n\
    code2 = code2.replace((\n\
        /^\\/\\*\\u0020jslint\\u0020ignore:start\\u0020\\*\\/$[\\S\\s]+?^\\/\\*\\u0020jslint\\u0020ignore:end\\u0020\\*\\/$/gm\n\
    ), function (match0) {\n\
        // preserve lineno\n\
        return match0.replace((\n\
            /.+/g\n\
        ), \"\");\n\
    });\n\
    // lint whitespace\n\
    code2.replace((\n\
        /^\\u0020+?(?:\\*|\\/\\/!!)|^\\u0020+|[\\r\\t]/gm\n\
    ), function (match0, ii) {\n\
        switch (match0.slice(-1)) {\n\
        case \" \":\n\
            if (match0.length % 4 === 0) {\n\
                return \"\";\n\
            }\n\
            err = {\n\
                message: \"non 4-space indent\"\n\
            };\n\
            break;\n\
        case \"\\r\":\n\
            err = {\n\
                message: \"unexpected \\\\r\"\n\
            };\n\
            break;\n\
        case \"\\t\":\n\
            err = {\n\
                message: \"unexpected \\\\t\"\n\
            };\n\
            break;\n\
        default:\n\
            return \"\";\n\
        }\n\
        Object.assign(err, stringGetLineAndCol(code2, ii));\n\
        errList.push({\n\
            column: err.column,\n\
            evidence: JSON.stringify(err.evidence),\n\
            line: err.line + 1,\n\
            message: err.message\n\
        });\n\
        return \"\";\n\
    });\n\
    switch (fileType) {\n\
    // jslintUtility2 - .css\n\
    case \".css\":\n\
        // ignore comment\n\
        code2 = code2.replace((\n\
            /^\\u0020*?\\/\\*[\\S\\s]*?\\*\\/\\u0020*?$/gm\n\
        ), function (match0) {\n\
            // preserve lineno\n\
            return match0.replace((\n\
                /.+/g\n\
            ), \"\");\n\
        });\n\
        code2.replace((\n\
            /\\S\\u0020{2}|\\u0020,|^\\S.*?,.|[;{}]./gm\n\
        ), function (match0, ii) {\n\
            switch (match0.slice(-2)) {\n\
            case \"  \":\n\
                err = {\n\
                    colOffset: 2,\n\
                    message: \"unexpected multi-whitespace\"\n\
                };\n\
                break;\n\
            case \" ,\":\n\
                err = {\n\
                    colOffset: 1,\n\
                    message: \"unexpected whitespace before comma\"\n\
                };\n\
                break;\n\
            default:\n\
                err = {\n\
                    colOffset: match0.length,\n\
                    message: \"unexpected multiline-statement\"\n\
                };\n\
            }\n\
            Object.assign(err, stringGetLineAndCol(code2, ii));\n\
            errList.push({\n\
                column: err.column + err.colOffset,\n\
                evidence: JSON.stringify(err.evidence),\n\
                line: err.line + 1,\n\
                message: err.message\n\
            });\n\
            return \"\";\n\
        });\n\
        // validate line-sorted - css-selector\n\
        previous = \"\";\n\
        code2 = code2.replace((\n\
            /^.|[#.>]|[,}]$|\\u0020\\{$|\\b\\w/gm\n\
        ), function (match0) {\n\
            switch (match0) {\n\
            case \" \":\n\
                return match0;\n\
            case \" {\":\n\
                return \"\\u0001\" + match0;\n\
            case \"#\":\n\
                return \"\\u0002\" + match0;\n\
            case \",\":\n\
                return \"\\u0000\" + match0;\n\
            case \".\":\n\
                return \"\\u0001\" + match0;\n\
            case \">\":\n\
                return \"\\u0003\" + match0;\n\
            case \"}\":\n\
                return match0;\n\
            default:\n\
                return \"\\u0000\" + match0;\n\
            }\n\
        });\n\
        code2.replace((\n\
            /\\n{2,}|^\\u0000@|^\\}\\n\\}|\\}|^(?:\\S.*?\\n)+/gm\n\
        ), function (match0, ii) {\n\
            switch (match0.slice(0, 2)) {\n\
            case \"\\n\\n\":\n\
            case \"\\u0000@\":\n\
            case \"}\\n\":\n\
                previous = \"\";\n\
                return \"\";\n\
            case \"}\":\n\
                return \"\";\n\
            }\n\
            match0 = match0.trim();\n\
            err = (\n\
                !(previous < match0)\n\
                ? {\n\
                    message: \"lines not sorted\\n\" + previous + \"\\n\" + match0\n\
                }\n\
                : match0.split(\"\\n\").sort().join(\"\\n\") !== match0\n\
                ? {\n\
                    message: \"lines not sorted\\n\" + match0\n\
                }\n\
                : undefined\n\
            );\n\
            if (err) {\n\
                Object.assign(err, stringGetLineAndCol(code2, ii));\n\
                errList.push({\n\
                    column: err.column,\n\
                    evidence: err.evidence,\n\
                    line: err.line + 1,\n\
                    message: err.message.replace((\n\
                        /[\\u0000-\\u0007]/g\n\
                    ), \"\")\n\
                });\n\
            }\n\
            previous = match0;\n\
            return \"\";\n\
        });\n\
        break;\n\
    // jslintUtility2 - .html\n\
    case \".html\":\n\
        break;\n\
    // jslintUtility2 - .js\n\
    case \".js\":\n\
        // validate line-sorted - \"local.xxx = \"\n\
        previous = \"\";\n\
        code2.replace((\n\
            /^\\/\\*\\u0020validateLineSortedReset\\u0020\\*\\/$|^\\(function\\u0020\\(|(^local\\.\\S*?\\u0020=\\u0020.*?$)/gm\n\
        ), function (ignore, match1, ii) {\n\
            if (!match1) {\n\
                previous = \"\";\n\
                return;\n\
            }\n\
            if (match1.slice(-3) === \"\\\\n\\\\\") {\n\
                return;\n\
            }\n\
            if (!(previous < match1)) {\n\
                err = {\n\
                    message: \"lines not sorted\\n\" + previous + \"\\n\" + match1\n\
                };\n\
                Object.assign(err, stringGetLineAndCol(code2, ii));\n\
                errList.push({\n\
                    column: err.column,\n\
                    evidence: err.evidence,\n\
                    line: err.line + 1,\n\
                    message: err.message\n\
                });\n\
            }\n\
            previous = match1;\n\
        });\n\
        break;\n\
    // jslintUtility2 - .md\n\
    case \".md\":\n\
        break;\n\
    // jslintUtility2 - .sh\n\
    case \".sh\":\n\
        previous = \"\";\n\
        code2.replace((\n\
            /(^sh\\w+?\\(\\)\\u0020\\{)|^sh\\w+?\\u0020*?\\(\\)\\u0020*?\\{/gm\n\
        ), function (ignore, match1, ii) {\n\
            err = undefined;\n\
            if (!match1) {\n\
                err = {\n\
                    message: \"invalid whitespace\"\n\
                };\n\
            } else {\n\
                if (!(previous < match1)) {\n\
                    err = {\n\
                        message: (\n\
                            \"lines not sorted\\n\" + previous + \"\\n\" + match1\n\
                        )\n\
                    };\n\
                }\n\
                previous = match1;\n\
            }\n\
            if (err) {\n\
                Object.assign(err, stringGetLineAndCol(code2, ii));\n\
                errList.push({\n\
                    column: err.column,\n\
                    evidence: err.evidence,\n\
                    line: err.line + 1,\n\
                    message: err.message\n\
                });\n\
            }\n\
            return \"\";\n\
        });\n\
        // validate line-sorted - case-esac-statement\n\
        previous = \"\";\n\
        code2.replace((\n\
            /^(\\u0020+?)(case\\u0020.+?\\u0020in|esac|[^\\u0020()]+?\\))$/gm\n\
        ), function (ignore, match1, match2, ii) {\n\
            err = undefined;\n\
            match2 = match2.replace(\"*\", \"~*\");\n\
            switch (match2.slice(0, 5)) {\n\
            case \"case \":\n\
                indent = indent || match1;\n\
                break;\n\
            case \"esac\":\n\
                if (match1 === indent) {\n\
                    indent = \"\";\n\
                    previous = \"\";\n\
                }\n\
                break;\n\
            default:\n\
                if (match1 !== indent) {\n\
                    break;\n\
                }\n\
                if (!(previous < match2)) {\n\
                    err = {\n\
                        message: (\n\
                            \"lines not sorted\\n\" + previous + \"\\n\" + match2\n\
                        )\n\
                    };\n\
                }\n\
                previous = match2;\n\
            }\n\
            if (err) {\n\
                Object.assign(err, stringGetLineAndCol(code2, ii));\n\
                errList.push({\n\
                    column: err.column,\n\
                    evidence: err.evidence,\n\
                    line: err.line + 1,\n\
                    message: err.message\n\
                });\n\
            }\n\
            return \"\";\n\
        });\n\
        break;\n\
    }\n\
};\n\
\n\
stringGetLineAndCol = function (code, ii) {\n\
/*\n\
 * this function will get line and column from <code> at <ii>\n\
 */\n\
    let aa;\n\
    let bb;\n\
    let line;\n\
    // https://jsperf.com/regexp-counting-2/8\n\
    bb = 0;\n\
    line = 0;\n\
    while (true) {\n\
        aa = bb;\n\
        bb = code.indexOf(\"\\n\", bb) + 1;\n\
        if (bb === 0 || ii < bb) {\n\
            break;\n\
        }\n\
        line += 1;\n\
    }\n\
    return {\n\
        column: ii - aa,\n\
        evidence: code.slice(aa, Math.max((bb || code.length) - 1, 0)),\n\
        line\n\
    };\n\
};\n\
\n\
local.jslintAndPrint = function (code, file = \"undefined\", opt = {}) {\n\
/*\n\
 * this function will jslint-autofix <code>\n\
 */\n\
    return jslintRecurse(code, file, opt, {});\n\
};\n\
\n\
local.jslintAndPrintDir = function (dir, opt, onError) {\n\
/*\n\
 * this function will jslint files in <dir>\n\
 */\n\
    let errCnt;\n\
    errCnt = 0;\n\
    onError = onError || function (err) {\n\
        process.exit(Math.min((err && err.message) | 0, 127));\n\
    };\n\
    dir = require(\"path\").resolve(dir) + require(\"path\").sep;\n\
    require(\"fs\").readdir(dir, function (err, fileList) {\n\
        local.onErrorThrow(err);\n\
        Promise.all(fileList.map(function (file) {\n\
            return new Promise(function (resolve) {\n\
                let timeStart;\n\
                timeStart = Date.now();\n\
                file = dir + file;\n\
                switch ((\n\
                    /\\.\\w+?$|$/m\n\
                ).exec(file)[0]) {\n\
                case \".css\":\n\
                case \".html\":\n\
                case \".js\":\n\
                case \".json\":\n\
                case \".md\":\n\
                case \".sh\":\n\
                    if ((\n\
                        /\\b(?:assets\\.app\\.js|lock|min|raw|rollup)\\b/\n\
                    ).test(file)) {\n\
                        resolve();\n\
                        return;\n\
                    }\n\
                    // jslint file\n\
                    require(\"fs\").readFile(file, \"utf8\", function (err, data) {\n\
                        if (err) {\n\
                            return;\n\
                        }\n\
                        local.jslintAndPrint(data, file, opt);\n\
                        errCnt += local.jslintResult.errList.length;\n\
                        console.error(\n\
                            \"jslint - \" + (Date.now() - timeStart) + \"ms - \"\n\
                            + file\n\
                        );\n\
                        resolve();\n\
                    });\n\
                    return;\n\
                }\n\
                resolve();\n\
            });\n\
        })).then(function () {\n\
            onError(errCnt && new Error(errCnt));\n\
        });\n\
    });\n\
};\n\
\n\
local.jslintResult = {};\n\
}());\n\
\n\
\n\
/* istanbul ignore next */\n\
// run node js-env code - init-after\n\
(function () {\n\
if (!local.isEnvNode) {\n\
    return;\n\
}\n\
\n\
local.cliDict = {};\n\
\n\
local.cliDict._default = function () {\n\
/*\n\
 * <file1> <file2> ...\n\
 * will jslint <file1> <file2> ... and print errors to stderr\n\
 */\n\
    // jslint files\n\
    process.argv.slice(2).forEach(function (file) {\n\
        if (file[0] === \"-\") {\n\
            return;\n\
        }\n\
        local.jslintAndPrint(\n\
            require(\"fs\").readFileSync(require(\"path\").resolve(file), \"utf8\"),\n\
            file,\n\
            {\n\
                modeAutofix: process.argv.indexOf(\"--autofix\") >= 0,\n\
                modeConditional: process.argv.indexOf(\"--conditional\") >= 0\n\
            }\n\
        );\n\
    });\n\
    // if err occurred, then exit with non-zero code\n\
    process.exit(Boolean(local.jslintResult.errList.length));\n\
};\n\
\n\
local.cliDict.dir = function () {\n\
/*\n\
 * <dir>\n\
 * will jslint files in shallow <dir>\n\
 */\n\
    local.jslintAndPrintDir(process.argv[3], {\n\
        modeAutofix: process.argv.indexOf(\"--autofix\") >= 0,\n\
        modeConditional: process.argv.indexOf(\"--conditional\") >= 0\n\
    });\n\
};\n\
\n\
// run the cli\n\
if (module === require.main && !globalThis.utility2_rollup) {\n\
    local.cliRun({});\n\
}\n\
}());\n\
}());\n\
");

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.utility2.lib.jslint.js */



/* script-begin /assets.utility2.test.js */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.test.js"] = (
"/* istanbul instrument in package utility2 */\n\
// assets.utility2.header.js - start\n\
/* jslint utility2:true */\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-local\n\
(function () {\n\
    \"use strict\";\n\
    let isEnvNode;\n\
    let local;\n\
    // init debugInline\n\
    if (!globalThis.debugInline) {\n\
        let consoleError;\n\
        consoleError = console.error;\n\
        globalThis.debugInline = function (...argList) {\n\
        /*\n\
         * this function will both print <argList> to stderr and\n\
         * return <argList>[0]\n\
         */\n\
            consoleError(\"\\n\\ndebugInline\");\n\
            consoleError(...argList);\n\
            consoleError(\"\\n\");\n\
            return argList[0];\n\
        };\n\
    }\n\
    // init isEnvNode\n\
    isEnvNode = (\n\
        typeof process === \"object\" && process &&\n\
        process.versions && typeof process.versions.node === \"string\"\n\
    );\n\
    // init function\n\
    function objectDeepCopyWithKeysSorted(obj) {\n\
    /*\n\
     * this function will recursively deep-copy <obj> with keys sorted\n\
     */\n\
        let sorted;\n\
        if (typeof obj !== \"object\" || !obj) {\n\
            return obj;\n\
        }\n\
        // recursively deep-copy list with child-keys sorted\n\
        if (Array.isArray(obj)) {\n\
            return obj.map(objectDeepCopyWithKeysSorted);\n\
        }\n\
        // recursively deep-copy obj with keys sorted\n\
        sorted = {};\n\
        Object.keys(obj).sort().forEach(function (key) {\n\
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n\
        });\n\
        return sorted;\n\
    }\n\
    function assertJsonEqual(aa, bb) {\n\
    /*\n\
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)\n\
     */\n\
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n\
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n\
        if (aa !== bb) {\n\
            throw new Error(JSON.stringify(aa) + \" !== \" + JSON.stringify(bb));\n\
        }\n\
    }\n\
    function assertOrThrow(passed, msg) {\n\
    /*\n\
     * this function will throw <msg> if <passed> is falsy\n\
     */\n\
        if (passed) {\n\
            return;\n\
        }\n\
        throw (\n\
            (\n\
                msg &&\n\
                typeof msg.message === \"string\" &&\n\
                typeof msg.stack === \"string\"\n\
            )\n\
            // if msg is err, then leave as is\n\
            ? msg\n\
            : new Error(\n\
                typeof msg === \"string\"\n\
                // if msg is string, then leave as is\n\
                ? msg\n\
                // else JSON.stringify(msg)\n\
                : JSON.stringify(msg, undefined, 4)\n\
            )\n\
        );\n\
    }\n\
    function documentQuerySelectorAll(selector) {\n\
    /*\n\
     * this function will return document.querySelectorAll(<selector>) or\n\
     * empty list if function is not available\n\
     */\n\
        return Array.from(\n\
            (\n\
                typeof document === \"object\" && document &&\n\
                typeof document.querySelectorAll === \"function\"\n\
            )\n\
            ? document.querySelectorAll(selector)\n\
            : []\n\
        );\n\
    }\n\
    function identity(val) {\n\
    /*\n\
     * this function will return <val>\n\
     */\n\
        return val;\n\
    }\n\
    function noop() {\n\
    /*\n\
     * this function will do nothing\n\
     */\n\
        return;\n\
    }\n\
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n\
    /*\n\
     * this function will if items from <tgt> are null, undefined, or\n\
     * \"\", then overwrite them with items from <src>\n\
     */\n\
        function recurse(tgt, src, depth) {\n\
            Object.entries(src).forEach(function ([\n\
                key, bb\n\
            ]) {\n\
                let aa;\n\
                aa = tgt[key];\n\
                if (aa === undefined || aa === null || aa === \"\") {\n\
                    tgt[key] = bb;\n\
                    return;\n\
                }\n\
                if (\n\
                    depth !== 0 &&\n\
                    typeof aa === \"object\" && aa && !Array.isArray(aa) &&\n\
                    typeof bb === \"object\" && bb && !Array.isArray(bb)\n\
                ) {\n\
                    recurse(aa, bb, depth - 1);\n\
                }\n\
            });\n\
        }\n\
        recurse(tgt, src, depth | 0);\n\
        return tgt;\n\
    }\n\
    function onErrorThrow(err) {\n\
    /*\n\
     * this function will throw <err> if exists\n\
     */\n\
        if (err) {\n\
            throw err;\n\
        }\n\
    }\n\
    // init local\n\
    local = {\n\
        assertJsonEqual,\n\
        assertOrThrow,\n\
        documentQuerySelectorAll,\n\
        identity,\n\
        isEnvNode,\n\
        local,\n\
        noop,\n\
        objectAssignDefault,\n\
        objectDeepCopyWithKeysSorted,\n\
        onErrorThrow\n\
    };\n\
    globalThis.globalLocal = local;\n\
}());\n\
// assets.utility2.header.js - end\n\
\n\
\n\
/* jslint utility2:true */\n\
(function (local) {\n\
\"use strict\";\n\
\n\
\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(\"./lib.utility2.js\");\n\
local = local.requireReadme();\n\
globalThis.local = local;\n\
// init test\n\
local.testRunDefault(local);\n\
}());\n\
\n\
\n\
// run shared js-env code - function\n\
(function () {\n\
let {\n\
    assertJsonEqual,\n\
    assertOrThrow,\n\
    isEnvNode,\n\
    noop,\n\
    onErrorThrow,\n\
    tryCatchOnError\n\
} = local;\n\
\n\
local.testCase_assertXxx_default = function (opt, onError) {\n\
/*\n\
 * this function will test assertXxx's default handling-behavior\n\
 */\n\
    // test assertion passed\n\
    assertOrThrow(true, true);\n\
    // test assertion failed with undefined message\n\
    tryCatchOnError(function () {\n\
        assertOrThrow(undefined);\n\
    }, function (err) {\n\
        // validate err\n\
        assertJsonEqual(err.message, \"\");\n\
    });\n\
    // test assertion failed with string message\n\
    tryCatchOnError(function () {\n\
        assertOrThrow(undefined, \"aa\");\n\
    }, function (err) {\n\
        // validate err\n\
        assertJsonEqual(err.message, \"aa\");\n\
    });\n\
    // test assertion failed with errObj\n\
    tryCatchOnError(function () {\n\
        assertOrThrow(undefined, new Error(\"aa\"));\n\
    }, function (err) {\n\
        // validate err\n\
        assertJsonEqual(err.message, \"aa\");\n\
    });\n\
    // test assertion failed with json object\n\
    tryCatchOnError(function () {\n\
        assertOrThrow(undefined, {\n\
            aa: 1\n\
        });\n\
    }, function (err) {\n\
        // validate err\n\
        assertJsonEqual(err.message, \"{\\n    \\\"aa\\\": 1\\n}\");\n\
    });\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_buildApidoc_default = function (opt, onError) {\n\
/*\n\
 * this function will test buildApidoc's default handling-behavior\n\
 */\n\
    local._testCase_buildApidoc_default({\n\
        blacklistDict: {}\n\
    }, onError, opt);\n\
};\n\
\n\
local.testCase_buildApp_default = function (opt, onError) {\n\
/*\n\
 * this function will test buildApp's default handling-behavior\n\
 */\n\
    local._testCase_buildApp_default({\n\
        customizeAssetsList: [\n\
            {\n\
                file: \"/assets.hello.txt\",\n\
                url: \"/assets.hello.txt\"\n\
            }, {\n\
                file: \"/assets.script_only.html\",\n\
                url: \"/assets.script_only.html\"\n\
            }, {\n\
                file: \"/assets.utility2.lib.istanbul.js\",\n\
                url: \"/assets.utility2.lib.istanbul.js\"\n\
            }, {\n\
                file: \"/assets.utility2.lib.jslint.js\",\n\
                url: \"/assets.utility2.lib.jslint.js\"\n\
            }, {\n\
                file: \"/assets.utility2.lib.marked.js\",\n\
                url: \"/assets.utility2.lib.marked.js\"\n\
            }, {\n\
                file: \"/assets.utility2.rollup.js\",\n\
                url: \"/assets.utility2.rollup.js\"\n\
            }\n\
        ],\n\
        customizeReadmeList: [\n\
            // customize quickstart-example-js-instruction\n\
            {\n\
                merge: (\n\
                    /\\n#\\u0020quickstart\\u0020example.js\\n[\\S\\s]*?\\n\\n\\n/\n\
                )\n\
            // customize quickstart-example-js-comment\n\
            }, {\n\
                aa: \"\\n<!-- utility2-comment\\n\",\n\
                bb: \"\\n\"\n\
            // customize quickstart-example-js-comment\n\
            }, {\n\
                aa: \"\\nutility2-comment -->\\n\",\n\
                bb: \"\\n\"\n\
            // customize quickstart-example-js-comment\n\
            }, {\n\
                aa: \"\\n<!-- utility2-comment\\n\",\n\
                bb: \"\\n\"\n\
            // customize quickstart-example-js-script-1\n\
            }, {\n\
                aa: \"<script src=\\\"assets.utility2.js\\\"></script>\\n\",\n\
                bb: \"\\n\"\n\
            // customize quickstart-example-js-script-2\n\
            }, {\n\
                aa: \"<script src=\\\"assets.utility2.rollup.js\\\"></script>\\n\",\n\
                bb: (\n\
                    \"<script src=\\\"assets.utility2.lib.istanbul.js\\\">\" +\n\
                    \"</script>\\n\" +\n\
                    \"<script src=\\\"assets.utility2.lib.jslint.js\\\">\" +\n\
                    \"</script>\\n\" +\n\
                    \"<script src=\\\"assets.utility2.lib.marked.js\\\">\" +\n\
                    \"</script>\\n\" +\n\
                    \"<script src=\\\"assets.utility2.js\\\"></script>\\n\"\n\
                )\n\
            // customize quickstart-example-js-comment\n\
            }, {\n\
                aa: \"\\nutility2-comment -->\\n\",\n\
                bb: \"\\n\"\n\
            // customize quickstart-example-js-screenshot\n\
            }, {\n\
                merge: (\n\
                    /\\n```[^`]*?\\n#\\u0020extra\\u0020screenshots\\n/\n\
                )\n\
            // customize build-script\n\
            }, {\n\
                merge: (\n\
                    /\\n#\\u0020internal\\u0020build\\u0020script\\n[\\S\\s]*?\\nshCiMain\\n/\n\
                )\n\
            }\n\
        ]\n\
    }, onError, opt);\n\
};\n\
\n\
local.testCase_chromeDevtoolsClient_coverage = async function (opt, onError) {\n\
/*\n\
 * this function will test chromeDevtoolsClient's coverage handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    await local.chromeDevtoolsClientCreate({\n\
        modeCoverageHack: 1\n\
    });\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_cliRun_default = function (opt, onError) {\n\
/*\n\
 * this function will test cliRun's default handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    local.testMock([\n\
        [\n\
            local, {\n\
                replStart: noop\n\
            }\n\
        ], [\n\
            local.cliDict, {}\n\
        ], [\n\
            process, {\n\
                argv: []\n\
            }\n\
        ], [\n\
            require(\"repl\"), {\n\
                start: noop\n\
            }\n\
        ], [\n\
            require(\"vm\"), {\n\
                runInThisContext: noop\n\
            }\n\
        ]\n\
    ], function (onError) {\n\
        // test default handling-behavior\n\
        local.cliDict = {\n\
            _default: noop\n\
        };\n\
        local.cliRun({\n\
            rgxComment: (\n\
                /^/\n\
            )\n\
        });\n\
        // test builtin handling-behavior\n\
        [\n\
            \"--eval\",\n\
            \"--help\",\n\
            \"--interactive\",\n\
            \"--version\",\n\
            \"undefined\"\n\
        ].forEach(function (key) {\n\
            process.argv[2] = key;\n\
            local.cliDict = {};\n\
            local.cliRun({\n\
                rgxComment: (\n\
                    /^/\n\
                )\n\
            });\n\
        });\n\
        // test err handling-behavior\n\
        local.cliDict = {};\n\
        tryCatchOnError(local.cliRun.bind(undefined, {}), assertOrThrow);\n\
        onError(undefined, opt);\n\
    }, onError);\n\
};\n\
\n\
local.testCase_eventListenerXxx_default = function (opt, onError) {\n\
/*\n\
 * this function will test eventListenerXxx's default handling-behavior\n\
 */\n\
    let listener;\n\
    listener = function ({\n\
        msg,\n\
        type\n\
    }) {\n\
        assertJsonEqual(msg, \"bb\");\n\
        assertJsonEqual(type, \"aa\");\n\
    };\n\
    local.eventListenerAdd(\"aa\", {}, listener);\n\
    local.eventListenerAdd(\"aa\", {\n\
        once: true\n\
    }, listener);\n\
    local.eventListenerEmit(\"aa\", \"bb\");\n\
    local.eventListenerEmit(\"aa\", \"bb\");\n\
    local.eventListenerRemove(listener);\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_libUtility2Js_standalone = function (opt, onError) {\n\
/*\n\
 * this function will test lib.utility2.js's standalone handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    require(\"fs\").readFile(\"lib.utility2.js\", \"utf8\", function (err, data) {\n\
        onErrorThrow(err);\n\
        require(\"fs\").writeFile(\".tmp/lib.utility2.js\", data.replace(\n\
            \"/* istanbul instrument in package utility2 */\",\n\
            \"\"\n\
        ), function (err) {\n\
            onErrorThrow(err);\n\
            require(\"./.tmp/lib.utility2.js\");\n\
        });\n\
        onError(undefined, opt);\n\
    });\n\
};\n\
\n\
local.testCase_listShuffle_default = function (opt, onError) {\n\
/*\n\
 * this function will test listShuffle's default handling-behavior\n\
 */\n\
    opt = {};\n\
    // init list\n\
    opt.list = \"[0,1]\";\n\
    // shuffle list 100 times\n\
    opt.ii = 0;\n\
    while (opt.ii < 100) {\n\
        opt.listShuffled = JSON.stringify(\n\
            local.listShuffle(JSON.parse(opt.list))\n\
        );\n\
        // validate shuffled list\n\
        assertJsonEqual(opt.listShuffled.length, opt.list.length);\n\
        opt.changed = opt.changed || opt.listShuffled !== opt.list;\n\
        opt.ii += 1;\n\
    }\n\
    // validate list changed at least once during shuffle\n\
    assertOrThrow(opt.changed, opt);\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_replStart_default = function (opt, onError) {\n\
/*\n\
 * this function will test replStart's default handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    local.replStart();\n\
    // coverage-hack - test replStart's muliple-call handling-behavior\n\
    local.replStart();\n\
    local.testMock([\n\
        [\n\
            require(\"child_process\"), {\n\
                spawn: function () {\n\
                    return {\n\
                        on: function (evt, callback) {\n\
                            callback(undefined, evt);\n\
                        }\n\
                    };\n\
                }\n\
            }\n\
        ],\n\
        // suppress process.stdout\n\
        [\n\
            process.stdout, {\n\
                write: noop\n\
            }\n\
        ]\n\
    ], function (onError) {\n\
        [\n\
            // test null-case handling-behavior\n\
            \"\",\n\
            // test shell handling-behavior\n\
            \"$ :\\n\",\n\
            // test git diff handling-behavior\n\
            \"$ git diff\\n\",\n\
            // test git log handling-behavior\n\
            \"$ git log\\n\",\n\
            // test ll handling-behavior\n\
            \"$ ll\\n\",\n\
            // test charCode handling-behavior\n\
            \"charCode abcd\\n\",\n\
            // test charSort handling-behavior\n\
            \"charSort abcd\\n\",\n\
            // test keys handling-behavior\n\
            \"keys {}\\n\",\n\
            // test print handling-behavior\n\
            \"print abcd\\n\",\n\
            // test err handling-behavior\n\
            \"undefined()\\n\"\n\
        ].forEach(function (script) {\n\
            globalThis.utility2_repl1.eval(script, null, \"repl\", noop);\n\
        });\n\
        onError(undefined, opt);\n\
    }, onError);\n\
};\n\
\n\
local.testCase_setTimeoutOnError_default = function (opt, onError) {\n\
/*\n\
 * this function will test setTimeoutOnError's default handling-behavior\n\
 */\n\
    // test null-case handling-behavior\n\
    assertJsonEqual(local.setTimeoutOnError(), undefined);\n\
    // test onError handling-behavior\n\
    assertJsonEqual(\n\
        local.setTimeoutOnError(onError, 0, null, {}, opt),\n\
        {}\n\
    );\n\
};\n\
\n\
local.testCase_stringHtmlSafe_default = function (opt, onError) {\n\
/*\n\
 * this function will test stringHtmlSafe's default handling-behavior\n\
 */\n\
    assertJsonEqual(\n\
        local.stringHtmlSafe(\n\
            local.stringHtmlSafe(local.stringCharsetAscii).slice(32, -1)\n\
        ),\n\
        (\n\
            \" !&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@\" +\n\
            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n\
        )\n\
    );\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_stringXxx_default = function (opt, onError) {\n\
/*\n\
 * this function will test stringXxx's default handling-behavior\n\
 */\n\
    assertJsonEqual(\n\
        local.regexpCharsetEncodeUri.source,\n\
        local.stringRegexpEscape(\n\
            local.stringCharsetEncodeUri\n\
        ).replace(\"\\\\-\", \"-\")\n\
    );\n\
    assertJsonEqual(\n\
        local.regexpCharsetEncodeUriComponent.source,\n\
        local.stringRegexpEscape(\n\
            local.stringCharsetEncodeUriComponent\n\
        ).replace(\"\\\\-\", \"-\")\n\
    );\n\
    assertJsonEqual(\n\
        local.stringCharsetEncodeUri,\n\
        Array.from(\n\
            new Set(encodeURI(local.stringCharsetAscii).split(\"\"))\n\
        ).sort().join(\"\")\n\
    );\n\
    assertJsonEqual(\n\
        local.stringCharsetEncodeUriComponent,\n\
        Array.from(\n\
            new Set(encodeURIComponent(local.stringCharsetAscii).split(\"\"))\n\
        ).sort().join(\"\")\n\
    );\n\
    assertJsonEqual(\n\
        local.stringRegexpEscape(local.stringCharsetAscii),\n\
        (\n\
            \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +\n\
            \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" +\n\
            \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" +\n\
            \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +\n\
            \" !\\\"#\\\\$%&'\\\\(\\\\)\\\\*\\\\+,\\\\-\\\\.\\\\/0123456789:;<=>\\\\?@\" +\n\
            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\[\\\\\\\\\\\\]\\\\^_`\" +\n\
            \"abcdefghijklmnopqrstuvwxyz\\\\{\\\\|\\\\}~\" +\n\
            \"\\u007f\"\n\
        )\n\
    );\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_testMock_err = function (opt, onError) {\n\
/*\n\
 * this function will test testMock's err handling-behavior\n\
 */\n\
    try {\n\
        local.testMock([], function () {\n\
            throw new Error();\n\
        });\n\
    } catch (errCaught) {\n\
        // handle err\n\
        assertOrThrow(errCaught, errCaught);\n\
        onError(undefined, opt);\n\
    }\n\
};\n\
\n\
local.testCase_uiAnimateXxx_default = function (opt, onError) {\n\
/*\n\
 * this function will test uiAnimateXxx's default handling-behavior\n\
 */\n\
    if (isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    opt = document.createElement(\"div\");\n\
    // test uiAnimateSlideXxx handling-behavior\n\
    local.uiAnimateSlideDown();\n\
    local.uiAnimateSlideUp();\n\
    opt.classList.add(\"uiAnimateSlide\");\n\
    local.uiAnimateSlideDown(opt);\n\
    assertOrThrow(\n\
        opt.style.maxHeight.indexOf(\"px\") >= 0,\n\
        opt.style.maxHeight\n\
    );\n\
    local.uiAnimateSlideUp(opt);\n\
    assertJsonEqual(opt.style.maxHeight, \"0px\");\n\
    // test uiAnimateSlideAccordian handling-behavior\n\
    local.uiAnimateSlideAccordian(\n\
        opt,\n\
        [\n\
            opt, document.createElement(\"div\")\n\
        ]\n\
    );\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_urlJoin_default = function (opt, onError) {\n\
/*\n\
 * this function will test urlJoin's default handling-behavior\n\
 */\n\
    assertJsonEqual(local.urlJoin(\"\", \"\"), \"/\");\n\
    assertJsonEqual(local.urlJoin(\"http://aa/bb\", \"zz\"), \"http://aa/zz\");\n\
    assertJsonEqual(\n\
        local.urlJoin(\"http://aa/bb/\", \"zz\"),\n\
        \"http://aa/bb/zz\"\n\
    );\n\
    assertJsonEqual(\n\
        local.urlJoin(\"http://aa/bb/\", \"/zz\"),\n\
        \"http://aa/zz\"\n\
    );\n\
    assertJsonEqual(local.urlJoin(\"http://aa/bb/\", \"//zz\"), \"http://zz\");\n\
    assertJsonEqual(\n\
        local.urlJoin(\"http://aa/bb/\", \"http://zz\"),\n\
        \"http://zz\"\n\
    );\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_uuid4Create_default = function (opt, onError) {\n\
/*\n\
 * this function will test uuid4Create's default handling-behavior\n\
 */\n\
    assertOrThrow(\n\
        local.regexpValidateUuid.test(local.uuid4Create()),\n\
        local.uuid4Create()\n\
    );\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testCase_webpage_default = async function (opt, onError) {\n\
/*\n\
 * this function will test webpage's default handling-behavior\n\
 */\n\
    local._testCase_webpage_default(opt, onError);\n\
};\n\
\n\
local.testCase_webpage_err = async function (opt, onError) {\n\
/*\n\
 * this function will test webpage's err handling-behavior\n\
 */\n\
    if (isEnvNode) {\n\
        await local.browserTest({\n\
            modeSilent: true,\n\
            url: (\n\
                \"http://127.0.0.1:\" + process.env.PORT +\n\
                \"/?npm_config_mode_test=1\" +\n\
                \"&npm_config_mode_test_case=testCase_webpage_err\"\n\
            )\n\
        });\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    if (local.npm_config_mode_test_case !== \"testCase_webpage_err\") {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    // ignore err in coverage-case\n\
    globalThis.utility2_testReport.testPlatformList[0].testCaseList = [];\n\
    globalThis.utility2_testReport.testsPending = 0;\n\
    setTimeout(function () {\n\
        // test err from callback handling-behavior\n\
        onError(new Error(), opt);\n\
        // test err from multiple-callback handling-behavior\n\
        onError(undefined, opt);\n\
    }, 2000);\n\
    // test uncaught-err handling-behavior\n\
    setTimeout(assertOrThrow.bind(undefined, undefined));\n\
};\n\
\n\
\n\
// run node js-env code - init-after\n\
/* istanbul ignore next */\n\
(function () {\n\
if (!isEnvNode) {\n\
    return;\n\
}\n\
// init cli\n\
if (module !== require.main || globalThis.utility2_rollup) {\n\
    return;\n\
}\n\
local.assetsDict[\"/assets.script_only.html\"] = (\n\
    \"<h1>script_only_test</h1>\\n\" +\n\
    \"<script src=\\\"assets.utility2.js\\\"></script>\\n\" +\n\
    \"<script>\\n\" +\n\
    \"window.utility2.onReadyIncrement();\\n\" +\n\
    \"window.addEventListener(\\\"load\\\", window.utility2.onReadyDecrement);\\n\" +\n\
    \"</script>\\n\" +\n\
    \"<script src=\\\"assets.example.js\\\"></script>\\n\" +\n\
    \"<script src=\\\"assets.test.js\\\"></script>\\n\"\n\
);\n\
if (process.argv[2]) {\n\
    // start with coverage\n\
    if (process.env.npm_config_mode_coverage) {\n\
        process.argv.splice(1, 1, __dirname + \"/lib.istanbul.js\", \"cover\");\n\
        local.istanbul.cliDict[process.argv[2]]();\n\
        return;\n\
    }\n\
    // start\n\
    process.argv.splice(1, 1);\n\
    process.argv[1] = require(\"path\").resolve(process.argv[1]);\n\
    require(\"module\").runMain();\n\
}\n\
// runme\n\
if (process.env.npm_config_runme) {\n\
    require(require(\"path\").resolve(process.env.npm_config_runme));\n\
}\n\
}());\n\
}());\n\
}());\n\
");

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.utility2.test.js */



/* script-begin /assets.utility2.rollup.end.js */
(function () {
    "use strict";
    globalThis.utility2_rollup_old = globalThis.utility2_rollup;
    globalThis.utility2_rollup = null;
}());
/* utility2.rollup.js end */
/* script-end /assets.utility2.rollup.end.js */
/* script-end /assets.utility2.rollup.js */



/* script-begin /assets.utility2.rollup.start.js */
/* utility2.rollup.js begin */
/* istanbul ignore all */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


/* jslint utility2:true */
(function () {
    "use strict";
    // init utility2_rollup
    globalThis.utility2_rollup = (
        globalThis.utility2_rollup_old
        || globalThis.globalLocal
    );
    globalThis.utility2_rollup.local = globalThis.utility2_rollup;
    globalThis.utility2_rollup_old = null;
}());
/* script-end /assets.utility2.rollup.start.js */



/* script-begin /assets.my_app.css */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.css"] = (
"");

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.my_app.css */



/* script-begin /assets.my_app.js */
(function (local) {
    "use strict";
/* jslint ignore:start */
local.assetsDict["/assets.utility2.js"] = (
"// usr/bin/env node\n\
/*\n\
 * lib.utility2.js (2020.12.3)\n\
 * https://github.com/kaizhu256/node-utility2\n\
 * this zero-dependency package will provide high-level functions to to build, test, and deploy webapps\n\
 *\n\
 */\n\
\n\
\n\
/* istanbul instrument in package utility2 */\n\
// assets.utility2.header.js - start\n\
/* jslint utility2:true */\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-local\n\
(function () {\n\
    \"use strict\";\n\
    let isEnvNode;\n\
    let local;\n\
    // init debugInline\n\
    if (!globalThis.debugInline) {\n\
        let consoleError;\n\
        consoleError = console.error;\n\
        globalThis.debugInline = function (...argList) {\n\
        /*\n\
         * this function will both print <argList> to stderr and\n\
         * return <argList>[0]\n\
         */\n\
            consoleError(\"\\n\\ndebugInline\");\n\
            consoleError(...argList);\n\
            consoleError(\"\\n\");\n\
            return argList[0];\n\
        };\n\
    }\n\
    // init isEnvNode\n\
    isEnvNode = (\n\
        typeof process === \"object\" && process &&\n\
        process.versions && typeof process.versions.node === \"string\"\n\
    );\n\
    // init function\n\
    function objectDeepCopyWithKeysSorted(obj) {\n\
    /*\n\
     * this function will recursively deep-copy <obj> with keys sorted\n\
     */\n\
        let sorted;\n\
        if (typeof obj !== \"object\" || !obj) {\n\
            return obj;\n\
        }\n\
        // recursively deep-copy list with child-keys sorted\n\
        if (Array.isArray(obj)) {\n\
            return obj.map(objectDeepCopyWithKeysSorted);\n\
        }\n\
        // recursively deep-copy obj with keys sorted\n\
        sorted = {};\n\
        Object.keys(obj).sort().forEach(function (key) {\n\
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n\
        });\n\
        return sorted;\n\
    }\n\
    function assertJsonEqual(aa, bb) {\n\
    /*\n\
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)\n\
     */\n\
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n\
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n\
        if (aa !== bb) {\n\
            throw new Error(JSON.stringify(aa) + \" !== \" + JSON.stringify(bb));\n\
        }\n\
    }\n\
    function assertOrThrow(passed, msg) {\n\
    /*\n\
     * this function will throw <msg> if <passed> is falsy\n\
     */\n\
        if (passed) {\n\
            return;\n\
        }\n\
        throw (\n\
            (\n\
                msg &&\n\
                typeof msg.message === \"string\" &&\n\
                typeof msg.stack === \"string\"\n\
            )\n\
            // if msg is err, then leave as is\n\
            ? msg\n\
            : new Error(\n\
                typeof msg === \"string\"\n\
                // if msg is string, then leave as is\n\
                ? msg\n\
                // else JSON.stringify(msg)\n\
                : JSON.stringify(msg, undefined, 4)\n\
            )\n\
        );\n\
    }\n\
    function documentQuerySelectorAll(selector) {\n\
    /*\n\
     * this function will return document.querySelectorAll(<selector>) or\n\
     * empty list if function is not available\n\
     */\n\
        return Array.from(\n\
            (\n\
                typeof document === \"object\" && document &&\n\
                typeof document.querySelectorAll === \"function\"\n\
            )\n\
            ? document.querySelectorAll(selector)\n\
            : []\n\
        );\n\
    }\n\
    function identity(val) {\n\
    /*\n\
     * this function will return <val>\n\
     */\n\
        return val;\n\
    }\n\
    function noop() {\n\
    /*\n\
     * this function will do nothing\n\
     */\n\
        return;\n\
    }\n\
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n\
    /*\n\
     * this function will if items from <tgt> are null, undefined, or\n\
     * \"\", then overwrite them with items from <src>\n\
     */\n\
        function recurse(tgt, src, depth) {\n\
            Object.entries(src).forEach(function ([\n\
                key, bb\n\
            ]) {\n\
                let aa;\n\
                aa = tgt[key];\n\
                if (aa === undefined || aa === null || aa === \"\") {\n\
                    tgt[key] = bb;\n\
                    return;\n\
                }\n\
                if (\n\
                    depth !== 0 &&\n\
                    typeof aa === \"object\" && aa && !Array.isArray(aa) &&\n\
                    typeof bb === \"object\" && bb && !Array.isArray(bb)\n\
                ) {\n\
                    recurse(aa, bb, depth - 1);\n\
                }\n\
            });\n\
        }\n\
        recurse(tgt, src, depth | 0);\n\
        return tgt;\n\
    }\n\
    function onErrorThrow(err) {\n\
    /*\n\
     * this function will throw <err> if exists\n\
     */\n\
        if (err) {\n\
            throw err;\n\
        }\n\
    }\n\
    // init local\n\
    local = {\n\
        assertJsonEqual,\n\
        assertOrThrow,\n\
        documentQuerySelectorAll,\n\
        identity,\n\
        isEnvNode,\n\
        local,\n\
        noop,\n\
        objectAssignDefault,\n\
        objectDeepCopyWithKeysSorted,\n\
        onErrorThrow\n\
    };\n\
    globalThis.globalLocal = local;\n\
}());\n\
// assets.utility2.header.js - end\n\
\n\
\n\
(function (local) {\n\
\"use strict\";\n\
\n\
\n\
/* istanbul ignore next */\n\
// run shared js-env code - init-before\n\
(function () {\n\
// init local\n\
local = (\n\
    globalThis.utility2_rollup ||\n\
    // globalThis.utility2_rollup_old ||\n\
    // require(\"./assets.utility2.rollup.js\") ||\n\
    globalThis.globalLocal\n\
);\n\
// init exports\n\
if (local.isEnvNode) {\n\
    module.exports = local;\n\
    module.exports.__dirname = __dirname;\n\
} else {\n\
    globalThis.utility2_utility2 = local;\n\
}\n\
// init lib main\n\
local.utility2 = local;\n\
\n\
\n\
/* validateLineSortedReset */\n\
// bug-workaround - throw unhandledRejections in node-process\n\
if (\n\
    typeof process === \"object\" && process &&\n\
    typeof process.on === \"function\" &&\n\
    !process.unhandledRejections\n\
) {\n\
    process.unhandledRejections = \"throw\";\n\
    process.on(\"unhandledRejection\", function (err) {\n\
        throw err;\n\
    });\n\
}\n\
}());\n\
\n\
\n\
(function () {\n\
// init lib utility2\n\
globalThis.utility2 = local;\n\
\n\
\n\
// run shared js-env code - state\n\
(function () {\n\
    let packageJson;\n\
    let state;\n\
    // init state - default\n\
    state = {\n\
        apidocCreate: local.identity,\n\
        coverageMerge: local.identity,\n\
        coverageReportCreate: local.identity,\n\
        instrumentInPackage: local.identity,\n\
        jslintAndPrint: local.identity,\n\
        jslintAndPrintDir: local.identity,\n\
        npm_config_timeout: 30000,\n\
        npm_package_description: \"the greatest app in the world!\",\n\
        npm_package_name: \"my-app\",\n\
        npm_package_version: \"0.0.1\"\n\
    };\n\
    // init state - utility2_state\n\
    state = Object.assign(state, globalThis.utility2_state);\n\
    // init state - package.json\n\
    try {\n\
        packageJson = JSON.parse(require(\"fs\").readFileSync(\"package.json\"));\n\
        Object.entries(packageJson).forEach(function ([\n\
            key, val\n\
        ]) {\n\
            state[\"npm_package_\" + key] = String(val);\n\
        });\n\
        packageJson.repository.url.replace((\n\
            /https:\\/\\/github\\.com\\/([^\\/]+?\\/[^.]+)/\n\
        ), function (ignore, match1) {\n\
            state.GITHUB_FULLNAME = match1;\n\
            return \"\";\n\
        });\n\
    } catch (ignore) {}\n\
    // init state - process.env\n\
    state = Object.assign(\n\
        state,\n\
        (typeof process === \"object\" && process && process.env)\n\
    );\n\
    // init state - location.search\n\
    if (\n\
        typeof location === \"object\" && location &&\n\
        typeof location.search === \"string\"\n\
    ) {\n\
        location.search.replace((\n\
            /\\b(npm_config_mode_test|npm_config_mode_test_case|npm_config_timeout)=([^&#]+)/g\n\
        ), function (ignore, key, val) {\n\
            state[key] = decodeURIComponent(val);\n\
            return \"\";\n\
        });\n\
    }\n\
    // init state - misc\n\
    state = Object.assign({\n\
        GITHUB_OWNER: String(state.GITHUB_FULLNAME).split(\"/\")[0],\n\
        GITHUB_REPO: String(state.GITHUB_FULLNAME).split(\"/\")[1],\n\
        UTILITY2_DIR_BUILD: (\n\
            local.isEnvNode\n\
            ? require(\"path\").resolve(\".tmp/build\")\n\
            : \"/\"\n\
        ),\n\
        npm_config_mode_test_case: \"\",\n\
        npm_package_nameLib: String(state.npm_package_name).replace((\n\
            /\\W/g\n\
        ), \"_\")\n\
    }, state);\n\
    state.npm_config_timeout |= 0;\n\
    // init lib extra\n\
    [\n\
        \"apidoc\",\n\
        \"dummy\",\n\
        // cbranch-no cstat-no fstat-no missing-if-branch\n\
        \"istanbul\",\n\
        \"jslint\",\n\
        \"marked\"\n\
    ].forEach(function (key) {\n\
        try {\n\
            local[key] = (\n\
                local.isEnvNode\n\
                ? require(\"./lib.\" + key + \".js\")\n\
                : globalThis[\"utility2_\" + key]\n\
            );\n\
        } catch (errCaught) {\n\
            local.assertOrThrow(\n\
                errCaught.code === \"MODULE_NOT_FOUND\",\n\
                errCaught\n\
            );\n\
        }\n\
        local[key] = local[key] || {};\n\
        Object.assign(state, local[key]);\n\
    });\n\
    [\n\
        \"coverageReportCreate\",\n\
        \"jslintAndPrintDir\",\n\
        \"CI_BRANCH\",\n\
        \"CI_COMMIT_ID\",\n\
        \"CI_COMMIT_MESSAGE\",\n\
        \"CI_HOST\",\n\
        \"GITHUB_FULLNAME\",\n\
        \"GITHUB_OWNER\",\n\
        \"GITHUB_REPO\",\n\
        \"HOME\",\n\
        \"MODE_CI\",\n\
        \"PATH\",\n\
        \"PORT\",\n\
        \"UTILITY2_DIR_BUILD\",\n\
        \"apidocCreate\",\n\
        \"coverageMerge\",\n\
        \"instrumentInPackage\",\n\
        \"jslintAndPrint\",\n\
        \"npm_config_mode_auto_restart\",\n\
        \"npm_config_mode_lib\",\n\
        \"npm_config_mode_start\",\n\
        \"npm_config_mode_test\",\n\
        \"npm_config_mode_test_case\",\n\
        \"npm_config_mode_test_report_merge\",\n\
        \"npm_config_timeout\",\n\
        \"npm_config_timeout_exit\",\n\
        \"npm_package_description\",\n\
        \"npm_package_homepage\",\n\
        \"npm_package_main\",\n\
        \"npm_package_name\",\n\
        \"npm_package_nameHeroku\",\n\
        \"npm_package_nameLib\",\n\
        \"npm_package_nameOriginal\",\n\
        \"npm_package_version\"\n\
    ].forEach(function (key) {\n\
        local[key] = state[key];\n\
    });\n\
}());\n\
let {\n\
    assertJsonEqual,\n\
    assertOrThrow,\n\
    documentQuerySelectorAll,\n\
    isEnvNode,\n\
    noop,\n\
    onErrorThrow,\n\
    CI_BRANCH,\n\
    CI_COMMIT_ID,\n\
    CI_COMMIT_MESSAGE,\n\
    CI_HOST,\n\
    GITHUB_FULLNAME,\n\
    GITHUB_OWNER,\n\
    GITHUB_REPO,\n\
    HOME,\n\
    MODE_CI,\n\
    PATH,\n\
    PORT,\n\
    UTILITY2_DIR_BUILD,\n\
    apidocCreate,\n\
    coverageMerge,\n\
    instrumentInPackage,\n\
    jslintAndPrint,\n\
    npm_config_mode_auto_restart,\n\
    npm_config_mode_lib,\n\
    npm_config_mode_start,\n\
    npm_config_mode_test,\n\
    npm_config_mode_test_case,\n\
    npm_config_mode_test_report_merge,\n\
    npm_config_timeout,\n\
    npm_config_timeout_exit,\n\
    npm_package_description,\n\
    npm_package_homepage,\n\
    npm_package_main,\n\
    npm_package_name,\n\
    npm_package_nameHeroku,\n\
    npm_package_nameLib,\n\
    npm_package_nameOriginal,\n\
    npm_package_version\n\
} = local;\n\
\n\
\n\
/* validateLineSortedReset */\n\
// run shared js-env code - assetsDict\n\
local.assetsDict = local.assetsDict || {};\n\
local.assetsDict[\"/assets.utility2.header.js\"] = (\n\
    \"// assets.utility2.header.js - start\\n\" +\n\
    \"/* jslint utility2:true */\\n\" +\n\
    \"/* istanbul ignore next */\\n\" +\n\
    \"// run shared js\\u002denv code - init-local\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"    let isEnvNode;\\n\" +\n\
    \"    let local;\\n\" +\n\
    \"    // init debugInline\\n\" +\n\
    \"    if (!globalThis.debugInline) {\\n\" +\n\
    \"        let consoleError;\\n\" +\n\
    \"        consoleError = console.error;\\n\" +\n\
    \"        globalThis.debugInline = function (...argList) {\\n\" +\n\
    \"        /*\\n\" +\n\
    \"         * this function will both print <argList> to stderr and\\n\" +\n\
    \"         * return <argList>[0]\\n\" +\n\
    \"         */\\n\" +\n\
    \"            consoleError(\\\"\\\\n\\\\ndebugInline\\\");\\n\" +\n\
    \"            consoleError(...argList);\\n\" +\n\
    \"            consoleError(\\\"\\\\n\\\");\\n\" +\n\
    \"            return argList[0];\\n\" +\n\
    \"        };\\n\" +\n\
    \"    }\\n\" +\n\
    \"    // init isEnvNode\\n\" +\n\
    \"    isEnvNode = (\\n\" +\n\
    \"        typeof process === \\\"object\\\" && process &&\\n\" +\n\
    \"        process.versions && typeof process.versions.node === \" +\n\
    \"\\\"string\\\"\\n\" +\n\
    \"    );\\n\" +\n\
    \"    // init function\\n\" +\n\
    \"    function objectDeepCopyWithKeysSorted(obj) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will recursively deep-copy <obj> with keys sorted\\n\" +\n\
    \"     */\\n\" +\n\
    \"        let sorted;\\n\" +\n\
    \"        if (typeof obj !== \\\"object\\\" || !obj) {\\n\" +\n\
    \"            return obj;\\n\" +\n\
    \"        }\\n\" +\n\
    \"        // recursively deep-copy list with child-keys sorted\\n\" +\n\
    \"        if (Array.isArray(obj)) {\\n\" +\n\
    \"            return obj.map(objectDeepCopyWithKeysSorted);\\n\" +\n\
    \"        }\\n\" +\n\
    \"        // recursively deep-copy obj with keys sorted\\n\" +\n\
    \"        sorted = {};\\n\" +\n\
    \"        Object.keys(obj).sort().forEach(function (key) {\\n\" +\n\
    \"            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\\n\" +\n\
    \"        });\\n\" +\n\
    \"        return sorted;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function assertJsonEqual(aa, bb) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will assert JSON.stringify(<aa>) === \" +\n\
    \"JSON.stringify(<bb>)\\n\" +\n\
    \"     */\\n\" +\n\
    \"        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\\n\" +\n\
    \"        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\\n\" +\n\
    \"        if (aa !== bb) {\\n\" +\n\
    \"            throw new Error(JSON.stringify(aa) + \\\" !== \\\" + \" +\n\
    \"JSON.stringify(bb));\\n\" +\n\
    \"        }\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function assertOrThrow(passed, msg) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will throw <msg> if <passed> is falsy\\n\" +\n\
    \"     */\\n\" +\n\
    \"        if (passed) {\\n\" +\n\
    \"            return;\\n\" +\n\
    \"        }\\n\" +\n\
    \"        throw (\\n\" +\n\
    \"            (\\n\" +\n\
    \"                msg &&\\n\" +\n\
    \"                typeof msg.message === \\\"string\\\" &&\\n\" +\n\
    \"                typeof msg.stack === \\\"string\\\"\\n\" +\n\
    \"            )\\n\" +\n\
    \"            // if msg is err, then leave as is\\n\" +\n\
    \"            ? msg\\n\" +\n\
    \"            : new Error(\\n\" +\n\
    \"                typeof msg === \\\"string\\\"\\n\" +\n\
    \"                // if msg is string, then leave as is\\n\" +\n\
    \"                ? msg\\n\" +\n\
    \"                // else JSON.stringify(msg)\\n\" +\n\
    \"                : JSON.stringify(msg, undefined, 4)\\n\" +\n\
    \"            )\\n\" +\n\
    \"        );\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function documentQuerySelectorAll(selector) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will return document.querySelectorAll(<selector>) \" +\n\
    \"or\\n\" +\n\
    \"     * empty list if function is not available\\n\" +\n\
    \"     */\\n\" +\n\
    \"        return Array.from(\\n\" +\n\
    \"            (\\n\" +\n\
    \"                typeof document === \\\"object\\\" && document &&\\n\" +\n\
    \"                typeof document.querySelectorAll === \\\"function\\\"\\n\" +\n\
    \"            )\\n\" +\n\
    \"            ? document.querySelectorAll(selector)\\n\" +\n\
    \"            : []\\n\" +\n\
    \"        );\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function identity(val) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will return <val>\\n\" +\n\
    \"     */\\n\" +\n\
    \"        return val;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function noop() {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will do nothing\\n\" +\n\
    \"     */\\n\" +\n\
    \"        return;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will if items from <tgt> are null, undefined, or\\n\" +\n\
    \"     * \\\"\\\", then overwrite them with items from <src>\\n\" +\n\
    \"     */\\n\" +\n\
    \"        function recurse(tgt, src, depth) {\\n\" +\n\
    \"            Object.entries(src).forEach(function ([\\n\" +\n\
    \"                key, bb\\n\" +\n\
    \"            ]) {\\n\" +\n\
    \"                let aa;\\n\" +\n\
    \"                aa = tgt[key];\\n\" +\n\
    \"                if (aa === undefined || aa === null || aa === \\\"\\\") {\\n\" +\n\
    \"                    tgt[key] = bb;\\n\" +\n\
    \"                    return;\\n\" +\n\
    \"                }\\n\" +\n\
    \"                if (\\n\" +\n\
    \"                    depth !== 0 &&\\n\" +\n\
    \"                    typeof aa === \\\"object\\\" && aa && \" +\n\
    \"!Array.isArray(aa) &&\\n\" +\n\
    \"                    typeof bb === \\\"object\\\" && bb && \" +\n\
    \"!Array.isArray(bb)\\n\" +\n\
    \"                ) {\\n\" +\n\
    \"                    recurse(aa, bb, depth - 1);\\n\" +\n\
    \"                }\\n\" +\n\
    \"            });\\n\" +\n\
    \"        }\\n\" +\n\
    \"        recurse(tgt, src, depth | 0);\\n\" +\n\
    \"        return tgt;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    function onErrorThrow(err) {\\n\" +\n\
    \"    /*\\n\" +\n\
    \"     * this function will throw <err> if exists\\n\" +\n\
    \"     */\\n\" +\n\
    \"        if (err) {\\n\" +\n\
    \"            throw err;\\n\" +\n\
    \"        }\\n\" +\n\
    \"    }\\n\" +\n\
    \"    // init local\\n\" +\n\
    \"    local = {\\n\" +\n\
    \"        assertJsonEqual,\\n\" +\n\
    \"        assertOrThrow,\\n\" +\n\
    \"        documentQuerySelectorAll,\\n\" +\n\
    \"        identity,\\n\" +\n\
    \"        isEnvNode,\\n\" +\n\
    \"        local,\\n\" +\n\
    \"        noop,\\n\" +\n\
    \"        objectAssignDefault,\\n\" +\n\
    \"        objectDeepCopyWithKeysSorted,\\n\" +\n\
    \"        onErrorThrow\\n\" +\n\
    \"    };\\n\" +\n\
    \"    globalThis.globalLocal = local;\\n\" +\n\
    \"}());\\n\" +\n\
    \"// assets.utility2.header.js - end\\n\"\n\
);\n\
local.assetsDict[\"/assets.utility2.template.html\"] = (\n\
    \"<!doctype html>\\n\" +\n\
    \"<html lang=\\\"en\\\">\\n\" +\n\
    \"<head>\\n\" +\n\
    \"<meta charset=\\\"utf-8\\\">\\n\" +\n\
    \"<meta\\n\" +\n\
    \"    content=\\\"width=device-width, initial-scale=1\\\"\\n\" +\n\
    \"    name=\\\"viewport\\\"\\n\" +\n\
    \">\\n\" +\n\
    \"<!-- \\\"assets.utility2.template.html\\\" -->\\n\" +\n\
    \"<title>{{npm_package_name}} ({{npm_package_version}})</title>\\n\" +\n\
    \"<style>\\n\" +\n\
    \"/* jslint\\u0020utility2:true */\\n\" +\n\
    \"/*csslint\\n\" +\n\
    \"*/\\n\" +\n\
    \"/* csslint ignore:start */\\n\" +\n\
    \"*,\\n\" +\n\
    \"*:after,\\n\" +\n\
    \"*:before {\\n\" +\n\
    \"    box-sizing: border-box;\\n\" +\n\
    \"}\\n\" +\n\
    \".uiAnimateSlide {\\n\" +\n\
    \"    overflow-y: hidden;\\n\" +\n\
    \"    transition:\\n\" +\n\
    \"        max-height ease-in 250ms,\\n\" +\n\
    \"        min-height ease-in 250ms,\\n\" +\n\
    \"        padding-bottom ease-in 250ms,\\n\" +\n\
    \"        padding-top ease-in 250ms;\\n\" +\n\
    \"}\\n\" +\n\
    \"/* csslint ignore:end */\\n\" +\n\
    \"@keyframes uiAnimateSpin {\\n\" +\n\
    \"0% {\\n\" +\n\
    \"    transform: rotate(0deg);\\n\" +\n\
    \"}\\n\" +\n\
    \"100% {\\n\" +\n\
    \"    transform: rotate(360deg);\\n\" +\n\
    \"}\\n\" +\n\
    \"}\\n\" +\n\
    \"a {\\n\" +\n\
    \"    overflow-wrap: break-word;\\n\" +\n\
    \"}\\n\" +\n\
    \"body {\\n\" +\n\
    \"    background: #f7f7f7;\\n\" +\n\
    \"    font-family: Arial, Helvetica, sans-serif;\\n\" +\n\
    \"    font-size: small;\\n\" +\n\
    \"    margin: 0 40px;\\n\" +\n\
    \"}\\n\" +\n\
    \"body > div,\\n\" +\n\
    \"body > input,\\n\" +\n\
    \"body > pre,\\n\" +\n\
    \"body > .button,\\n\" +\n\
    \"body > .textarea {\\n\" +\n\
    \"    margin-bottom: 20px;\\n\" +\n\
    \"    margin-top: 0;\\n\" +\n\
    \"}\\n\" +\n\
    \"body > input,\\n\" +\n\
    \"body > .button {\\n\" +\n\
    \"    width: 20rem;\\n\" +\n\
    \"}\\n\" +\n\
    \"body > .readonly {\\n\" +\n\
    \"    background: #ddd;\\n\" +\n\
    \"}\\n\" +\n\
    \"body > .textarea {\\n\" +\n\
    \"    height: 10rem;\\n\" +\n\
    \"    resize: vertical;\\n\" +\n\
    \"    width: 100%;\\n\" +\n\
    \"}\\n\" +\n\
    \"code,\\n\" +\n\
    \"pre,\\n\" +\n\
    \".textarea {\\n\" +\n\
    \"    font-family: Consolas, Menlo, monospace;\\n\" +\n\
    \"    font-size: smaller;\\n\" +\n\
    \"}\\n\" +\n\
    \"pre {\\n\" +\n\
    \"    overflow-wrap: break-word;\\n\" +\n\
    \"    white-space: pre-wrap;\\n\" +\n\
    \"}\\n\" +\n\
    \".button {\\n\" +\n\
    \"    background: #ddd;\\n\" +\n\
    \"    border: 1px solid #999;\\n\" +\n\
    \"    color: #000;\\n\" +\n\
    \"    cursor: pointer;\\n\" +\n\
    \"    display: inline-block;\\n\" +\n\
    \"    padding: 2px 5px;\\n\" +\n\
    \"    text-align: center;\\n\" +\n\
    \"    text-decoration: none;\\n\" +\n\
    \"}\\n\" +\n\
    \".button:hover {\\n\" +\n\
    \"    background: #bbb;\\n\" +\n\
    \"}\\n\" +\n\
    \".colorError {\\n\" +\n\
    \"    color: #d00;\\n\" +\n\
    \"}\\n\" +\n\
    \".textarea {\\n\" +\n\
    \"    background: #fff;\\n\" +\n\
    \"    border: 1px solid #999;\\n\" +\n\
    \"    border-radius: 0;\\n\" +\n\
    \"    cursor: auto;\\n\" +\n\
    \"    overflow: auto;\\n\" +\n\
    \"    padding: 2px;\\n\" +\n\
    \"}\\n\" +\n\
    \".zeroPixel {\\n\" +\n\
    \"    border: 0;\\n\" +\n\
    \"    height: 0;\\n\" +\n\
    \"    margin: 0;\\n\" +\n\
    \"    padding: 0;\\n\" +\n\
    \"    width: 0;\\n\" +\n\
    \"}\\n\" +\n\
    \"</style>\\n\" +\n\
    \"</head>\\n\" +\n\
    \"<body>\\n\" +\n\
    \"<div class=\\\"uiAnimateSpin\\\" style=\\\"\\n\" +\n\
    \"    animation: uiAnimateSpin 2s linear infinite;\\n\" +\n\
    \"    border-radius: 50%;\\n\" +\n\
    \"    border-top: 5px solid #7d7;\\n\" +\n\
    \"    border: 5px solid #999;\\n\" +\n\
    \"    display: none;\\n\" +\n\
    \"    height: 25px;\\n\" +\n\
    \"    vertical-align: middle;\\n\" +\n\
    \"    width: 25px;\\n\" +\n\
    \"\\\"></div>\\n\" +\n\
    \"<script>\\n\" +\n\
    \"/* jslint\\u0020utility2:true */\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"    // polyfill globalThis\\n\" +\n\
    \"    window.globalThis = window;\\n\" +\n\
    \"    // measure-and-print time-elapsed for window.onload\\n\" +\n\
    \"    if (!window.domOnEventWindowOnloadTimeElapsed) {\\n\" +\n\
    \"        window.domOnEventWindowOnloadTimeElapsed = Date.now() + 100;\\n\" +\n\
    \"        window.addEventListener(\\\"load\\\", function () {\\n\" +\n\
    \"            setTimeout(function () {\\n\" +\n\
    \"                window.domOnEventWindowOnloadTimeElapsed = (\\n\" +\n\
    \"                    Date.now() -\\n\" +\n\
    \"                    window.domOnEventWindowOnloadTimeElapsed\\n\" +\n\
    \"                );\\n\" +\n\
    \"                console.error(\\n\" +\n\
    \"                    \\\"domOnEventWindowOnloadTimeElapsed = \\\" +\\n\" +\n\
    \"                    window.domOnEventWindowOnloadTimeElapsed\\n\" +\n\
    \"                );\\n\" +\n\
    \"            }, 100);\\n\" +\n\
    \"        });\\n\" +\n\
    \"    }\\n\" +\n\
    \"    // limit select-all within <pre tabIndex=\\\"0\\\"> elem\\n\" +\n\
    \"    if (!window.domOnEventSelectAllWithinPre) {\\n\" +\n\
    \"        window.domOnEventSelectAllWithinPre = function (evt) {\\n\" +\n\
    \"            let range;\\n\" +\n\
    \"            let selection;\\n\" +\n\
    \"            if (\\n\" +\n\
    \"                (evt.ctrlKey || evt.metaKey) &&\\n\" +\n\
    \"                evt.key === \\\"a\\\" &&\\n\" +\n\
    \"                evt.target.closest(\\\"pre\\\")\\n\" +\n\
    \"            ) {\\n\" +\n\
    \"                range = document.createRange();\\n\" +\n\
    \"                range.selectNodeContents(evt.target.closest(\\\"pre\\\"));\\n\" +\n\
    \"                selection = window.getSelection();\\n\" +\n\
    \"                selection.removeAllRanges();\\n\" +\n\
    \"                selection.addRange(range);\\n\" +\n\
    \"                evt.preventDefault();\\n\" +\n\
    \"            }\\n\" +\n\
    \"        };\\n\" +\n\
    \"        // handle evt\\n\" +\n\
    \"        document.addEventListener(\\n\" +\n\
    \"            \\\"keydown\\\",\\n\" +\n\
    \"            window.domOnEventSelectAllWithinPre\\n\" +\n\
    \"        );\\n\" +\n\
    \"    }\\n\" +\n\
    \"}());\\n\" +\n\
    \"</script>\\n\" +\n\
    \"<h1>\\n\" +\n\
    \"<a href=\\\"{{npm_package_homepage}}\\\" target=\\\"_blank\\\">\\n\" +\n\
    \"    {{npm_package_name}} ({{npm_package_version}})\\n\" +\n\
    \"</a>\\n\" +\n\
    \"</h1>\\n\" +\n\
    \"<h3>{{npm_package_description}}</h3>\\n\" +\n\
    \"<!-- utility2-comment\\n\" +\n\
    \"<a\\n\" +\n\
    \"    class=\\\"button\\\" download href=\\\"assets.app.js\\\"\\n\" +\n\
    \">download standalone app</a><br>\\n\" +\n\
    \"<button\\n\" +\n\
    \"    class=\\\"button\\\"\\n\" +\n\
    \"    id=\\\"buttonTestRun1\\\"\\n\" +\n\
    \">run browser-tests</button><br>\\n\" +\n\
    \"<div class=\\\"uiAnimateSlide\\\" id=\\\"htmlTestReport1\\\" style=\\\"\\n\" +\n\
    \"    border-bottom: 0;\\n\" +\n\
    \"    border-top: 0;\\n\" +\n\
    \"    margin-bottom: 0;\\n\" +\n\
    \"    margin-top: 0;\\n\" +\n\
    \"    max-height: 0;\\n\" +\n\
    \"    padding-bottom: 0;\\n\" +\n\
    \"    padding-top: 0;\\n\" +\n\
    \"\\\"></div>\\n\" +\n\
    \"utility2-comment -->\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"<!-- custom-html-start -->\\n\" +\n\
    \"<label>stderr and stdout</label>\\n\" +\n\
    \"<textarea\\n\" +\n\
    \"    class=\\\"onevent-output-reset readonly textarea\\\"\\n\" +\n\
    \"    id=\\\"outputStdout1\\\"\\n\" +\n\
    \"    readonly\\n\" +\n\
    \"></textarea>\\n\" +\n\
    \"<!-- custom-html-end -->\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"<!-- utility2-comment\\n\" +\n\
    \"<script>\\n\" +\n\
    \"window.utility2_state = {\\n\" +\n\
    \"npm_config_mode_backend: {{npm_config_mode_backend jsonStringify}},\\n\" +\n\
    \"npm_package_description: {{npm_package_description jsonStringify}},\\n\" +\n\
    \"npm_package_homepage: {{npm_package_homepage jsonStringify}},\\n\" +\n\
    \"npm_package_name: {{npm_package_name jsonStringify}},\\n\" +\n\
    \"npm_package_nameLib: {{npm_package_nameLib jsonStringify}},\\n\" +\n\
    \"npm_package_version: {{npm_package_version jsonStringify}}\\n\" +\n\
    \"}\\n\" +\n\
    \"</script>\\n\" +\n\
    \"<script src=\\\"assets.utility2.rollup.js\\\"></script>\\n\" +\n\
    \"<script>\\n\" +\n\
    \"/* jslint utility2:true */\\n\" +\n\
    \"window.utility2.onReadyIncrement();\\n\" +\n\
    \"window.addEventListener(\\\"load\\\", function () {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"    let local;\\n\" +\n\
    \"    function onTestRun({\\n\" +\n\
    \"        msg,\\n\" +\n\
    \"        target,\\n\" +\n\
    \"        type\\n\" +\n\
    \"    }) {\\n\" +\n\
    \"        switch ((target && target.id) || type) {\\n\" +\n\
    \"        case \\\"buttonTestRun1\\\":\\n\" +\n\
    \"            window.utility2_modeTest = 1;\\n\" +\n\
    \"            local.testRunDefault(window.local);\\n\" +\n\
    \"            return;\\n\" +\n\
    \"        case \\\"utility2.testRunEnd\\\":\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\"#buttonTestRun1\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                elem.textContent = \\\"run tests\\\";\\n\" +\n\
    \"            });\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\"#htmlTestReport1\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                elem.innerHTML = msg.html;\\n\" +\n\
    \"            });\\n\" +\n\
    \"            return;\\n\" +\n\
    \"        case \\\"utility2.testRunStart\\\":\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\".onevent-output-reset\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                elem.textContent = \\\"\\\";\\n\" +\n\
    \"            });\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\"#buttonTestRun1\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                elem.textContent = \\\"running tests\\\";\\n\" +\n\
    \"            });\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\"#htmlTestReport1\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                local.uiAnimateSlideDown(elem);\\n\" +\n\
    \"                elem.innerHTML = msg.html;\\n\" +\n\
    \"            });\\n\" +\n\
    \"            return;\\n\" +\n\
    \"        case \\\"utility2.testRunUpdate\\\":\\n\" +\n\
    \"            document.querySelectorAll(\\n\" +\n\
    \"                \\\"#htmlTestReport1\\\"\\n\" +\n\
    \"            ).forEach(function (elem) {\\n\" +\n\
    \"                local.uiAnimateSlideDown(elem);\\n\" +\n\
    \"                elem.innerHTML = msg.html;\\n\" +\n\
    \"            });\\n\" +\n\
    \"            return;\\n\" +\n\
    \"        }\\n\" +\n\
    \"    }\\n\" +\n\
    \"    local = window.utility2;\\n\" +\n\
    \"    document.querySelectorAll(\\n\" +\n\
    \"        \\\"#buttonTestRun1\\\"\\n\" +\n\
    \"    ).forEach(function (elem) {\\n\" +\n\
    \"        elem.addEventListener(\\\"click\\\", onTestRun);\\n\" +\n\
    \"    });\\n\" +\n\
    \"    local.eventListenerAdd(\\\"utility2.testRunEnd\\\", {}, onTestRun);\\n\" +\n\
    \"    local.eventListenerAdd(\\\"utility2.testRunUpdate\\\", {}, onTestRun);\\n\" +\n\
    \"    local.eventListenerAdd(\\\"utility2.testRunStart\\\", {}, onTestRun);\\n\" +\n\
    \"    local.onReadyDecrement();\\n\" +\n\
    \"});\\n\" +\n\
    \"</script>\\n\" +\n\
    \"utility2-comment -->\\n\" +\n\
    \"<script src=\\\"assets.{{npm_package_nameLib}}.js\\\"></script>\\n\" +\n\
    \"<script src=\\\"assets.example.js\\\"></script>\\n\" +\n\
    \"<script src=\\\"assets.test.js\\\"></script>\\n\" +\n\
    \"<div style=\\\"text-align: center;\\\">\\n\" +\n\
    \"    [\\n\" +\n\
    \"    this app was created with\\n\" +\n\
    \"    <a\\n\" +\n\
    \"        href=\\\"https://github.com/kaizhu256/node-utility2\\\"\\n\" +\n\
    \"        target=\\\"_blank\\\"\\n\" +\n\
    \"    >utility2</a>\\n\" +\n\
    \"    ]\\n\" +\n\
    \"</div>\\n\" +\n\
    \"</body>\\n\" +\n\
    \"</html>\\n\"\n\
);\n\
/* validateLineSortedReset */\n\
local.assetsDict[\"/assets.example.html\"] = \"\";\n\
local.assetsDict[\"/assets.example.template.js\"] = (\n\
    \"/*\\n\" +\n\
    \"example.js\\n\" +\n\
    \"\\n\" +\n\
    \"this script will run web-demo of my-app\\n\" +\n\
    \"\\n\" +\n\
    \"instruction\\n\" +\n\
    \"    1. save this script as example.js\\n\" +\n\
    \"    2. run shell-cmd:\\n\" +\n\
    \"        $ npm install my-app && \\\\\\n\" +\n\
    \"            PORT=8081 node example.js\\n\" +\n\
    \"    3. open browser to http://127.0.0.1:8081 and play with web-demo\\n\" +\n\
    \"    4. edit this script to suit your needs\\n\" +\n\
    \"*/\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul instrument in package my_app */\\n\" +\n\
    local.assetsDict[\"/assets.utility2.header.js\"] +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* jslint utility2:true */\\n\" +\n\
    \"(function (local) {\\n\" +\n\
    \"\\\"use strict\\\";\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"// run shared js\\u002denv code - init-before\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"// init local\\n\" +\n\
    \"local = (\\n\" +\n\
    \"    globalThis.utility2_rollup ||\\n\" +\n\
    \"    globalThis.utility2_my_app ||\\n\" +\n\
    \"    require(\\\"my-app\\\")\\n\" +\n\
    \");\\n\" +\n\
    \"// init exports\\n\" +\n\
    \"globalThis.local = local;\\n\" +\n\
    \"}());\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul ignore next */\\n\" +\n\
    \"// run browser js\\u002denv code - init-test\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"if (local.isEnvNode) {\\n\" +\n\
    \"    return;\\n\" +\n\
    \"}\\n\" +\n\
    \"// log stderr and stdout to #outputStdout1\\n\" +\n\
    \"[\\\"error\\\", \\\"log\\\"].forEach(function (key) {\\n\" +\n\
    \"    let elem;\\n\" +\n\
    \"    let fnc;\\n\" +\n\
    \"    elem = document.querySelector(\\\"#outputStdout1\\\");\\n\" +\n\
    \"    if (!elem) {\\n\" +\n\
    \"        return;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    fnc = console[key];\\n\" +\n\
    \"    console[key] = function (...argList) {\\n\" +\n\
    \"        fnc(...argList);\\n\" +\n\
    \"        // append text to #outputStdout1\\n\" +\n\
    \"        elem.textContent += argList.map(function (arg) {\\n\" +\n\
    \"            return (\\n\" +\n\
    \"                typeof arg === \\\"string\\\"\\n\" +\n\
    \"                ? arg\\n\" +\n\
    \"                : JSON.stringify(arg, undefined, 4)\\n\" +\n\
    \"            );\\n\" +\n\
    \"        }).join(\\\" \\\").replace((\\n\" +\n\
    \"            /\\\\u001b\\\\[\\\\d+?m/g\\n\" +\n\
    \"        ), \\\"\\\") + \\\"\\\\n\\\";\\n\" +\n\
    \"        // scroll textarea to bottom\\n\" +\n\
    \"        elem.scrollTop = elem.scrollHeight;\\n\" +\n\
    \"    };\\n\" +\n\
    \"});\\n\" +\n\
    \"}());\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul ignore next */\\n\" +\n\
    \"// run node js\\u002denv code - init-test\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"if (!local.isEnvNode) {\\n\" +\n\
    \"    return;\\n\" +\n\
    \"}\\n\" +\n\
    \"// init exports\\n\" +\n\
    \"module.exports = local;\\n\" +\n\
    \"// init assetsDict\\n\" +\n\
    \"local.assetsDict = local.assetsDict || {};\\n\" +\n\
    \"local.assetsDict[\\\"/assets.my_app.js\\\"] = (\\n\" +\n\
    \"    local.assetsDict[\\\"/assets.my_app.js\\\"] ||\\n\" +\n\
    \"    require(\\\"fs\\\").readFileSync(\\n\" +\n\
    \"        require(\\\"path\\\").resolve(local.__dirname + \" +\n\
    \"\\\"/lib.my_app.js\\\"),\\n\" +\n\
    \"        \\\"utf8\\\"\\n\" +\n\
    \"    ).replace((\\n\" +\n\
    \"        /^#!\\\\//\\n\" +\n\
    \"    ), \\\"// \\\")\\n\" +\n\
    \");\\n\" +\n\
    \"/* validateLineSortedReset */\\n\" +\n\
    \"/* jslint ignore:start */\\n\" +\n\
    \"local.assetsDict[\\\"/\\\"] = `\" +\n\
    local.assetsDict[\"/assets.utility2.template.html\"].replace((\n\
        /[$\\\\`]/g\n\
    ), \"\\\\$&\") +\n\
    \"`;\\n\" +\n\
    \"/* jslint ignore:end */\\n\" +\n\
    \"local.assetsDict[\\\"/assets.example.html\\\"] = local.assetsDict[\\\"/\\\"];\\n\" +\n\
    \"// init cli\\n\" +\n\
    \"if (module !== require.main || globalThis.utility2_rollup) {\\n\" +\n\
    \"    return;\\n\" +\n\
    \"}\\n\" +\n\
    \"local.assetsDict[\\\"/assets.example.js\\\"] = (\\n\" +\n\
    \"    local.assetsDict[\\\"/assets.example.js\\\"] ||\\n\" +\n\
    \"    require(\\\"fs\\\").readFileSync(__filename, \\\"utf8\\\")\\n\" +\n\
    \");\\n\" +\n\
    \"local.assetsDict[\\\"/favicon.ico\\\"] = \" +\n\
    \"local.assetsDict[\\\"/favicon.ico\\\"] || \\\"\\\";\\n\" +\n\
    \"local.assetsDict[\\\"/index.html\\\"] = local.assetsDict[\\\"/\\\"];\\n\" +\n\
    \"// if $npm_config_timeout_exit exists,\\n\" +\n\
    \"// then exit this process after $npm_config_timeout_exit ms\\n\" +\n\
    \"if (process.env.npm_config_timeout_exit) {\\n\" +\n\
    \"    setTimeout(\\n\" +\n\
    \"        process.exit.bind(undefined, 15),\\n\" +\n\
    \"        process.env.npm_config_timeout_exit | 0\\n\" +\n\
    \"    ).unref();\\n\" +\n\
    \"}\\n\" +\n\
    \"// start server\\n\" +\n\
    \"if (globalThis.utility2_serverHttp1) {\\n\" +\n\
    \"    return;\\n\" +\n\
    \"}\\n\" +\n\
    \"process.env.PORT = process.env.PORT || \\\"8081\\\";\\n\" +\n\
    \"console.error(\\\"http-server listening on port \\\" + process.env.PORT);\\n\" +\n\
    \"require(\\\"http\\\").createServer(function (req, res) {\\n\" +\n\
    \"    let data;\\n\" +\n\
    \"    data = local.assetsDict[require(\\\"url\\\").parse(req.url).pathname];\\n\" +\n\
    \"    if (data !== undefined) {\\n\" +\n\
    \"        res.end(data);\\n\" +\n\
    \"        return;\\n\" +\n\
    \"    }\\n\" +\n\
    \"    res.statusCode = 404;\\n\" +\n\
    \"    res.end();\\n\" +\n\
    \"}).listen(process.env.PORT);\\n\" +\n\
    \"}());\\n\" +\n\
    \"}());\\n\"\n\
);\n\
local.assetsDict[\"/assets.my_app.template.js\"] = (\n\
    \"#!/usr/bin/env node\\n\" +\n\
    \"/*\\n\" +\n\
    \" * lib.my_app.js ({{npm_package_version}})\\n\" +\n\
    \" * https://github.com/kaizhu256/node-my-app\\n\" +\n\
    \" * {{npm_package_description}}\\n\" +\n\
    \" *\\n\" +\n\
    \" */\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul instrument in package my_app */\\n\" +\n\
    local.assetsDict[\"/assets.utility2.header.js\"] +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"(function (local) {\\n\" +\n\
    \"\\\"use strict\\\";\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul ignore next */\\n\" +\n\
    \"// run shared js\\u002denv code - init-before\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"// init local\\n\" +\n\
    \"local = (\\n\" +\n\
    \"    globalThis.utility2_rollup ||\\n\" +\n\
    \"    // globalThis.utility2_rollup_old ||\\n\" +\n\
    \"    // require(\\\"./assets.utility2.rollup.js\\\") ||\\n\" +\n\
    \"    globalThis.globalLocal\\n\" +\n\
    \");\\n\" +\n\
    \"// init exports\\n\" +\n\
    \"if (local.isEnvNode) {\\n\" +\n\
    \"    module.exports = local;\\n\" +\n\
    \"    module.exports.__dirname = __dirname;\\n\" +\n\
    \"} else {\\n\" +\n\
    \"    globalThis.utility2_my_app = local;\\n\" +\n\
    \"}\\n\" +\n\
    \"// init lib main\\n\" +\n\
    \"local.my_app = local;\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* validateLineSortedReset */\\n\" +\n\
    \"return;\\n\" +\n\
    \"}());\\n\" +\n\
    \"}());\\n\"\n\
);\n\
local.assetsDict[\"/assets.readme.template.md\"] = String(\n\
    \"# my-app\\n\" +\n\
    \"the greatest app in the world!\\n\" +\n\
    \"\\n\" +\n\
    \"# live web demo\\n\" +\n\
    \"- [{{app.io}}/build..beta..github.com/app]\" +\n\
    \"({{app.io}}/build..beta..github.com/app)\\n\" +\n\
    \"\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithub.{{app.png}})]\" +\n\
    \"({{app.io}}/build..beta..github.com/app)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"[![github.com ci-status]\" +\n\
    \"(https://github.com/kaizhu256/node-my-app/workflows/\" +\n\
    \"Node.js%20CI/badge.svg)]\" +\n\
    \"(https://github.com/kaizhu256/node-my-app/actions) \" +\n\
    \"[![coverage]\" +\n\
    \"({{app.io}}/build/coverage/coverage.badge.svg)]\" +\n\
    \"({{app.io}}/build/coverage/index.html)\\n\" +\n\
    \"\\n\" +\n\
    \"[![NPM]\" +\n\
    \"(https://nodei.co/npm/my-app.png?downloads=true)]\" +\n\
    \"(https://www.npmjs.com/package/my-app)\\n\" +\n\
    \"\\n\" +\n\
    \"[![commit status]\" +\n\
    \"({{app.io}}/build/commit.badge.svg)]\" +\n\
    \"(https://github.com/kaizhu256/node-my-app/actions)\\n\" +\n\
    \"\\n\" +\n\
    \"| git-branch : | \" +\n\
    \"[master]\" +\n\
    \"({{app.com}}/tree/master) | \" +\n\
    \"[beta]\" +\n\
    \"({{app.com}}/tree/beta) | \" +\n\
    \"[alpha]\" +\n\
    \"({{app.com}}/tree/alpha)|\\n\" +\n\
    \"|--:|:--|:--|:--|\\n\" +\n\
    \"| test-server-github : | \" +\n\
    \"[![github.com test-server]\" +\n\
    \"({{app.io}}/GitHub-Mark-32px.png)]\" +\n\
    \"({{app.io}}/build..master..github.com/app) | \" +\n\
    \"[![github.com test-server]\" +\n\
    \"({{app.io}}/GitHub-Mark-32px.png)]\" +\n\
    \"({{app.io}}/build..beta..github.com/app) | \" +\n\
    \"[![github.com test-server]\" +\n\
    \"({{app.io}}/GitHub-Mark-32px.png)]\" +\n\
    \"({{app.io}}/build..alpha..github.com/app)|\\n\" +\n\
    \"| test-server-heroku : | \" +\n\
    \"[![heroku.com test-server]\" +\n\
    \"({{app.io}}/heroku-logo.75x25.png)]\" +\n\
    \"(https://h1-my-app-master.herokuapp.com) | \" +\n\
    \"[![heroku.com test-server]\" +\n\
    \"({{app.io}}/heroku-logo.75x25.png)]\" +\n\
    \"(https://h1-my-app-beta.herokuapp.com) | \" +\n\
    \"[![heroku.com test-server]\" +\n\
    \"({{app.io}}/heroku-logo.75x25.png)]\" +\n\
    \"(https://h1-my-app-alpha.herokuapp.com)|\\n\" +\n\
    \"| test-report : | \" +\n\
    \"[![test-report]\" +\n\
    \"({{app.io}}/build..master..github.com/test-report.badge.svg)]\" +\n\
    \"({{app.io}}/build..master..github.com/test-report.html) | \" +\n\
    \"[![test-report]\" +\n\
    \"({{app.io}}/build..beta..github.com/test-report.badge.svg)]\" +\n\
    \"({{app.io}}/build..beta..github.com/test-report.html) | \" +\n\
    \"[![test-report]\" +\n\
    \"({{app.io}}/build..alpha..github.com/test-report.badge.svg)]\" +\n\
    \"({{app.io}}/build..alpha..github.com/test-report.html)|\\n\" +\n\
    \"| coverage : | \" +\n\
    \"[![coverage]\" +\n\
    \"({{app.io}}/build..master..github.com/coverage/coverage.badge.svg)]\" +\n\
    \"({{app.io}}/build..master..github.com/coverage/index.html) | \" +\n\
    \"[![coverage]\" +\n\
    \"({{app.io}}/build..beta..github.com/coverage/coverage.badge.svg)]\" +\n\
    \"({{app.io}}/build..beta..github.com/coverage/index.html) | \" +\n\
    \"[![coverage]\" +\n\
    \"({{app.io}}/build..alpha..github.com/coverage/coverage.badge.svg)]\" +\n\
    \"({{app.io}}/build..alpha..github.com/coverage/index.html)|\\n\" +\n\
    \"| build-artifacts : | \" +\n\
    \"[![build-artifacts]\" +\n\
    \"({{app.io}}/glyphicons_144_folder_open.png)]\" +\n\
    \"({{app.com}}/tree/gh-pages/build..master..github.com) | \" +\n\
    \"[![build-artifacts]\" +\n\
    \"({{app.io}}/glyphicons_144_folder_open.png)]\" +\n\
    \"({{app.com}}/tree/gh-pages/build..beta..github.com) | \" +\n\
    \"[![build-artifacts]\" +\n\
    \"({{app.io}}/glyphicons_144_folder_open.png)]\" +\n\
    \"({{app.com}}/tree/gh-pages/build..alpha..github.com)|\\n\" +\n\
    \"\\n\" +\n\
    \"[![npmPackageListing]\" +\n\
    \"({{app.io}}/build/screenshot.npmPackageListing.svg)]\" +\n\
    \"({{app.com}})\\n\" +\n\
    \"\\n\" +\n\
    \"![npmPackageDependencyTree]\" +\n\
    \"({{app.io}}/build/screenshot.npmPackageDependencyTree.svg)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# table of contents\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# cdn download\\n\" +\n\
    \"- [{{app.io}}/build..beta..github.com/app/assets.my_app.js]\" +\n\
    \"({{app.io}}/build..beta..github.com/app/assets.my_app.js)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# documentation\\n\" +\n\
    \"#### api doc\\n\" +\n\
    \"- [{{app.io}}/build..beta..github.com/apidoc.html]\" +\n\
    \"({{app.io}}/build..beta..github.com/apidoc.html)\\n\" +\n\
    \"\\n\" +\n\
    \"[![apidoc]\" +\n\
    \"({{app.io}}/build/{{screenshot}}apidoc.html.png)]\" +\n\
    \"({{app.io}}/build..beta..github.com/apidoc.html)\\n\" +\n\
    \"\\n\" +\n\
    \"#### cli help\\n\" +\n\
    \"![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.npmPackageCliHelp.svg)\\n\" +\n\
    \"\\n\" +\n\
    \"#### changelog 0.0.1\\n\" +\n\
    \"- update build\\n\" +\n\
    \"- none\\n\" +\n\
    \"\\n\" +\n\
    \"#### todo\\n\" +\n\
    \"- none\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# quickstart standalone app\\n\" +\n\
    \"#### to run this example, follow instruction in script below\\n\" +\n\
    \"- [assets.app.js]\" +\n\
    \"({{app.io}}/build..beta..github.com/app/assets.app.js)\\n\" +\n\
    \"```shell\\n\" +\n\
    \"# example.sh\\n\" +\n\
    \"\\n\" +\n\
    \"# this shell script will download and run web-demo of my-app \" +\n\
    \"as standalone app\\n\" +\n\
    \"\\n\" +\n\
    \"# 1. download standalone app\\n\" +\n\
    \"curl -O {{app.io}}/build..beta..github.com/app/assets.app.js\\n\" +\n\
    \"# 2. run standalone app\\n\" +\n\
    \"PORT=8081 node ./assets.app.js\\n\" +\n\
    \"# 3. open browser to http://127.0.0.1:8081 and play with web-demo\\n\" +\n\
    \"# 4. edit file assets.app.js to suit your needs\\n\" +\n\
    \"```\\n\" +\n\
    \"\\n\" +\n\
    \"#### output from browser\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/app/assets.example.html)\\n\" +\n\
    \"\\n\" +\n\
    \"#### output from shell\\n\" +\n\
    \"![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleSh.svg)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# quickstart example.js\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/app/assets.example.html)\\n\" +\n\
    \"\\n\" +\n\
    \"#### to run this example, follow instruction in script below\\n\" +\n\
    \"- [example.js]\" +\n\
    \"({{app.io}}/build..beta..github.com/example.js)\\n\" +\n\
    \"```javascript\\n\" +\n\
    local.assetsDict[\"/assets.example.template.js\"] +\n\
    \"```\\n\" +\n\
    \"\\n\" +\n\
    \"#### output from browser\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/app/assets.example.html)\\n\" +\n\
    \"\\n\" +\n\
    \"#### output from shell\\n\" +\n\
    \"![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.svg)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# extra screenshots\\n\" +\n\
    \"1. [{{app.io}}/build/{{screenshot}}apidoc.html.png]\" +\n\
    \"({{app.io}}/build/{{screenshot}}apidoc.html.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/{{screenshot}}apidoc.html.png)]\" +\n\
    \"({{app.io}}/build/{{screenshot}}apidoc.html.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/{{screenshot}}coverage.lib.html.png]\" +\n\
    \"({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/{{screenshot}}coverage.lib.html.png)]\" +\n\
    \"({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/{{screenshot}}test-report.html.png]\" +\n\
    \"({{app.io}}/build/{{screenshot}}test-report.html.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/{{screenshot}}test-report.html.png)]\" +\n\
    \"({{app.io}}/build/{{screenshot}}test-report.html.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.deployGithub.{{app.png}}]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithub.{{app.png}})\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithub.{{app.png}})]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithub.{{app.png}})\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.deployGithubTest.{{app.png}}]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})]\" +\n\
    \"({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.deployHeroku.browser.%252F.png]\" +\n\
    \"({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png]\" +\n\
    \"({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.npmTest.browser.%252F.png]\" +\n\
    \"({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.npmTest.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\\n\" +\n\
    \"\\n\" +\n\
    \"1. [{{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]\" +\n\
    \"({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# package.json\\n\" +\n\
    \"```json\\n\" +\n\
    \"{\\n\" +\n\
    \"    \\\"!!jslint_utility2\\\": true,\\n\" +\n\
    \"    \\\"author\\\": \\\"kai zhu <kaizhu256@gmail.com>\\\",\\n\" +\n\
    \"    \\\"description\\\": \\\"the greatest app in the world!\\\",\\n\" +\n\
    \"    \\\"devDependencies\\\": {\\n\" +\n\
    \"        \\\"utility2\\\": \\\"kaizhu256/node-utility2#alpha\\\"\\n\" +\n\
    \"    },\\n\" +\n\
    \"    \\\"engines\\\": {\\n\" +\n\
    \"        \\\"node\\\": \\\">=12.0\\\"\\n\" +\n\
    \"    },\\n\" +\n\
    \"    \\\"fileCount\\\": 0,\\n\" +\n\
    \"    \\\"homepage\\\": \\\"{{app.com}}\\\",\\n\" +\n\
    \"    \\\"keywords\\\": [],\\n\" +\n\
    \"    \\\"license\\\": \\\"MIT\\\",\\n\" +\n\
    \"    \\\"main\\\": \\\"lib.my_app.js\\\",\\n\" +\n\
    \"    \\\"name\\\": \\\"my-app\\\",\\n\" +\n\
    \"    \\\"nameAliasPublish\\\": \\\"\\\",\\n\" +\n\
    \"    \\\"repository\\\": {\\n\" +\n\
    \"        \\\"type\\\": \\\"git\\\",\\n\" +\n\
    \"        \\\"url\\\": \\\"{{app.com}}.git\\\"\\n\" +\n\
    \"    },\\n\" +\n\
    \"    \\\"scripts\\\": {\\n\" +\n\
    \"        \\\"build-ci\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"env\\\": \\\"env\\\",\\n\" +\n\
    \"        \\\"eval\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"heroku-postbuild\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"postinstall\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"start\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"test\\\": \\\"sh npm_scripts.sh\\\",\\n\" +\n\
    \"        \\\"utility2\\\": \\\"sh npm_scripts.sh\\\"\\n\" +\n\
    \"    },\\n\" +\n\
    \"    \\\"version\\\": \\\"0.0.1\\\"\\n\" +\n\
    \"}\\n\" +\n\
    \"```\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# changelog of last 50 commits\\n\" +\n\
    \"[![screenshot]\" +\n\
    \"({{app.io}}/build/screenshot.gitLog.svg)]\" +\n\
    \"({{app.com}}/commits)\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# internal build script\\n\" +\n\
    \"- build_ci.sh\\n\" +\n\
    \"```shell\\n\" +\n\
    \"# build_ci.sh\\n\" +\n\
    \"\\n\" +\n\
    \"# this shell script will run build-ci for this package\\n\" +\n\
    \"\\n\" +\n\
    \"shCiAfter () {(set -e\\n\" +\n\
    \"    # shDeployCustom\\n\" +\n\
    \"    shDeployGithub\\n\" +\n\
    \"    # shDeployHeroku\\n\" +\n\
    \"    shReadmeEval example.sh\\n\" +\n\
    \")}\\n\" +\n\
    \"\\n\" +\n\
    \"shCiBefore () {(set -e\\n\" +\n\
    \"    # shNpmTestPublished\\n\" +\n\
    \"    shReadmeEval example.js\\n\" +\n\
    \")}\\n\" +\n\
    \"\\n\" +\n\
    \"# run shCiMain\\n\" +\n\
    \"eval \\\"$(utility2 source)\\\"\\n\" +\n\
    \"shCiMain\\n\" +\n\
    \"```\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"# misc\\n\" +\n\
    \"- this package was created with [utility2]\" +\n\
    \"(https://github.com/kaizhu256/node-utility2)\\n\"\n\
).replace((\n\
    /\\{\\{app\\.com\\}\\}/g\n\
), \"https://github.com/kaizhu256/node-my-app\").replace((\n\
    /\\{\\{app\\.io\\}\\}/g\n\
), \"https://kaizhu256.github.io/node-my-app\").replace((\n\
    /\\{\\{app.png\\}\\}/g\n\
), \"browser.%252Fnode-my-app%252Fbuild%252Fapp.png\").replace((\n\
    /\\{\\{screenshot\\}\\}/g\n\
), \"screenshot.ci.browser.%252F.tmp%252Fbuild%252F\");\n\
local.assetsDict[\"/assets.test.template.js\"] = (\n\
    \"/* istanbul instrument in package my_app */\\n\" +\n\
    local.assetsDict[\"/assets.utility2.header.js\"] +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* jslint utility2:true */\\n\" +\n\
    \"(function (local) {\\n\" +\n\
    \"\\\"use strict\\\";\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* istanbul ignore next */\\n\" +\n\
    \"// run shared js\\u002denv code - init-before\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"// init local\\n\" +\n\
    \"local = globalThis.utility2 || require(\\\"utility2\\\");\\n\" +\n\
    \"local = local.requireReadme();\\n\" +\n\
    \"globalThis.local = local;\\n\" +\n\
    \"// init test\\n\" +\n\
    \"local.testRunDefault(local);\\n\" +\n\
    \"}());\\n\" +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"// run shared js\\u002denv code - function\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"return;\\n\" +\n\
    \"}());\\n\" +\n\
    \"}());\\n\"\n\
);\n\
local.assetsDict[\"/assets.utility2.rollup.content.js\"] = (\n\
    \"(function (local) {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"/* jslint ignore:start */\\n\" +\n\
    \"/* utility2.rollup.js content */\\n\" +\n\
    \"/* jslint ignore:end */\\n\" +\n\
    \"    return local;\\n\" +\n\
    \"}(globalThis.utility2_rollup));\\n\"\n\
);\n\
local.assetsDict[\"/assets.utility2.rollup.end.js\"] = (\n\
    \"(function () {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"    globalThis.utility2_rollup_old = globalThis.utility2_rollup;\\n\" +\n\
    \"    globalThis.utility2_rollup = null;\\n\" +\n\
    \"}());\\n\" +\n\
    \"/* utility2.rollup.js end */\\n\"\n\
);\n\
local.assetsDict[\"/assets.utility2.rollup.start.js\"] = (\n\
    \"/* utility2.rollup.js begin */\\n\" +\n\
    \"/* istanbul ignore all */\\n\" +\n\
    local.assetsDict[\"/assets.utility2.header.js\"] +\n\
    \"\\n\" +\n\
    \"\\n\" +\n\
    \"/* jslint utility2:true */\\n\" +\n\
    \"(function () {\\n\" +\n\
    \"    \\\"use strict\\\";\\n\" +\n\
    \"    // init utility2_rollup\\n\" +\n\
    \"    globalThis.utility2_rollup = (\\n\" +\n\
    \"        globalThis.utility2_rollup_old\\n\" +\n\
    \"        || globalThis.globalLocal\\n\" +\n\
    \"    );\\n\" +\n\
    \"    globalThis.utility2_rollup.local = globalThis.utility2_rollup;\\n\" +\n\
    \"    globalThis.utility2_rollup_old = null;\\n\" +\n\
    \"}());\\n\"\n\
);\n\
local.assetsDict[\"/favicon.ico\"] = \"\";\n\
\n\
\n\
/* validateLineSortedReset */\n\
// run shared js-env code - function\n\
let localEventListenerDict;\n\
let localEventListenerId;\n\
let localOnReadyCnt;\n\
localEventListenerDict = {};\n\
localEventListenerId = 0;\n\
localOnReadyCnt = 0;\n\
\n\
local._testCase_buildApidoc_default = function (opt, onError) {\n\
/*\n\
 * this function will test buildApidoc's default handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    function require2(file) {\n\
    /*\n\
     * this function will require <file> in sandbox-env\n\
     */\n\
        let exports;\n\
        let mockDict;\n\
        let mockList;\n\
        mockList = [\n\
            [\n\
                globalThis, {\n\
                    setImmediate: noop,\n\
                    setInterval: noop,\n\
                    setTimeout: noop\n\
                }\n\
            ]\n\
        ];\n\
        // disable io and side-effect\n\
        [\n\
            process,\n\
            process.stdin,\n\
            process.stdout,\n\
            require(\"child_process\"),\n\
            require(\"cluster\"),\n\
            require(\"crypto\"),\n\
            require(\"dgram\"),\n\
            require(\"dns\"),\n\
            require(\"domain\"),\n\
            require(\"events\").prototype,\n\
            require(\"http\"),\n\
            require(\"https\"),\n\
            require(\"net\"),\n\
            require(\"os\"),\n\
            require(\"readline\"),\n\
            require(\"repl\"),\n\
            require(\"stream\").prototype,\n\
            require(\"timers\"),\n\
            require(\"tls\"),\n\
            require(\"tty\"),\n\
            require(\"util\"),\n\
            require(\"v8\"),\n\
            require(\"vm\"),\n\
            {\n\
                // coverage-hack\n\
                \"__zjqx1234__\": noop\n\
            }\n\
        ].forEach(function (dict) {\n\
            mockDict = {};\n\
            Object.keys(dict).forEach(function (key) {\n\
                if (typeof dict[key] === \"function\" && (\n\
                    // coverage-hack\n\
                    key === \"__zjqx1234__\" ||\n\
                    npm_config_mode_test_case === \"testCase_buildApidoc_default\"\n\
                )) {\n\
                    mockDict[key] = noop;\n\
                }\n\
            });\n\
            mockList.push([\n\
                dict, mockDict\n\
            ]);\n\
        });\n\
        local.testMock(mockList, function (onError) {\n\
            try {\n\
                exports = require(file);\n\
            } catch (errCaught) {\n\
                console.error(errCaught);\n\
            }\n\
            onError();\n\
        }, onErrorThrow);\n\
        return exports;\n\
    }\n\
    // coverage-hack\n\
    require2();\n\
    // save apidoc.html\n\
    local.fsWriteFileWithMkdirpSync(\".tmp/build/apidoc.html\", apidocCreate(\n\
        Object.assign({\n\
            blacklistDict: local,\n\
            modeNoop: (\n\
                npm_config_mode_test_case !== \"testCase_buildApidoc_default\"\n\
            ),\n\
            require: require2\n\
        }, opt)\n\
    ));\n\
    onError();\n\
};\n\
\n\
local._testCase_buildApp_default = function (opt, onError) {\n\
/*\n\
 * this function will test buildApp's default handling-behavior\n\
 */\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    local.buildApp(opt, onError);\n\
};\n\
\n\
local._testCase_webpage_default = async function (opt, onError) {\n\
/*\n\
 * this function will test webpage's default handling-behavior\n\
 */\n\
    local.domQuerySelectorAllTagName(\"html\");\n\
    local.domStyleValidate();\n\
    if (!isEnvNode) {\n\
        onError(undefined, opt);\n\
        return;\n\
    }\n\
    await local.browserTest({\n\
        url: (\n\
            \"http://127.0.0.1:\" + PORT +\n\
            \"/?npm_config_mode_test=1&npm_config_timeout=\" +\n\
            npm_config_timeout +\n\
            \"&npm_config_mode_test_case=\" + npm_config_mode_test_case.replace((\n\
                /\\b_?testCase_webpage_default\\b/\n\
            ), \"\")\n\
        )\n\
    });\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.browserTest = async function ({\n\
    modeSilent,\n\
    modeWindowSize,\n\
    url\n\
}) {\n\
/*\n\
 * this function will spawn google-chrome-process to test <url>\n\
 */\n\
    let chromeClient;\n\
    let chromeFrameId;\n\
    let fileScreenshot;\n\
    let isDone;\n\
    let promiseScreenshot;\n\
    let testErr;\n\
    let testId;\n\
    let testName;\n\
    let testReport;\n\
    let {\n\
        chromeDevtoolsClientCreate,\n\
        testReportMerge\n\
    } = local;\n\
    // node - init\n\
    testId = Math.random().toString(16);\n\
    testName = MODE_CI + \".browser.\" + encodeURIComponent(\n\
        require(\"url\").parse(url).pathname.replace(\n\
            \"/build..\" + CI_BRANCH + \"..\" + CI_HOST,\n\
            \"/build\"\n\
        )\n\
    );\n\
    fileScreenshot = (\n\
        UTILITY2_DIR_BUILD + \"/screenshot.\" + testName + \".png\"\n\
    );\n\
    chromeClient = await chromeDevtoolsClientCreate({\n\
        modeSilent,\n\
        modeWindowSize,\n\
        timeout: npm_config_timeout\n\
    });\n\
    // init page\n\
    chromeClient.rpc(\"Page.enable\");\n\
    chromeClient.rpc(\"Page.setLifecycleEventsEnabled\", {\n\
        enabled: true\n\
    });\n\
    chromeClient.rpc(\"Performance.enable\");\n\
    // load url\n\
    chromeClient.rpc(\"Page.navigate\", {\n\
        url\n\
    });\n\
    chromeFrameId = (\n\
        await chromeClient.rpc(\"Page.getFrameTree\")\n\
    ).frameTree.frame.id;\n\
    await new Promise(function (resolve) {\n\
        chromeClient.on(\"Page.lifecycleEvent\", function onLoad({\n\
            frameId,\n\
            name\n\
        }) {\n\
            if (frameId === chromeFrameId && name === \"load\") {\n\
                chromeClient.removeListener(\"Page.lifecycleEvent\", onLoad);\n\
                resolve();\n\
            }\n\
        });\n\
    });\n\
    console.error(\"chrome-devtools - loaded - page \" + url);\n\
    // screenshot\n\
    promiseScreenshot = new Promise(async function (resolve) {\n\
        let data;\n\
        await new Promise(function (resolve) {\n\
            setTimeout(resolve, 100);\n\
        });\n\
        data = await chromeClient.rpc(\"Page.captureScreenshot\", {\n\
            format: \"png\"\n\
        });\n\
        await require(\"fs\").promises.writeFile(\n\
            fileScreenshot,\n\
            Buffer.from(data.data, \"base64\")\n\
        );\n\
        console.error(\"chrome-devtools - wrote - screenshot \" + fileScreenshot);\n\
        resolve();\n\
    });\n\
    chromeClient.evaluate(\n\
        // coverage-hack\n\
        \"console.timeStamp();\\n\" +\n\
        \"window.utility2_testId=\\\"\" + testId + \"\\\";\\n\" +\n\
        \"if(!window.utility2_modeTest){\\n\" +\n\
        \"console.timeStamp(window.utility2_testId);\\n\" +\n\
        \"}\\n\"\n\
    );\n\
    testReport = await new Promise(function (resolve) {\n\
        chromeClient.on(\"Performance.metrics\", function ({\n\
            title\n\
        }) {\n\
            if (isDone || title !== testId) {\n\
                return;\n\
            }\n\
            isDone = true;\n\
            resolve(chromeClient.evaluate(\n\
                \"JSON.stringify(\\n\" +\n\
                \"window.utility2_testReport\\n\" +\n\
                \"||{testPlatformList:[{}]}\\n\" +\n\
                \");\\n\"\n\
            ));\n\
        });\n\
    });\n\
    testReport = JSON.parse(testReport);\n\
    // init testErr\n\
    testErr = testReport.testPlatformList[0].testsFailed && new Error(\n\
        testReport.testPlatformList[0].testsFailed\n\
    );\n\
    // merge browser-screenshot\n\
    testReport.testPlatformList[0].screenshot = fileScreenshot.replace((\n\
        /.*\\//\n\
    ), \"\");\n\
    // merge browser-coverage\n\
    coverageMerge(globalThis.__coverage__, testReport.coverage);\n\
    // merge browser-test-report\n\
    testReportMerge(globalThis.utility2_testReport, testReport);\n\
    // save test-report.json\n\
    await require(\"fs\").promises.writeFile(\n\
        require(\"path\").resolve(UTILITY2_DIR_BUILD + \"/test-report.json\"),\n\
        JSON.stringify(globalThis.utility2_testReport)\n\
    );\n\
    console.error(\n\
        \"\\nbrowserTest - merged test-report \" +\n\
        UTILITY2_DIR_BUILD + \"/test-report.json\" + \"\\n\"\n\
    );\n\
    noop(await promiseScreenshot);\n\
    // cleanup chromeClient\n\
    chromeClient.destroy();\n\
    onErrorThrow(testErr);\n\
};\n\
\n\
local.buildApp = function ({\n\
    customizeAssetsList = [],\n\
    customizeReadmeList = []\n\
}, onError) {\n\
/*\n\
 * this function will build app\n\
 */\n\
    let assert;\n\
    let fileDict;\n\
    let packageJson;\n\
    let packageNameLib;\n\
    let port;\n\
    let promiseList;\n\
    let src;\n\
    let tgt;\n\
    assert = require(\"assert\");\n\
    function tgtReplaceConditional(conditional, replaceList) {\n\
    /*\n\
     * this function will conditionally replace <tgt> with replacements in\n\
     * <replaceList>\n\
     */\n\
        replaceList.forEach(function ({\n\
            aa,\n\
            bb,\n\
            merge\n\
        }) {\n\
            let isMatch;\n\
            if (!conditional) {\n\
                aa = aa || merge;\n\
                console.error(\n\
                    \"buildApp - replace-skipped - \" +\n\
                    JSON.stringify((aa && aa.source) || aa)\n\
                );\n\
                return;\n\
            }\n\
            if (aa) {\n\
                if (!tgt.match(aa)) {\n\
                    console.error(\n\
                        \"buildApp - replace-unmatched - \" +\n\
                        JSON.stringify((aa && aa.source) || aa)\n\
                    );\n\
                    return;\n\
                }\n\
                tgt = tgt.replace(aa, bb);\n\
                return;\n\
            }\n\
            src.replace(merge, function (match2) {\n\
                tgt.replace(merge, function (match1) {\n\
                    isMatch = true;\n\
                    // disable $-escape in replacement-string\n\
                    tgt = tgt.replace(match1, function () {\n\
                        return match2;\n\
                    });\n\
                    return \"\";\n\
                });\n\
                return \"\";\n\
            });\n\
            if (!isMatch) {\n\
                console.error(\n\
                    \"buildApp - replace-unmatched - \" +\n\
                    JSON.stringify(merge.source)\n\
                );\n\
            }\n\
        });\n\
    }\n\
    function writeFileLog(file) {\n\
    /*\n\
     * this function will notify <file> written\n\
     */\n\
        console.error(\"buildApp - wrote - \" + require(\"path\").resolve(file));\n\
    }\n\
    function writeFile(file, data, resolve) {\n\
    /*\n\
     * this function will write <data> to <file> with notification\n\
     */\n\
        require(\"fs\").writeFile(file, data, function (err) {\n\
            onErrorThrow(err);\n\
            writeFileLog(file);\n\
            resolve();\n\
        });\n\
    }\n\
    async function buildAppAssets(resolve) {\n\
        // fetch assets\n\
        await Promise.all([\n\
            {\n\
                url: \"/LICENSE\"\n\
            }, {\n\
                file: \"/assets.\" + packageNameLib + \".html\",\n\
                url: \"/index.html\"\n\
            }, {\n\
                url: \"/assets.\" + packageNameLib + \".css\"\n\
            }, {\n\
                url: \"/assets.\" + packageNameLib + \".js\"\n\
            }, {\n\
                url: \"/assets.app.js\"\n\
            }, {\n\
                url: \"/assets.example.html\"\n\
            }, {\n\
                url: \"/assets.example.js\"\n\
            }, {\n\
                url: \"/assets.test.js\"\n\
            }, {\n\
                url: \"/assets.utility2.html\"\n\
            }, {\n\
                url: \"/assets.utility2.lib.jslint.js\"\n\
            }, {\n\
                url: \"/assets.utility2.rollup.js\"\n\
            }, {\n\
                url: \"/index.html\"\n\
            }\n\
        ].concat(customizeAssetsList).map(function ({\n\
            file,\n\
            url\n\
        }) {\n\
            return new Promise(function (resolve) {\n\
                require(\"http\").get((\n\
                    \"http://127.0.0.1:\" + PORT + url\n\
                ), function (res) {\n\
                    let bufList;\n\
                    assert.ok(res.statusCode === 200, url);\n\
                    bufList = [];\n\
                    res.on(\"data\", function (chunk) {\n\
                        bufList.push(chunk);\n\
                    }).on(\"end\", function () {\n\
                        writeFile(\n\
                            \".tmp/build/app/\" + (file || url),\n\
                            Buffer.concat(bufList),\n\
                            resolve\n\
                        );\n\
                    });\n\
                });\n\
            });\n\
        }));\n\
        // jslint assets\n\
        require(\"child_process\").spawn(\"node\", [\n\
            \"assets.utility2.lib.jslint.js\", \"dir\", \".\", \"--conditional\"\n\
        ], {\n\
            cwd: \".tmp/build/app\",\n\
            stdio: [\n\
                \"ignore\", 1, 2\n\
            ]\n\
        }).on(\"exit\", resolve);\n\
    }\n\
    async function buildAppStandalone(resolve) {\n\
        let fileList;\n\
        // write native-module\n\
        fileList = await require(\"fs\").promises.readdir(\".\");\n\
        await Promise.all(fileList.map(function (file) {\n\
            return new Promise(function (resolve) {\n\
                if (require(\"path\").extname(file) !== \".node\") {\n\
                    resolve();\n\
                    return;\n\
                }\n\
                require(\"fs\").copyFile(file, (\n\
                    \".tmp/build/app.standalone/\" + file\n\
                ), function (err) {\n\
                    onErrorThrow(err);\n\
                    resolve();\n\
                });\n\
            });\n\
        }));\n\
        // write assets.app.js\n\
        writeFile((\n\
            \".tmp/build/app.standalone/assets.app.js\"\n\
        ), local.assetsDict[\"/assets.app.js\"], function () {\n\
            let child;\n\
            // test-file assets.app.js\n\
            child = require(\"child_process\").spawn(\"node\", [\n\
                \"assets.app.js\"\n\
            ], {\n\
                cwd: \".tmp/build/app.standalone\",\n\
                env: {\n\
                    HOME,\n\
                    PATH,\n\
                    PORT: port\n\
                },\n\
                stdio: [\n\
                    \"ignore\", 1, 2\n\
                ]\n\
            }).on(\"exit\", function (exitCode, signal) {\n\
                assert.ok(!exitCode && signal === \"SIGTERM\", JSON.stringify({\n\
                    exitCode,\n\
                    signal\n\
                }));\n\
                resolve();\n\
            });\n\
            setTimeout(child.kill.bind(child, \"SIGTERM\"), 4000);\n\
        });\n\
    }\n\
    function buildLib(resolve) {\n\
        src = fileDict[\"lib.\" + packageNameLib + \".js\"];\n\
        // render lib.xxx.js\n\
        tgt = local.templateRenderMyApp(\n\
            local.assetsDict[\"/assets.my_app.template.js\"]\n\
        );\n\
        tgtReplaceConditional(true, [\n\
            {\n\
                // customize top-level comment-description\n\
                merge: (\n\
                    /\\n\\u0020\\*\\n(?:[\\S\\s]*?\\n)?\\u0020\\*\\/\\n/\n\
                )\n\
            }, {\n\
                // customize code after /* validateLineSortedReset */\n\
                merge: (\n\
                    /\\n\\/\\*\\u0020validateLineSortedReset\\u0020\\*\\/\\n[\\S\\s]*?$/\n\
                )\n\
            }\n\
        ]);\n\
        // customize assets.utility2.rollup.js\n\
        tgtReplaceConditional(fileDict[\"assets.utility2.rollup.js\"], [\n\
            {\n\
                aa: \"    // || globalThis.utility2_rollup_old\",\n\
                bb: \"    || globalThis.utility2_rollup_old\"\n\
            }, {\n\
                aa: \"    // || require(\\\"./assets.utility2.rollup.js\\\")\",\n\
                bb: \"    || require(\\\"./assets.utility2.rollup.js\\\")\"\n\
            }\n\
        ]);\n\
        // write lib.xxx.js\n\
        writeFile(\"lib.\" + packageNameLib + \".js\", tgt, resolve);\n\
    }\n\
    function buildReadme(resolve) {\n\
    /*\n\
     * this function will build readme with template assets.readme.template.md\n\
     */\n\
        let packageJsonRgx;\n\
        let toc;\n\
        // reset toc\n\
        src = fileDict[\"README.md\"].replace((\n\
            /\\n#\\u0020table\\u0020of\\u0020contents$[\\S\\s]*?\\n\\n\\n/m\n\
        ), \"\\n# table of contents\\n\\n\\n\");\n\
        packageJsonRgx = (\n\
            /\\n#\\u0020package.json\\n```json\\n([\\S\\s]*?)\\n```\\n/\n\
        );\n\
        // render README.md\n\
        tgt = local.templateRenderMyApp(\n\
            local.assetsDict[\"/assets.readme.template.md\"]\n\
        );\n\
        // init packageJson\n\
        src.replace(packageJsonRgx, function (match0, match1) {\n\
            // remove null from package.json\n\
            packageJson = JSON.parse(match1.replace((\n\
                /\\u0020{4}\".*?\":\\u0020null,?$/gm\n\
            ), \"\"));\n\
            packageJson.description = src.split(\"\\n\")[1];\n\
            local.objectAssignDefault(packageJson, {\n\
                nameLib: JSON.parse(fileDict[\"package.json\"]).nameLib\n\
            });\n\
            packageJson = local.objectAssignDefault(packageJson, {\n\
                nameLib: packageJson.name.replace((\n\
                    /\\W/g\n\
                ), \"_\"),\n\
                nameOriginal: packageJson.name\n\
            });\n\
            packageJson = local.objectAssignDefault(\n\
                packageJson,\n\
                JSON.parse(local.templateRenderMyApp(packageJsonRgx.exec(\n\
                    local.assetsDict[\"/assets.readme.template.md\"]\n\
                )[1])),\n\
                2\n\
            );\n\
            // avoid npm-installing that\n\
            delete packageJson.devDependencies[packageJson.name];\n\
            // reset scripts\n\
            packageJson.scripts = {\n\
                \"build-ci\": \"sh npm_scripts.sh\",\n\
                env: \"env\",\n\
                eval: \"sh npm_scripts.sh\",\n\
                \"heroku-postbuild\": \"sh npm_scripts.sh\",\n\
                postinstall: \"sh npm_scripts.sh\",\n\
                start: \"sh npm_scripts.sh\",\n\
                test: \"sh npm_scripts.sh\",\n\
                utility2: \"sh npm_scripts.sh\"\n\
            };\n\
            // write package.json\n\
            require(\"fs\").writeFileSync(\n\
                \"package.json\",\n\
                JSON.stringify(local.objectDeepCopyWithKeysSorted(\n\
                    packageJson\n\
                ), undefined, 4) + \"\\n\"\n\
            );\n\
            writeFileLog(\"package.json\");\n\
            // re-render README.md\n\
            tgt = local.templateRenderMyApp(\n\
                local.assetsDict[\"/assets.readme.template.md\"]\n\
            ).replace(packageJsonRgx, match0.replace(\n\
                match1,\n\
                JSON.stringify(local.objectDeepCopyWithKeysSorted(\n\
                    packageJson\n\
                ), undefined, 4)\n\
            ));\n\
            return \"\";\n\
        });\n\
        tgtReplaceConditional(true, [\n\
            // customize name and description\n\
            {\n\
                merge: (\n\
                    /.*?\\n.*?\\n/\n\
                )\n\
            // customize cdn-download\n\
            }, {\n\
                merge: (\n\
                    /\\n#\\u0020cdn\\u0020download\\n[\\S\\s]*?\\n\\n\\n/\n\
                )\n\
            // customize live-web-demo\n\
            }, {\n\
                merge: (\n\
                    /\\n#\\u0020live\\u0020web\\u0020demo\\n[\\S\\s]*?\\n\\n\\n/\n\
                )\n\
            // customize changelog\n\
            }, {\n\
                merge: (\n\
                    /\\n####\\u0020changelog\\u0020[\\S\\s]*?\\n\\n\\n/\n\
                )\n\
            // customize example.js - shared js\\u002denv code - init-before\n\
            }, {\n\
                merge: (\n\
                    /\\nglobalThis\\.local\\u0020=\\u0020local;\\n[^`]*?\\n\\/\\*\\u0020istanbul\\u0020ignore\\u0020next\\u0020\\*\\/\\n\\/\\/\\u0020run\\u0020browser\\u0020js\\u002denv\\u0020code\\u0020-\\u0020init-test\\n/\n\
                )\n\
            // customize example.js - html-body\n\
            }, {\n\
                merge: (\n\
                    /\\n<!--\\u0020custom-html-start\\u0020-->\\n[\\S\\s]*?\\n<!--\\u0020custom-html-end\\u0020-->\\n/\n\
                )\n\
            // customize build_ci - shCiAfter\n\
            }, {\n\
                merge: (\n\
                    /\\nshCiAfter\\u0020\\(\\)\\u0020\\{\\(set\\u0020-e\\n[\\S\\s]*?\\n\\)\\}\\n/\n\
                )\n\
            // customize build_ci - shCiBefore\n\
            }, {\n\
                merge: (\n\
                    /\\nshCiBefore\\u0020\\(\\)\\u0020\\{\\(set\\u0020-e\\n[\\S\\s]*?\\n\\)\\}\\n/\n\
                )\n\
            }\n\
        ]);\n\
        // customize private-repository\n\
        tgtReplaceConditional(packageJson.private, [\n\
            {\n\
                aa: (\n\
                    /\\n\\[!\\[NPM\\]\\(https:\\/\\/nodei.co\\/npm\\/.*?\\n/\n\
                ),\n\
                bb: \"\"\n\
            }, {\n\
                aa: \"$ npm install \",\n\
                bb: (\n\
                    \"$ git clone \\\\\\n\" +\n\
                    packageJson.repository.url.replace(\n\
                        \"git+https://github.com/\",\n\
                        \"git@github.com:\"\n\
                    ) + \" \\\\\\n--single-branch -b beta node_modules/\"\n\
                )\n\
            }\n\
        ]);\n\
        // customize version\n\
        [\n\
            src, tgt\n\
        ] = [\n\
            src, tgt\n\
        ].map(function (elem) {\n\
            return elem.replace((\n\
                /\\n(####\\u0020changelog\\u0020|-\\u0020npm\\u0020publish\\u0020)\\d+?\\.\\d+?\\.\\d+?.*?\\n/g\n\
            ), \"\\n$1\" + packageJson.version + \"\\n\");\n\
        });\n\
        // customize example.js\n\
        tgtReplaceConditional(local.assetsDict[\n\
            \"/index.html\"\n\
        ].indexOf(\"<script src=\\\"assets.example.js\\\"></script>\") < 0, [\n\
            {\n\
                aa: (\n\
                    /\\nif\\u0020\\(local.isEnvNode\\)\\u0020\\{\\n[\\S\\s]*?\\n\\}\\(\\)\\);\\n/g\n\
                ),\n\
                bb: \"\\nif (local.isEnvNode) {\\n    return;\\n}\\n}());\\n\"\n\
            }\n\
        ]);\n\
        // customize comment\n\
        src.replace((\n\
            /^(\\u0020*?)(?:#\\!\\!\\u0020|#\\/\\/\\u0020|\\/\\/\\!\\!\\u0020|<!--\\u0020)(.*?)(?:\\u0020-->)?$/gm\n\
        ), function (match0, match1, match2) {\n\
            tgt = tgt.replace(\n\
                \"\\n\" + match1 + match2 + \"\\n\",\n\
                \"\\n\" + match0 + \"\\n\"\n\
            );\n\
        });\n\
        // customize - user-defined\n\
        tgtReplaceConditional(true, customizeReadmeList);\n\
        // customize index.html\n\
        tgtReplaceConditional(local.assetsDict[\n\
            \"/index.html\"\n\
        ].indexOf(\"\\\"assets.utility2.template.html\\\"\") < 0, [\n\
            {\n\
                aa: (\n\
                    /\\n\\/\\*\\u0020jslint\\u0020ignore:start\\u0020\\*\\/\\nlocal.assetsDict\\[\"\\/index.html\"\\]\\u0020=\\u0020'\\\\\\n[\\S\\s]*?\\n\\/\\*\\u0020jslint\\u0020ignore:end\\u0020\\*\\/\\n/\n\
                ),\n\
                bb: \"\\n\"\n\
            }\n\
        ]);\n\
        // customize shDeployCustom\n\
        tgtReplaceConditional(src.indexOf(\"    shDeployCustom\\n\") >= 0, [\n\
            {\n\
                // customize example.sh\n\
                merge: (\n\
                    /\\n####\\u0020changelog\\u0020[\\S\\s]*?\\n#\\u0020quickstart\\u0020example.js\\n/\n\
                )\n\
            }, {\n\
                // customize screenshot\n\
                merge: (\n\
                    /\\n#\\u0020quickstart\\u0020[\\S\\s]*?\\n#\\u0020extra\\u0020screenshots\\n/\n\
                )\n\
            }, {\n\
                // customize screenshot\n\
                aa: (\n\
                    /^1\\.\\u0020.*?screenshot\\.(?:npmTest|readmeEvalExampleJs|readmeEvalExampleSh).*?\\.png[\\S\\s]*?\\n\\n/gm\n\
                ),\n\
                bb: \"\"\n\
            }\n\
        ]);\n\
        // customize shNpmTestPublished\n\
        tgt = tgt.replace(\n\
            \"$ npm install \" + GITHUB_FULLNAME + \"#alpha\",\n\
            \"$ npm install \" + packageJson.name\n\
        );\n\
        tgtReplaceConditional(src.indexOf(\"    shNpmTestPublished\\n\") < 0, [\n\
            {\n\
                aa: \"$ npm install \" + packageJson.name,\n\
                bb: \"$ npm install \" + GITHUB_FULLNAME + \"#alpha\"\n\
            }, {\n\
                aa: (\n\
                    /\\n.*?\\bhttps:\\/\\/www.npmjs.com\\/package\\/.*?\\n/\n\
                ),\n\
                bb: \"\"\n\
            }, {\n\
                aa: (\n\
                    /\\n.*?npmPackageDependencyTree.*?\\n/\n\
                ),\n\
                bb: \"\"\n\
            }\n\
        ]);\n\
        // customize shCiAfter and shCiBefore\n\
        [\n\
            [\n\
                \"shDeployGithub\", (\n\
                    /.*?\\/screenshot\\.deployGithub.*?\\n/g\n\
                )\n\
            ], [\n\
                \"shDeployHeroku\", (\n\
                    /.*?\\/screenshot\\.deployHeroku.*?\\n/g\n\
                )\n\
            ], [\n\
                \"shReadmeEval example.js\", (\n\
                    /.*?\\/screenshot\\.readmeEvalExampleJs.*?\\n/g\n\
                )\n\
            ], [\n\
                \"shReadmeEval example.sh\", (\n\
                    /.*?\\/screenshot\\.readmeEvalExampleSh.*?\\n/g\n\
                )\n\
            ], [\n\
                // coverage-hack\n\
                \"__zjqx1234__\" + Math.random(), \"__zjqx1234__\" + Math.random()\n\
            ]\n\
        ].forEach(function ([\n\
            conditional, rgxScreenshot\n\
        ]) {\n\
            if (src.indexOf(\"    \" + conditional + \"\\n\") >= 0) {\n\
                return;\n\
            }\n\
            // customize test-server\n\
            tgt = tgt.replace(\n\
                new RegExp(\n\
                    \"\\\\n\\\\| test-server-\" +\n\
                    conditional.replace(\"shDeploy\", \"\").toLowerCase() +\n\
                    \" : \\\\|.*?\\\\n\"\n\
                ),\n\
                \"\\n\"\n\
            );\n\
            // customize screenshot\n\
            tgt = tgt.replace(rgxScreenshot, \"\");\n\
        });\n\
        tgt = local.templateRenderMyApp(tgt);\n\
        // customize toc\n\
        toc = \"\\n# table of contents\\n\";\n\
        tgt.replace((\n\
            /\\n\\n\\n#\\u0020(.*)/g\n\
        ), function (ignore, match1) {\n\
            if (match1 === \"table of contents\") {\n\
                return;\n\
            }\n\
            toc += \"1. [\" + match1 + \"](#\" + match1.toLowerCase().replace((\n\
                /[^\\u0020\\-0-9A-Z_a-z]/g\n\
            ), \"\").replace((\n\
                /\\u0020/g\n\
            ), \"-\") + \")\\n\";\n\
        });\n\
        tgt = tgt.replace(\"\\n# table of contents\\n\", toc);\n\
        // eslint - no-multiple-empty-lines\n\
        // https://github.com/eslint/eslint/blob/v7.2.0/docs/rules/no-multiple-empty-lines.md\n\
        tgt = tgt.replace((\n\
            /\\n{4,}/g\n\
        ), \"\\n\\n\\n\");\n\
        // write README.md\n\
        writeFile(\"README.md\", tgt, resolve);\n\
    }\n\
    function buildTest(resolve) {\n\
        src = fileDict[\"test.js\"];\n\
        // render test.js\n\
        tgt = local.templateRenderMyApp(\n\
            local.assetsDict[\"/assets.test.template.js\"]\n\
        );\n\
        // customize shared js\\u002denv code - function\n\
        tgtReplaceConditional(true, [\n\
            {\n\
                merge: (\n\
                    /\\n\\}\\(\\)\\);\\n\\n\\n\\/\\/\\u0020run\\u0020shared\\u0020js\\u002denv\\u0020code\\u0020-\\u0020function\\n[\\S\\s]*?$/\n\
                )\n\
            }\n\
        ]);\n\
        // customize require(\"utility2\")\n\
        Array.from([\n\
            \"assets.utility2.rollup.js\",\n\
            \"lib.utility2.js\"\n\
        ]).some(function (file) {\n\
            if (fileDict[file]) {\n\
                tgt = tgt.replace(\n\
                    \"require(\\\"utility2\\\")\",\n\
                    \"require(\\\"./\" + file + \"\\\")\"\n\
                );\n\
                return true;\n\
            }\n\
        });\n\
        // write test.js\n\
        writeFile(\"test.js\", tgt, resolve);\n\
    }\n\
    // buildInit\n\
    Promise.resolve().then(function () {\n\
        // init packageJson\n\
        packageJson = JSON.parse(\n\
            require(\"fs\").readFileSync(\"package.json\", \"utf8\")\n\
        );\n\
        // init packageNameLib\n\
        packageNameLib = packageJson.nameLib || packageJson.name;\n\
        fileDict = {};\n\
        promiseList = [];\n\
        // cleanup build-dir\n\
        promiseList.push(new Promise(function (resolve) {\n\
            require(\"child_process\").spawn((\n\
                \"for DIR in .tmp/build/app/ .tmp/build/app.standalone/;\" +\n\
                \"do rm -rf $DIR; mkdir -p $DIR; done\"\n\
            ), {\n\
                shell: true,\n\
                stdio: [\n\
                    \"ignore\", 1, 2\n\
                ]\n\
            }).on(\"exit\", resolve);\n\
        }));\n\
        // init port\n\
        promiseList.push(new Promise(function (resolve) {\n\
            let server;\n\
            function recurse(err) {\n\
                if (server) {\n\
                    server.close();\n\
                }\n\
                if (!err) {\n\
                    resolve();\n\
                    return;\n\
                }\n\
                port = (\n\
                    \"0x\" + require(\"crypto\").randomBytes(2).toString(\"hex\")\n\
                ) | 0x8000;\n\
                server = require(\"net\").createServer().listen(port);\n\
                server.on(\"error\", recurse).on(\"listening\", recurse);\n\
            }\n\
            recurse(true);\n\
        }));\n\
        // read file\n\
        [\n\
            \"README.md\",\n\
            \"lib.\" + packageNameLib + \".js\",\n\
            \"package.json\",\n\
            \"test.js\"\n\
        ].forEach(function (file) {\n\
            promiseList.push(new Promise(function (resolve) {\n\
                require(\"fs\").readFile(file, \"utf8\", function (err, data) {\n\
                    fileDict[file] = data;\n\
                    resolve(err);\n\
                });\n\
            }));\n\
        });\n\
        // exists file\n\
        [\n\
            \"assets.utility2.rollup.js\",\n\
            \"lib.utility2.js\"\n\
        ].forEach(function (file) {\n\
            promiseList.push(new Promise(function (resolve) {\n\
                require(\"fs\").access(file, function (notExists) {\n\
                    fileDict[file] = !notExists;\n\
                    resolve();\n\
                });\n\
            }));\n\
        });\n\
        return Promise.all(promiseList);\n\
    }).then(function (errList) {\n\
        errList.forEach(onErrorThrow);\n\
        promiseList = [];\n\
        promiseList.push(new Promise(buildReadme));\n\
        promiseList.push(new Promise(buildLib));\n\
        promiseList.push(new Promise(buildTest));\n\
        return Promise.all(promiseList);\n\
    }).then(function (errList) {\n\
        errList.forEach(onErrorThrow);\n\
        promiseList = [];\n\
        promiseList.push(new Promise(buildAppAssets));\n\
        promiseList.push(new Promise(buildAppStandalone));\n\
        return Promise.all(promiseList);\n\
    }).then(function (errList) {\n\
        errList.forEach(onErrorThrow);\n\
        onError();\n\
    });\n\
};\n\
\n\
local.chromeDevtoolsClientCreate = async function ({\n\
    chromeBin,\n\
    modeCoverageHack,\n\
    modeSilent,\n\
    modeWindowSize = \"800x600\",\n\
    processPlatform,\n\
    timeout\n\
}) {\n\
/*\n\
 * this function with create chrome-devtools-client from <chromeBin>\n\
 */\n\
    let WS_READ_HEADER;\n\
    let WS_READ_LENGTH16;\n\
    let WS_READ_LENGTH63;\n\
    let WS_READ_PAYLOAD;\n\
    let assert;\n\
    let callbackDict;\n\
    let callbackId;\n\
    let chromeClient;\n\
    let chromeProcess;\n\
    let chromeSessionId;\n\
    let chromeUserDataDir;\n\
    let secWebsocketKey;\n\
    let timerTimeout;\n\
    let websocket;\n\
    let websocketUrl;\n\
    let wsBufList;\n\
    let wsPayloadLength;\n\
    let wsReadState;\n\
    let wsReader;\n\
    if (modeCoverageHack === 1) {\n\
        [\n\
            \"darwin\", \"linux\", \"win32\"\n\
        ].forEach(function (processPlatform) {\n\
            local.chromeDevtoolsClientCreate({\n\
                modeCoverageHack: 2,\n\
                processPlatform\n\
            }).catch(noop);\n\
        });\n\
        return;\n\
    }\n\
    WS_READ_HEADER = 0;\n\
    WS_READ_LENGTH16 = 1;\n\
    WS_READ_LENGTH63 = 2;\n\
    WS_READ_PAYLOAD = 3;\n\
    assert = require(\"assert\");\n\
    callbackDict = {};\n\
    callbackId = 0;\n\
    wsBufList = [];\n\
    wsPayloadLength = 0;\n\
    wsReadState = WS_READ_HEADER;\n\
    function chromeCleanup() {\n\
    /*\n\
     * this function will\n\
     * 1. kill <chromeProcess>\n\
     * 2. rm -rf <chromeUserDataDir>\n\
     * 3. destroy <chromeClient>, <websocket>, <wsReader>\n\
     */\n\
        // cleanup timerTimeout\n\
        clearTimeout(timerTimeout);\n\
        // 1. kill <chromeProcess>\n\
        try {\n\
            if (processPlatform === \"win32\") {\n\
                require(\"child_process\").spawnSync(\"taskkill\", [\n\
                    \"/pid\", chromeProcess.pid, \"/T\", \"/F\"\n\
                ], {\n\
                    stdio: \"ignore\"\n\
                });\n\
            } else {\n\
                // kill child process tree with \".kill(-pid)\" cmd.\n\
                process.kill(-chromeProcess.pid, \"SIGKILL\");\n\
            }\n\
        } catch (ignore) {}\n\
        // 2. rm -rf <chromeUserDataDir>\n\
        if (chromeUserDataDir) {\n\
            require(\"fs\").rmdirSync(chromeUserDataDir, {\n\
                recursive: true\n\
            });\n\
        }\n\
        // 3. destroy <chromeClient>, <websocket>, <wsReader>\n\
        chromeClient.destroy();\n\
        if (websocket) {\n\
            websocket.destroy();\n\
        }\n\
        wsReader.destroy();\n\
    }\n\
    async function chromeEvaluate(expression) {\n\
    /*\n\
     * this function will eval <expression> in chrome-browser\n\
     */\n\
        let {\n\
            exceptionDetails,\n\
            result\n\
        } = await chromeClient.rpc(\"Runtime.evaluate\", {\n\
            awaitPromise: true,\n\
            expression,\n\
            returnByValue: false,\n\
            userGesture: true\n\
        });\n\
        assert.ok(!exceptionDetails, (\n\
            \"chrome-devtools - evaluate - \" +\n\
            JSON.stringify(exceptionDetails)\n\
        ));\n\
        return result.value;\n\
    }\n\
    function chromeOnData(payload) {\n\
    /*\n\
     * this function will handle callback for <payload>\n\
     * received from chrome-browser using chrome-devtools-protocol\n\
     */\n\
        // console.error(\"\\u25c0 RECV \" + payload.slice(0, 256).toString());\n\
        let callback;\n\
        let {\n\
            error,\n\
            id,\n\
            method,\n\
            params,\n\
            result\n\
        } = JSON.parse(payload);\n\
        assert.ok(!method || (\n\
            /^[A-Z]\\w*?\\.[a-z]\\w*?$/\n\
        ).test(method), \"chrome-devtools - read - invalid method \" + method);\n\
        // init callback\n\
        callback = callbackDict[id];\n\
        delete callbackDict[id];\n\
        // callback.resolve\n\
        if (callback) {\n\
            // preserve stack-trace\n\
            callback.err.message = (\n\
                \"chrome-devtools - read - \" + JSON.stringify(error)\n\
            );\n\
            assert.ok(!error, callback.err);\n\
            callback.resolve(result);\n\
            return;\n\
        }\n\
        assert.ok(!error, \"chrome-devtools - read - \" + JSON.stringify(error));\n\
        chromeClient.emit(method, params);\n\
    }\n\
    function chromeRead() {\n\
    /*\n\
     * this function will implement stream.Duplex.prototype._read\n\
     */\n\
        if (websocket && websocket.readable) {\n\
            websocket.resume();\n\
        }\n\
    }\n\
    function chromeRpc(method, params) {\n\
    /*\n\
     * this function will message-pass\n\
     * JSON.stringify({\n\
     *     id: <callbackId>,\n\
     *     method: <method>,\n\
     *     params: <params>,\n\
     *     sessionId: <chromeSessionId>\n\
     * })\n\
     * to chrome-browser using chrome-devtools-protocol\n\
     */\n\
        callbackId = (callbackId % 256) + 1;\n\
        chromeClient.write(Buffer.from(JSON.stringify({\n\
            id: callbackId,\n\
            method,\n\
            params,\n\
            sessionId: (\n\
                typeof chromeSessionId === \"string\"\n\
                ? chromeSessionId\n\
                : undefined\n\
            )\n\
        })));\n\
        return new Promise(function (resolve) {\n\
            callbackDict[callbackId] = {\n\
                err: new Error(),\n\
                method,\n\
                resolve\n\
            };\n\
        });\n\
    }\n\
    function chromeWrite(payload, ignore, callback) {\n\
    /*\n\
     * this function will implement stream.Duplex.prototype._write\n\
     */\n\
        // console.error(\"SEND \\u25ba \" + payload.slice(0, 256).toString());\n\
        let header;\n\
        let maskKey;\n\
        let result;\n\
        // init header\n\
        header = Buffer.alloc(2 + 8 + 4);\n\
        // init fin = true\n\
        header[0] |= 0x80;\n\
        // init opcode = text-frame\n\
        header[0] |= 1;\n\
        // init mask = true\n\
        header[1] |= 0x80;\n\
        // init payload.length\n\
        if (payload.length < 126) {\n\
            header = header.slice(0, 2 + 0 + 4);\n\
            header[1] |= payload.length;\n\
        // } else if (payload.length < 65536) {\n\
        } else {\n\
            assert.ok(payload.length < 65536, (\n\
                \"chrome-devtools - write - \" +\n\
                \"payload-length must be less than 65536 bytes, not \" +\n\
                payload.length\n\
            ));\n\
            header = header.slice(0, 2 + 2 + 4);\n\
            header[1] |= 126;\n\
            header.writeUInt16BE(payload.length, 2);\n\
        /*\n\
        } else {\n\
            header[1] |= 127;\n\
            header.writeUInt32BE(payload.length, 6);\n\
        */\n\
        }\n\
        // init maskKey\n\
        maskKey = require(\"crypto\").randomBytes(4);\n\
        maskKey.copy(header, header.length - 4);\n\
        // send header\n\
        websocket.cork();\n\
        websocket.write(header);\n\
        // send payload ^ maskKey\n\
        payload.forEach(function (ignore, ii) {\n\
            payload[ii] ^= maskKey[ii & 3];\n\
        });\n\
        // return write-result\n\
        result = websocket.write(payload, callback);\n\
        websocket.uncork();\n\
        return result;\n\
    }\n\
    function wsBufListRead(nn) {\n\
    /*\n\
     * this function will read <nn> bytes from <wsBufList>\n\
     */\n\
        let buf;\n\
        wsBufList = (\n\
            wsBufList.length === 1\n\
            ? wsBufList[0]\n\
            : Buffer.concat(wsBufList)\n\
        );\n\
        buf = wsBufList.slice(0, nn);\n\
        wsBufList = [\n\
            wsBufList.slice(nn)\n\
        ];\n\
        return buf;\n\
    }\n\
    function wsFrameRead() {\n\
    /*\n\
     * this function will read websocket-data-frame\n\
     */\n\
        let buf;\n\
        let opcode;\n\
        if (wsBufList.reduce(function (aa, bb) {\n\
            return aa + bb.length;\n\
        }, 0) < (\n\
            wsReadState === WS_READ_PAYLOAD\n\
            ? Math.max(wsPayloadLength, 1)\n\
            : wsReadState === WS_READ_LENGTH63\n\
            ? 8\n\
            : 2\n\
        )) {\n\
            return;\n\
        }\n\
        switch (wsReadState) {\n\
        // read frame-header\n\
        case WS_READ_HEADER:\n\
            buf = wsBufListRead(2);\n\
            // validate opcode\n\
            opcode = buf[0] & 0x0f;\n\
            assert.ok(opcode === 0x01, (\n\
                \"chrome-devtools - read - opcode must be 0x01, not 0x0\" +\n\
                opcode.toString(16)\n\
            ));\n\
            wsPayloadLength = buf[1] & 0x7f;\n\
            wsReadState = (\n\
                wsPayloadLength === 126\n\
                ? WS_READ_LENGTH16\n\
                : wsPayloadLength === 127\n\
                ? WS_READ_LENGTH63\n\
                : WS_READ_PAYLOAD\n\
            );\n\
            break;\n\
        // read frame-payload-length-16\n\
        case WS_READ_LENGTH16:\n\
            wsPayloadLength = wsBufListRead(2).readUInt16BE(0);\n\
            wsReadState = WS_READ_PAYLOAD;\n\
            break;\n\
        // read frame-payload-length-63\n\
        case WS_READ_LENGTH63:\n\
            buf = wsBufListRead(8);\n\
            wsPayloadLength = (\n\
                buf.readUInt32BE(0) * 0x100000000 + buf.readUInt32BE(4)\n\
            );\n\
            wsReadState = WS_READ_PAYLOAD;\n\
            break;\n\
        // read frame-payload-data\n\
        case WS_READ_PAYLOAD:\n\
            assert.ok((\n\
                0 <= wsPayloadLength && wsPayloadLength <= 10000000\n\
            ), (\n\
                \"chrome-devtools - read - \" +\n\
                \"payload-length must be between 0 and 256 MiB, not \" +\n\
                wsPayloadLength\n\
            ));\n\
            buf = wsBufListRead(wsPayloadLength);\n\
            wsReadState = WS_READ_HEADER;\n\
            chromeClient.push(buf);\n\
            break;\n\
        }\n\
        return true;\n\
    }\n\
    function wsReaderTransform(chunk, ignore, callback) {\n\
    /*\n\
     * this function will implement Transform.prototype._transform\n\
     */\n\
        wsBufList.push(chunk);\n\
        while (true) {\n\
            if (!wsFrameRead()) {\n\
                break;\n\
            }\n\
        }\n\
        callback();\n\
    }\n\
    // init chromeClient\n\
    function ChromeClient() {\n\
    /*\n\
     * this function will construct <chromeClient>\n\
     */\n\
        chromeClient = this;\n\
        require(\"util\").inherits(ChromeClient, require(\"stream\").Duplex);\n\
        require(\"stream\").Duplex.call(chromeClient);\n\
        Object.assign(chromeClient.__proto__, {\n\
            _destroy: chromeCleanup,\n\
            _read: chromeRead,\n\
            _write: chromeWrite,\n\
            evaluate: chromeEvaluate,\n\
            rpc: chromeRpc\n\
        });\n\
        chromeClient.on(\"data\", chromeOnData);\n\
    }\n\
    chromeClient = new ChromeClient();\n\
/*\n\
https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-13#section-5.2\n\
+---------------------------------------------------------------+\n\
|0               1               2               3              |\n\
|0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f|\n\
+-+-+-+-+-------+-+-------------+-------------------------------+\n\
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n\
|I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |\n\
|N|V|V|V|       |S|             |   (if payload len==126/127)   |\n\
| |1|2|3|       |K|             |                               |\n\
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n\
|     Extended payload length continued, if payload len == 127  |\n\
+ - - - - - - - - - - - - - - - +-------------------------------+\n\
|                               |Masking-key, if MASK set to 1  |\n\
+-------------------------------+-------------------------------+\n\
| Masking-key (continued)       |          Payload Data         |\n\
+-------------------------------- - - - - - - - - - - - - - - - +\n\
:                     Payload Data continued ...                :\n\
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n\
|                     Payload Data continued ...                |\n\
+---------------------------------------------------------------+\n\
FIN: 1 bit\n\
    Indicates that this is the final fragment in a message.  The first\n\
    fragment MAY also be the final fragment.\n\
RSV1, RSV2, RSV3: 1 bit each\n\
    MUST be 0 unless an extension is negotiated which defines meanings\n\
    for non-zero values.  If a nonzero value is received and none of\n\
    the negotiated extensions defines the meaning of such a nonzero\n\
    value, the receiving endpoint MUST _Fail the WebSocket\n\
    Connection_.\n\
Opcode: 4 bits\n\
    Defines the interpretation of the payload data.  If an unknown\n\
    opcode is received, the receiving endpoint MUST _Fail the\n\
    WebSocket Connection_.  The following values are defined.\n\
    *  %x0 denotes a continuation frame\n\
    *  %x1 denotes a text frame\n\
    *  %x2 denotes a binary frame\n\
    *  %x3-7 are reserved for further non-control frames\n\
    *  %x8 denotes a connection close\n\
    *  %x9 denotes a ping\n\
    *  %xA denotes a pong\n\
    *  %xB-F are reserved for further control frames\n\
Mask: 1 bit\n\
    Defines whether the payload data is masked.  If set to 1, a\n\
    masking key is present in masking-key, and this is used to unmask\n\
    the payload data as per Section 5.3.  All frames sent from client\n\
    to server have this bit set to 1.\n\
Payload length: 7 bits, 7+16 bits, or 7+64 bits\n\
    The length of the payload data, in bytes: if 0-125, that is the\n\
    payload length.  If 126, the following 2 bytes interpreted as a 16\n\
    bit unsigned integer are the payload length.  If 127, the\n\
    following 8 bytes interpreted as a 64-bit unsigned integer (the\n\
    most significant bit MUST be 0) are the payload length.  Multibyte\n\
    length quantities are expressed in network byte order.  The\n\
    payload length is the length of the extension data + the length of\n\
    the application data.  The length of the extension data may be\n\
    zero, in which case the payload length is the length of the\n\
    application data.\n\
Masking-key: 0 or 4 bytes\n\
    All frames sent from the client to the server are masked by a 32-\n\
    bit value that is contained within the frame.  This field is\n\
    present if the mask bit is set to 1, and is absent if the mask bit\n\
    is set to 0.  See Section 5.3 for further information on client-\n\
    to-server masking.\n\
Payload data: (x+y) bytes\n\
    The payload data is defined as extension data concatenated with\n\
    application data.\n\
Extension data: x bytes\n\
    The extension data is 0 bytes unless an extension has been\n\
    negotiated.  Any extension MUST specify the length of the\n\
    extension data, or how that length may be calculated, and how the\n\
    extension use MUST be negotiated during the opening handshake.  If\n\
    present, the extension data is included in the total payload\n\
    length.\n\
Application data: y bytes\n\
    Arbitrary application data, taking up the remainder of the frame\n\
    after any extension data.  The length of the application data is\n\
    equal to the payload length minus the length of the extension\n\
    data.\n\
*/\n\
    // init wsReader that can read websocket-frames from websocket\n\
    function WsReader() {\n\
    /*\n\
     * this function will construct <wsReader>\n\
     */\n\
        wsReader = this;\n\
        require(\"util\").inherits(WsReader, require(\"stream\").Transform);\n\
        require(\"stream\").Transform.call(wsReader);\n\
        Object.assign(wsReader.__proto__, {\n\
            _transform: wsReaderTransform\n\
        });\n\
    }\n\
    wsReader = new WsReader();\n\
    // init chromeProcess\n\
    processPlatform = processPlatform || process.platform;\n\
    chromeUserDataDir = await require(\"fs\").promises.mkdtemp(\n\
        require(\"path\").join(require(\"os\").tmpdir(), \"puppeteer_dev_profile-\")\n\
    );\n\
    chromeBin = chromeBin || (\n\
        processPlatform === \"darwin\"\n\
        ? \"/Applications/Google Chrome.app/Contents/MacOS/\" +\n\
        \"Google Chrome\"\n\
        : processPlatform === \"win32\"\n\
        ? \"C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\\" +\n\
        \"chrome.exe\"\n\
        : \"/usr/bin/google-chrome-stable\"\n\
    );\n\
    console.error(\"chrome-devtools - spawning - \" + chromeBin);\n\
    chromeProcess = require(\"child_process\").spawn((\n\
        chromeBin\n\
    ), [\n\
        \"--headless\",\n\
        \"--incognito\",\n\
        \"--remote-debugging-port=0\",\n\
        \"--user-data-dir=\" + chromeUserDataDir,\n\
        \"--window-size=\" + modeWindowSize,\n\
        Array.from([\n\
            \"\", \"--no-sandbox\"\n\
        ])[(process.getuid && process.getuid() === 0) | 0]\n\
    ], {\n\
        // On non-windows platforms, `detached: false` makes child process\n\
        // a leader of a new process group, making it possible to kill\n\
        // child process tree with `.kill(-pid)` cmd.\n\
        // https://nodejs.org/api/child_process.html#child_process_options_detached\n\
        detached: process.platform !== \"win32\",\n\
        stdio: [\n\
            \"ignore\", (\n\
                !modeSilent\n\
                ? 1\n\
                : \"ignore\"\n\
            ), \"pipe\"\n\
        ]\n\
    });\n\
    if (!modeSilent) {\n\
        chromeProcess.stderr.pipe(process.stderr, {\n\
            end: false\n\
        });\n\
    }\n\
    process.on(\"exit\", chromeCleanup);\n\
    process.on(\"SIGINT\", chromeCleanup);\n\
    process.on(\"SIGTERM\", chromeCleanup);\n\
    process.on(\"SIGHUP\", chromeCleanup);\n\
    // init timerTimeout\n\
    timeout = timeout || 30000;\n\
    if (modeCoverageHack === 2) {\n\
        chromeClient.on(\"error\", noop);\n\
        chromeProcess.on(\"error\", noop);\n\
        timeout = 0;\n\
    }\n\
    timerTimeout = setTimeout(function () {\n\
        chromeCleanup();\n\
        chromeClient.emit(\"error\", new Error(\n\
            \"chrome-devtools - timeout - \" + timeout + \" ms\"\n\
        ));\n\
    }, timeout);\n\
    // init websocketUrl\n\
    websocketUrl = await new Promise(function (resolve) {\n\
        let stderr;\n\
        stderr = \"\";\n\
        chromeProcess.stderr.on(\"data\", function onData(chunk) {\n\
            assert.ok(\n\
                stderr.length < 65536,\n\
                \"chrome-devtools - connecting - cannot connect to chrome\"\n\
            );\n\
            stderr += chunk;\n\
            stderr.replace((\n\
                /^DevTools\\u0020listening\\u0020on\\u0020(ws:\\/\\/.*)$/m\n\
            ), function (ignore, url) {\n\
                chromeProcess.stderr.removeListener(\"data\", onData);\n\
                resolve(url);\n\
                return \"\";\n\
            });\n\
        });\n\
    });\n\
    // init websocket\n\
    console.error(\"chrome-devtools - connecting - \" + websocketUrl);\n\
    secWebsocketKey = require(\"crypto\").randomBytes(16).toString(\"base64\");\n\
    await new Promise(function (resolve) {\n\
        require(\"http\").get((\n\
            websocketUrl\n\
        ), {\n\
            createConnection: function (opt) {\n\
                delete opt.path;\n\
                return require(\"net\").connect(opt);\n\
            },\n\
            headers: {\n\
                Connection: \"Upgrade\",\n\
                \"Sec-WebSocket-Key\": secWebsocketKey,\n\
                \"Sec-WebSocket-Version\": 13,\n\
                Upgrade: \"websocket\"\n\
            },\n\
            protocol: \"http:\",\n\
            protocolVersion: 13\n\
        }).once(\"upgrade\", function (res, _, head) {\n\
            assert.ok((\n\
                res.headers[\n\
                    \"sec-websocket-accept\"\n\
                ] === require(\"crypto\").createHash(\"sha1\").update(\n\
                    secWebsocketKey +\n\
                    \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\
                ).digest(\"base64\")\n\
            ), (\n\
                \"chrome-devtools - connecting - \" +\n\
                \"invalid header sec-websocket-accept\"\n\
            ));\n\
            websocket = _;\n\
            websocket.unshift(head);\n\
            // websocket - disable timeout\n\
            websocket.setTimeout(0);\n\
            // websocket - disable nagle's algorithm\n\
            websocket.setNoDelay();\n\
            websocket.on(\"end\", websocket.end.bind(websocket));\n\
            // pipe websocket to wsReader\n\
            websocket.pipe(wsReader);\n\
            resolve();\n\
        });\n\
    });\n\
    // init chromeSessionId\n\
    chromeSessionId = await chromeClient.rpc(\"Target.createTarget\", {\n\
        url: \"about:blank\"\n\
    });\n\
    chromeSessionId = await chromeClient.rpc(\"Target.attachToTarget\", {\n\
        targetId: chromeSessionId.targetId,\n\
        flatten: true\n\
    });\n\
    chromeSessionId = chromeSessionId.sessionId;\n\
    console.error(\"chrome-devtools - created - blank-page with sessionId\");\n\
    return chromeClient;\n\
};\n\
\n\
local.cliRun = function ({\n\
    rgxComment\n\
}) {\n\
/*\n\
 * this function will run cli\n\
 */\n\
    let {\n\
        _default,\n\
        _eval,\n\
        _help,\n\
        _interactive,\n\
        _version,\n\
        cliDict,\n\
        replStart\n\
    } = Object.assign({}, local, local.cliDict);\n\
    _eval = _eval || function () {\n\
    /*\n\
     * <code>\n\
     * will eval <code>\n\
     */\n\
        Object.assign(globalThis, local);\n\
        require(\"vm\").runInThisContext(process.argv[3]);\n\
    };\n\
    _help = _help || function () {\n\
    /*\n\
     *\n\
     * will print help\n\
     */\n\
        let cmdList;\n\
        let file;\n\
        let packageJson;\n\
        let str;\n\
        let strDict;\n\
        cmdList = [\n\
            {\n\
                argList: \"<arg2>  ...\",\n\
                description: \"usage:\",\n\
                cmd: [\n\
                    \"<arg1>\"\n\
                ]\n\
            }, {\n\
                argList: \"'console.log(\\\"hello world\\\")'\",\n\
                description: \"example:\",\n\
                cmd: [\n\
                    \"--eval\"\n\
                ]\n\
            }\n\
        ];\n\
        file = __filename.replace((\n\
            /.*\\//\n\
        ), \"\");\n\
        packageJson = require(\"./package.json\");\n\
        // validate comment\n\
        rgxComment = rgxComment || (\n\
            /\\)\\u0020\\{\\n(?:|\\u0020{4})\\/\\*\\n(?:\\u0020|\\u0020{5})\\*((?:\\u0020<[^>]*?>|\\u0020\\.\\.\\.)*?)\\n(?:\\u0020|\\u0020{5})\\*\\u0020(will\\u0020.*?\\S)\\n(?:\\u0020|\\u0020{5})\\*\\/\\n(?:\\u0020{4}|\\u0020{8})\\S/\n\
        );\n\
        strDict = {};\n\
        Object.keys(cliDict).sort().forEach(function (key, ii) {\n\
            if (key[0] === \"_\" && key !== \"_default\") {\n\
                return;\n\
            }\n\
            str = String(cliDict[key]);\n\
            if (key === \"_default\") {\n\
                key = \"\";\n\
            }\n\
            strDict[str] = strDict[str] || (ii + 2);\n\
            ii = strDict[str];\n\
            if (cmdList[ii]) {\n\
                cmdList[ii].cmd.push(key);\n\
                return;\n\
            }\n\
            cmdList[ii] = rgxComment.exec(str);\n\
            if (!cmdList[ii]) {\n\
                throw new Error(\n\
                    \"cliRun - cannot parse comment in cmd \" +\n\
                    key + \":\\nnew RegExp(\" +\n\
                    JSON.stringify(rgxComment.source) +\n\
                    \").exec(\" + JSON.stringify(str).replace((\n\
                        /\\\\\\\\/g\n\
                    ), \"\\u0000\").replace((\n\
                        /\\\\n/g\n\
                    ), \"\\\\n\\\\\\n\").replace((\n\
                        /\\u0000/g\n\
                    ), \"\\\\\\\\\") + \");\"\n\
                );\n\
            }\n\
            cmdList[ii] = {\n\
                argList: String(cmdList[ii][1] || \"\").trim(),\n\
                cmd: [\n\
                    key\n\
                ],\n\
                description: cmdList[ii][2]\n\
            };\n\
        });\n\
        str = \"\";\n\
        str += packageJson.name + \" (\" + packageJson.version + \")\\n\\n\";\n\
        str += cmdList.filter(function (elem) {\n\
            return elem;\n\
        }).map(function (elem, ii) {\n\
            elem.cmd = elem.cmd.filter(function (elem) {\n\
                return elem;\n\
            });\n\
            switch (ii) {\n\
            case 0:\n\
            case 1:\n\
                elem.argList = [\n\
                    elem.argList\n\
                ];\n\
                break;\n\
            default:\n\
                elem.argList = elem.argList.split(\" \");\n\
                elem.description = (\n\
                    \"# CMD \" +\n\
                    (elem.cmd[0] || \"<none>\") + \"\\n# \" +\n\
                    elem.description\n\
                );\n\
            }\n\
            return (\n\
                elem.description + \"\\n  \" + file +\n\
                \"  \" + elem.cmd.sort().join(\"|\") + \"  \" +\n\
                elem.argList.join(\"  \")\n\
            );\n\
        }).join(\"\\n\\n\");\n\
        console.log(str);\n\
    };\n\
    _interactive = _interactive || function () {\n\
    /*\n\
     *\n\
     * will start interactive-mode\n\
     */\n\
        Object.assign(globalThis, local);\n\
        replStart = replStart || require(\"repl\").start;\n\
        replStart({\n\
            useGlobal: true\n\
        });\n\
    };\n\
    _version = _version || function () {\n\
    /*\n\
     *\n\
     * will print version\n\
     */\n\
        console.log(require(__dirname + \"/package.json\").version);\n\
    };\n\
    _default = _default || _help;\n\
    Object.assign(cliDict, {\n\
        \"--eval\": _eval,\n\
        \"--help\": _help,\n\
        \"--interactive\": _interactive,\n\
        \"--version\": _version,\n\
        \"-e\": _eval,\n\
        \"-h\": _help,\n\
        \"-i\": _interactive,\n\
        \"-v\": _version,\n\
        _default,\n\
        _eval,\n\
        _help,\n\
        _interactive,\n\
        _version\n\
    });\n\
    // run help-cmd if no arguments are given\n\
    if (process.argv.length <= 2) {\n\
        _help();\n\
        return;\n\
    }\n\
    // run defined-cmd if it exists\n\
    if (cliDict[process.argv[2]]) {\n\
        cliDict[process.argv[2]]();\n\
        return;\n\
    }\n\
    // run default-cmd\n\
    _default();\n\
};\n\
\n\
local.domQuerySelectorAllTagName = function (selector) {\n\
/*\n\
 * this function will return list of tagName matching <selector>\n\
 */\n\
    let dict;\n\
    dict = {};\n\
    documentQuerySelectorAll(selector).forEach(function (elem) {\n\
        dict[elem.tagName] = true;\n\
    });\n\
    return Object.keys(dict).sort();\n\
};\n\
\n\
local.domStyleValidate = function () {\n\
/*\n\
 * this function will validate <style> tags\n\
 */\n\
    let list;\n\
    let rgx;\n\
    rgx = (\n\
        /^0\\u0020(?:(body\\u0020>\\u0020)?(?:\\.test-report-div\\u0020.+|\\.x-istanbul\\u0020.+|\\.button|\\.colorError|\\.readonly|\\.textarea|\\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\\u0020\\{))|^[1-9]\\d*?\\u0020#/m\n\
    );\n\
    list = [];\n\
    documentQuerySelectorAll(\"style\").forEach(function (elem, ii) {\n\
        elem.innerHTML.replace((\n\
            /\\/\\*[\\S\\s]*?\\*\\/|;|\\}/g\n\
        ), \"\\n\").replace((\n\
            /^([^\\n\\u0020@].*?)[,{:].*?$/gm\n\
        ), function (match0, match1) {\n\
            try {\n\
                ii = document.querySelectorAll(match1).length;\n\
            } catch (errCaught) {\n\
                console.error(errCaught);\n\
            }\n\
            if (!(ii > 1) && !rgx.test(elem)) {\n\
                list.push(ii + \" \" + match0);\n\
            }\n\
        });\n\
    });\n\
    list.filter(function (elem) {\n\
        return !rgx.test(elem);\n\
    }).sort().reverse().forEach(function (elem, ii, list) {\n\
        console.error(\n\
            \"domStyleValidateUnmatched \" + (list.length - ii) + \". \" + elem\n\
        );\n\
    });\n\
};\n\
\n\
local.eventListenerAdd = function (type, {\n\
    once\n\
}, listener) {\n\
/*\n\
 * this function will listen evt <type> with <listener>\n\
 */\n\
    localEventListenerId = (localEventListenerId + 1) | 0;\n\
    localEventListenerDict[localEventListenerId] = {\n\
        listener,\n\
        once,\n\
        type\n\
    };\n\
};\n\
\n\
local.eventListenerEmit = function (type, msg) {\n\
/*\n\
 * this function will emit evt <type> with <msg>\n\
 */\n\
    Object.entries(localEventListenerDict).forEach(function ([\n\
        id, elem\n\
    ]) {\n\
        if (elem.type === type) {\n\
            if (elem.once) {\n\
                delete localEventListenerDict[id];\n\
            }\n\
            elem.listener({\n\
                msg,\n\
                type\n\
            });\n\
        }\n\
    });\n\
};\n\
\n\
local.eventListenerRemove = function (listener) {\n\
/*\n\
 * this function will emit evt <type> with <msg>\n\
 */\n\
    Object.entries(localEventListenerDict).forEach(function ([\n\
        id, elem\n\
    ]) {\n\
        if (elem.listener === listener) {\n\
            delete localEventListenerDict[id];\n\
        }\n\
    });\n\
};\n\
\n\
local.fsReadFileOrDefaultSync = function (pathname, type, dflt) {\n\
/*\n\
 * this function will sync-read <pathname> with given <type> and <dflt>\n\
 */\n\
    let fs;\n\
    // do nothing if module does not exist\n\
    try {\n\
        fs = require(\"fs\");\n\
        pathname = require(\"path\").resolve(pathname);\n\
    } catch (ignore) {\n\
        return dflt;\n\
    }\n\
    // try to read pathname\n\
    try {\n\
        return (\n\
            type === \"json\"\n\
            ? JSON.parse(fs.readFileSync(pathname, \"utf8\"))\n\
            : fs.readFileSync(pathname, type)\n\
        );\n\
    } catch (ignore) {\n\
        return dflt;\n\
    }\n\
};\n\
\n\
local.fsWriteFileWithMkdirpSync = function (pathname, data) {\n\
/*\n\
 * this function will sync write <data> to <pathname> with \"mkdir -p\"\n\
 */\n\
    let fs;\n\
    // do nothing if module does not exist\n\
    try {\n\
        fs = require(\"fs\");\n\
        pathname = require(\"path\").resolve(pathname);\n\
    } catch (ignore) {\n\
        return;\n\
    }\n\
    // try to write pathname\n\
    try {\n\
        fs.writeFileSync(pathname, data);\n\
    } catch (ignore) {\n\
        // mkdir -p\n\
        fs.mkdirSync(require(\"path\").dirname(pathname), {\n\
            recursive: true\n\
        });\n\
        // re-write pathname\n\
        fs.writeFileSync(pathname, data);\n\
    }\n\
    console.error(\"fsWriteFileWithMkdirpSync - wrote - \" + pathname);\n\
    return true;\n\
};\n\
\n\
local.httpFetch = async function (url, opt = {}) {\n\
/*\n\
 * this function fetch <url> with given <opt>\n\
 */\n\
    let buf;\n\
    let bufList;\n\
    let req;\n\
    let res;\n\
    function arrayBuffer() {\n\
        return buf;\n\
    }\n\
    async function json() {\n\
        return JSON.stringify(await buf);\n\
    }\n\
    async function text() {\n\
        return String(await buf);\n\
    }\n\
    // use browser fetch\n\
    if (\n\
        typeof globalThis.XMLHttpRequest === \"function\" &&\n\
        typeof globalThis.fetch === \"function\"\n\
    ) {\n\
        return globalThis.fetch(url, opt);\n\
    }\n\
    // use node http-request\n\
    if (!(\n\
        /^https?:/\n\
    ).test(url)) {\n\
        url = \"http://127.0.0.1:\" + process.env.PORT + \"/\" + url.replace((\n\
            /^\\//\n\
        ), \"\");\n\
    }\n\
    res = await new Promise(function (resolve) {\n\
        req = require(url.split(\":\")[0]).request(url, opt, resolve).end();\n\
    });\n\
    let {\n\
        headers,\n\
        statusCode\n\
    } = res;\n\
    bufList = [];\n\
    res.on(\"data\", function (chunk) {\n\
        bufList.push(chunk);\n\
    });\n\
    buf = new Promise(function (resolve) {\n\
        res.on(\"end\", function () {\n\
            resolve(Buffer.concat(bufList));\n\
        });\n\
    });\n\
    return Object.assign(res, {\n\
        arrayBuffer,\n\
        blob: arrayBuffer,\n\
        headers: new Map(Object.entries(headers)),\n\
        json,\n\
        ok: 200 <= statusCode && statusCode <= 299,\n\
        req,\n\
        status: statusCode,\n\
        statusText: require(\"http\").STATUS_CODES[statusCode],\n\
        text,\n\
        url\n\
    });\n\
};\n\
\n\
local.jslintAutofixLocalFunction = function (code, file) {\n\
/*\n\
 * this function will jslint-autofix local-function\n\
 */\n\
    let code2;\n\
    let dictFnc;\n\
    let dictProp;\n\
    function stringMerge(str1, str2, rgx) {\n\
    /*\n\
     * this function will merge <str2> into <str1>,\n\
     * for sections where both match <rgx> with no magic\n\
     */\n\
        str2.replace(rgx, function (match2) {\n\
            str1.replace(rgx, function (match1) {\n\
                str1 = str1.replace(match1, function () {\n\
                    return match2;\n\
                });\n\
                return \"\";\n\
            });\n\
            return \"\";\n\
        });\n\
        return str1;\n\
    }\n\
    if (!isEnvNode) {\n\
        return code;\n\
    }\n\
    // make file relative\n\
    file = require(\"path\").resolve(file);\n\
    if (file.indexOf(process.cwd() + require(\"path\").sep) === 0) {\n\
        file = file.replace(process.cwd() + require(\"path\").sep, \"\");\n\
    }\n\
    switch (file) {\n\
    case \"README.md\":\n\
    case \"lib.\" + npm_package_nameLib + \".js\":\n\
    case \"lib.\" + npm_package_nameLib + \".sh\":\n\
    case \"lib.apidoc.js\":\n\
    case \"lib.istanbul.js\":\n\
    case \"lib.jslint.js\":\n\
    case \"lib.marked.js\":\n\
    case \"npm_scripts.sh\":\n\
    case \"test.js\":\n\
        break;\n\
    default:\n\
        return code;\n\
    }\n\
    // autofix - assets.utility2.header.js\n\
    code = code.replace((\n\
        /\\n\\/\\/\\u0020assets.utility2\\.header\\.js\\u0020-\\u0020start\\n[\\S\\s]*?\\n\\/\\/\\u0020assets.utility2\\.header\\.js\\u0020-\\u0020end\\n/\n\
    ), \"\\n\" + local.assetsDict[\"/assets.utility2.header.js\"]);\n\
    // autofix - assets.my_app.template.js\n\
    code = stringMerge(\n\
        code,\n\
        local.assetsDict[\"/assets.my_app.template.js\"].replace((\n\
            /my_app/g\n\
        ), file.split(\".\")[1]),\n\
        (\n\
            file === \"README.md\"\n\
            ? (\n\
                /$^/m\n\
            )\n\
            : (\n\
                /\\n\\/\\*\\u0020istanbul\\u0020instrument\\u0020in\\u0020package\\u0020[\\S\\s]*?\\n\\/\\*\\u0020validateLineSortedReset\\u0020\\*\\/\\n/\n\
            )\n\
        )\n\
    );\n\
    // customize local for assets.utility2.rollup.js\n\
    if (\n\
        file === \"lib.\" + npm_package_nameLib + \".js\" &&\n\
        require(\"fs\").existsSync(\"./assets.utility2.rollup.js\")\n\
    ) {\n\
        code = code.replace(\n\
            \"    // || globalThis.utility2_rollup_old\",\n\
            \"    || globalThis.utility2_rollup_old\"\n\
        ).replace(\n\
            \"    // || require(\\\"./assets.utility2.rollup.js\\\")\",\n\
            \"    || require(\\\"./assets.utility2.rollup.js\\\")\"\n\
        );\n\
    }\n\
    // init functionAllDict and functionBaseDict\n\
    [\n\
        [\n\
            \"utility2\"\n\
        ], [\n\
            \"utility2\", \"apidoc\"\n\
        ]\n\
    ].forEach(function (dictList, ii) {\n\
        dictFnc = (\n\
            ii\n\
            ? \"functionAllDict\"\n\
            : \"functionBaseDict\"\n\
        );\n\
        if (local[dictFnc]) {\n\
            return;\n\
        }\n\
        local[dictFnc] = {};\n\
        dictList.forEach(function (dict) {\n\
            dict = local[dict];\n\
            Object.keys(dict).forEach(function (key) {\n\
                if (\n\
                    !(\n\
                        /^[A-Z_]|^testCase_/m\n\
                    ).test(key) &&\n\
                    typeof dict[key] === \"function\"\n\
                ) {\n\
                    local[dictFnc][key] = (\n\
                        local[dictFnc][key] || String(dict[key])\n\
                    );\n\
                }\n\
            });\n\
        });\n\
        Object.keys(local[dictFnc]).forEach(function (key) {\n\
            if (process.binding(\"natives\")[key]) {\n\
                local[dictFnc][key] = undefined;\n\
            }\n\
        });\n\
    });\n\
    // autofix - local-function\n\
    dictFnc = {};\n\
    dictProp = {};\n\
    code = code.replace((\n\
        /^local\\.(.*?)\\u0020=\\u0020(function\\u0020\\([\\S\\s]*?\\n\\});\\n+/gm\n\
    ), function (match0, key, match2, match3) {\n\
        // local-function - duplicate\n\
        if (dictFnc[key]) {\n\
            return \"\";\n\
        }\n\
        // local-function - normalize\n\
        dictFnc[key] = true;\n\
        match3 = local.functionAllDict[key] || \"\";\n\
        // make shell-safe\n\
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c\n\
        if (file.slice(-3) === \".sh\") {\n\
            match3 = match3.replace((\n\
                /'/g\n\
            ), \"'\\\"'\\\"'\");\n\
        }\n\
        if (match3 && match3 !== match2) {\n\
            match0 = match0.replace(match2, match3.replace((\n\
                /\\$\\$|\\$/g\n\
            ), \"$$$$\"));\n\
        }\n\
        return match0.trimEnd() + \"\\n\\n\";\n\
    });\n\
    // comment\n\
    code2 = code;\n\
    code2 = code2.replace((\n\
        /^\\u0020*?\\/\\*[\\S\\s]*?\\*\\/|^\\u0020*?(?:\\/\\/.*?|.*?\\\\)$/gm\n\
    ), \"\");\n\
    // local-function - update dictFnc and dictProp\n\
    code2.replace((\n\
        /\\blocal\\.(\\w+?\\b)(?:\\u0020(===|=|\\|\\|)(?:\\u0020\"function\"\\u0020&&\\u0020local\\.\\w|\\u0020|$))?/gm\n\
    ), function (ignore, match1, match2) {\n\
        switch (match2) {\n\
        case \"=\":\n\
            dictFnc[match1] = true;\n\
            break;\n\
        case \"===\":\n\
        case \"||\":\n\
            dictProp[match1] = false;\n\
            break;\n\
        default:\n\
            dictProp[match1] = true;\n\
        }\n\
    });\n\
    [\n\
        dictFnc, dictProp\n\
    ].forEach(function (dict) {\n\
        Object.keys(dict).forEach(function (key) {\n\
            dict[key] = dict[key] && local.functionBaseDict[key];\n\
        });\n\
    });\n\
    dictFnc = JSON.parse(JSON.stringify(dictFnc));\n\
    dictProp = JSON.parse(JSON.stringify(dictProp));\n\
    [\n\
        \"assertJsonEqual\",\n\
        \"assertOrThrow\",\n\
        \"identity\",\n\
        \"noop\",\n\
        \"objectAssignDefault\",\n\
        \"objectDeepCopyWithKeysSorted\",\n\
        \"onErrorThrow\"\n\
    ].forEach(function (key) {\n\
        dictFnc[key] = true;\n\
        dictProp[key] = true;\n\
    });\n\
    // local-function - missing\n\
    switch (require(\"fs\").existsSync(\"assets.utility2.rollup.js\") || file) {\n\
    case \"README.md\":\n\
    case \"lib.utility2.js\":\n\
    case \"test.js\":\n\
    case true:\n\
        break;\n\
    default:\n\
        Object.keys(dictProp).forEach(function (key) {\n\
            if (dictProp[key] && !dictFnc[key]) {\n\
                console.error(\n\
                    \"local-function - missing (\" + file + \") local.\" + key\n\
                );\n\
            }\n\
        });\n\
    }\n\
    // local-function - unused\n\
    switch (file) {\n\
    case \"lib.utility2.js\":\n\
    case \"lib.utility2.sh\":\n\
        break;\n\
    default:\n\
        Object.keys(dictFnc).forEach(function (key) {\n\
            if (!dictProp.hasOwnProperty(key)) {\n\
                console.error(\n\
                    \"local-function - unused (\" + file + \") local.\" + key\n\
                );\n\
            }\n\
        });\n\
    }\n\
    return code;\n\
};\n\
\n\
local.listShuffle = function (list) {\n\
/*\n\
 * this function will inplace shuffle <list> using fisher-yates algorithm\n\
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\
 */\n\
    let ii;\n\
    let random;\n\
    let swap;\n\
    ii = list.length;\n\
    while (ii > 1) {\n\
        ii -= 1;\n\
        random = Math.floor(Math.random() * (ii + 1));\n\
        swap = list[ii];\n\
        list[ii] = list[random];\n\
        list[random] = swap;\n\
    }\n\
    return list;\n\
};\n\
\n\
local.onReadyDecrement = function (err) {\n\
/*\n\
 * this function will decrement <onReadyCnt>\n\
 */\n\
    localOnReadyCnt -= 1;\n\
    if (localOnReadyCnt === 0) {\n\
        local.eventListenerEmit(\"utility2.onReady\", err);\n\
    }\n\
    return localOnReadyCnt;\n\
};\n\
\n\
local.onReadyIncrement = function () {\n\
/*\n\
 * this function will increment <onReadyCnt>\n\
 */\n\
    localOnReadyCnt += 1;\n\
    return localOnReadyCnt;\n\
};\n\
\n\
local.replStart = function () {\n\
/*\n\
 * this function will start repl-debugger\n\
 */\n\
    let that;\n\
    if (globalThis.utility2_repl1) {\n\
        return;\n\
    }\n\
    // start repl\n\
    that = require(\"repl\").start({\n\
        useGlobal: true\n\
    });\n\
    globalThis.utility2_repl1 = that;\n\
    // init history\n\
    that.setupHistory(require(\"path\").resolve(\n\
        process.env.HOME + \"/.node_repl_history\"\n\
    ), function () {\n\
        return;\n\
    });\n\
    // save eval-function\n\
    that.evalDefault = that.eval;\n\
    // hook custom-eval-function\n\
    that.eval = function (script, context, file, onError) {\n\
        script.replace((\n\
            /^(\\S+)\\u0020(.*?)\\n/\n\
        ), function (ignore, match1, match2) {\n\
            switch (match1) {\n\
            // syntax-sugar - run shell-cmd\n\
            case \"$\":\n\
                switch (match2.split(\" \").slice(0, 2).join(\" \")) {\n\
                // syntax-sugar - run git diff\n\
                case \"git diff\":\n\
                    match2 += \" --color\";\n\
                    break;\n\
                // syntax-sugar - run git log\n\
                case \"git log\":\n\
                    match2 += \" -n 10\";\n\
                    break;\n\
                // syntax-sugar - run ll\n\
                case \"ll\":\n\
                    match2 = \"ls -Fal\";\n\
                    break;\n\
                }\n\
                match2 = match2.replace((\n\
                    /^git\\u0020/\n\
                ), \"git --no-pager \");\n\
                // source lib.utility2.sh\n\
                match2 = (\n\
                    (\n\
                        process.platform !== \"win32\" &&\n\
                        process.env.UTILITY2_BIN && (match2 !== \":\")\n\
                    )\n\
                    ? \". \" + process.env.UTILITY2_BIN + \"; \" + match2\n\
                    : match2\n\
                );\n\
                // run shell-cmd\n\
                console.error(\"$ \" + match2);\n\
                require(\"child_process\").spawn(match2, {\n\
                    shell: true,\n\
                    stdio: [\n\
                        \"ignore\", 1, 2\n\
                    ]\n\
                // print exitCode\n\
                }).on(\"exit\", function (exitCode) {\n\
                    console.error(\"$ EXIT_CODE=\" + exitCode);\n\
                    that.evalDefault(\"\\n\", context, file, onError);\n\
                });\n\
                script = \"\\n\";\n\
                break;\n\
            // syntax-sugar - map text with charCodeAt\n\
            case \"charCode\":\n\
                console.error(\n\
                    match2.split(\"\").map(function (chr) {\n\
                        return (\n\
                            \"\\\\u\" +\n\
                            chr.charCodeAt(0).toString(16).padStart(4, 0)\n\
                        );\n\
                    }).join(\"\")\n\
                );\n\
                script = \"\\n\";\n\
                break;\n\
            // syntax-sugar - sort chr\n\
            case \"charSort\":\n\
                console.error(JSON.stringify(match2.split(\"\").sort().join(\"\")));\n\
                script = \"\\n\";\n\
                break;\n\
            // syntax-sugar - list obj-keys, sorted by item-type\n\
            // console.error(Object.keys(global).map(function(key){return(typeof global[key]==='object'&&global[key]&&global[key]===global[key]?'global':typeof global[key])+' '+key;}).sort().join('\\n')) // jslint ignore:line\n\
            case \"keys\":\n\
                script = (\n\
                    \"console.error(Object.keys(\" + match2 +\n\
                    \").map(function(key){return(\" +\n\
                    \"typeof \" + match2 + \"[key]==='object'&&\" +\n\
                    match2 + \"[key]&&\" +\n\
                    match2 + \"[key]===global[key]\" +\n\
                    \"?'global'\" +\n\
                    \":typeof \" + match2 + \"[key]\" +\n\
                    \")+' '+key;\" +\n\
                    \"}).sort().join('\\\\n'))\\n\"\n\
                );\n\
                break;\n\
            // syntax-sugar - print String(val)\n\
            case \"print\":\n\
                script = \"console.error(String(\" + match2 + \"))\\n\";\n\
                break;\n\
            }\n\
        });\n\
        // eval script\n\
        that.evalDefault(script, context, file, onError);\n\
    };\n\
};\n\
\n\
local.requireReadme = function () {\n\
/*\n\
 * this function will require and export example.js embedded in README.md\n\
 */\n\
    let Module;\n\
    let code;\n\
    let exports;\n\
    let file;\n\
    let {\n\
        assetsDict,\n\
        fsReadFileOrDefaultSync,\n\
        objectAssignDefault,\n\
        replStart,\n\
        templateRenderMyApp\n\
    } = local;\n\
    // if library-mode, then return local\n\
    if (npm_config_mode_lib) {\n\
        local.testRunDefault = noop;\n\
        return local;\n\
    }\n\
    // if file modified, then restart process\n\
    if (npm_config_mode_auto_restart) {\n\
        require(\"fs\").readdir(\".\", function (ignore, fileList) {\n\
            fileList.concat(__filename).forEach(async function (file) {\n\
                let stats;\n\
                if (file[0] === \".\") {\n\
                    return;\n\
                }\n\
                stats = await require(\"fs\").promises.stat(file);\n\
                if (!stats.isFile()) {\n\
                    return;\n\
                }\n\
                require(\"fs\").watchFile(file, {\n\
                    interval: 1000,\n\
                    persistent: false\n\
                }, function () {\n\
                    console.error(\"watchFile - modified - \" + file);\n\
                    setTimeout(process.exit.bind(undefined, 77), 1000);\n\
                });\n\
            });\n\
        });\n\
    }\n\
    // if browser-env, then return local\n\
    if (!isEnvNode) {\n\
        return objectAssignDefault(\n\
            globalThis.utility2_rollup || globalThis.local,\n\
            local\n\
        );\n\
    }\n\
    // start repl-debugger\n\
    replStart();\n\
    // jslint $PWD\n\
    require(\"child_process\").spawn(\"node\", [\n\
        \"-e\", (\n\
            \"require(\" + JSON.stringify(__filename) +\n\
            \").jslintAndPrintDir(\" + JSON.stringify(process.cwd()) +\n\
            \", {modeAutofix:\" + !npm_config_mode_test +\n\
            \",modeConditional:true});\"\n\
        )\n\
    ], {\n\
        env: Object.assign({}, process.env, {\n\
            npm_config_mode_lib: \"1\"\n\
        }),\n\
        stdio: [\n\
            \"ignore\", 1, 2\n\
        ]\n\
    });\n\
    // if rollup, then return local\n\
    if (globalThis.utility2_rollup || npm_config_mode_start) {\n\
        assetsDict[\"/assets.app.js\"] = require(\"fs\").readFileSync(\n\
            __filename,\n\
            \"utf8\"\n\
        ).replace((\n\
            /^#!\\//\n\
        ), \"// \");\n\
        // init exports\n\
        local[npm_package_nameLib] = local;\n\
        return local;\n\
    }\n\
    // init utility2_moduleExports from $npm_package_main\n\
    globalThis.utility2_moduleExports = require(\n\
        require(\"path\").resolve(npm_package_main)\n\
    );\n\
    // read example.js from README.md\n\
    code = assetsDict[\"/assets.example.template.js\"];\n\
    fsReadFileOrDefaultSync(\"README.md\", \"utf8\", \"\").replace((\n\
        /\\n```javascript(\\n\\/\\*\\nexample\\.js\\n[\\S\\s]*?\\n)```\\n/\n\
    ), function (ignore, match1, ii, input) {\n\
        // preserve lineno\n\
        code = input.slice(0, ii).replace((\n\
            /.+/g\n\
        ), \"\") + \"\\n\" + match1;\n\
        return \"\";\n\
    });\n\
    // alias require($npm_package_name) to utility2_moduleExports;\n\
    code = code.replace(\n\
        new RegExp(\"require\\\\(.\" + npm_package_name + \".\\\\)\"),\n\
        \"globalThis.utility2_moduleExports\"\n\
    ).replace(\n\
        new RegExp(\"require\\\\(.\" + npm_package_nameOriginal + \".\\\\)\"),\n\
        \"globalThis.utility2_moduleExports\"\n\
    );\n\
    // jslint example.js\n\
    file = require(\"path\").resolve(\"example.js\");\n\
    jslintAndPrint(code, file);\n\
    // instrument example.js\n\
    code = instrumentInPackage(code, file);\n\
    // eval example.js\n\
    Module = require(\"module\");\n\
    exports = new Module(file);\n\
    require.cache[file] = exports;\n\
    exports._compile(code, file);\n\
    // export example.js\n\
    exports = exports.exports;\n\
    exports.utility2 = local;\n\
    exports[npm_package_nameLib] = globalThis.utility2_moduleExports;\n\
    // cleanup utility2_moduleExports\n\
    delete globalThis.utility2_moduleExports;\n\
    // init assets lib.xxx.js\n\
    [\n\
        \".css\", \".js\"\n\
    ].forEach(function (extname) {\n\
        assetsDict[\n\
            \"/assets.\" + npm_package_nameLib + extname\n\
        ] = fsReadFileOrDefaultSync(\n\
            require(\"path\").resolve(npm_package_main).replace((\n\
                /\\.\\w+?$/\n\
            ), extname),\n\
            \"utf8\",\n\
            \"\"\n\
        ).replace((\n\
            /^#!\\//\n\
        ), \"// \");\n\
    });\n\
    Object.assign(assetsDict, exports.assetsDict);\n\
    // instrument assets lib.xxx.js\n\
    assetsDict[\"/assets.\" + npm_package_nameLib + \".js\"] = (\n\
        instrumentInPackage(\n\
            assetsDict[\"/assets.\" + npm_package_nameLib + \".js\"],\n\
            npm_package_main\n\
        )\n\
    );\n\
    exports.assetsDict = assetsDict;\n\
    assetsDict[\"/assets.example.js\"] = code;\n\
    assetsDict[\"/assets.test.js\"] = instrumentInPackage(\n\
        require(\"fs\").readFileSync(\"test.js\", \"utf8\"),\n\
        \"test.js\"\n\
    );\n\
    // init assets index.html\n\
    file = assetsDict[\"/\"];\n\
    // uncomment utility2-comment\n\
    file = file.replace((\n\
        /\\n<!--\\u0020utility2-comment\\n|\\nutility2-comment\\u0020-->\\n/g\n\
    ), \"\\n\\n\");\n\
    // interpolate {{...}}\n\
    file = templateRenderMyApp(file);\n\
    assetsDict[\"/\"] = file;\n\
    assetsDict[\"/index.html\"] = file;\n\
    // init assets.app.js\n\
    assetsDict[\"/assets.app.js\"] = [\n\
        \"header\",\n\
        \"/assets.utility2.rollup.js\",\n\
        \"/assets.utility2.rollup.start.js\",\n\
        \"/assets.my_app.css\",\n\
        \"/assets.my_app.js\",\n\
        \"/assets.example.js\",\n\
        \"/assets.test.js\",\n\
        \"/assets.utility2.rollup.end.js\"\n\
    ].map(function (key) {\n\
        switch (key) {\n\
        case \"/assets.my_app.css\":\n\
            file = \"/assets.\" + npm_package_nameLib + \".css\";\n\
            // disable $-escape in replacement-string\n\
            code = assetsDict[\n\
                \"/assets.utility2.rollup.content.js\"\n\
            ].replace(\"/* utility2.rollup.js content */\", function () {\n\
                return (\n\
                    \"local.assetsDict[\\\"\" + file + \"\\\"] = (\\n\" +\n\
                    JSON.stringify(assetsDict[file]).replace((\n\
                        /\\\\\\\\/g\n\
                    ), \"\\u0000\").replace((\n\
                        /\\\\n/g\n\
                    ), \"\\\\n\\\\\\n\").replace((\n\
                        /\\u0000/g\n\
                    ), \"\\\\\\\\\") +\n\
                    \");\\n\"\n\
                );\n\
            });\n\
            break;\n\
        case \"/assets.my_app.js\":\n\
            file = \"/assets.\" + npm_package_nameLib + \".js\";\n\
            // disable $-escape in replacement-string\n\
            code = assetsDict[\n\
                \"/assets.utility2.rollup.content.js\"\n\
            ].replace(\"/* utility2.rollup.js content */\", function () {\n\
                return (\n\
                    \"local.assetsDict[\\\"\" + file + \"\\\"] = (\\n\" +\n\
                    JSON.stringify(assetsDict[file]).replace((\n\
                        /\\\\\\\\/g\n\
                    ), \"\\u0000\").replace((\n\
                        /\\\\n/g\n\
                    ), \"\\\\n\\\\\\n\").replace((\n\
                        /\\u0000/g\n\
                    ), \"\\\\\\\\\") +\n\
                    \");\\n\" +\n\
                    assetsDict[file]\n\
                );\n\
            });\n\
            break;\n\
        case \"header\":\n\
            return (\n\
                \"/* this rollup was created with utility2\\n\" +\n\
                \" * https://github.com/kaizhu256/node-utility2\\n\" +\n\
                \" */\\n\" +\n\
                \"\\n\" +\n\
                \"\\n\" +\n\
                \"/*\\n\" +\n\
                \"assets.app.js\\n\" +\n\
                \"\\n\" +\n\
                npm_package_description + \"\\n\" +\n\
                \"\\n\" +\n\
                \"instruction\\n\" +\n\
                \"    1. save this script as assets.app.js\\n\" +\n\
                \"    2. run shell-cmd:\\n\" +\n\
                \"        $ PORT=8081 node assets.app.js\\n\" +\n\
                \"    3. open browser to http://127.0.0.1:8081 \" +\n\
                \"and play with web-demo\\n\" +\n\
                \"    4. edit this script to suit your needs\\n\" +\n\
                \"*/\\n\" +\n\
                assetsDict[\"/assets.utility2.rollup.start.js\"].replace((\n\
                    /utility2_rollup/g\n\
                ), \"utility2_app\")\n\
            );\n\
        default:\n\
            code = assetsDict[key];\n\
        }\n\
        return (\n\
            \"/* script-begin \" + key + \" */\\n\" +\n\
            code.trim() +\n\
            \"\\n/* script-end \" + key + \" */\\n\"\n\
        );\n\
    }).join(\"\\n\\n\\n\");\n\
    objectAssignDefault(exports, local);\n\
    // init testCase_buildXxx\n\
    Object.keys(local).forEach(function (key) {\n\
        if (\n\
            key.indexOf(\"_testCase_build\") === 0 ||\n\
            key === \"_testCase_webpage_default\"\n\
        ) {\n\
            exports[key.slice(1)] = exports[key.slice(1)] || local[key];\n\
        }\n\
    });\n\
    return exports;\n\
};\n\
\n\
local.serverRequestListener = function (req, res) {\n\
/*\n\
 * this function will handle server-<req> and server-<res> using\n\
 * express-like middleware-chaining\n\
 */\n\
    let isDone;\n\
    let list;\n\
    let timeStart;\n\
    let timeout;\n\
    let timerTimeout;\n\
    let urlParsed;\n\
    let {\n\
        assetsDict,\n\
        middlewareList\n\
    } = local;\n\
    function onClose() {\n\
    /*\n\
     * this function will hand \"close\" evt\n\
     */\n\
        console.error(\"serverLog - \" + JSON.stringify({\n\
            time: new Date(timeStart).toISOString(),\n\
            type: \"serverResponse\",\n\
            method: req.method,\n\
            url: urlParsed.pathname,\n\
            statusCode: res.statusCode | 0,\n\
            timeElapsed: Date.now() - timeStart\n\
        }) + \"\\n\");\n\
        isDone = true;\n\
        clearTimeout(timerTimeout);\n\
        req.destroy();\n\
        res.destroy();\n\
    }\n\
    function onError(err) {\n\
    /*\n\
     * this function will end server-request\n\
     */\n\
        if (!isDone && !err) {\n\
            isDone = true;\n\
            res.statusCode = 404;\n\
            res.end(\"404 Not Found\");\n\
            return;\n\
        }\n\
        console.error(err || new Error(\"onError called more than once\"));\n\
        if (isDone) {\n\
            req.destroy();\n\
            res.destroy();\n\
            return;\n\
        }\n\
        isDone = true;\n\
        res.statusCode = 500;\n\
        res.end(\"500 Internal Server Error\");\n\
    }\n\
    function onTimeout() {\n\
        isDone = true;\n\
        onError(new Error(\"timeout - \" + timeout + \" ms\"));\n\
    }\n\
    async function middlewareInit(req, ignore, next) {\n\
        let contentType;\n\
        // init timeStart\n\
        timeStart = Date.now();\n\
        // init timerTimeout\n\
        timeout = timeout || npm_config_timeout;\n\
        timerTimeout = setTimeout(onTimeout, timeout);\n\
        // init urlParsed\n\
        urlParsed = new URL(\"http://127.0.0.1:\" + PORT + req.url);\n\
        // init evt-handling\n\
        req.on(\"abort\", onError);\n\
        req.on(\"close\", onClose);\n\
        req.on(\"error\", onError);\n\
        res.on(\"error\", onError);\n\
        res.on(\"close\", onClose);\n\
        // set reponse-header \"content-type\"\n\
        contentType = {\n\
            // application\n\
            \".js\": \"application/javascript; charset=utf-8\",\n\
            \".json\": \"application/json; charset=utf-8\",\n\
            \".mjs\": \"application/javascript; charset=utf-8\",\n\
            \".pdf\": \"application/pdf\",\n\
            \".wasm\": \"application/wasm\",\n\
            \".xml\": \"application/xml; charset=utf-8\",\n\
            // image\n\
            \".bmp\": \"image/bmp\",\n\
            \".gif\": \"image/gif\",\n\
            \".jpe\": \"image/jpeg\",\n\
            \".jpeg\": \"image/jpeg\",\n\
            \".jpg\": \"image/jpeg\",\n\
            \".png\": \"image/png\",\n\
            \".svg\": \"image/svg+xml; charset=utf-8\",\n\
            // text\n\
            \".css\": \"text/css; charset=utf-8\",\n\
            \".htm\": \"text/html; charset=utf-8\",\n\
            \".html\": \"text/html; charset=utf-8\",\n\
            \".md\": \"text/markdown; charset=utf-8\",\n\
            \".txt\": \"text/plain; charset=utf-8\",\n\
            \"/\": \"text/html; charset=utf-8\"\n\
        };\n\
        contentType = contentType[(\n\
            /^\\/$|\\.[^.]*?$|$/m\n\
        ).exec(urlParsed.pathname)[0]];\n\
        if (contentType) {\n\
            res.setHeader(\"content-type\", contentType);\n\
        }\n\
        await next();\n\
    }\n\
    async function middlewareServeAsset(ignore, res, next) {\n\
    /*\n\
     * this function will serve assets from <assetsDict>\n\
     */\n\
        if (!assetsDict.hasOwnProperty(urlParsed.pathname)) {\n\
            await next();\n\
            return;\n\
        }\n\
        res.statusCode = 200;\n\
        res.end(assetsDict[urlParsed.pathname]);\n\
    }\n\
    async function middlewareServeFile(req, res, next) {\n\
    /*\n\
     * this function will serve <file> from fs\n\
     */\n\
        let file;\n\
        if (req.method !== \"GET\") {\n\
            await next();\n\
            return;\n\
        }\n\
        file = urlParsed.pathname.slice(1);\n\
        // replace trailing \"/\" with \"/index.html\"\n\
        file = file.replace((\n\
            /\\/$/\n\
        ), \"/index.html\");\n\
        // resolve file\n\
        file = require(\"path\").resolve(file);\n\
        if (\n\
            // security - disable parent-directory lookup\n\
            file.indexOf(process.cwd() + require(\"path\").sep) !== 0 ||\n\
            // security - ignore file with non-alphanumeric-first-character\n\
            !(\n\
                /[0-9A-Za-z]/\n\
            ).test(require(\"path\").basename(file)[0])\n\
        ) {\n\
            await next();\n\
            return;\n\
        }\n\
        try {\n\
            file = await require(\"fs\").promises.readFile(file);\n\
        } catch (ignore) {\n\
            await next();\n\
            return;\n\
        }\n\
        res.end(file);\n\
    }\n\
    async function next() {\n\
        let middleware;\n\
        try {\n\
            middleware = list.shift();\n\
            if (isDone || !middleware) {\n\
                onError();\n\
                return;\n\
            }\n\
            // recurse\n\
            await middleware(req, res, next);\n\
        } catch (errCaught) {\n\
            onError(errCaught);\n\
        }\n\
    }\n\
    // init list\n\
    list = [].concat(\n\
        middlewareInit,\n\
        middlewareList,\n\
        middlewareServeAsset,\n\
        middlewareServeFile\n\
    );\n\
    next();\n\
};\n\
\n\
local.serverRespondEcho = function (req, res) {\n\
/*\n\
 * this function will respond with debug info\n\
 */\n\
    res.write(\n\
        req.method + \" \" + req.url +\n\
        \" HTTP/\" + req.httpVersion + \"\\r\\n\" +\n\
        Object.keys(req.headers).map(function (key) {\n\
            return key + \": \" + req.headers[key] + \"\\r\\n\";\n\
        }).join(\"\") + \"\\r\\n\"\n\
    );\n\
    req.pipe(res);\n\
};\n\
\n\
local.setTimeoutOnError = function (onError, timeout, err, data) {\n\
/*\n\
 * this function will after timeout has passed,\n\
 * then call <onError>(<err>, <data>)\n\
 */\n\
    if (typeof onError === \"function\") {\n\
        setTimeout(function () {\n\
            onError(err, data);\n\
        }, timeout);\n\
    }\n\
    return data;\n\
};\n\
\n\
local.stringHtmlSafe = function (str) {\n\
/*\n\
 * this function will make <str> html-safe\n\
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html\n\
 */\n\
    return str.replace((\n\
        /&/gu\n\
    ), \"&amp;\").replace((\n\
        /\"/gu\n\
    ), \"&quot;\").replace((\n\
        /'/gu\n\
    ), \"&apos;\").replace((\n\
        /</gu\n\
    ), \"&lt;\").replace((\n\
        />/gu\n\
    ), \"&gt;\").replace((\n\
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu\n\
    ), \"&$1\");\n\
};\n\
\n\
local.stringRegexpEscape = function (str) {\n\
/*\n\
 * this function will regexp-escape <str>\n\
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\
 */\n\
    return str.replace((\n\
        /[\\-\\/\\\\\\^$*+?.()|\\[\\]{}]/g\n\
    ), \"\\\\$&\");\n\
};\n\
\n\
local.svgBadgeCreate = function ({\n\
    fill,\n\
    str1,\n\
    str2\n\
}) {\n\
/*\n\
 * this function will create svg-badge\n\
 */\n\
    let xx1;\n\
    let xx2;\n\
    str1 = String(str1);\n\
    str2 = String(str2);\n\
    xx1 = 6 * str1.length + 20;\n\
    xx2 = 6 * str2.length + 20;\n\
    return (\n\
        \"<svg height=\\\"20\\\" width=\\\"\" +\n\
        (xx1 + xx2) +\n\
        \"\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\" +\n\
        \"<rect fill=\\\"#555\\\" height=\\\"20\\\" width=\\\"\" +\n\
        (xx1 + xx2) +\n\
        \"\\\"/>\\n\" +\n\
        \"<rect fill=\\\"\" + fill + \"\\\" height=\\\"20\\\" width=\\\"\" +\n\
        xx2 + \"\\\" x=\\\"\" + xx1 + \"\\\"/>\\n\" +\n\
        \"<g\\n\" +\n\
        \"fill=\\\"#fff\\\"\\n\" +\n\
        \"font-family=\\\"DejaVu Sans,Verdana,Geneva,sans-serif\\\"\\n\" +\n\
        \"font-size=\\\"11\\\"\\n\" +\n\
        \"text-anchor=\\\"middle\\\"\\n\" +\n\
        \">\\n\" +\n\
        \"<text fill-opacity=\\\".5\\\" fill=\\\"#777\\\" x=\\\"\" +\n\
        0.5 * xx1 + \"\\\" y=\\\"15\\\">\" + str1 + \"</text>\\n\" +\n\
        \"<text x=\\\"\" + 0.5 * xx1 + \"\\\" y=\\\"14\\\">\" + str1 + \"</text>\\n\" +\n\
        \"<text fill-opacity=\\\".5\\\" fill=\\\"#777\\\" x=\\\"\" +\n\
        (xx1 + 0.5 * xx2) + \"\\\" y=\\\"15\\\">\" + str2 + \"</text>\\n\" +\n\
        \"<text x=\\\"\" + (xx1 + 0.5 * xx2) + \"\\\" y=\\\"14\\\">\" + str2 + \"</text>\\n\" +\n\
        \"</g>\\n\" +\n\
        \"</svg>\\n\"\n\
    );\n\
};\n\
\n\
local.templateRenderMyApp = function (template) {\n\
/*\n\
 * this function will render my-app template\n\
 */\n\
    template = template.replace((\n\
        /kaizhu256(\\.github\\.io\\/|%252F|\\/)/g\n\
    ), GITHUB_OWNER + \"$1\");\n\
    template = template.replace((\n\
        /node-my-app/g\n\
    ), GITHUB_REPO);\n\
    template = template.replace((\n\
        /\\bh1-my-app\\b/g\n\
    ), (\n\
        npm_package_nameHeroku ||\n\
        (\"h1-\" + npm_package_nameLib.replace((\n\
            /_/g\n\
        ), \"-\"))\n\
    ));\n\
    template = template.replace((\n\
        /\\bmy-app\\b/g\n\
    ), npm_package_name);\n\
    template = template.replace((\n\
        /my_app/g\n\
    ), npm_package_nameLib);\n\
    template = template.replace((\n\
        /\\{\\{(\\w+)(\\u0020jsonStringify)?\\}\\}/g\n\
    ), function (ignore, key, jsonStringify) {\n\
        return String(\n\
            jsonStringify\n\
            ? JSON.stringify(local[key])\n\
            : String(local[key])\n\
        ).replace((\n\
            /<\\//g\n\
        ), \"<\\\\/\");\n\
    });\n\
    return template;\n\
};\n\
\n\
local.testCase_noop_default = function (opt, onError) {\n\
/*\n\
 * this function will test noop's default handling-behavior\n\
 */\n\
    noop();\n\
    onError(undefined, opt);\n\
};\n\
\n\
local.testMock = function (mockList, onTestCase, onError) {\n\
/*\n\
 * this function will mock objects in <mockList> when running <onTestCase>\n\
 */\n\
    let onError2;\n\
    onError2 = function (err) {\n\
        // restore mock[0] from mock[2]\n\
        mockList.reverse().forEach(function (mock) {\n\
            Object.keys(mock[2]).forEach(function (key) {\n\
                try {\n\
                    mock[0][key] = mock[2][key];\n\
                } catch (errCaught) {\n\
                    console.error(errCaught);\n\
                }\n\
            });\n\
        });\n\
        onError(err);\n\
    };\n\
    // suppress console.error and console.log\n\
    mockList.unshift([\n\
        console, {}\n\
    ]);\n\
    local.objectAssignDefault(mockList[0][1], {\n\
        error: noop,\n\
        log: noop\n\
    });\n\
    // mock mock[0]\n\
    mockList.forEach(function (mock) {\n\
        mock[2] = {};\n\
        // backup mock[0] into mock[2]\n\
        Object.keys(mock[1]).forEach(function (key) {\n\
            mock[2][key] = mock[0][key];\n\
        });\n\
        // override mock[0] with mock[1]\n\
        Object.keys(mock[1]).forEach(function (key) {\n\
            try {\n\
                mock[0][key] = mock[1][key];\n\
            } catch (errCaught) {\n\
                console.error(errCaught);\n\
            }\n\
        });\n\
    });\n\
    // try to run onTestCase with mock[0]\n\
    try {\n\
        // run onTestCase\n\
        onTestCase(onError2);\n\
    } catch (errCaught) {\n\
        onError2(errCaught);\n\
    }\n\
};\n\
\n\
local.testReportMerge = function (\n\
    testReport = {},\n\
    testReport2 = {},\n\
    mode = undefined\n\
) {\n\
/*\n\
 * this function will\n\
 * 1. merge <testReport2> into <testReport>\n\
 * 2. render <testReport>.html\n\
 * 3. write <testReport> to fs\n\
 */\n\
    let html;\n\
    let testCaseNumber;\n\
    let testPlatformDict;\n\
    let testPlatformList;\n\
    function fileWrite(file, data) {\n\
    /*\n\
     * this function will write <data> to <file>\n\
     */\n\
        file = require(\"path\").resolve(UTILITY2_DIR_BUILD + \"/\" + file);\n\
        require(\"fs\").writeFileSync(file, data);\n\
        console.error(\"test-report - wrote - \" + file);\n\
    }\n\
    // 1. merge <testReport2> into <testReport>\n\
    testReport = local.objectAssignDefault(testReport, {\n\
        coverage: globalThis.__coverage__,\n\
        date: new Date().toISOString(),\n\
        testPlatformList: [\n\
            {}\n\
        ]\n\
    });\n\
    testPlatformDict = {};\n\
    // deduplicate testPlatform with same name\n\
    testPlatformList = [].concat(\n\
        testReport.testPlatformList,\n\
        testReport2.testPlatformList || []\n\
    ).reverse().map(function (testPlatform) {\n\
        local.objectAssignDefault(testPlatform, {\n\
            date: new Date().toISOString(),\n\
            modeBuild: MODE_CI,\n\
            nameBase: (\n\
                isEnvNode\n\
                ? \"node - \" + process.platform + \" - \" + process.version\n\
                : \"browser - \" + location.pathname + \" - \" + navigator.userAgent\n\
            ),\n\
            status: \"pending\",\n\
            testCaseList: [],\n\
            testsFailed: 0,\n\
            testsPassed: 0,\n\
            testsPending: 0,\n\
            timeElapsed: 0,\n\
            timeOnload: (\n\
                globalThis.domOnEventWindowOnloadTimeElapsed < 0x10000000000 &&\n\
                globalThis.domOnEventWindowOnloadTimeElapsed | 0\n\
            ),\n\
            timeStart: 0\n\
        });\n\
        testPlatform.name = (\n\
            testPlatform.modeBuild + \" - \" + testPlatform.nameBase\n\
        );\n\
        testPlatformDict[testPlatform.name] = testPlatform;\n\
        return testPlatform;\n\
    }).slice(-1);\n\
    delete testPlatformDict[testPlatformList[0].name];\n\
    testPlatformList = [\n\
        testPlatformList[0]\n\
    ].concat(Object.values(testPlatformDict).sort(function (aa, bb) {\n\
        return (\n\
            aa.date < bb.date\n\
            ? 1\n\
            : -1\n\
        );\n\
    }));\n\
    Object.assign(testReport, {\n\
        testsFailed: 0,\n\
        testsPassed: 0,\n\
        testsPending: 0\n\
    });\n\
    testPlatformList.forEach(function (testPlatform) {\n\
        Object.assign(testPlatform, {\n\
            testsFailed: 0,\n\
            testsPassed: 0,\n\
            testsPending: 0\n\
        });\n\
        testPlatform.testCaseList.forEach(function ({\n\
            status\n\
        }) {\n\
            switch (status) {\n\
            // update failed tests\n\
            case \"failed\":\n\
                testPlatform.testsFailed += 1;\n\
                testReport.testsFailed += 1;\n\
                break;\n\
            // update passed tests\n\
            case \"passed\":\n\
                testPlatform.testsPassed += 1;\n\
                testReport.testsPassed += 1;\n\
                break;\n\
            // update pending tests\n\
            default:\n\
                testPlatform.testsPending += 1;\n\
                testReport.testsPending += 1;\n\
            }\n\
        });\n\
        // update testPlatform.status\n\
        testPlatform.status = (\n\
            testPlatform.testsFailed\n\
            ? \"failed\"\n\
            : testPlatform.testsPending\n\
            ? \"pending\"\n\
            : \"passed\"\n\
        );\n\
        // sort testCaseList by status and name\n\
        testPlatform.testCaseList.sort(function (aa, bb) {\n\
            return (\n\
                (aa.status.replace(\"passed\", \"z\") + aa.name) >\n\
                (bb.status.replace(\"passed\", \"z\") + bb.name)\n\
                ? 1\n\
                : -1\n\
            );\n\
        });\n\
    });\n\
    // 2. render <testReport>.html\n\
    testCaseNumber = 0;\n\
    html = local.assetsDict[\"/assets.utility2.template.html\"];\n\
    html = html.replace(\"assets.utility2.template.html\", \"\");\n\
    html = html.replace((\n\
        /<title>.*?<\\/title>/\n\
    ), \"<title>test-report</title>\");\n\
    // init html - style\n\
    html = html.replace((\n\
        \"\\n</style>\\n\"\n\
    ), (\n\
        \"\\n\" +\n\
        \"</style>\\n\" +\n\
        \"<style>\\n\" +\n\
        \"/* jslint utility2:true */\\n\" +\n\
        \".test-report-div img {\\n\" +\n\
        \"    border: 1px solid #999;\\n\" +\n\
        \"    margin: 5px 0 5px 0;\\n\" +\n\
        \"    max-height: 256px;\\n\" +\n\
        \"    max-width: 512px;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div pre {\\n\" +\n\
        \"    background: #fdd;\\n\" +\n\
        \"    border-top: 1px solid #999;\\n\" +\n\
        \"    margin-bottom: 0;\\n\" +\n\
        \"    padding: 10px;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div span {\\n\" +\n\
        \"    display: inline-block;\\n\" +\n\
        \"    width: 120px;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div table {\\n\" +\n\
        \"    border-top: 1px solid #999;\\n\" +\n\
        \"    text-align: left;\\n\" +\n\
        \"    width: 100%;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div table > tbody > tr:nth-child(odd) {\\n\" +\n\
        \"    background: #bfb;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div .footer {\\n\" +\n\
        \"    text-align: center;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div .platform {\\n\" +\n\
        \"    background: #fff;\\n\" +\n\
        \"    border: 1px solid #999;\\n\" +\n\
        \"    margin-bottom: 20px;\\n\" +\n\
        \"    padding: 0 10px 10px 10px;\\n\" +\n\
        \"    text-align: left;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div .summary {\\n\" +\n\
        \"    background: #bfb;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div .test-failed {\\n\" +\n\
        \"    background: #f99;\\n\" +\n\
        \"}\\n\" +\n\
        \".test-report-div .test-pending {\\n\" +\n\
        \"    background: #99f;\\n\" +\n\
        \"}\\n\" +\n\
        \"</style>\\n\"\n\
    ));\n\
    // init html - body\n\
    html = html.replace((\n\
        /\\n<\\/script>[\\S\\s]*?<\\/body>\\n/\n\
    ), function () {\n\
        return (\n\
            \"\\n\" +\n\
            \"</script>\\n\" +\n\
            \"<div class=\\\"test-report-div\\\">\\n\" +\n\
            // init html - header\n\
            \"<h1>test-report for\\n\" +\n\
            \"    <a href=\\\"\" + (npm_package_homepage || \"#\") + \"\\\">\\n\" +\n\
            \"    \" + npm_package_name + \" (\" + npm_package_version + \")\\n\" +\n\
            \"    </a>\\n\" +\n\
            \"</h1>\\n\" +\n\
            \"\\n\" +\n\
            // init html - summary\n\
            \"<div class=\\\"platform summary\\\">\\n\" +\n\
            \"<h2>summary</h2>\\n\" +\n\
            \"<h4>\\n\" +\n\
            \"    <span>version</span>- \" + npm_package_version + \"<br>\\n\" +\n\
            \"    <span>test-date</span>- \" + testReport.date + \"<br>\\n\" +\n\
            \"    <span>commit-info</span>- \" +\n\
            CI_COMMIT_ID + \" - \" + CI_COMMIT_MESSAGE + \"<br>\\n\" +\n\
            \"</h4>\\n\" +\n\
            \"<table>\\n\" +\n\
            \"<thead>\\n\" +\n\
            \"    <tr>\\n\" +\n\
            \"    <th>total tests-failed</th>\\n\" +\n\
            \"    <th>total tests-passed</th>\\n\" +\n\
            \"    <th>total tests-pending</th>\\n\" +\n\
            \"    </tr>\\n\" +\n\
            \"</thead>\\n\" +\n\
            \"<tbody>\\n\" +\n\
            \"    <tr>\\n\" +\n\
            \"    <td class=\\\"\" + (\n\
                testReport.testsFailed\n\
                ? \"testFailed\"\n\
                : \"testPassed\"\n\
            ) + \"\\\">\" + testReport.testsFailed + \"</td>\\n\" +\n\
            \"    <td>\" + testReport.testsPassed + \"</td>\\n\" +\n\
            \"    <td>\" + testReport.testsPending + \"</td>\\n\" +\n\
            \"    </tr>\\n\" +\n\
            \"</tbody>\\n\" +\n\
            \"</table>\\n\" +\n\
            \"</div>\\n\" +\n\
            \"\\n\" +\n\
            // init html - testPlatformList\n\
            testPlatformList.map(function ({\n\
                date,\n\
                name,\n\
                screenshot,\n\
                testCaseList,\n\
                testsFailed,\n\
                testsPassed,\n\
                testsPending,\n\
                timeElapsed,\n\
                timeOnload\n\
            }, ii) {\n\
                let errStackList;\n\
                errStackList = [];\n\
                screenshot = screenshot && encodeURIComponent(screenshot);\n\
                return (\n\
                    \"<div class=\\\"platform\\\">\\n\" +\n\
                    \"<h4>\\n\" +\n\
                    (ii + 1) + \". \" + name + \"<br>\\n\" + (\n\
                        screenshot\n\
                        ? \"<a href=\\\"\" + screenshot + \"\\\">\\n\" +\n\
                        \"<img\\n\" +\n\
                        \"alt=\\\"\" + screenshot + \"\\\"\\n\" +\n\
                        \"src=\\\"\" + screenshot + \"\\\"\\n\" +\n\
                        \">\\n\" +\n\
                        \"</a>\\n\" +\n\
                        \"<br>\\n\"\n\
                        : \"\"\n\
                    ) + (\n\
                        timeOnload\n\
                        ? \"<span>onload-time</span>- \" +\n\
                        timeOnload +\n\
                        \" ms<br>\\n\"\n\
                        : \"\"\n\
                    ) +\n\
                    \"<span>test-date</span>- \" + date + \"<br>\\n\" +\n\
                    \"<span>time-elapsed</span>- \" + timeElapsed + \" ms<br>\\n\" +\n\
                    \"<span>tests-failed</span>- \" + testsFailed + \"<br>\\n\" +\n\
                    \"<span>tests-passed</span>- \" + testsPassed + \"<br>\\n\" +\n\
                    \"<span>tests-pending</span>- \" + testsPending + \"<br>\\n\" +\n\
                    \"</h4>\\n\" +\n\
                    \"\\n\" +\n\
                    // init html - testCaseList\n\
                    \"<table>\\n\" +\n\
                    \"<thead><tr>\\n\" +\n\
                    \"<th>#</th>\\n\" +\n\
                    \"<th>time-elapsed</th>\\n\" +\n\
                    \"<th>status</th>\\n\" +\n\
                    \"<th>test-case</th>\\n\" +\n\
                    \"</tr></thead>\\n\" +\n\
                    \"<tbody>\\n\" +\n\
                    testCaseList.map(function ({\n\
                        errStack,\n\
                        name,\n\
                        status,\n\
                        timeElapsed\n\
                    }) {\n\
                        testCaseNumber += 1;\n\
                        if (errStack) {\n\
                            errStackList.push(\n\
                                testCaseNumber + \". \" + name + \"\\n\" +\n\
                                errStack\n\
                            );\n\
                        }\n\
                        return (\n\
                            \"<tr>\\n\" +\n\
                            \"<td>\" + testCaseNumber + \"</td>\\n\" +\n\
                            \"<td>\" + timeElapsed + \" ms</td>\\n\" +\n\
                            \"<td class=\\\"test-\" + status + \"\\\">\" +\n\
                            status + \"</td>\\n\" +\n\
                            \"<td>\" + name + \"</td>\\n\" +\n\
                            \"</tr>\\n\"\n\
                        );\n\
                    }).join(\"\") +\n\
                    \"</tbody>\\n\" +\n\
                    \"</table>\\n\" +\n\
                    \"\\n\" + (\n\
                        errStackList.length\n\
                        ? \"<pre tabIndex=\\\"0\\\">\\n\" +\n\
                        errStackList.join(\"\\n\") + \"\\n\" +\n\
                        \"</pre>\\n\"\n\
                        : \"\"\n\
                    ) +\n\
                    \"</div>\\n\"\n\
                );\n\
            }).join(\"\") +\n\
            \"\\n\" +\n\
            // init html - footer\n\
            \"<div class=\\\"footer\\\">\\n\" +\n\
            \"[ this document was created with <a\\n\" +\n\
            \"    href=\\\"https://github.com/kaizhu256/node-utility2\\\"\\n\" +\n\
            \"    target=\\\"_blank\\\"\\n\" +\n\
            \">utility2</a> ]\\n\" +\n\
            \"</div>\\n\" +\n\
            \"\\n\" +\n\
            \"</div>\\n\" +\n\
            \"</body>\\n\"\n\
        );\n\
    });\n\
    testReport = Object.assign(testReport, {\n\
        html,\n\
        testPlatformList\n\
    });\n\
    // 3. write <testReport> to fs\n\
    if (mode !== \"modeWrite\") {\n\
        return testReport;\n\
    }\n\
    delete testReport.coverage;\n\
    delete testReport.html;\n\
    // print test-report summary\n\
    console.error(\n\
        \"\\n\" + new Array(56).join(\"-\") + \"\\n\" +\n\
        testPlatformList.filter(function (testPlatform) {\n\
            // if testPlatform has no tests, then filter it out\n\
            return testPlatform.testCaseList.length;\n\
        }).map(function (testPlatform) {\n\
            return (\n\
                \"| test-report - \" + testPlatform.name + \"\\n|\" +\n\
                String(\n\
                    testPlatform.timeElapsed + \" ms     \"\n\
                ).padStart(16, \" \") +\n\
                String(\n\
                    testPlatform.testsFailed + \" failed \"\n\
                ).padStart(16, \" \") +\n\
                String(\n\
                    testPlatform.testsPassed + \" passed \"\n\
                ).padStart(16, \" \") +\n\
                \"     |\\n\" + new Array(56).join(\"-\") + \"\\n\"\n\
            );\n\
        }).join(\"\")\n\
    );\n\
    // print failed testCase\n\
    testPlatformList.forEach(function (testPlatform) {\n\
        testPlatform.testCaseList.forEach(function (testCase) {\n\
            if (testCase.status !== \"passed\") {\n\
                console.error(JSON.stringify(testCase, undefined, 4));\n\
            }\n\
        });\n\
    });\n\
    // jslint html\n\
    jslintAndPrint(html, \"test-report.html\");\n\
    // create test-report.html\n\
    fileWrite(\"test-report.html\", html);\n\
    // create commit.badge.svg\n\
    fileWrite(\"commit.badge.svg\", local.svgBadgeCreate({\n\
        fill: \"#07f\",\n\
        str1: \"last build\",\n\
        str2: (\n\
            new Date().toISOString().slice(0, 19).replace(\"T\", \" \") +\n\
            \" - \" + CI_BRANCH + \" - \" + CI_COMMIT_ID\n\
        )\n\
    }));\n\
    // create test-report.badge.svg\n\
    fileWrite(\"test-report.badge.svg\", local.svgBadgeCreate({\n\
        fill: (\n\
            testPlatformList[0].testsFailed\n\
            ? \"#d00\"\n\
            : \"#0d0\"\n\
        ),\n\
        str1: \"tests failed\",\n\
        str2: testPlatformList[0].testsFailed\n\
    }));\n\
    // if tests failed, then exit with non-zero exitCode\n\
    process.exit(testReport.testsFailed !== 0);\n\
};\n\
\n\
local.testRunDefault = async function (testCaseDict = {}) {\n\
/*\n\
 * this function will run tests in <testCaseDict>\n\
 */\n\
    let consoleError;\n\
    let isCoverage;\n\
    let processExit;\n\
    let testPlatform;\n\
    let testReport;\n\
    let timerInterval;\n\
    function timeElapsedPoll(opt) {\n\
    /*\n\
     * this function will poll \"Date.now() - <opt>.timeStart\"\n\
     */\n\
        opt.timeStart = opt.timeStart || Date.now();\n\
        opt.timeElapsed = Date.now() - opt.timeStart;\n\
    }\n\
    async function testCaseRun(testCase) {\n\
        let testCasePromise;\n\
        let testCaseResolve;\n\
        testCasePromise = new Promise(function (resolve) {\n\
            testCaseResolve = resolve;\n\
        });\n\
        function onError(err) {\n\
            // update testPlatform.timeElapsed\n\
            timeElapsedPoll(testPlatform);\n\
            // if testCase isDone, then fail testCase\n\
            if (testCase.isDone) {\n\
                err = err || new Error(\n\
                    \"callback in testCase \" +\n\
                    testCase.name +\n\
                    \" called multiple times\"\n\
                );\n\
            }\n\
            // if err occurred, then fail testCase\n\
            if (err) {\n\
                // restore console.log\n\
                console.error = consoleError;\n\
                testCase.status = \"failed\";\n\
                consoleError(\n\
                    \"\\ntestRunDefault - \" +\n\
                    testPlatform.timeElapsed + \" ms - testCase failed - \" +\n\
                    testCase.name + \"\\n\" + err.message + \"\\n\" + err.stack\n\
                );\n\
                testCase.errStack = (\n\
                    testCase.errStack || err.message + \"\\n\" + err.stack\n\
                );\n\
                // validate errStack is non-empty\n\
                assertOrThrow(\n\
                    testCase.errStack,\n\
                    \"invalid errStack \" + testCase.errStack\n\
                );\n\
            }\n\
            // if tests isDone, then do nothing\n\
            if (testCase.isDone) {\n\
                return;\n\
            }\n\
            testCase.isDone = true;\n\
            if (testCase.status === \"pending\") {\n\
                testCase.status = \"passed\";\n\
            }\n\
            // stop testCase timer\n\
            timeElapsedPoll(testCase);\n\
            consoleError(\n\
                \"testRunDefault - \" +\n\
                testPlatform.timeElapsed + \" ms - [\" + (\n\
                    isEnvNode\n\
                    ? \"node\"\n\
                    : \"browser\"\n\
                ) + \" test-case \" +\n\
                testPlatform.testCaseList.filter(function (testCase) {\n\
                    return testCase.isDone;\n\
                }).length + \" of \" + testPlatform.testCaseList.length\n\
                + \" \" + testCase.status + \"] - \" + testCase.name\n\
            );\n\
            testCaseResolve();\n\
        }\n\
        try {\n\
            timeElapsedPoll(testCase);\n\
            testCase.onTestCase({}, onError);\n\
            noop(await testCasePromise);\n\
        } catch (errCaught) {\n\
            onError(errCaught);\n\
        }\n\
    }\n\
    if (npm_config_mode_lib) {\n\
        return;\n\
    }\n\
    // init middlewareList\n\
    local.middlewareList = local.middlewareList || [];\n\
    // init http-server on $PORT\n\
    if (isEnvNode && !globalThis.utility2_serverHttp1) {\n\
        globalThis.utility2_serverHttp1 = require(\"http\").createServer(\n\
            local.serverRequestListener\n\
        );\n\
        console.error(\"http-server listening on port \" + PORT);\n\
        local.onReadyIncrement();\n\
        globalThis.utility2_serverHttp1.listen(PORT, local.onReadyDecrement);\n\
    }\n\
    globalThis.utility2_modeTest = (\n\
        globalThis.utility2_modeTest ||\n\
        testCaseDict.modeTest ||\n\
        npm_config_mode_test\n\
    ) | 0;\n\
    if (\n\
        globalThis.utility2_modeTest !== 1 ||\n\
        Object.keys(testCaseDict).length === 0\n\
    ) {\n\
        return;\n\
    }\n\
    if (localOnReadyCnt !== 0) {\n\
        local.eventListenerAdd(\"utility2.onReady\", {\n\
            once: true\n\
        }, local.testRunDefault.bind(undefined, testCaseDict));\n\
        return;\n\
    }\n\
    globalThis.utility2_modeTest += 1;\n\
    // visual notification - testRun\n\
    // mock console.error\n\
    consoleError = console.error;\n\
    isCoverage = (\n\
        typeof globalThis.__coverage__ === \"object\" &&\n\
        globalThis.__coverage__ &&\n\
        Object.keys(globalThis.__coverage__).length\n\
    );\n\
    console.error = function (...argList) {\n\
    /*\n\
     * this function will ignore serverLog-msg during test-run\n\
     */\n\
        if (!isCoverage && !(\n\
            /^serverLog\\u0020-\\u0020\\{/\n\
        ).test(argList[0])) {\n\
            consoleError(...argList);\n\
        }\n\
    };\n\
    // mock proces.exit\n\
    if (isEnvNode) {\n\
        processExit = process.exit;\n\
        process.exit = function (exitCode) {\n\
            local.eventListenerEmit(\n\
                \"utility2.testRunMock.process.exit\",\n\
                exitCode | 0\n\
            );\n\
        };\n\
    }\n\
    // init testReport\n\
    testReport = globalThis.utility2_testReport;\n\
    // init testPlatform\n\
    testPlatform = testReport.testPlatformList[0];\n\
    // init testPlatform timer\n\
    timeElapsedPoll(testPlatform);\n\
    // reset testPlatform.testCaseList\n\
    testPlatform.testCaseList.length = 0;\n\
    // add tests into testPlatform.testCaseList\n\
    Object.entries(testCaseDict).forEach(function ([\n\
        key, val\n\
    ]) {\n\
        // add testCase testCaseDict[key] to testPlatform.testCaseList\n\
        if (\n\
            key && typeof val === \"function\" && (\n\
                npm_config_mode_test_case\n\
                ? npm_config_mode_test_case.split(\",\").indexOf(key) >= 0\n\
                : key.indexOf(\"testCase_\") === 0\n\
            )\n\
        ) {\n\
            testPlatform.testCaseList.push({\n\
                name: key,\n\
                status: \"pending\",\n\
                onTestCase: val\n\
            });\n\
        }\n\
    });\n\
    local.testReportMerge(testReport);\n\
    local.eventListenerEmit(\"utility2.testRunStart\", testReport);\n\
    // testRunUpdate every 2000 ms until isDone\n\
    timerInterval = setInterval(function () {\n\
        // update testPlatform.timeElapsed\n\
        timeElapsedPoll(testPlatform);\n\
        local.testReportMerge(testReport);\n\
        local.eventListenerEmit(\"utility2.testRunUpdate\", testReport);\n\
        // cleanup timerInterval\n\
        if (!testReport.testsPending) {\n\
            clearInterval(timerInterval);\n\
        }\n\
        // list pending testCase every 5000 ms\n\
        if (testPlatform.timeElapsed % 5000 < 3000) {\n\
            consoleError(\n\
                \"testRunDefault - \" +\n\
                testPlatform.timeElapsed + \" ms - testCase pending - \" +\n\
                testPlatform.testCaseList.filter(function (testCase) {\n\
                    return testCase.status === \"pending\";\n\
                }).slice(0, 4).map(function (testCase) {\n\
                    return testCase.name;\n\
                }).join(\", \") + \" ...\"\n\
            );\n\
        }\n\
    }, 2000);\n\
    // run testCaseList\n\
    await Promise.all(testPlatform.testCaseList.map(testCaseRun));\n\
    clearInterval(timerInterval);\n\
    // update timeElapsed\n\
    timeElapsedPoll(testPlatform);\n\
    // finalize testReport\n\
    local.testReportMerge(testReport);\n\
    // restore console.log\n\
    console.error = consoleError;\n\
    // restore process.exit\n\
    if (processExit) {\n\
        process.exit = processExit;\n\
    }\n\
    // create test-report.json\n\
    delete testReport.coverage;\n\
    local.fsWriteFileWithMkdirpSync(\n\
        UTILITY2_DIR_BUILD + \"/test-report.json\",\n\
        JSON.stringify(testReport, undefined, 4)\n\
    );\n\
    // reset utility2_modeTest\n\
    globalThis.utility2_modeTest = 0;\n\
    // save testReport and coverage\n\
    testReport.coverage = globalThis.__coverage__;\n\
    console.timeStamp(globalThis.utility2_testId);\n\
    local.eventListenerEmit(\"utility2.testRunEnd\", testReport);\n\
    // exit with number of tests failed\n\
    if (processExit) {\n\
        process.exit(testReport.testsFailed, testReport);\n\
    }\n\
};\n\
\n\
local.tryCatchOnError = function (fnc, onError) {\n\
/*\n\
 * this function will run <fnc> in tryCatch block,\n\
 * else call onError with errCaught\n\
 */\n\
    let result;\n\
    // validate onError\n\
    local.assertOrThrow(typeof onError === \"function\", typeof onError);\n\
    try {\n\
        // reset errCaught\n\
        delete local._debugTryCatchError;\n\
        result = fnc();\n\
        delete local._debugTryCatchError;\n\
        return result;\n\
    } catch (errCaught) {\n\
        // debug errCaught\n\
        local._debugTryCatchError = errCaught;\n\
        return onError(errCaught);\n\
    }\n\
};\n\
\n\
local.uiAnimateSlideAccordian = function (elem, elemList, onError) {\n\
/*\n\
 * this function will slideDown <elem>, but slideUp elements in <elemList>\n\
 */\n\
    elemList.forEach(function (elem2) {\n\
        if (elem2 !== elem) {\n\
            local.uiAnimateSlideUp(elem2);\n\
        }\n\
    });\n\
    setTimeout(function () {\n\
        local.uiAnimateSlideDown(elem, onError);\n\
    }, 250);\n\
};\n\
\n\
local.uiAnimateSlideDown = function (elem, onError) {\n\
/*\n\
 * this function will slideDown dom-<elem>\n\
 */\n\
    onError = onError || noop;\n\
    if (!(\n\
        elem &&\n\
        elem.style && elem.style.maxHeight !== \"100%\" &&\n\
        elem.classList && elem.classList.contains(\"uiAnimateSlide\")\n\
    )) {\n\
        onError();\n\
        return;\n\
    }\n\
    elem.style.borderBottom = \"\";\n\
    elem.style.borderTop = \"\";\n\
    elem.style.marginBottom = \"\";\n\
    elem.style.marginTop = \"\";\n\
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + \"px\";\n\
    elem.style.paddingBottom = \"\";\n\
    elem.style.paddingTop = \"\";\n\
    setTimeout(function () {\n\
        elem.style.maxHeight = \"100%\";\n\
        onError();\n\
    }, 250);\n\
};\n\
\n\
local.uiAnimateSlideUp = function (elem, onError) {\n\
/*\n\
 * this function will slideUp dom-<elem>\n\
 */\n\
    if (!(\n\
        elem &&\n\
        elem.style && elem.style.maxHeight !== \"0px\" &&\n\
        elem.classList && elem.classList.contains(\"uiAnimateSlide\")\n\
    )) {\n\
        local.setTimeoutOnError(onError);\n\
        return;\n\
    }\n\
    elem.style.borderBottom = \"0\";\n\
    elem.style.borderTop = \"0\";\n\
    elem.style.marginBottom = \"0\";\n\
    elem.style.marginTop = \"0\";\n\
    elem.style.maxHeight = \"0\";\n\
    elem.style.paddingBottom = \"0\";\n\
    elem.style.paddingTop = \"0\";\n\
    local.setTimeoutOnError(onError, 250);\n\
};\n\
\n\
local.urlJoin = function (aa, bb) {\n\
/*\n\
 * this function will if bb is relative, url-join aa with bb\n\
 */\n\
    // bb is absolute-url\n\
    if ((\n\
        /^\\w+?:\\/\\//\n\
    ).test(bb)) {\n\
        return bb;\n\
    }\n\
    // bb is absolute-url without protocol\n\
    if (bb.slice(0, 2) === \"//\") {\n\
        return aa.split(\"/\")[0] + bb;\n\
    }\n\
    // bb is absolute-url without host\n\
    if (bb[0] === \"/\") {\n\
        return aa.split(\"/\").slice(0, 3).join(\"/\") + bb;\n\
    }\n\
    // bb is relative-url\n\
    if (aa.split(\"/\").length < 4) {\n\
        aa += \"/\";\n\
    }\n\
    return aa.replace((\n\
        /[?#].*?$/\n\
    ), \"\").replace((\n\
        /[^\\/]*?$/\n\
    ), \"\") + bb;\n\
};\n\
\n\
local.uuid4Create = function () {\n\
/*\n\
 * this function will create random uuid with format\n\
 * \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\"\n\
 */\n\
    // code derived from http://jsperf.com/uuid4\n\
    let id;\n\
    let ii;\n\
    id = \"\";\n\
    ii = 0;\n\
    while (ii < 32) {\n\
        switch (ii) {\n\
        case 8:\n\
        case 20:\n\
            id += \"-\";\n\
            // coerce to finite integer\n\
            id += local.identity((Math.random() * 16) | 0).toString(16);\n\
            break;\n\
        case 12:\n\
            id += \"-\";\n\
            id += \"4\";\n\
            break;\n\
        case 16:\n\
            id += \"-\";\n\
            id += local.identity((Math.random() * 4) | 8).toString(16);\n\
            break;\n\
        default:\n\
            // coerce to finite integer\n\
            id += local.identity((Math.random() * 16) | 0).toString(16);\n\
        }\n\
        ii += 1;\n\
    }\n\
    return id;\n\
};\n\
\n\
/* validateLineSortedReset */\n\
// run shared js-env code - init-after\n\
// init utility2_testReport\n\
globalThis.utility2_testReport = local.testReportMerge(\n\
    globalThis.utility2_testReport\n\
);\n\
local.regexpCharsetEncodeUri = (\n\
    /!#\\$%&'\\(\\)\\*\\+,-\\.\\/0123456789:;=\\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/\n\
);\n\
local.regexpCharsetEncodeUriComponent = (\n\
    /!%'\\(\\)\\*-\\.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/\n\
);\n\
// https://www.w3.org/TR/html5/sec-forms.html#email-state-typeemail\n\
local.regexpValidateEmail = (\n\
    /^[a-zA-Z0-9.!#$%&'*+\\/=?\\^_`{|}~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?)*$/\n\
);\n\
// https://en.wikipedia.org/wiki/E.164\n\
local.regexpValidatePhone = (\n\
    /^(?:\\+\\d{1,3}[\\u0020\\-]?)?(?:\\(\\d{1,4}\\)[\\u0020\\-]?)?\\d[\\d\\u0020\\-]{7,17}$/\n\
);\n\
local.regexpValidateUuid = (\n\
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/\n\
);\n\
local.stringCharsetAscii = (\n\
    \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +\n\
    \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" +\n\
    \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" +\n\
    \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +\n\
    \" !\\\"#$%&'()*+,-./0123456789:;<=>?\" +\n\
    \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\" +\n\
    \"`abcdefghijklmnopqrstuvwxyz{|}~\\u007f\"\n\
);\n\
assertJsonEqual(\n\
    local.stringCharsetAscii,\n\
    Array.from(new Array(128), function (ignore, ii) {\n\
        return String.fromCharCode(ii);\n\
    }).join(\"\")\n\
);\n\
local.stringCharsetEncodeUri = (\n\
    \"!#$%&'()*+,-./\" +\n\
    \"0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\"\n\
);\n\
local.stringCharsetEncodeUriComponent = (\n\
    \"!%'()*-.\" +\n\
    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\"\n\
);\n\
local.stringHelloEmoji = \"hello \\ud83d\\ude01\\n\";\n\
\n\
\n\
/* istanbul ignore next */\n\
// run node js-env code - init-after\n\
(function () {\n\
if (!isEnvNode) {\n\
    return;\n\
}\n\
// exit after $npm_config_timeout_exit\n\
if (!npm_config_mode_lib && npm_config_timeout_exit) {\n\
    setTimeout(process.exit.bind(undefined, 15), npm_config_timeout_exit);\n\
}\n\
// merge previous test-report\n\
if (!npm_config_mode_lib && npm_config_mode_test_report_merge) {\n\
    local.testReportMerge(\n\
        globalThis.utility2_testReport,\n\
        local.fsReadFileOrDefaultSync(\n\
            UTILITY2_DIR_BUILD + \"/test-report.json\",\n\
            \"json\",\n\
            {}\n\
        )\n\
    );\n\
    if (process.argv[2] !== \"--help\") {\n\
        console.error(\n\
            \"\\n\" + MODE_CI + \" - merged test-report from file \" +\n\
            UTILITY2_DIR_BUILD + \"/test-report.json\"\n\
        );\n\
    }\n\
}\n\
// init cli\n\
local.cliDict = {};\n\
local.cliDict[\"utility2.browserTest\"] = async function () {\n\
/*\n\
 * <urlList> <mode>\n\
 * will browser-test in parallel, comma-separated <urlList> with given <mode>\n\
 */\n\
    local.browserTest({\n\
        url: process.argv[3]\n\
    });\n\
};\n\
\n\
local.cliDict[\"utility2.testReportCreate\"] = function () {\n\
/*\n\
 *\n\
 * will create test-report\n\
 */\n\
    let testReport;\n\
    try {\n\
        testReport = JSON.parse(require(\"fs\").readFileSync(\n\
            UTILITY2_DIR_BUILD + \"/test-report.json\",\n\
            \"utf8\"\n\
        ));\n\
    } catch (ignore) {}\n\
    local.testReportMerge(testReport, {}, \"modeWrite\");\n\
};\n\
\n\
if (module === require.main && (!globalThis.utility2_rollup || (\n\
    process.argv[2] &&\n\
    local.cliDict[process.argv[2]] &&\n\
    process.argv[2].indexOf(\"utility2.\") === 0\n\
))) {\n\
    local.cliRun({});\n\
    if (local.cliDict[process.argv[2]]) {\n\
        switch (process.argv[2]) {\n\
        case \"--interactive\":\n\
        case \"-i\":\n\
        case \"utility2.start\":\n\
            break;\n\
        default:\n\
            return;\n\
        }\n\
    }\n\
}\n\
// override assets\n\
if (globalThis.utility2_rollup) {\n\
    local.assetsDict[\"/assets.utility2.rollup.js\"] = (\n\
        require(\"fs\").readFileSync(\n\
            __filename,\n\
            \"utf8\"\n\
        ).split(\"\\n/* script-end /assets.utility2.rollup.end.js */\")[0] +\n\
        \"\\n/* script-end /assets.utility2.rollup.end.js */\\n\"\n\
    );\n\
    return;\n\
}\n\
// init assets\n\
[\n\
    \"/assets.utility2.example.js\",\n\
    \"/assets.utility2.html\",\n\
    \"/assets.utility2.test.js\",\n\
    \"lib.apidoc.js\",\n\
    \"lib.istanbul.js\",\n\
    \"lib.jslint.js\",\n\
    \"lib.marked.js\",\n\
    \"lib.utility2.js\",\n\
    \"test.js\"\n\
].forEach(function (key) {\n\
    switch (key) {\n\
    case \"/assets.utility2.example.js\":\n\
        local.assetsDict[key] = \"\";\n\
        local.fsReadFileOrDefaultSync(\n\
            __dirname + \"/README.md\",\n\
            \"utf8\",\n\
            \"\"\n\
        ).replace((\n\
            /```javascript([\\S\\s]*?)```/\n\
        ), function (ignore, match1) {\n\
            local.assetsDict[key] = match1.trim() + \"\\n\";\n\
            return \"\";\n\
        });\n\
        break;\n\
    case \"/assets.utility2.html\":\n\
        local.assetsDict[key] = \"\";\n\
        local.fsReadFileOrDefaultSync(\n\
            __dirname + \"/README.md\",\n\
            \"utf8\",\n\
            \"\"\n\
        ).replace((\n\
            /<!doctype\\u0020html>[\\S\\s]*?<\\/html>\\\\n\\\\\\n/\n\
        ), function (match0) {\n\
            match0 = match0.replace((\n\
                /\\\\n\\\\$|\\\\(.)/gm\n\
            ), function (ignore, match1) {\n\
                return match1 || \"\";\n\
            });\n\
            match0 = match0.replace(\n\
                \"<script src=\\\"assets.app.js\\\"></script>\\n\",\n\
                (\n\
                    \"<script \" +\n\
                    \"src=\\\"assets.utility2.rollup.js\\\"></script>\\n\" +\n\
                    \"<script \" +\n\
                    \"src=\\\"assets.utility2.example.js\\\"></script>\\n\" +\n\
                    \"<script \" +\n\
                    \"src=\\\"assets.utility2.test.js\\\"></script>\\n\"\n\
                )\n\
            );\n\
            match0 = match0.replace(\n\
                \"assets.example.js\",\n\
                \"assets.utility2.example.js\"\n\
            );\n\
            match0 = match0.replace(\n\
                \"assets.test.js\",\n\
                \"assets.utility2.test.js\"\n\
            );\n\
            match0 = match0.replace((\n\
                /npm_package_/g\n\
            ), \"\");\n\
            match0 = match0.replace((\n\
                /<!--\\u0020utility2-comment\\b([\\S\\s]*?)\\butility2-comment\\u0020-->/g\n\
            ), \"$1\");\n\
            return \"\";\n\
        });\n\
        break;\n\
    case \"/assets.utility2.test.js\":\n\
        local.assetsDict[key] = local.fsReadFileOrDefaultSync(\n\
            __dirname + \"/test.js\",\n\
            \"utf8\",\n\
            \"\"\n\
        );\n\
        break;\n\
    case \"lib.utility2.js\":\n\
        key = key.replace(\"lib.\", \"\");\n\
        local.assetsDict[\"/assets.\" + key] = local.fsReadFileOrDefaultSync(\n\
            __dirname + \"/lib.\" + key,\n\
            \"utf8\",\n\
            \"\"\n\
        ).replace((\n\
            /^#!\\//\n\
        ), \"// \");\n\
        break;\n\
    default:\n\
        local.assetsDict[\"/assets.utility2.\" + key] = (\n\
            local.fsReadFileOrDefaultSync(\n\
                __dirname + \"/\" + key,\n\
                \"utf8\",\n\
                \"\"\n\
            ).replace((\n\
                /^#!\\//\n\
            ), \"// \")\n\
        );\n\
    }\n\
});\n\
/* validateLineSortedReset */\n\
local.assetsDict[\"/assets.utility2.rollup.js\"] = [\n\
    \"header\",\n\
    \"/assets.utility2.rollup.start.js\",\n\
    \"lib.apidoc.js\",\n\
    \"lib.istanbul.js\",\n\
    \"lib.jslint.js\",\n\
    \"lib.marked.js\",\n\
    \"lib.utility2.js\",\n\
    \"/assets.utility2.example.js\",\n\
    \"/assets.utility2.html\",\n\
    \"/assets.utility2.lib.jslint.js\",\n\
    \"/assets.utility2.test.js\",\n\
    \"/assets.utility2.rollup.end.js\"\n\
].map(function (key) {\n\
    let code;\n\
    switch (key) {\n\
    case \"/assets.utility2.example.js\":\n\
    case \"/assets.utility2.html\":\n\
    case \"/assets.utility2.lib.jslint.js\":\n\
    case \"/assets.utility2.test.js\":\n\
        // disable $-escape in replacement-string\n\
        code = local.assetsDict[\n\
            \"/assets.utility2.rollup.content.js\"\n\
        ].replace(\"/* utility2.rollup.js content */\", function () {\n\
            return (\n\
                \"local.assetsDict[\\\"\" + key + \"\\\"] = (\\n\" +\n\
                JSON.stringify(local.assetsDict[key]).replace((\n\
                    /\\\\\\\\/g\n\
                ), \"\\u0000\").replace((\n\
                    /\\\\n/g\n\
                ), \"\\\\n\\\\\\n\").replace((\n\
                    /\\u0000/g\n\
                ), \"\\\\\\\\\") +\n\
                \");\\n\"\n\
            );\n\
        });\n\
        break;\n\
    case \"/assets.utility2.rollup.start.js\":\n\
    case \"/assets.utility2.rollup.end.js\":\n\
        code = local.assetsDict[key];\n\
        break;\n\
    case \"header\":\n\
        return (\n\
            \"/* this rollup was created with utility2\\n\" +\n\
            \" * https://github.com/kaizhu256/node-utility2\\n\" +\n\
            \" */\\n\"\n\
        );\n\
    case \"lib.utility2.js\":\n\
        key = \"/assets.\" + key.replace(\"lib.\", \"\");\n\
        code = local.assetsDict[key];\n\
        break;\n\
    default:\n\
        key = \"/assets.utility2.\" + key;\n\
        code = local.assetsDict[key];\n\
    }\n\
    return (\n\
        \"/* script-begin \" + key + \" */\\n\" +\n\
        code.trim() +\n\
        \"\\n/* script-end \" + key + \" */\\n\"\n\
    );\n\
}).join(\"\\n\\n\\n\");\n\
}());\n\
}());\n\
}());\n\
");
// usr/bin/env node
/*
 * lib.utility2.js (2020.12.3)
 * https://github.com/kaizhu256/node-utility2
 * this zero-dependency package will provide high-level functions to to build, test, and deploy webapps
 *
 */


/* istanbul instrument in package utility2 */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    // globalThis.utility2_rollup_old ||
    // require("./assets.utility2.rollup.js") ||
    globalThis.globalLocal
);
// init exports
if (local.isEnvNode) {
    module.exports = local;
    module.exports.__dirname = __dirname;
} else {
    globalThis.utility2_utility2 = local;
}
// init lib main
local.utility2 = local;


/* validateLineSortedReset */
// bug-workaround - throw unhandledRejections in node-process
if (
    typeof process === "object" && process &&
    typeof process.on === "function" &&
    !process.unhandledRejections
) {
    process.unhandledRejections = "throw";
    process.on("unhandledRejection", function (err) {
        throw err;
    });
}
}());


(function () {
// init lib utility2
globalThis.utility2 = local;


// run shared js-env code - state
(function () {
    let packageJson;
    let state;
    // init state - default
    state = {
        apidocCreate: local.identity,
        coverageMerge: local.identity,
        coverageReportCreate: local.identity,
        instrumentInPackage: local.identity,
        jslintAndPrint: local.identity,
        jslintAndPrintDir: local.identity,
        npm_config_timeout: 30000,
        npm_package_description: "the greatest app in the world!",
        npm_package_name: "my-app",
        npm_package_version: "0.0.1"
    };
    // init state - utility2_state
    state = Object.assign(state, globalThis.utility2_state);
    // init state - package.json
    try {
        packageJson = JSON.parse(require("fs").readFileSync("package.json"));
        Object.entries(packageJson).forEach(function ([
            key, val
        ]) {
            state["npm_package_" + key] = String(val);
        });
        packageJson.repository.url.replace((
            /https:\/\/github\.com\/([^\/]+?\/[^.]+)/
        ), function (ignore, match1) {
            state.GITHUB_FULLNAME = match1;
            return "";
        });
    } catch (ignore) {}
    // init state - process.env
    state = Object.assign(
        state,
        (typeof process === "object" && process && process.env)
    );
    // init state - location.search
    if (
        typeof location === "object" && location &&
        typeof location.search === "string"
    ) {
        location.search.replace((
            /\b(npm_config_mode_test|npm_config_mode_test_case|npm_config_timeout)=([^&#]+)/g
        ), function (ignore, key, val) {
            state[key] = decodeURIComponent(val);
            return "";
        });
    }
    // init state - misc
    state = Object.assign({
        GITHUB_OWNER: String(state.GITHUB_FULLNAME).split("/")[0],
        GITHUB_REPO: String(state.GITHUB_FULLNAME).split("/")[1],
        UTILITY2_DIR_BUILD: (
            local.isEnvNode
            ? require("path").resolve(".tmp/build")
            : "/"
        ),
        npm_config_mode_test_case: "",
        npm_package_nameLib: String(state.npm_package_name).replace((
            /\W/g
        ), "_")
    }, state);
    state.npm_config_timeout |= 0;
    // init lib extra
    [
        "apidoc",
        "dummy",
        // cbranch-no cstat-no fstat-no missing-if-branch
        "istanbul",
        "jslint",
        "marked"
    ].forEach(function (key) {
        try {
            local[key] = (
                local.isEnvNode
                ? require("./lib." + key + ".js")
                : globalThis["utility2_" + key]
            );
        } catch (errCaught) {
            local.assertOrThrow(
                errCaught.code === "MODULE_NOT_FOUND",
                errCaught
            );
        }
        local[key] = local[key] || {};
        Object.assign(state, local[key]);
    });
    [
        "coverageReportCreate",
        "jslintAndPrintDir",
        "CI_BRANCH",
        "CI_COMMIT_ID",
        "CI_COMMIT_MESSAGE",
        "CI_HOST",
        "GITHUB_FULLNAME",
        "GITHUB_OWNER",
        "GITHUB_REPO",
        "HOME",
        "MODE_CI",
        "PATH",
        "PORT",
        "UTILITY2_DIR_BUILD",
        "apidocCreate",
        "coverageMerge",
        "instrumentInPackage",
        "jslintAndPrint",
        "npm_config_mode_auto_restart",
        "npm_config_mode_lib",
        "npm_config_mode_start",
        "npm_config_mode_test",
        "npm_config_mode_test_case",
        "npm_config_mode_test_report_merge",
        "npm_config_timeout",
        "npm_config_timeout_exit",
        "npm_package_description",
        "npm_package_homepage",
        "npm_package_main",
        "npm_package_name",
        "npm_package_nameHeroku",
        "npm_package_nameLib",
        "npm_package_nameOriginal",
        "npm_package_version"
    ].forEach(function (key) {
        local[key] = state[key];
    });
}());
let {
    assertJsonEqual,
    assertOrThrow,
    documentQuerySelectorAll,
    isEnvNode,
    noop,
    onErrorThrow,
    CI_BRANCH,
    CI_COMMIT_ID,
    CI_COMMIT_MESSAGE,
    CI_HOST,
    GITHUB_FULLNAME,
    GITHUB_OWNER,
    GITHUB_REPO,
    HOME,
    MODE_CI,
    PATH,
    PORT,
    UTILITY2_DIR_BUILD,
    apidocCreate,
    coverageMerge,
    instrumentInPackage,
    jslintAndPrint,
    npm_config_mode_auto_restart,
    npm_config_mode_lib,
    npm_config_mode_start,
    npm_config_mode_test,
    npm_config_mode_test_case,
    npm_config_mode_test_report_merge,
    npm_config_timeout,
    npm_config_timeout_exit,
    npm_package_description,
    npm_package_homepage,
    npm_package_main,
    npm_package_name,
    npm_package_nameHeroku,
    npm_package_nameLib,
    npm_package_nameOriginal,
    npm_package_version
} = local;


/* validateLineSortedReset */
// run shared js-env code - assetsDict
local.assetsDict = local.assetsDict || {};
local.assetsDict["/assets.utility2.header.js"] = (
    "// assets.utility2.header.js - start\n" +
    "/* jslint utility2:true */\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-local\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    let isEnvNode;\n" +
    "    let local;\n" +
    "    // init debugInline\n" +
    "    if (!globalThis.debugInline) {\n" +
    "        let consoleError;\n" +
    "        consoleError = console.error;\n" +
    "        globalThis.debugInline = function (...argList) {\n" +
    "        /*\n" +
    "         * this function will both print <argList> to stderr and\n" +
    "         * return <argList>[0]\n" +
    "         */\n" +
    "            consoleError(\"\\n\\ndebugInline\");\n" +
    "            consoleError(...argList);\n" +
    "            consoleError(\"\\n\");\n" +
    "            return argList[0];\n" +
    "        };\n" +
    "    }\n" +
    "    // init isEnvNode\n" +
    "    isEnvNode = (\n" +
    "        typeof process === \"object\" && process &&\n" +
    "        process.versions && typeof process.versions.node === " +
    "\"string\"\n" +
    "    );\n" +
    "    // init function\n" +
    "    function objectDeepCopyWithKeysSorted(obj) {\n" +
    "    /*\n" +
    "     * this function will recursively deep-copy <obj> with keys sorted\n" +
    "     */\n" +
    "        let sorted;\n" +
    "        if (typeof obj !== \"object\" || !obj) {\n" +
    "            return obj;\n" +
    "        }\n" +
    "        // recursively deep-copy list with child-keys sorted\n" +
    "        if (Array.isArray(obj)) {\n" +
    "            return obj.map(objectDeepCopyWithKeysSorted);\n" +
    "        }\n" +
    "        // recursively deep-copy obj with keys sorted\n" +
    "        sorted = {};\n" +
    "        Object.keys(obj).sort().forEach(function (key) {\n" +
    "            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);\n" +
    "        });\n" +
    "        return sorted;\n" +
    "    }\n" +
    "    function assertJsonEqual(aa, bb) {\n" +
    "    /*\n" +
    "     * this function will assert JSON.stringify(<aa>) === " +
    "JSON.stringify(<bb>)\n" +
    "     */\n" +
    "        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));\n" +
    "        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));\n" +
    "        if (aa !== bb) {\n" +
    "            throw new Error(JSON.stringify(aa) + \" !== \" + " +
    "JSON.stringify(bb));\n" +
    "        }\n" +
    "    }\n" +
    "    function assertOrThrow(passed, msg) {\n" +
    "    /*\n" +
    "     * this function will throw <msg> if <passed> is falsy\n" +
    "     */\n" +
    "        if (passed) {\n" +
    "            return;\n" +
    "        }\n" +
    "        throw (\n" +
    "            (\n" +
    "                msg &&\n" +
    "                typeof msg.message === \"string\" &&\n" +
    "                typeof msg.stack === \"string\"\n" +
    "            )\n" +
    "            // if msg is err, then leave as is\n" +
    "            ? msg\n" +
    "            : new Error(\n" +
    "                typeof msg === \"string\"\n" +
    "                // if msg is string, then leave as is\n" +
    "                ? msg\n" +
    "                // else JSON.stringify(msg)\n" +
    "                : JSON.stringify(msg, undefined, 4)\n" +
    "            )\n" +
    "        );\n" +
    "    }\n" +
    "    function documentQuerySelectorAll(selector) {\n" +
    "    /*\n" +
    "     * this function will return document.querySelectorAll(<selector>) " +
    "or\n" +
    "     * empty list if function is not available\n" +
    "     */\n" +
    "        return Array.from(\n" +
    "            (\n" +
    "                typeof document === \"object\" && document &&\n" +
    "                typeof document.querySelectorAll === \"function\"\n" +
    "            )\n" +
    "            ? document.querySelectorAll(selector)\n" +
    "            : []\n" +
    "        );\n" +
    "    }\n" +
    "    function identity(val) {\n" +
    "    /*\n" +
    "     * this function will return <val>\n" +
    "     */\n" +
    "        return val;\n" +
    "    }\n" +
    "    function noop() {\n" +
    "    /*\n" +
    "     * this function will do nothing\n" +
    "     */\n" +
    "        return;\n" +
    "    }\n" +
    "    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {\n" +
    "    /*\n" +
    "     * this function will if items from <tgt> are null, undefined, or\n" +
    "     * \"\", then overwrite them with items from <src>\n" +
    "     */\n" +
    "        function recurse(tgt, src, depth) {\n" +
    "            Object.entries(src).forEach(function ([\n" +
    "                key, bb\n" +
    "            ]) {\n" +
    "                let aa;\n" +
    "                aa = tgt[key];\n" +
    "                if (aa === undefined || aa === null || aa === \"\") {\n" +
    "                    tgt[key] = bb;\n" +
    "                    return;\n" +
    "                }\n" +
    "                if (\n" +
    "                    depth !== 0 &&\n" +
    "                    typeof aa === \"object\" && aa && " +
    "!Array.isArray(aa) &&\n" +
    "                    typeof bb === \"object\" && bb && " +
    "!Array.isArray(bb)\n" +
    "                ) {\n" +
    "                    recurse(aa, bb, depth - 1);\n" +
    "                }\n" +
    "            });\n" +
    "        }\n" +
    "        recurse(tgt, src, depth | 0);\n" +
    "        return tgt;\n" +
    "    }\n" +
    "    function onErrorThrow(err) {\n" +
    "    /*\n" +
    "     * this function will throw <err> if exists\n" +
    "     */\n" +
    "        if (err) {\n" +
    "            throw err;\n" +
    "        }\n" +
    "    }\n" +
    "    // init local\n" +
    "    local = {\n" +
    "        assertJsonEqual,\n" +
    "        assertOrThrow,\n" +
    "        documentQuerySelectorAll,\n" +
    "        identity,\n" +
    "        isEnvNode,\n" +
    "        local,\n" +
    "        noop,\n" +
    "        objectAssignDefault,\n" +
    "        objectDeepCopyWithKeysSorted,\n" +
    "        onErrorThrow\n" +
    "    };\n" +
    "    globalThis.globalLocal = local;\n" +
    "}());\n" +
    "// assets.utility2.header.js - end\n"
);
local.assetsDict["/assets.utility2.template.html"] = (
    "<!doctype html>\n" +
    "<html lang=\"en\">\n" +
    "<head>\n" +
    "<meta charset=\"utf-8\">\n" +
    "<meta\n" +
    "    content=\"width=device-width, initial-scale=1\"\n" +
    "    name=\"viewport\"\n" +
    ">\n" +
    "<!-- \"assets.utility2.template.html\" -->\n" +
    "<title>{{npm_package_name}} ({{npm_package_version}})</title>\n" +
    "<style>\n" +
    "/* jslint\u0020utility2:true */\n" +
    "/*csslint\n" +
    "*/\n" +
    "/* csslint ignore:start */\n" +
    "*,\n" +
    "*:after,\n" +
    "*:before {\n" +
    "    box-sizing: border-box;\n" +
    "}\n" +
    ".uiAnimateSlide {\n" +
    "    overflow-y: hidden;\n" +
    "    transition:\n" +
    "        max-height ease-in 250ms,\n" +
    "        min-height ease-in 250ms,\n" +
    "        padding-bottom ease-in 250ms,\n" +
    "        padding-top ease-in 250ms;\n" +
    "}\n" +
    "/* csslint ignore:end */\n" +
    "@keyframes uiAnimateSpin {\n" +
    "0% {\n" +
    "    transform: rotate(0deg);\n" +
    "}\n" +
    "100% {\n" +
    "    transform: rotate(360deg);\n" +
    "}\n" +
    "}\n" +
    "a {\n" +
    "    overflow-wrap: break-word;\n" +
    "}\n" +
    "body {\n" +
    "    background: #f7f7f7;\n" +
    "    font-family: Arial, Helvetica, sans-serif;\n" +
    "    font-size: small;\n" +
    "    margin: 0 40px;\n" +
    "}\n" +
    "body > div,\n" +
    "body > input,\n" +
    "body > pre,\n" +
    "body > .button,\n" +
    "body > .textarea {\n" +
    "    margin-bottom: 20px;\n" +
    "    margin-top: 0;\n" +
    "}\n" +
    "body > input,\n" +
    "body > .button {\n" +
    "    width: 20rem;\n" +
    "}\n" +
    "body > .readonly {\n" +
    "    background: #ddd;\n" +
    "}\n" +
    "body > .textarea {\n" +
    "    height: 10rem;\n" +
    "    resize: vertical;\n" +
    "    width: 100%;\n" +
    "}\n" +
    "code,\n" +
    "pre,\n" +
    ".textarea {\n" +
    "    font-family: Consolas, Menlo, monospace;\n" +
    "    font-size: smaller;\n" +
    "}\n" +
    "pre {\n" +
    "    overflow-wrap: break-word;\n" +
    "    white-space: pre-wrap;\n" +
    "}\n" +
    ".button {\n" +
    "    background: #ddd;\n" +
    "    border: 1px solid #999;\n" +
    "    color: #000;\n" +
    "    cursor: pointer;\n" +
    "    display: inline-block;\n" +
    "    padding: 2px 5px;\n" +
    "    text-align: center;\n" +
    "    text-decoration: none;\n" +
    "}\n" +
    ".button:hover {\n" +
    "    background: #bbb;\n" +
    "}\n" +
    ".colorError {\n" +
    "    color: #d00;\n" +
    "}\n" +
    ".textarea {\n" +
    "    background: #fff;\n" +
    "    border: 1px solid #999;\n" +
    "    border-radius: 0;\n" +
    "    cursor: auto;\n" +
    "    overflow: auto;\n" +
    "    padding: 2px;\n" +
    "}\n" +
    ".zeroPixel {\n" +
    "    border: 0;\n" +
    "    height: 0;\n" +
    "    margin: 0;\n" +
    "    padding: 0;\n" +
    "    width: 0;\n" +
    "}\n" +
    "</style>\n" +
    "</head>\n" +
    "<body>\n" +
    "<div class=\"uiAnimateSpin\" style=\"\n" +
    "    animation: uiAnimateSpin 2s linear infinite;\n" +
    "    border-radius: 50%;\n" +
    "    border-top: 5px solid #7d7;\n" +
    "    border: 5px solid #999;\n" +
    "    display: none;\n" +
    "    height: 25px;\n" +
    "    vertical-align: middle;\n" +
    "    width: 25px;\n" +
    "\"></div>\n" +
    "<script>\n" +
    "/* jslint\u0020utility2:true */\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    // polyfill globalThis\n" +
    "    window.globalThis = window;\n" +
    "    // measure-and-print time-elapsed for window.onload\n" +
    "    if (!window.domOnEventWindowOnloadTimeElapsed) {\n" +
    "        window.domOnEventWindowOnloadTimeElapsed = Date.now() + 100;\n" +
    "        window.addEventListener(\"load\", function () {\n" +
    "            setTimeout(function () {\n" +
    "                window.domOnEventWindowOnloadTimeElapsed = (\n" +
    "                    Date.now() -\n" +
    "                    window.domOnEventWindowOnloadTimeElapsed\n" +
    "                );\n" +
    "                console.error(\n" +
    "                    \"domOnEventWindowOnloadTimeElapsed = \" +\n" +
    "                    window.domOnEventWindowOnloadTimeElapsed\n" +
    "                );\n" +
    "            }, 100);\n" +
    "        });\n" +
    "    }\n" +
    "    // limit select-all within <pre tabIndex=\"0\"> elem\n" +
    "    if (!window.domOnEventSelectAllWithinPre) {\n" +
    "        window.domOnEventSelectAllWithinPre = function (evt) {\n" +
    "            let range;\n" +
    "            let selection;\n" +
    "            if (\n" +
    "                (evt.ctrlKey || evt.metaKey) &&\n" +
    "                evt.key === \"a\" &&\n" +
    "                evt.target.closest(\"pre\")\n" +
    "            ) {\n" +
    "                range = document.createRange();\n" +
    "                range.selectNodeContents(evt.target.closest(\"pre\"));\n" +
    "                selection = window.getSelection();\n" +
    "                selection.removeAllRanges();\n" +
    "                selection.addRange(range);\n" +
    "                evt.preventDefault();\n" +
    "            }\n" +
    "        };\n" +
    "        // handle evt\n" +
    "        document.addEventListener(\n" +
    "            \"keydown\",\n" +
    "            window.domOnEventSelectAllWithinPre\n" +
    "        );\n" +
    "    }\n" +
    "}());\n" +
    "</script>\n" +
    "<h1>\n" +
    "<a href=\"{{npm_package_homepage}}\" target=\"_blank\">\n" +
    "    {{npm_package_name}} ({{npm_package_version}})\n" +
    "</a>\n" +
    "</h1>\n" +
    "<h3>{{npm_package_description}}</h3>\n" +
    "<!-- utility2-comment\n" +
    "<a\n" +
    "    class=\"button\" download href=\"assets.app.js\"\n" +
    ">download standalone app</a><br>\n" +
    "<button\n" +
    "    class=\"button\"\n" +
    "    id=\"buttonTestRun1\"\n" +
    ">run browser-tests</button><br>\n" +
    "<div class=\"uiAnimateSlide\" id=\"htmlTestReport1\" style=\"\n" +
    "    border-bottom: 0;\n" +
    "    border-top: 0;\n" +
    "    margin-bottom: 0;\n" +
    "    margin-top: 0;\n" +
    "    max-height: 0;\n" +
    "    padding-bottom: 0;\n" +
    "    padding-top: 0;\n" +
    "\"></div>\n" +
    "utility2-comment -->\n" +
    "\n" +
    "\n" +
    "<!-- custom-html-start -->\n" +
    "<label>stderr and stdout</label>\n" +
    "<textarea\n" +
    "    class=\"onevent-output-reset readonly textarea\"\n" +
    "    id=\"outputStdout1\"\n" +
    "    readonly\n" +
    "></textarea>\n" +
    "<!-- custom-html-end -->\n" +
    "\n" +
    "\n" +
    "<!-- utility2-comment\n" +
    "<script>\n" +
    "window.utility2_state = {\n" +
    "npm_config_mode_backend: {{npm_config_mode_backend jsonStringify}},\n" +
    "npm_package_description: {{npm_package_description jsonStringify}},\n" +
    "npm_package_homepage: {{npm_package_homepage jsonStringify}},\n" +
    "npm_package_name: {{npm_package_name jsonStringify}},\n" +
    "npm_package_nameLib: {{npm_package_nameLib jsonStringify}},\n" +
    "npm_package_version: {{npm_package_version jsonStringify}}\n" +
    "}\n" +
    "</script>\n" +
    "<script src=\"assets.utility2.rollup.js\"></script>\n" +
    "<script>\n" +
    "/* jslint utility2:true */\n" +
    "window.utility2.onReadyIncrement();\n" +
    "window.addEventListener(\"load\", function () {\n" +
    "    \"use strict\";\n" +
    "    let local;\n" +
    "    function onTestRun({\n" +
    "        msg,\n" +
    "        target,\n" +
    "        type\n" +
    "    }) {\n" +
    "        switch ((target && target.id) || type) {\n" +
    "        case \"buttonTestRun1\":\n" +
    "            window.utility2_modeTest = 1;\n" +
    "            local.testRunDefault(window.local);\n" +
    "            return;\n" +
    "        case \"utility2.testRunEnd\":\n" +
    "            document.querySelectorAll(\n" +
    "                \"#buttonTestRun1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"run tests\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        case \"utility2.testRunStart\":\n" +
    "            document.querySelectorAll(\n" +
    "                \".onevent-output-reset\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#buttonTestRun1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                elem.textContent = \"running tests\";\n" +
    "            });\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                local.uiAnimateSlideDown(elem);\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        case \"utility2.testRunUpdate\":\n" +
    "            document.querySelectorAll(\n" +
    "                \"#htmlTestReport1\"\n" +
    "            ).forEach(function (elem) {\n" +
    "                local.uiAnimateSlideDown(elem);\n" +
    "                elem.innerHTML = msg.html;\n" +
    "            });\n" +
    "            return;\n" +
    "        }\n" +
    "    }\n" +
    "    local = window.utility2;\n" +
    "    document.querySelectorAll(\n" +
    "        \"#buttonTestRun1\"\n" +
    "    ).forEach(function (elem) {\n" +
    "        elem.addEventListener(\"click\", onTestRun);\n" +
    "    });\n" +
    "    local.eventListenerAdd(\"utility2.testRunEnd\", {}, onTestRun);\n" +
    "    local.eventListenerAdd(\"utility2.testRunUpdate\", {}, onTestRun);\n" +
    "    local.eventListenerAdd(\"utility2.testRunStart\", {}, onTestRun);\n" +
    "    local.onReadyDecrement();\n" +
    "});\n" +
    "</script>\n" +
    "utility2-comment -->\n" +
    "<script src=\"assets.{{npm_package_nameLib}}.js\"></script>\n" +
    "<script src=\"assets.example.js\"></script>\n" +
    "<script src=\"assets.test.js\"></script>\n" +
    "<div style=\"text-align: center;\">\n" +
    "    [\n" +
    "    this app was created with\n" +
    "    <a\n" +
    "        href=\"https://github.com/kaizhu256/node-utility2\"\n" +
    "        target=\"_blank\"\n" +
    "    >utility2</a>\n" +
    "    ]\n" +
    "</div>\n" +
    "</body>\n" +
    "</html>\n"
);
/* validateLineSortedReset */
local.assetsDict["/assets.example.html"] = "";
local.assetsDict["/assets.example.template.js"] = (
    "/*\n" +
    "example.js\n" +
    "\n" +
    "this script will run web-demo of my-app\n" +
    "\n" +
    "instruction\n" +
    "    1. save this script as example.js\n" +
    "    2. run shell-cmd:\n" +
    "        $ npm install my-app && \\\n" +
    "            PORT=8081 node example.js\n" +
    "    3. open browser to http://127.0.0.1:8081 and play with web-demo\n" +
    "    4. edit this script to suit your needs\n" +
    "*/\n" +
    "\n" +
    "\n" +
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = (\n" +
    "    globalThis.utility2_rollup ||\n" +
    "    globalThis.utility2_my_app ||\n" +
    "    require(\"my-app\")\n" +
    ");\n" +
    "// init exports\n" +
    "globalThis.local = local;\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run browser js\u002denv code - init-test\n" +
    "(function () {\n" +
    "if (local.isEnvNode) {\n" +
    "    return;\n" +
    "}\n" +
    "// log stderr and stdout to #outputStdout1\n" +
    "[\"error\", \"log\"].forEach(function (key) {\n" +
    "    let elem;\n" +
    "    let fnc;\n" +
    "    elem = document.querySelector(\"#outputStdout1\");\n" +
    "    if (!elem) {\n" +
    "        return;\n" +
    "    }\n" +
    "    fnc = console[key];\n" +
    "    console[key] = function (...argList) {\n" +
    "        fnc(...argList);\n" +
    "        // append text to #outputStdout1\n" +
    "        elem.textContent += argList.map(function (arg) {\n" +
    "            return (\n" +
    "                typeof arg === \"string\"\n" +
    "                ? arg\n" +
    "                : JSON.stringify(arg, undefined, 4)\n" +
    "            );\n" +
    "        }).join(\" \").replace((\n" +
    "            /\\u001b\\[\\d+?m/g\n" +
    "        ), \"\") + \"\\n\";\n" +
    "        // scroll textarea to bottom\n" +
    "        elem.scrollTop = elem.scrollHeight;\n" +
    "    };\n" +
    "});\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run node js\u002denv code - init-test\n" +
    "(function () {\n" +
    "if (!local.isEnvNode) {\n" +
    "    return;\n" +
    "}\n" +
    "// init exports\n" +
    "module.exports = local;\n" +
    "// init assetsDict\n" +
    "local.assetsDict = local.assetsDict || {};\n" +
    "local.assetsDict[\"/assets.my_app.js\"] = (\n" +
    "    local.assetsDict[\"/assets.my_app.js\"] ||\n" +
    "    require(\"fs\").readFileSync(\n" +
    "        require(\"path\").resolve(local.__dirname + " +
    "\"/lib.my_app.js\"),\n" +
    "        \"utf8\"\n" +
    "    ).replace((\n" +
    "        /^#!\\//\n" +
    "    ), \"// \")\n" +
    ");\n" +
    "/* validateLineSortedReset */\n" +
    "/* jslint ignore:start */\n" +
    "local.assetsDict[\"/\"] = `" +
    local.assetsDict["/assets.utility2.template.html"].replace((
        /[$\\`]/g
    ), "\\$&") +
    "`;\n" +
    "/* jslint ignore:end */\n" +
    "local.assetsDict[\"/assets.example.html\"] = local.assetsDict[\"/\"];\n" +
    "// init cli\n" +
    "if (module !== require.main || globalThis.utility2_rollup) {\n" +
    "    return;\n" +
    "}\n" +
    "local.assetsDict[\"/assets.example.js\"] = (\n" +
    "    local.assetsDict[\"/assets.example.js\"] ||\n" +
    "    require(\"fs\").readFileSync(__filename, \"utf8\")\n" +
    ");\n" +
    "local.assetsDict[\"/favicon.ico\"] = " +
    "local.assetsDict[\"/favicon.ico\"] || \"\";\n" +
    "local.assetsDict[\"/index.html\"] = local.assetsDict[\"/\"];\n" +
    "// if $npm_config_timeout_exit exists,\n" +
    "// then exit this process after $npm_config_timeout_exit ms\n" +
    "if (process.env.npm_config_timeout_exit) {\n" +
    "    setTimeout(\n" +
    "        process.exit.bind(undefined, 15),\n" +
    "        process.env.npm_config_timeout_exit | 0\n" +
    "    ).unref();\n" +
    "}\n" +
    "// start server\n" +
    "if (globalThis.utility2_serverHttp1) {\n" +
    "    return;\n" +
    "}\n" +
    "process.env.PORT = process.env.PORT || \"8081\";\n" +
    "console.error(\"http-server listening on port \" + process.env.PORT);\n" +
    "require(\"http\").createServer(function (req, res) {\n" +
    "    let data;\n" +
    "    data = local.assetsDict[require(\"url\").parse(req.url).pathname];\n" +
    "    if (data !== undefined) {\n" +
    "        res.end(data);\n" +
    "        return;\n" +
    "    }\n" +
    "    res.statusCode = 404;\n" +
    "    res.end();\n" +
    "}).listen(process.env.PORT);\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.my_app.template.js"] = (
    "#!/usr/bin/env node\n" +
    "/*\n" +
    " * lib.my_app.js ({{npm_package_version}})\n" +
    " * https://github.com/kaizhu256/node-my-app\n" +
    " * {{npm_package_description}}\n" +
    " *\n" +
    " */\n" +
    "\n" +
    "\n" +
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = (\n" +
    "    globalThis.utility2_rollup ||\n" +
    "    // globalThis.utility2_rollup_old ||\n" +
    "    // require(\"./assets.utility2.rollup.js\") ||\n" +
    "    globalThis.globalLocal\n" +
    ");\n" +
    "// init exports\n" +
    "if (local.isEnvNode) {\n" +
    "    module.exports = local;\n" +
    "    module.exports.__dirname = __dirname;\n" +
    "} else {\n" +
    "    globalThis.utility2_my_app = local;\n" +
    "}\n" +
    "// init lib main\n" +
    "local.my_app = local;\n" +
    "\n" +
    "\n" +
    "/* validateLineSortedReset */\n" +
    "return;\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.readme.template.md"] = String(
    "# my-app\n" +
    "the greatest app in the world!\n" +
    "\n" +
    "# live web demo\n" +
    "- [{{app.io}}/build..beta..github.com/app]" +
    "({{app.io}}/build..beta..github.com/app)\n" +
    "\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})]" +
    "({{app.io}}/build..beta..github.com/app)\n" +
    "\n" +
    "\n" +
    "[![github.com ci-status]" +
    "(https://github.com/kaizhu256/node-my-app/workflows/" +
    "Node.js%20CI/badge.svg)]" +
    "(https://github.com/kaizhu256/node-my-app/actions) " +
    "[![coverage]" +
    "({{app.io}}/build/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build/coverage/index.html)\n" +
    "\n" +
    "[![NPM]" +
    "(https://nodei.co/npm/my-app.png?downloads=true)]" +
    "(https://www.npmjs.com/package/my-app)\n" +
    "\n" +
    "[![commit status]" +
    "({{app.io}}/build/commit.badge.svg)]" +
    "(https://github.com/kaizhu256/node-my-app/actions)\n" +
    "\n" +
    "| git-branch : | " +
    "[master]" +
    "({{app.com}}/tree/master) | " +
    "[beta]" +
    "({{app.com}}/tree/beta) | " +
    "[alpha]" +
    "({{app.com}}/tree/alpha)|\n" +
    "|--:|:--|:--|:--|\n" +
    "| test-server-github : | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..master..github.com/app) | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..beta..github.com/app) | " +
    "[![github.com test-server]" +
    "({{app.io}}/GitHub-Mark-32px.png)]" +
    "({{app.io}}/build..alpha..github.com/app)|\n" +
    "| test-server-heroku : | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-master.herokuapp.com) | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-beta.herokuapp.com) | " +
    "[![heroku.com test-server]" +
    "({{app.io}}/heroku-logo.75x25.png)]" +
    "(https://h1-my-app-alpha.herokuapp.com)|\n" +
    "| test-report : | " +
    "[![test-report]" +
    "({{app.io}}/build..master..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..master..github.com/test-report.html) | " +
    "[![test-report]" +
    "({{app.io}}/build..beta..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..beta..github.com/test-report.html) | " +
    "[![test-report]" +
    "({{app.io}}/build..alpha..github.com/test-report.badge.svg)]" +
    "({{app.io}}/build..alpha..github.com/test-report.html)|\n" +
    "| coverage : | " +
    "[![coverage]" +
    "({{app.io}}/build..master..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..master..github.com/coverage/index.html) | " +
    "[![coverage]" +
    "({{app.io}}/build..beta..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..beta..github.com/coverage/index.html) | " +
    "[![coverage]" +
    "({{app.io}}/build..alpha..github.com/coverage/coverage.badge.svg)]" +
    "({{app.io}}/build..alpha..github.com/coverage/index.html)|\n" +
    "| build-artifacts : | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..master..github.com) | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..beta..github.com) | " +
    "[![build-artifacts]" +
    "({{app.io}}/glyphicons_144_folder_open.png)]" +
    "({{app.com}}/tree/gh-pages/build..alpha..github.com)|\n" +
    "\n" +
    "[![npmPackageListing]" +
    "({{app.io}}/build/screenshot.npmPackageListing.svg)]" +
    "({{app.com}})\n" +
    "\n" +
    "![npmPackageDependencyTree]" +
    "({{app.io}}/build/screenshot.npmPackageDependencyTree.svg)\n" +
    "\n" +
    "\n" +
    "# table of contents\n" +
    "\n" +
    "\n" +
    "# cdn download\n" +
    "- [{{app.io}}/build..beta..github.com/app/assets.my_app.js]" +
    "({{app.io}}/build..beta..github.com/app/assets.my_app.js)\n" +
    "\n" +
    "\n" +
    "# documentation\n" +
    "#### api doc\n" +
    "- [{{app.io}}/build..beta..github.com/apidoc.html]" +
    "({{app.io}}/build..beta..github.com/apidoc.html)\n" +
    "\n" +
    "[![apidoc]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)]" +
    "({{app.io}}/build..beta..github.com/apidoc.html)\n" +
    "\n" +
    "#### cli help\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.npmPackageCliHelp.svg)\n" +
    "\n" +
    "#### changelog 0.0.1\n" +
    "- update build\n" +
    "- none\n" +
    "\n" +
    "#### todo\n" +
    "- none\n" +
    "\n" +
    "\n" +
    "# quickstart standalone app\n" +
    "#### to run this example, follow instruction in script below\n" +
    "- [assets.app.js]" +
    "({{app.io}}/build..beta..github.com/app/assets.app.js)\n" +
    "```shell\n" +
    "# example.sh\n" +
    "\n" +
    "# this shell script will download and run web-demo of my-app " +
    "as standalone app\n" +
    "\n" +
    "# 1. download standalone app\n" +
    "curl -O {{app.io}}/build..beta..github.com/app/assets.app.js\n" +
    "# 2. run standalone app\n" +
    "PORT=8081 node ./assets.app.js\n" +
    "# 3. open browser to http://127.0.0.1:8081 and play with web-demo\n" +
    "# 4. edit file assets.app.js to suit your needs\n" +
    "```\n" +
    "\n" +
    "#### output from browser\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### output from shell\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.svg)\n" +
    "\n" +
    "\n" +
    "# quickstart example.js\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### to run this example, follow instruction in script below\n" +
    "- [example.js]" +
    "({{app.io}}/build..beta..github.com/example.js)\n" +
    "```javascript\n" +
    local.assetsDict["/assets.example.template.js"] +
    "```\n" +
    "\n" +
    "#### output from browser\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/app/assets.example.html)\n" +
    "\n" +
    "#### output from shell\n" +
    "![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.svg)\n" +
    "\n" +
    "\n" +
    "# extra screenshots\n" +
    "1. [{{app.io}}/build/{{screenshot}}apidoc.html.png]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)]" +
    "({{app.io}}/build/{{screenshot}}apidoc.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/{{screenshot}}coverage.lib.html.png]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)]" +
    "({{app.io}}/build/{{screenshot}}coverage.lib.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/{{screenshot}}test-report.html.png]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)]" +
    "({{app.io}}/build/{{screenshot}}test-report.html.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployGithub.{{app.png}}]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})]" +
    "({{app.io}}/build/screenshot.deployGithub.{{app.png}})\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployGithubTest.{{app.png}}]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})]" +
    "({{app.io}}/build/screenshot.deployGithubTest.{{app.png}})\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployHeroku.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.deployHeroku.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.deployHerokuTest.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.npmTest.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.npmTest.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleJs.browser.%252F.png)\n" +
    "\n" +
    "1. [{{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)]" +
    "({{app.io}}/build/screenshot.readmeEvalExampleSh.browser.%252F.png)\n" +
    "\n" +
    "\n" +
    "# package.json\n" +
    "```json\n" +
    "{\n" +
    "    \"!!jslint_utility2\": true,\n" +
    "    \"author\": \"kai zhu <kaizhu256@gmail.com>\",\n" +
    "    \"description\": \"the greatest app in the world!\",\n" +
    "    \"devDependencies\": {\n" +
    "        \"utility2\": \"kaizhu256/node-utility2#alpha\"\n" +
    "    },\n" +
    "    \"engines\": {\n" +
    "        \"node\": \">=12.0\"\n" +
    "    },\n" +
    "    \"fileCount\": 0,\n" +
    "    \"homepage\": \"{{app.com}}\",\n" +
    "    \"keywords\": [],\n" +
    "    \"license\": \"MIT\",\n" +
    "    \"main\": \"lib.my_app.js\",\n" +
    "    \"name\": \"my-app\",\n" +
    "    \"nameAliasPublish\": \"\",\n" +
    "    \"repository\": {\n" +
    "        \"type\": \"git\",\n" +
    "        \"url\": \"{{app.com}}.git\"\n" +
    "    },\n" +
    "    \"scripts\": {\n" +
    "        \"build-ci\": \"sh npm_scripts.sh\",\n" +
    "        \"env\": \"env\",\n" +
    "        \"eval\": \"sh npm_scripts.sh\",\n" +
    "        \"heroku-postbuild\": \"sh npm_scripts.sh\",\n" +
    "        \"postinstall\": \"sh npm_scripts.sh\",\n" +
    "        \"start\": \"sh npm_scripts.sh\",\n" +
    "        \"test\": \"sh npm_scripts.sh\",\n" +
    "        \"utility2\": \"sh npm_scripts.sh\"\n" +
    "    },\n" +
    "    \"version\": \"0.0.1\"\n" +
    "}\n" +
    "```\n" +
    "\n" +
    "\n" +
    "# changelog of last 50 commits\n" +
    "[![screenshot]" +
    "({{app.io}}/build/screenshot.gitLog.svg)]" +
    "({{app.com}}/commits)\n" +
    "\n" +
    "\n" +
    "# internal build script\n" +
    "- build_ci.sh\n" +
    "```shell\n" +
    "# build_ci.sh\n" +
    "\n" +
    "# this shell script will run build-ci for this package\n" +
    "\n" +
    "shCiAfter () {(set -e\n" +
    "    # shDeployCustom\n" +
    "    shDeployGithub\n" +
    "    # shDeployHeroku\n" +
    "    shReadmeEval example.sh\n" +
    ")}\n" +
    "\n" +
    "shCiBefore () {(set -e\n" +
    "    # shNpmTestPublished\n" +
    "    shReadmeEval example.js\n" +
    ")}\n" +
    "\n" +
    "# run shCiMain\n" +
    "eval \"$(utility2 source)\"\n" +
    "shCiMain\n" +
    "```\n" +
    "\n" +
    "\n" +
    "# misc\n" +
    "- this package was created with [utility2]" +
    "(https://github.com/kaizhu256/node-utility2)\n"
).replace((
    /\{\{app\.com\}\}/g
), "https://github.com/kaizhu256/node-my-app").replace((
    /\{\{app\.io\}\}/g
), "https://kaizhu256.github.io/node-my-app").replace((
    /\{\{app.png\}\}/g
), "browser.%252Fnode-my-app%252Fbuild%252Fapp.png").replace((
    /\{\{screenshot\}\}/g
), "screenshot.ci.browser.%252F.tmp%252Fbuild%252F");
local.assetsDict["/assets.test.template.js"] = (
    "/* istanbul instrument in package my_app */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function (local) {\n" +
    "\"use strict\";\n" +
    "\n" +
    "\n" +
    "/* istanbul ignore next */\n" +
    "// run shared js\u002denv code - init-before\n" +
    "(function () {\n" +
    "// init local\n" +
    "local = globalThis.utility2 || require(\"utility2\");\n" +
    "local = local.requireReadme();\n" +
    "globalThis.local = local;\n" +
    "// init test\n" +
    "local.testRunDefault(local);\n" +
    "}());\n" +
    "\n" +
    "\n" +
    "// run shared js\u002denv code - function\n" +
    "(function () {\n" +
    "return;\n" +
    "}());\n" +
    "}());\n"
);
local.assetsDict["/assets.utility2.rollup.content.js"] = (
    "(function (local) {\n" +
    "    \"use strict\";\n" +
    "/* jslint ignore:start */\n" +
    "/* utility2.rollup.js content */\n" +
    "/* jslint ignore:end */\n" +
    "    return local;\n" +
    "}(globalThis.utility2_rollup));\n"
);
local.assetsDict["/assets.utility2.rollup.end.js"] = (
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    globalThis.utility2_rollup_old = globalThis.utility2_rollup;\n" +
    "    globalThis.utility2_rollup = null;\n" +
    "}());\n" +
    "/* utility2.rollup.js end */\n"
);
local.assetsDict["/assets.utility2.rollup.start.js"] = (
    "/* utility2.rollup.js begin */\n" +
    "/* istanbul ignore all */\n" +
    local.assetsDict["/assets.utility2.header.js"] +
    "\n" +
    "\n" +
    "/* jslint utility2:true */\n" +
    "(function () {\n" +
    "    \"use strict\";\n" +
    "    // init utility2_rollup\n" +
    "    globalThis.utility2_rollup = (\n" +
    "        globalThis.utility2_rollup_old\n" +
    "        || globalThis.globalLocal\n" +
    "    );\n" +
    "    globalThis.utility2_rollup.local = globalThis.utility2_rollup;\n" +
    "    globalThis.utility2_rollup_old = null;\n" +
    "}());\n"
);
local.assetsDict["/favicon.ico"] = "";


/* validateLineSortedReset */
// run shared js-env code - function
let localEventListenerDict;
let localEventListenerId;
let localOnReadyCnt;
localEventListenerDict = {};
localEventListenerId = 0;
localOnReadyCnt = 0;

local._testCase_buildApidoc_default = function (opt, onError) {
/*
 * this function will test buildApidoc's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    function require2(file) {
    /*
     * this function will require <file> in sandbox-env
     */
        let exports;
        let mockDict;
        let mockList;
        mockList = [
            [
                globalThis, {
                    setImmediate: noop,
                    setInterval: noop,
                    setTimeout: noop
                }
            ]
        ];
        // disable io and side-effect
        [
            process,
            process.stdin,
            process.stdout,
            require("child_process"),
            require("cluster"),
            require("crypto"),
            require("dgram"),
            require("dns"),
            require("domain"),
            require("events").prototype,
            require("http"),
            require("https"),
            require("net"),
            require("os"),
            require("readline"),
            require("repl"),
            require("stream").prototype,
            require("timers"),
            require("tls"),
            require("tty"),
            require("util"),
            require("v8"),
            require("vm"),
            {
                // coverage-hack
                "__zjqx1234__": noop
            }
        ].forEach(function (dict) {
            mockDict = {};
            Object.keys(dict).forEach(function (key) {
                if (typeof dict[key] === "function" && (
                    // coverage-hack
                    key === "__zjqx1234__" ||
                    npm_config_mode_test_case === "testCase_buildApidoc_default"
                )) {
                    mockDict[key] = noop;
                }
            });
            mockList.push([
                dict, mockDict
            ]);
        });
        local.testMock(mockList, function (onError) {
            try {
                exports = require(file);
            } catch (errCaught) {
                console.error(errCaught);
            }
            onError();
        }, onErrorThrow);
        return exports;
    }
    // coverage-hack
    require2();
    // save apidoc.html
    local.fsWriteFileWithMkdirpSync(".tmp/build/apidoc.html", apidocCreate(
        Object.assign({
            blacklistDict: local,
            modeNoop: (
                npm_config_mode_test_case !== "testCase_buildApidoc_default"
            ),
            require: require2
        }, opt)
    ));
    onError();
};

local._testCase_buildApp_default = function (opt, onError) {
/*
 * this function will test buildApp's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    local.buildApp(opt, onError);
};

local._testCase_webpage_default = async function (opt, onError) {
/*
 * this function will test webpage's default handling-behavior
 */
    local.domQuerySelectorAllTagName("html");
    local.domStyleValidate();
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    await local.browserTest({
        url: (
            "http://127.0.0.1:" + PORT +
            "/?npm_config_mode_test=1&npm_config_timeout=" +
            npm_config_timeout +
            "&npm_config_mode_test_case=" + npm_config_mode_test_case.replace((
                /\b_?testCase_webpage_default\b/
            ), "")
        )
    });
    onError(undefined, opt);
};

local.browserTest = async function ({
    modeSilent,
    modeWindowSize,
    url
}) {
/*
 * this function will spawn google-chrome-process to test <url>
 */
    let chromeClient;
    let chromeFrameId;
    let fileScreenshot;
    let isDone;
    let promiseScreenshot;
    let testErr;
    let testId;
    let testName;
    let testReport;
    let {
        chromeDevtoolsClientCreate,
        testReportMerge
    } = local;
    // node - init
    testId = Math.random().toString(16);
    testName = MODE_CI + ".browser." + encodeURIComponent(
        require("url").parse(url).pathname.replace(
            "/build.." + CI_BRANCH + ".." + CI_HOST,
            "/build"
        )
    );
    fileScreenshot = (
        UTILITY2_DIR_BUILD + "/screenshot." + testName + ".png"
    );
    chromeClient = await chromeDevtoolsClientCreate({
        modeSilent,
        modeWindowSize,
        timeout: npm_config_timeout
    });
    // init page
    chromeClient.rpc("Page.enable");
    chromeClient.rpc("Page.setLifecycleEventsEnabled", {
        enabled: true
    });
    chromeClient.rpc("Performance.enable");
    // load url
    chromeClient.rpc("Page.navigate", {
        url
    });
    chromeFrameId = (
        await chromeClient.rpc("Page.getFrameTree")
    ).frameTree.frame.id;
    await new Promise(function (resolve) {
        chromeClient.on("Page.lifecycleEvent", function onLoad({
            frameId,
            name
        }) {
            if (frameId === chromeFrameId && name === "load") {
                chromeClient.removeListener("Page.lifecycleEvent", onLoad);
                resolve();
            }
        });
    });
    console.error("chrome-devtools - loaded - page " + url);
    // screenshot
    promiseScreenshot = new Promise(async function (resolve) {
        let data;
        await new Promise(function (resolve) {
            setTimeout(resolve, 100);
        });
        data = await chromeClient.rpc("Page.captureScreenshot", {
            format: "png"
        });
        await require("fs").promises.writeFile(
            fileScreenshot,
            Buffer.from(data.data, "base64")
        );
        console.error("chrome-devtools - wrote - screenshot " + fileScreenshot);
        resolve();
    });
    chromeClient.evaluate(
        // coverage-hack
        "console.timeStamp();\n" +
        "window.utility2_testId=\"" + testId + "\";\n" +
        "if(!window.utility2_modeTest){\n" +
        "console.timeStamp(window.utility2_testId);\n" +
        "}\n"
    );
    testReport = await new Promise(function (resolve) {
        chromeClient.on("Performance.metrics", function ({
            title
        }) {
            if (isDone || title !== testId) {
                return;
            }
            isDone = true;
            resolve(chromeClient.evaluate(
                "JSON.stringify(\n" +
                "window.utility2_testReport\n" +
                "||{testPlatformList:[{}]}\n" +
                ");\n"
            ));
        });
    });
    testReport = JSON.parse(testReport);
    // init testErr
    testErr = testReport.testPlatformList[0].testsFailed && new Error(
        testReport.testPlatformList[0].testsFailed
    );
    // merge browser-screenshot
    testReport.testPlatformList[0].screenshot = fileScreenshot.replace((
        /.*\//
    ), "");
    // merge browser-coverage
    coverageMerge(globalThis.__coverage__, testReport.coverage);
    // merge browser-test-report
    testReportMerge(globalThis.utility2_testReport, testReport);
    // save test-report.json
    await require("fs").promises.writeFile(
        require("path").resolve(UTILITY2_DIR_BUILD + "/test-report.json"),
        JSON.stringify(globalThis.utility2_testReport)
    );
    console.error(
        "\nbrowserTest - merged test-report " +
        UTILITY2_DIR_BUILD + "/test-report.json" + "\n"
    );
    noop(await promiseScreenshot);
    // cleanup chromeClient
    chromeClient.destroy();
    onErrorThrow(testErr);
};

local.buildApp = function ({
    customizeAssetsList = [],
    customizeReadmeList = []
}, onError) {
/*
 * this function will build app
 */
    let assert;
    let fileDict;
    let packageJson;
    let packageNameLib;
    let port;
    let promiseList;
    let src;
    let tgt;
    assert = require("assert");
    function tgtReplaceConditional(conditional, replaceList) {
    /*
     * this function will conditionally replace <tgt> with replacements in
     * <replaceList>
     */
        replaceList.forEach(function ({
            aa,
            bb,
            merge
        }) {
            let isMatch;
            if (!conditional) {
                aa = aa || merge;
                console.error(
                    "buildApp - replace-skipped - " +
                    JSON.stringify((aa && aa.source) || aa)
                );
                return;
            }
            if (aa) {
                if (!tgt.match(aa)) {
                    console.error(
                        "buildApp - replace-unmatched - " +
                        JSON.stringify((aa && aa.source) || aa)
                    );
                    return;
                }
                tgt = tgt.replace(aa, bb);
                return;
            }
            src.replace(merge, function (match2) {
                tgt.replace(merge, function (match1) {
                    isMatch = true;
                    // disable $-escape in replacement-string
                    tgt = tgt.replace(match1, function () {
                        return match2;
                    });
                    return "";
                });
                return "";
            });
            if (!isMatch) {
                console.error(
                    "buildApp - replace-unmatched - " +
                    JSON.stringify(merge.source)
                );
            }
        });
    }
    function writeFileLog(file) {
    /*
     * this function will notify <file> written
     */
        console.error("buildApp - wrote - " + require("path").resolve(file));
    }
    function writeFile(file, data, resolve) {
    /*
     * this function will write <data> to <file> with notification
     */
        require("fs").writeFile(file, data, function (err) {
            onErrorThrow(err);
            writeFileLog(file);
            resolve();
        });
    }
    async function buildAppAssets(resolve) {
        // fetch assets
        await Promise.all([
            {
                url: "/LICENSE"
            }, {
                file: "/assets." + packageNameLib + ".html",
                url: "/index.html"
            }, {
                url: "/assets." + packageNameLib + ".css"
            }, {
                url: "/assets." + packageNameLib + ".js"
            }, {
                url: "/assets.app.js"
            }, {
                url: "/assets.example.html"
            }, {
                url: "/assets.example.js"
            }, {
                url: "/assets.test.js"
            }, {
                url: "/assets.utility2.html"
            }, {
                url: "/assets.utility2.lib.jslint.js"
            }, {
                url: "/assets.utility2.rollup.js"
            }, {
                url: "/index.html"
            }
        ].concat(customizeAssetsList).map(function ({
            file,
            url
        }) {
            return new Promise(function (resolve) {
                require("http").get((
                    "http://127.0.0.1:" + PORT + url
                ), function (res) {
                    let bufList;
                    assert.ok(res.statusCode === 200, url);
                    bufList = [];
                    res.on("data", function (chunk) {
                        bufList.push(chunk);
                    }).on("end", function () {
                        writeFile(
                            ".tmp/build/app/" + (file || url),
                            Buffer.concat(bufList),
                            resolve
                        );
                    });
                });
            });
        }));
        // jslint assets
        require("child_process").spawn("node", [
            "assets.utility2.lib.jslint.js", "dir", ".", "--conditional"
        ], {
            cwd: ".tmp/build/app",
            stdio: [
                "ignore", 1, 2
            ]
        }).on("exit", resolve);
    }
    async function buildAppStandalone(resolve) {
        let fileList;
        // write native-module
        fileList = await require("fs").promises.readdir(".");
        await Promise.all(fileList.map(function (file) {
            return new Promise(function (resolve) {
                if (require("path").extname(file) !== ".node") {
                    resolve();
                    return;
                }
                require("fs").copyFile(file, (
                    ".tmp/build/app.standalone/" + file
                ), function (err) {
                    onErrorThrow(err);
                    resolve();
                });
            });
        }));
        // write assets.app.js
        writeFile((
            ".tmp/build/app.standalone/assets.app.js"
        ), local.assetsDict["/assets.app.js"], function () {
            let child;
            // test-file assets.app.js
            child = require("child_process").spawn("node", [
                "assets.app.js"
            ], {
                cwd: ".tmp/build/app.standalone",
                env: {
                    HOME,
                    PATH,
                    PORT: port
                },
                stdio: [
                    "ignore", 1, 2
                ]
            }).on("exit", function (exitCode, signal) {
                assert.ok(!exitCode && signal === "SIGTERM", JSON.stringify({
                    exitCode,
                    signal
                }));
                resolve();
            });
            setTimeout(child.kill.bind(child, "SIGTERM"), 4000);
        });
    }
    function buildLib(resolve) {
        src = fileDict["lib." + packageNameLib + ".js"];
        // render lib.xxx.js
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.my_app.template.js"]
        );
        tgtReplaceConditional(true, [
            {
                // customize top-level comment-description
                merge: (
                    /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
                )
            }, {
                // customize code after /* validateLineSortedReset */
                merge: (
                    /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
                )
            }
        ]);
        // customize assets.utility2.rollup.js
        tgtReplaceConditional(fileDict["assets.utility2.rollup.js"], [
            {
                aa: "    // || globalThis.utility2_rollup_old",
                bb: "    || globalThis.utility2_rollup_old"
            }, {
                aa: "    // || require(\"./assets.utility2.rollup.js\")",
                bb: "    || require(\"./assets.utility2.rollup.js\")"
            }
        ]);
        // write lib.xxx.js
        writeFile("lib." + packageNameLib + ".js", tgt, resolve);
    }
    function buildReadme(resolve) {
    /*
     * this function will build readme with template assets.readme.template.md
     */
        let packageJsonRgx;
        let toc;
        // reset toc
        src = fileDict["README.md"].replace((
            /\n#\u0020table\u0020of\u0020contents$[\S\s]*?\n\n\n/m
        ), "\n# table of contents\n\n\n");
        packageJsonRgx = (
            /\n#\u0020package.json\n```json\n([\S\s]*?)\n```\n/
        );
        // render README.md
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.readme.template.md"]
        );
        // init packageJson
        src.replace(packageJsonRgx, function (match0, match1) {
            // remove null from package.json
            packageJson = JSON.parse(match1.replace((
                /\u0020{4}".*?":\u0020null,?$/gm
            ), ""));
            packageJson.description = src.split("\n")[1];
            local.objectAssignDefault(packageJson, {
                nameLib: JSON.parse(fileDict["package.json"]).nameLib
            });
            packageJson = local.objectAssignDefault(packageJson, {
                nameLib: packageJson.name.replace((
                    /\W/g
                ), "_"),
                nameOriginal: packageJson.name
            });
            packageJson = local.objectAssignDefault(
                packageJson,
                JSON.parse(local.templateRenderMyApp(packageJsonRgx.exec(
                    local.assetsDict["/assets.readme.template.md"]
                )[1])),
                2
            );
            // avoid npm-installing that
            delete packageJson.devDependencies[packageJson.name];
            // reset scripts
            packageJson.scripts = {
                "build-ci": "sh npm_scripts.sh",
                env: "env",
                eval: "sh npm_scripts.sh",
                "heroku-postbuild": "sh npm_scripts.sh",
                postinstall: "sh npm_scripts.sh",
                start: "sh npm_scripts.sh",
                test: "sh npm_scripts.sh",
                utility2: "sh npm_scripts.sh"
            };
            // write package.json
            require("fs").writeFileSync(
                "package.json",
                JSON.stringify(local.objectDeepCopyWithKeysSorted(
                    packageJson
                ), undefined, 4) + "\n"
            );
            writeFileLog("package.json");
            // re-render README.md
            tgt = local.templateRenderMyApp(
                local.assetsDict["/assets.readme.template.md"]
            ).replace(packageJsonRgx, match0.replace(
                match1,
                JSON.stringify(local.objectDeepCopyWithKeysSorted(
                    packageJson
                ), undefined, 4)
            ));
            return "";
        });
        tgtReplaceConditional(true, [
            // customize name and description
            {
                merge: (
                    /.*?\n.*?\n/
                )
            // customize cdn-download
            }, {
                merge: (
                    /\n#\u0020cdn\u0020download\n[\S\s]*?\n\n\n/
                )
            // customize live-web-demo
            }, {
                merge: (
                    /\n#\u0020live\u0020web\u0020demo\n[\S\s]*?\n\n\n/
                )
            // customize changelog
            }, {
                merge: (
                    /\n####\u0020changelog\u0020[\S\s]*?\n\n\n/
                )
            // customize example.js - shared js\u002denv code - init-before
            }, {
                merge: (
                    /\nglobalThis\.local\u0020=\u0020local;\n[^`]*?\n\/\*\u0020istanbul\u0020ignore\u0020next\u0020\*\/\n\/\/\u0020run\u0020browser\u0020js\u002denv\u0020code\u0020-\u0020init-test\n/
                )
            // customize example.js - html-body
            }, {
                merge: (
                    /\n<!--\u0020custom-html-start\u0020-->\n[\S\s]*?\n<!--\u0020custom-html-end\u0020-->\n/
                )
            // customize build_ci - shCiAfter
            }, {
                merge: (
                    /\nshCiAfter\u0020\(\)\u0020\{\(set\u0020-e\n[\S\s]*?\n\)\}\n/
                )
            // customize build_ci - shCiBefore
            }, {
                merge: (
                    /\nshCiBefore\u0020\(\)\u0020\{\(set\u0020-e\n[\S\s]*?\n\)\}\n/
                )
            }
        ]);
        // customize private-repository
        tgtReplaceConditional(packageJson.private, [
            {
                aa: (
                    /\n\[!\[NPM\]\(https:\/\/nodei.co\/npm\/.*?\n/
                ),
                bb: ""
            }, {
                aa: "$ npm install ",
                bb: (
                    "$ git clone \\\n" +
                    packageJson.repository.url.replace(
                        "git+https://github.com/",
                        "git@github.com:"
                    ) + " \\\n--single-branch -b beta node_modules/"
                )
            }
        ]);
        // customize version
        [
            src, tgt
        ] = [
            src, tgt
        ].map(function (elem) {
            return elem.replace((
                /\n(####\u0020changelog\u0020|-\u0020npm\u0020publish\u0020)\d+?\.\d+?\.\d+?.*?\n/g
            ), "\n$1" + packageJson.version + "\n");
        });
        // customize example.js
        tgtReplaceConditional(local.assetsDict[
            "/index.html"
        ].indexOf("<script src=\"assets.example.js\"></script>") < 0, [
            {
                aa: (
                    /\nif\u0020\(local.isEnvNode\)\u0020\{\n[\S\s]*?\n\}\(\)\);\n/g
                ),
                bb: "\nif (local.isEnvNode) {\n    return;\n}\n}());\n"
            }
        ]);
        // customize comment
        src.replace((
            /^(\u0020*?)(?:#\!\!\u0020|#\/\/\u0020|\/\/\!\!\u0020|<!--\u0020)(.*?)(?:\u0020-->)?$/gm
        ), function (match0, match1, match2) {
            tgt = tgt.replace(
                "\n" + match1 + match2 + "\n",
                "\n" + match0 + "\n"
            );
        });
        // customize - user-defined
        tgtReplaceConditional(true, customizeReadmeList);
        // customize index.html
        tgtReplaceConditional(local.assetsDict[
            "/index.html"
        ].indexOf("\"assets.utility2.template.html\"") < 0, [
            {
                aa: (
                    /\n\/\*\u0020jslint\u0020ignore:start\u0020\*\/\nlocal.assetsDict\["\/index.html"\]\u0020=\u0020'\\\n[\S\s]*?\n\/\*\u0020jslint\u0020ignore:end\u0020\*\/\n/
                ),
                bb: "\n"
            }
        ]);
        // customize shDeployCustom
        tgtReplaceConditional(src.indexOf("    shDeployCustom\n") >= 0, [
            {
                // customize example.sh
                merge: (
                    /\n####\u0020changelog\u0020[\S\s]*?\n#\u0020quickstart\u0020example.js\n/
                )
            }, {
                // customize screenshot
                merge: (
                    /\n#\u0020quickstart\u0020[\S\s]*?\n#\u0020extra\u0020screenshots\n/
                )
            }, {
                // customize screenshot
                aa: (
                    /^1\.\u0020.*?screenshot\.(?:npmTest|readmeEvalExampleJs|readmeEvalExampleSh).*?\.png[\S\s]*?\n\n/gm
                ),
                bb: ""
            }
        ]);
        // customize shNpmTestPublished
        tgt = tgt.replace(
            "$ npm install " + GITHUB_FULLNAME + "#alpha",
            "$ npm install " + packageJson.name
        );
        tgtReplaceConditional(src.indexOf("    shNpmTestPublished\n") < 0, [
            {
                aa: "$ npm install " + packageJson.name,
                bb: "$ npm install " + GITHUB_FULLNAME + "#alpha"
            }, {
                aa: (
                    /\n.*?\bhttps:\/\/www.npmjs.com\/package\/.*?\n/
                ),
                bb: ""
            }, {
                aa: (
                    /\n.*?npmPackageDependencyTree.*?\n/
                ),
                bb: ""
            }
        ]);
        // customize shCiAfter and shCiBefore
        [
            [
                "shDeployGithub", (
                    /.*?\/screenshot\.deployGithub.*?\n/g
                )
            ], [
                "shDeployHeroku", (
                    /.*?\/screenshot\.deployHeroku.*?\n/g
                )
            ], [
                "shReadmeEval example.js", (
                    /.*?\/screenshot\.readmeEvalExampleJs.*?\n/g
                )
            ], [
                "shReadmeEval example.sh", (
                    /.*?\/screenshot\.readmeEvalExampleSh.*?\n/g
                )
            ], [
                // coverage-hack
                "__zjqx1234__" + Math.random(), "__zjqx1234__" + Math.random()
            ]
        ].forEach(function ([
            conditional, rgxScreenshot
        ]) {
            if (src.indexOf("    " + conditional + "\n") >= 0) {
                return;
            }
            // customize test-server
            tgt = tgt.replace(
                new RegExp(
                    "\\n\\| test-server-" +
                    conditional.replace("shDeploy", "").toLowerCase() +
                    " : \\|.*?\\n"
                ),
                "\n"
            );
            // customize screenshot
            tgt = tgt.replace(rgxScreenshot, "");
        });
        tgt = local.templateRenderMyApp(tgt);
        // customize toc
        toc = "\n# table of contents\n";
        tgt.replace((
            /\n\n\n#\u0020(.*)/g
        ), function (ignore, match1) {
            if (match1 === "table of contents") {
                return;
            }
            toc += "1. [" + match1 + "](#" + match1.toLowerCase().replace((
                /[^\u0020\-0-9A-Z_a-z]/g
            ), "").replace((
                /\u0020/g
            ), "-") + ")\n";
        });
        tgt = tgt.replace("\n# table of contents\n", toc);
        // eslint - no-multiple-empty-lines
        // https://github.com/eslint/eslint/blob/v7.2.0/docs/rules/no-multiple-empty-lines.md
        tgt = tgt.replace((
            /\n{4,}/g
        ), "\n\n\n");
        // write README.md
        writeFile("README.md", tgt, resolve);
    }
    function buildTest(resolve) {
        src = fileDict["test.js"];
        // render test.js
        tgt = local.templateRenderMyApp(
            local.assetsDict["/assets.test.template.js"]
        );
        // customize shared js\u002denv code - function
        tgtReplaceConditional(true, [
            {
                merge: (
                    /\n\}\(\)\);\n\n\n\/\/\u0020run\u0020shared\u0020js\u002denv\u0020code\u0020-\u0020function\n[\S\s]*?$/
                )
            }
        ]);
        // customize require("utility2")
        Array.from([
            "assets.utility2.rollup.js",
            "lib.utility2.js"
        ]).some(function (file) {
            if (fileDict[file]) {
                tgt = tgt.replace(
                    "require(\"utility2\")",
                    "require(\"./" + file + "\")"
                );
                return true;
            }
        });
        // write test.js
        writeFile("test.js", tgt, resolve);
    }
    // buildInit
    Promise.resolve().then(function () {
        // init packageJson
        packageJson = JSON.parse(
            require("fs").readFileSync("package.json", "utf8")
        );
        // init packageNameLib
        packageNameLib = packageJson.nameLib || packageJson.name;
        fileDict = {};
        promiseList = [];
        // cleanup build-dir
        promiseList.push(new Promise(function (resolve) {
            require("child_process").spawn((
                "for DIR in .tmp/build/app/ .tmp/build/app.standalone/;" +
                "do rm -rf $DIR; mkdir -p $DIR; done"
            ), {
                shell: true,
                stdio: [
                    "ignore", 1, 2
                ]
            }).on("exit", resolve);
        }));
        // init port
        promiseList.push(new Promise(function (resolve) {
            let server;
            function recurse(err) {
                if (server) {
                    server.close();
                }
                if (!err) {
                    resolve();
                    return;
                }
                port = (
                    "0x" + require("crypto").randomBytes(2).toString("hex")
                ) | 0x8000;
                server = require("net").createServer().listen(port);
                server.on("error", recurse).on("listening", recurse);
            }
            recurse(true);
        }));
        // read file
        [
            "README.md",
            "lib." + packageNameLib + ".js",
            "package.json",
            "test.js"
        ].forEach(function (file) {
            promiseList.push(new Promise(function (resolve) {
                require("fs").readFile(file, "utf8", function (err, data) {
                    fileDict[file] = data;
                    resolve(err);
                });
            }));
        });
        // exists file
        [
            "assets.utility2.rollup.js",
            "lib.utility2.js"
        ].forEach(function (file) {
            promiseList.push(new Promise(function (resolve) {
                require("fs").access(file, function (notExists) {
                    fileDict[file] = !notExists;
                    resolve();
                });
            }));
        });
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        promiseList = [];
        promiseList.push(new Promise(buildReadme));
        promiseList.push(new Promise(buildLib));
        promiseList.push(new Promise(buildTest));
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        promiseList = [];
        promiseList.push(new Promise(buildAppAssets));
        promiseList.push(new Promise(buildAppStandalone));
        return Promise.all(promiseList);
    }).then(function (errList) {
        errList.forEach(onErrorThrow);
        onError();
    });
};

local.chromeDevtoolsClientCreate = async function ({
    chromeBin,
    modeCoverageHack,
    modeSilent,
    modeWindowSize = "800x600",
    processPlatform,
    timeout
}) {
/*
 * this function with create chrome-devtools-client from <chromeBin>
 */
    let WS_READ_HEADER;
    let WS_READ_LENGTH16;
    let WS_READ_LENGTH63;
    let WS_READ_PAYLOAD;
    let assert;
    let callbackDict;
    let callbackId;
    let chromeClient;
    let chromeProcess;
    let chromeSessionId;
    let chromeUserDataDir;
    let secWebsocketKey;
    let timerTimeout;
    let websocket;
    let websocketUrl;
    let wsBufList;
    let wsPayloadLength;
    let wsReadState;
    let wsReader;
    if (modeCoverageHack === 1) {
        [
            "darwin", "linux", "win32"
        ].forEach(function (processPlatform) {
            local.chromeDevtoolsClientCreate({
                modeCoverageHack: 2,
                processPlatform
            }).catch(noop);
        });
        return;
    }
    WS_READ_HEADER = 0;
    WS_READ_LENGTH16 = 1;
    WS_READ_LENGTH63 = 2;
    WS_READ_PAYLOAD = 3;
    assert = require("assert");
    callbackDict = {};
    callbackId = 0;
    wsBufList = [];
    wsPayloadLength = 0;
    wsReadState = WS_READ_HEADER;
    function chromeCleanup() {
    /*
     * this function will
     * 1. kill <chromeProcess>
     * 2. rm -rf <chromeUserDataDir>
     * 3. destroy <chromeClient>, <websocket>, <wsReader>
     */
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // 1. kill <chromeProcess>
        try {
            if (processPlatform === "win32") {
                require("child_process").spawnSync("taskkill", [
                    "/pid", chromeProcess.pid, "/T", "/F"
                ], {
                    stdio: "ignore"
                });
            } else {
                // kill child process tree with ".kill(-pid)" cmd.
                process.kill(-chromeProcess.pid, "SIGKILL");
            }
        } catch (ignore) {}
        // 2. rm -rf <chromeUserDataDir>
        if (chromeUserDataDir) {
            require("fs").rmdirSync(chromeUserDataDir, {
                recursive: true
            });
        }
        // 3. destroy <chromeClient>, <websocket>, <wsReader>
        chromeClient.destroy();
        if (websocket) {
            websocket.destroy();
        }
        wsReader.destroy();
    }
    async function chromeEvaluate(expression) {
    /*
     * this function will eval <expression> in chrome-browser
     */
        let {
            exceptionDetails,
            result
        } = await chromeClient.rpc("Runtime.evaluate", {
            awaitPromise: true,
            expression,
            returnByValue: false,
            userGesture: true
        });
        assert.ok(!exceptionDetails, (
            "chrome-devtools - evaluate - " +
            JSON.stringify(exceptionDetails)
        ));
        return result.value;
    }
    function chromeOnData(payload) {
    /*
     * this function will handle callback for <payload>
     * received from chrome-browser using chrome-devtools-protocol
     */
        // console.error("\u25c0 RECV " + payload.slice(0, 256).toString());
        let callback;
        let {
            error,
            id,
            method,
            params,
            result
        } = JSON.parse(payload);
        assert.ok(!method || (
            /^[A-Z]\w*?\.[a-z]\w*?$/
        ).test(method), "chrome-devtools - read - invalid method " + method);
        // init callback
        callback = callbackDict[id];
        delete callbackDict[id];
        // callback.resolve
        if (callback) {
            // preserve stack-trace
            callback.err.message = (
                "chrome-devtools - read - " + JSON.stringify(error)
            );
            assert.ok(!error, callback.err);
            callback.resolve(result);
            return;
        }
        assert.ok(!error, "chrome-devtools - read - " + JSON.stringify(error));
        chromeClient.emit(method, params);
    }
    function chromeRead() {
    /*
     * this function will implement stream.Duplex.prototype._read
     */
        if (websocket && websocket.readable) {
            websocket.resume();
        }
    }
    function chromeRpc(method, params) {
    /*
     * this function will message-pass
     * JSON.stringify({
     *     id: <callbackId>,
     *     method: <method>,
     *     params: <params>,
     *     sessionId: <chromeSessionId>
     * })
     * to chrome-browser using chrome-devtools-protocol
     */
        callbackId = (callbackId % 256) + 1;
        chromeClient.write(Buffer.from(JSON.stringify({
            id: callbackId,
            method,
            params,
            sessionId: (
                typeof chromeSessionId === "string"
                ? chromeSessionId
                : undefined
            )
        })));
        return new Promise(function (resolve) {
            callbackDict[callbackId] = {
                err: new Error(),
                method,
                resolve
            };
        });
    }
    function chromeWrite(payload, ignore, callback) {
    /*
     * this function will implement stream.Duplex.prototype._write
     */
        // console.error("SEND \u25ba " + payload.slice(0, 256).toString());
        let header;
        let maskKey;
        let result;
        // init header
        header = Buffer.alloc(2 + 8 + 4);
        // init fin = true
        header[0] |= 0x80;
        // init opcode = text-frame
        header[0] |= 1;
        // init mask = true
        header[1] |= 0x80;
        // init payload.length
        if (payload.length < 126) {
            header = header.slice(0, 2 + 0 + 4);
            header[1] |= payload.length;
        // } else if (payload.length < 65536) {
        } else {
            assert.ok(payload.length < 65536, (
                "chrome-devtools - write - " +
                "payload-length must be less than 65536 bytes, not " +
                payload.length
            ));
            header = header.slice(0, 2 + 2 + 4);
            header[1] |= 126;
            header.writeUInt16BE(payload.length, 2);
        /*
        } else {
            header[1] |= 127;
            header.writeUInt32BE(payload.length, 6);
        */
        }
        // init maskKey
        maskKey = require("crypto").randomBytes(4);
        maskKey.copy(header, header.length - 4);
        // send header
        websocket.cork();
        websocket.write(header);
        // send payload ^ maskKey
        payload.forEach(function (ignore, ii) {
            payload[ii] ^= maskKey[ii & 3];
        });
        // return write-result
        result = websocket.write(payload, callback);
        websocket.uncork();
        return result;
    }
    function wsBufListRead(nn) {
    /*
     * this function will read <nn> bytes from <wsBufList>
     */
        let buf;
        wsBufList = (
            wsBufList.length === 1
            ? wsBufList[0]
            : Buffer.concat(wsBufList)
        );
        buf = wsBufList.slice(0, nn);
        wsBufList = [
            wsBufList.slice(nn)
        ];
        return buf;
    }
    function wsFrameRead() {
    /*
     * this function will read websocket-data-frame
     */
        let buf;
        let opcode;
        if (wsBufList.reduce(function (aa, bb) {
            return aa + bb.length;
        }, 0) < (
            wsReadState === WS_READ_PAYLOAD
            ? Math.max(wsPayloadLength, 1)
            : wsReadState === WS_READ_LENGTH63
            ? 8
            : 2
        )) {
            return;
        }
        switch (wsReadState) {
        // read frame-header
        case WS_READ_HEADER:
            buf = wsBufListRead(2);
            // validate opcode
            opcode = buf[0] & 0x0f;
            assert.ok(opcode === 0x01, (
                "chrome-devtools - read - opcode must be 0x01, not 0x0" +
                opcode.toString(16)
            ));
            wsPayloadLength = buf[1] & 0x7f;
            wsReadState = (
                wsPayloadLength === 126
                ? WS_READ_LENGTH16
                : wsPayloadLength === 127
                ? WS_READ_LENGTH63
                : WS_READ_PAYLOAD
            );
            break;
        // read frame-payload-length-16
        case WS_READ_LENGTH16:
            wsPayloadLength = wsBufListRead(2).readUInt16BE(0);
            wsReadState = WS_READ_PAYLOAD;
            break;
        // read frame-payload-length-63
        case WS_READ_LENGTH63:
            buf = wsBufListRead(8);
            wsPayloadLength = (
                buf.readUInt32BE(0) * 0x100000000 + buf.readUInt32BE(4)
            );
            wsReadState = WS_READ_PAYLOAD;
            break;
        // read frame-payload-data
        case WS_READ_PAYLOAD:
            assert.ok((
                0 <= wsPayloadLength && wsPayloadLength <= 10000000
            ), (
                "chrome-devtools - read - " +
                "payload-length must be between 0 and 256 MiB, not " +
                wsPayloadLength
            ));
            buf = wsBufListRead(wsPayloadLength);
            wsReadState = WS_READ_HEADER;
            chromeClient.push(buf);
            break;
        }
        return true;
    }
    function wsReaderTransform(chunk, ignore, callback) {
    /*
     * this function will implement Transform.prototype._transform
     */
        wsBufList.push(chunk);
        while (true) {
            if (!wsFrameRead()) {
                break;
            }
        }
        callback();
    }
    // init chromeClient
    function ChromeClient() {
    /*
     * this function will construct <chromeClient>
     */
        chromeClient = this;
        require("util").inherits(ChromeClient, require("stream").Duplex);
        require("stream").Duplex.call(chromeClient);
        Object.assign(chromeClient.__proto__, {
            _destroy: chromeCleanup,
            _read: chromeRead,
            _write: chromeWrite,
            evaluate: chromeEvaluate,
            rpc: chromeRpc
        });
        chromeClient.on("data", chromeOnData);
    }
    chromeClient = new ChromeClient();
/*
https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-13#section-5.2
+---------------------------------------------------------------+
|0               1               2               3              |
|0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f|
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
FIN: 1 bit
    Indicates that this is the final fragment in a message.  The first
    fragment MAY also be the final fragment.
RSV1, RSV2, RSV3: 1 bit each
    MUST be 0 unless an extension is negotiated which defines meanings
    for non-zero values.  If a nonzero value is received and none of
    the negotiated extensions defines the meaning of such a nonzero
    value, the receiving endpoint MUST _Fail the WebSocket
    Connection_.
Opcode: 4 bits
    Defines the interpretation of the payload data.  If an unknown
    opcode is received, the receiving endpoint MUST _Fail the
    WebSocket Connection_.  The following values are defined.
    *  %x0 denotes a continuation frame
    *  %x1 denotes a text frame
    *  %x2 denotes a binary frame
    *  %x3-7 are reserved for further non-control frames
    *  %x8 denotes a connection close
    *  %x9 denotes a ping
    *  %xA denotes a pong
    *  %xB-F are reserved for further control frames
Mask: 1 bit
    Defines whether the payload data is masked.  If set to 1, a
    masking key is present in masking-key, and this is used to unmask
    the payload data as per Section 5.3.  All frames sent from client
    to server have this bit set to 1.
Payload length: 7 bits, 7+16 bits, or 7+64 bits
    The length of the payload data, in bytes: if 0-125, that is the
    payload length.  If 126, the following 2 bytes interpreted as a 16
    bit unsigned integer are the payload length.  If 127, the
    following 8 bytes interpreted as a 64-bit unsigned integer (the
    most significant bit MUST be 0) are the payload length.  Multibyte
    length quantities are expressed in network byte order.  The
    payload length is the length of the extension data + the length of
    the application data.  The length of the extension data may be
    zero, in which case the payload length is the length of the
    application data.
Masking-key: 0 or 4 bytes
    All frames sent from the client to the server are masked by a 32-
    bit value that is contained within the frame.  This field is
    present if the mask bit is set to 1, and is absent if the mask bit
    is set to 0.  See Section 5.3 for further information on client-
    to-server masking.
Payload data: (x+y) bytes
    The payload data is defined as extension data concatenated with
    application data.
Extension data: x bytes
    The extension data is 0 bytes unless an extension has been
    negotiated.  Any extension MUST specify the length of the
    extension data, or how that length may be calculated, and how the
    extension use MUST be negotiated during the opening handshake.  If
    present, the extension data is included in the total payload
    length.
Application data: y bytes
    Arbitrary application data, taking up the remainder of the frame
    after any extension data.  The length of the application data is
    equal to the payload length minus the length of the extension
    data.
*/
    // init wsReader that can read websocket-frames from websocket
    function WsReader() {
    /*
     * this function will construct <wsReader>
     */
        wsReader = this;
        require("util").inherits(WsReader, require("stream").Transform);
        require("stream").Transform.call(wsReader);
        Object.assign(wsReader.__proto__, {
            _transform: wsReaderTransform
        });
    }
    wsReader = new WsReader();
    // init chromeProcess
    processPlatform = processPlatform || process.platform;
    chromeUserDataDir = await require("fs").promises.mkdtemp(
        require("path").join(require("os").tmpdir(), "puppeteer_dev_profile-")
    );
    chromeBin = chromeBin || (
        processPlatform === "darwin"
        ? "/Applications/Google Chrome.app/Contents/MacOS/" +
        "Google Chrome"
        : processPlatform === "win32"
        ? "C:\\Program Files (x86)\\Google\\Chrome\\Application\\" +
        "chrome.exe"
        : "/usr/bin/google-chrome-stable"
    );
    console.error("chrome-devtools - spawning - " + chromeBin);
    chromeProcess = require("child_process").spawn((
        chromeBin
    ), [
        "--headless",
        "--incognito",
        "--remote-debugging-port=0",
        "--user-data-dir=" + chromeUserDataDir,
        "--window-size=" + modeWindowSize,
        Array.from([
            "", "--no-sandbox"
        ])[(process.getuid && process.getuid() === 0) | 0]
    ], {
        // On non-windows platforms, `detached: false` makes child process
        // a leader of a new process group, making it possible to kill
        // child process tree with `.kill(-pid)` cmd.
        // https://nodejs.org/api/child_process.html#child_process_options_detached
        detached: process.platform !== "win32",
        stdio: [
            "ignore", (
                !modeSilent
                ? 1
                : "ignore"
            ), "pipe"
        ]
    });
    if (!modeSilent) {
        chromeProcess.stderr.pipe(process.stderr, {
            end: false
        });
    }
    process.on("exit", chromeCleanup);
    process.on("SIGINT", chromeCleanup);
    process.on("SIGTERM", chromeCleanup);
    process.on("SIGHUP", chromeCleanup);
    // init timerTimeout
    timeout = timeout || 30000;
    if (modeCoverageHack === 2) {
        chromeClient.on("error", noop);
        chromeProcess.on("error", noop);
        timeout = 0;
    }
    timerTimeout = setTimeout(function () {
        chromeCleanup();
        chromeClient.emit("error", new Error(
            "chrome-devtools - timeout - " + timeout + " ms"
        ));
    }, timeout);
    // init websocketUrl
    websocketUrl = await new Promise(function (resolve) {
        let stderr;
        stderr = "";
        chromeProcess.stderr.on("data", function onData(chunk) {
            assert.ok(
                stderr.length < 65536,
                "chrome-devtools - connecting - cannot connect to chrome"
            );
            stderr += chunk;
            stderr.replace((
                /^DevTools\u0020listening\u0020on\u0020(ws:\/\/.*)$/m
            ), function (ignore, url) {
                chromeProcess.stderr.removeListener("data", onData);
                resolve(url);
                return "";
            });
        });
    });
    // init websocket
    console.error("chrome-devtools - connecting - " + websocketUrl);
    secWebsocketKey = require("crypto").randomBytes(16).toString("base64");
    await new Promise(function (resolve) {
        require("http").get((
            websocketUrl
        ), {
            createConnection: function (opt) {
                delete opt.path;
                return require("net").connect(opt);
            },
            headers: {
                Connection: "Upgrade",
                "Sec-WebSocket-Key": secWebsocketKey,
                "Sec-WebSocket-Version": 13,
                Upgrade: "websocket"
            },
            protocol: "http:",
            protocolVersion: 13
        }).once("upgrade", function (res, _, head) {
            assert.ok((
                res.headers[
                    "sec-websocket-accept"
                ] === require("crypto").createHash("sha1").update(
                    secWebsocketKey +
                    "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
                ).digest("base64")
            ), (
                "chrome-devtools - connecting - " +
                "invalid header sec-websocket-accept"
            ));
            websocket = _;
            websocket.unshift(head);
            // websocket - disable timeout
            websocket.setTimeout(0);
            // websocket - disable nagle's algorithm
            websocket.setNoDelay();
            websocket.on("end", websocket.end.bind(websocket));
            // pipe websocket to wsReader
            websocket.pipe(wsReader);
            resolve();
        });
    });
    // init chromeSessionId
    chromeSessionId = await chromeClient.rpc("Target.createTarget", {
        url: "about:blank"
    });
    chromeSessionId = await chromeClient.rpc("Target.attachToTarget", {
        targetId: chromeSessionId.targetId,
        flatten: true
    });
    chromeSessionId = chromeSessionId.sessionId;
    console.error("chrome-devtools - created - blank-page with sessionId");
    return chromeClient;
};

local.cliRun = function ({
    rgxComment
}) {
/*
 * this function will run cli
 */
    let {
        _default,
        _eval,
        _help,
        _interactive,
        _version,
        cliDict,
        replStart
    } = Object.assign({}, local, local.cliDict);
    _eval = _eval || function () {
    /*
     * <code>
     * will eval <code>
     */
        Object.assign(globalThis, local);
        require("vm").runInThisContext(process.argv[3]);
    };
    _help = _help || function () {
    /*
     *
     * will print help
     */
        let cmdList;
        let file;
        let packageJson;
        let str;
        let strDict;
        cmdList = [
            {
                argList: "<arg2>  ...",
                description: "usage:",
                cmd: [
                    "<arg1>"
                ]
            }, {
                argList: "'console.log(\"hello world\")'",
                description: "example:",
                cmd: [
                    "--eval"
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), "");
        packageJson = require("./package.json");
        // validate comment
        rgxComment = rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020<[^>]*?>|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(cliDict).sort().forEach(function (key, ii) {
            if (key[0] === "_" && key !== "_default") {
                return;
            }
            str = String(cliDict[key]);
            if (key === "_default") {
                key = "";
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (cmdList[ii]) {
                cmdList[ii].cmd.push(key);
                return;
            }
            cmdList[ii] = rgxComment.exec(str);
            if (!cmdList[ii]) {
                throw new Error(
                    "cliRun - cannot parse comment in cmd " +
                    key + ":\nnew RegExp(" +
                    JSON.stringify(rgxComment.source) +
                    ").exec(" + JSON.stringify(str).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") + ");"
                );
            }
            cmdList[ii] = {
                argList: String(cmdList[ii][1] || "").trim(),
                cmd: [
                    key
                ],
                description: cmdList[ii][2]
            };
        });
        str = "";
        str += packageJson.name + " (" + packageJson.version + ")\n\n";
        str += cmdList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.cmd = elem.cmd.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(" ");
                elem.description = (
                    "# CMD " +
                    (elem.cmd[0] || "<none>") + "\n# " +
                    elem.description
                );
            }
            return (
                elem.description + "\n  " + file +
                "  " + elem.cmd.sort().join("|") + "  " +
                elem.argList.join("  ")
            );
        }).join("\n\n");
        console.log(str);
    };
    _interactive = _interactive || function () {
    /*
     *
     * will start interactive-mode
     */
        Object.assign(globalThis, local);
        replStart = replStart || require("repl").start;
        replStart({
            useGlobal: true
        });
    };
    _version = _version || function () {
    /*
     *
     * will print version
     */
        console.log(require(__dirname + "/package.json").version);
    };
    _default = _default || _help;
    Object.assign(cliDict, {
        "--eval": _eval,
        "--help": _help,
        "--interactive": _interactive,
        "--version": _version,
        "-e": _eval,
        "-h": _help,
        "-i": _interactive,
        "-v": _version,
        _default,
        _eval,
        _help,
        _interactive,
        _version
    });
    // run help-cmd if no arguments are given
    if (process.argv.length <= 2) {
        _help();
        return;
    }
    // run defined-cmd if it exists
    if (cliDict[process.argv[2]]) {
        cliDict[process.argv[2]]();
        return;
    }
    // run default-cmd
    _default();
};

local.domQuerySelectorAllTagName = function (selector) {
/*
 * this function will return list of tagName matching <selector>
 */
    let dict;
    dict = {};
    documentQuerySelectorAll(selector).forEach(function (elem) {
        dict[elem.tagName] = true;
    });
    return Object.keys(dict).sort();
};

local.domStyleValidate = function () {
/*
 * this function will validate <style> tags
 */
    let list;
    let rgx;
    rgx = (
        /^0\u0020(?:(body\u0020>\u0020)?(?:\.test-report-div\u0020.+|\.x-istanbul\u0020.+|\.button|\.colorError|\.readonly|\.textarea|\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\u0020\{))|^[1-9]\d*?\u0020#/m
    );
    list = [];
    documentQuerySelectorAll("style").forEach(function (elem, ii) {
        elem.innerHTML.replace((
            /\/\*[\S\s]*?\*\/|;|\}/g
        ), "\n").replace((
            /^([^\n\u0020@].*?)[,{:].*?$/gm
        ), function (match0, match1) {
            try {
                ii = document.querySelectorAll(match1).length;
            } catch (errCaught) {
                console.error(errCaught);
            }
            if (!(ii > 1) && !rgx.test(elem)) {
                list.push(ii + " " + match0);
            }
        });
    });
    list.filter(function (elem) {
        return !rgx.test(elem);
    }).sort().reverse().forEach(function (elem, ii, list) {
        console.error(
            "domStyleValidateUnmatched " + (list.length - ii) + ". " + elem
        );
    });
};

local.eventListenerAdd = function (type, {
    once
}, listener) {
/*
 * this function will listen evt <type> with <listener>
 */
    localEventListenerId = (localEventListenerId + 1) | 0;
    localEventListenerDict[localEventListenerId] = {
        listener,
        once,
        type
    };
};

local.eventListenerEmit = function (type, msg) {
/*
 * this function will emit evt <type> with <msg>
 */
    Object.entries(localEventListenerDict).forEach(function ([
        id, elem
    ]) {
        if (elem.type === type) {
            if (elem.once) {
                delete localEventListenerDict[id];
            }
            elem.listener({
                msg,
                type
            });
        }
    });
};

local.eventListenerRemove = function (listener) {
/*
 * this function will emit evt <type> with <msg>
 */
    Object.entries(localEventListenerDict).forEach(function ([
        id, elem
    ]) {
        if (elem.listener === listener) {
            delete localEventListenerDict[id];
        }
    });
};

local.fsReadFileOrDefaultSync = function (pathname, type, dflt) {
/*
 * this function will sync-read <pathname> with given <type> and <dflt>
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return dflt;
    }
    // try to read pathname
    try {
        return (
            type === "json"
            ? JSON.parse(fs.readFileSync(pathname, "utf8"))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};

local.fsWriteFileWithMkdirpSync = function (pathname, data) {
/*
 * this function will sync write <data> to <pathname> with "mkdir -p"
 */
    let fs;
    // do nothing if module does not exist
    try {
        fs = require("fs");
        pathname = require("path").resolve(pathname);
    } catch (ignore) {
        return;
    }
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require("path").dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
    }
    console.error("fsWriteFileWithMkdirpSync - wrote - " + pathname);
    return true;
};

local.httpFetch = async function (url, opt = {}) {
/*
 * this function fetch <url> with given <opt>
 */
    let buf;
    let bufList;
    let req;
    let res;
    function arrayBuffer() {
        return buf;
    }
    async function json() {
        return JSON.stringify(await buf);
    }
    async function text() {
        return String(await buf);
    }
    // use browser fetch
    if (
        typeof globalThis.XMLHttpRequest === "function" &&
        typeof globalThis.fetch === "function"
    ) {
        return globalThis.fetch(url, opt);
    }
    // use node http-request
    if (!(
        /^https?:/
    ).test(url)) {
        url = "http://127.0.0.1:" + process.env.PORT + "/" + url.replace((
            /^\//
        ), "");
    }
    res = await new Promise(function (resolve) {
        req = require(url.split(":")[0]).request(url, opt, resolve).end();
    });
    let {
        headers,
        statusCode
    } = res;
    bufList = [];
    res.on("data", function (chunk) {
        bufList.push(chunk);
    });
    buf = new Promise(function (resolve) {
        res.on("end", function () {
            resolve(Buffer.concat(bufList));
        });
    });
    return Object.assign(res, {
        arrayBuffer,
        blob: arrayBuffer,
        headers: new Map(Object.entries(headers)),
        json,
        ok: 200 <= statusCode && statusCode <= 299,
        req,
        status: statusCode,
        statusText: require("http").STATUS_CODES[statusCode],
        text,
        url
    });
};

local.jslintAutofixLocalFunction = function (code, file) {
/*
 * this function will jslint-autofix local-function
 */
    let code2;
    let dictFnc;
    let dictProp;
    function stringMerge(str1, str2, rgx) {
    /*
     * this function will merge <str2> into <str1>,
     * for sections where both match <rgx> with no magic
     */
        str2.replace(rgx, function (match2) {
            str1.replace(rgx, function (match1) {
                str1 = str1.replace(match1, function () {
                    return match2;
                });
                return "";
            });
            return "";
        });
        return str1;
    }
    if (!isEnvNode) {
        return code;
    }
    // make file relative
    file = require("path").resolve(file);
    if (file.indexOf(process.cwd() + require("path").sep) === 0) {
        file = file.replace(process.cwd() + require("path").sep, "");
    }
    switch (file) {
    case "README.md":
    case "lib." + npm_package_nameLib + ".js":
    case "lib." + npm_package_nameLib + ".sh":
    case "lib.apidoc.js":
    case "lib.istanbul.js":
    case "lib.jslint.js":
    case "lib.marked.js":
    case "npm_scripts.sh":
    case "test.js":
        break;
    default:
        return code;
    }
    // autofix - assets.utility2.header.js
    code = code.replace((
        /\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020start\n[\S\s]*?\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020end\n/
    ), "\n" + local.assetsDict["/assets.utility2.header.js"]);
    // autofix - assets.my_app.template.js
    code = stringMerge(
        code,
        local.assetsDict["/assets.my_app.template.js"].replace((
            /my_app/g
        ), file.split(".")[1]),
        (
            file === "README.md"
            ? (
                /$^/m
            )
            : (
                /\n\/\*\u0020istanbul\u0020instrument\u0020in\u0020package\u0020[\S\s]*?\n\/\*\u0020validateLineSortedReset\u0020\*\/\n/
            )
        )
    );
    // customize local for assets.utility2.rollup.js
    if (
        file === "lib." + npm_package_nameLib + ".js" &&
        require("fs").existsSync("./assets.utility2.rollup.js")
    ) {
        code = code.replace(
            "    // || globalThis.utility2_rollup_old",
            "    || globalThis.utility2_rollup_old"
        ).replace(
            "    // || require(\"./assets.utility2.rollup.js\")",
            "    || require(\"./assets.utility2.rollup.js\")"
        );
    }
    // init functionAllDict and functionBaseDict
    [
        [
            "utility2"
        ], [
            "utility2", "apidoc"
        ]
    ].forEach(function (dictList, ii) {
        dictFnc = (
            ii
            ? "functionAllDict"
            : "functionBaseDict"
        );
        if (local[dictFnc]) {
            return;
        }
        local[dictFnc] = {};
        dictList.forEach(function (dict) {
            dict = local[dict];
            Object.keys(dict).forEach(function (key) {
                if (
                    !(
                        /^[A-Z_]|^testCase_/m
                    ).test(key) &&
                    typeof dict[key] === "function"
                ) {
                    local[dictFnc][key] = (
                        local[dictFnc][key] || String(dict[key])
                    );
                }
            });
        });
        Object.keys(local[dictFnc]).forEach(function (key) {
            if (process.binding("natives")[key]) {
                local[dictFnc][key] = undefined;
            }
        });
    });
    // autofix - local-function
    dictFnc = {};
    dictProp = {};
    code = code.replace((
        /^local\.(.*?)\u0020=\u0020(function\u0020\([\S\s]*?\n\});\n+/gm
    ), function (match0, key, match2, match3) {
        // local-function - duplicate
        if (dictFnc[key]) {
            return "";
        }
        // local-function - normalize
        dictFnc[key] = true;
        match3 = local.functionAllDict[key] || "";
        // make shell-safe
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c
        if (file.slice(-3) === ".sh") {
            match3 = match3.replace((
                /'/g
            ), "'\"'\"'");
        }
        if (match3 && match3 !== match2) {
            match0 = match0.replace(match2, match3.replace((
                /\$\$|\$/g
            ), "$$$$"));
        }
        return match0.trimEnd() + "\n\n";
    });
    // comment
    code2 = code;
    code2 = code2.replace((
        /^\u0020*?\/\*[\S\s]*?\*\/|^\u0020*?(?:\/\/.*?|.*?\\)$/gm
    ), "");
    // local-function - update dictFnc and dictProp
    code2.replace((
        /\blocal\.(\w+?\b)(?:\u0020(===|=|\|\|)(?:\u0020"function"\u0020&&\u0020local\.\w|\u0020|$))?/gm
    ), function (ignore, match1, match2) {
        switch (match2) {
        case "=":
            dictFnc[match1] = true;
            break;
        case "===":
        case "||":
            dictProp[match1] = false;
            break;
        default:
            dictProp[match1] = true;
        }
    });
    [
        dictFnc, dictProp
    ].forEach(function (dict) {
        Object.keys(dict).forEach(function (key) {
            dict[key] = dict[key] && local.functionBaseDict[key];
        });
    });
    dictFnc = JSON.parse(JSON.stringify(dictFnc));
    dictProp = JSON.parse(JSON.stringify(dictProp));
    [
        "assertJsonEqual",
        "assertOrThrow",
        "identity",
        "noop",
        "objectAssignDefault",
        "objectDeepCopyWithKeysSorted",
        "onErrorThrow"
    ].forEach(function (key) {
        dictFnc[key] = true;
        dictProp[key] = true;
    });
    // local-function - missing
    switch (require("fs").existsSync("assets.utility2.rollup.js") || file) {
    case "README.md":
    case "lib.utility2.js":
    case "test.js":
    case true:
        break;
    default:
        Object.keys(dictProp).forEach(function (key) {
            if (dictProp[key] && !dictFnc[key]) {
                console.error(
                    "local-function - missing (" + file + ") local." + key
                );
            }
        });
    }
    // local-function - unused
    switch (file) {
    case "lib.utility2.js":
    case "lib.utility2.sh":
        break;
    default:
        Object.keys(dictFnc).forEach(function (key) {
            if (!dictProp.hasOwnProperty(key)) {
                console.error(
                    "local-function - unused (" + file + ") local." + key
                );
            }
        });
    }
    return code;
};

local.listShuffle = function (list) {
/*
 * this function will inplace shuffle <list> using fisher-yates algorithm
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
    let ii;
    let random;
    let swap;
    ii = list.length;
    while (ii > 1) {
        ii -= 1;
        random = Math.floor(Math.random() * (ii + 1));
        swap = list[ii];
        list[ii] = list[random];
        list[random] = swap;
    }
    return list;
};

local.onReadyDecrement = function (err) {
/*
 * this function will decrement <onReadyCnt>
 */
    localOnReadyCnt -= 1;
    if (localOnReadyCnt === 0) {
        local.eventListenerEmit("utility2.onReady", err);
    }
    return localOnReadyCnt;
};

local.onReadyIncrement = function () {
/*
 * this function will increment <onReadyCnt>
 */
    localOnReadyCnt += 1;
    return localOnReadyCnt;
};

local.replStart = function () {
/*
 * this function will start repl-debugger
 */
    let that;
    if (globalThis.utility2_repl1) {
        return;
    }
    // start repl
    that = require("repl").start({
        useGlobal: true
    });
    globalThis.utility2_repl1 = that;
    // init history
    that.setupHistory(require("path").resolve(
        process.env.HOME + "/.node_repl_history"
    ), function () {
        return;
    });
    // save eval-function
    that.evalDefault = that.eval;
    // hook custom-eval-function
    that.eval = function (script, context, file, onError) {
        script.replace((
            /^(\S+)\u0020(.*?)\n/
        ), function (ignore, match1, match2) {
            switch (match1) {
            // syntax-sugar - run shell-cmd
            case "$":
                switch (match2.split(" ").slice(0, 2).join(" ")) {
                // syntax-sugar - run git diff
                case "git diff":
                    match2 += " --color";
                    break;
                // syntax-sugar - run git log
                case "git log":
                    match2 += " -n 10";
                    break;
                // syntax-sugar - run ll
                case "ll":
                    match2 = "ls -Fal";
                    break;
                }
                match2 = match2.replace((
                    /^git\u0020/
                ), "git --no-pager ");
                // source lib.utility2.sh
                match2 = (
                    (
                        process.platform !== "win32" &&
                        process.env.UTILITY2_BIN && (match2 !== ":")
                    )
                    ? ". " + process.env.UTILITY2_BIN + "; " + match2
                    : match2
                );
                // run shell-cmd
                console.error("$ " + match2);
                require("child_process").spawn(match2, {
                    shell: true,
                    stdio: [
                        "ignore", 1, 2
                    ]
                // print exitCode
                }).on("exit", function (exitCode) {
                    console.error("$ EXIT_CODE=" + exitCode);
                    that.evalDefault("\n", context, file, onError);
                });
                script = "\n";
                break;
            // syntax-sugar - map text with charCodeAt
            case "charCode":
                console.error(
                    match2.split("").map(function (chr) {
                        return (
                            "\\u" +
                            chr.charCodeAt(0).toString(16).padStart(4, 0)
                        );
                    }).join("")
                );
                script = "\n";
                break;
            // syntax-sugar - sort chr
            case "charSort":
                console.error(JSON.stringify(match2.split("").sort().join("")));
                script = "\n";
                break;
            // syntax-sugar - list obj-keys, sorted by item-type
            // console.error(Object.keys(global).map(function(key){return(typeof global[key]==='object'&&global[key]&&global[key]===global[key]?'global':typeof global[key])+' '+key;}).sort().join('\n')) // jslint ignore:line
            case "keys":
                script = (
                    "console.error(Object.keys(" + match2 +
                    ").map(function(key){return(" +
                    "typeof " + match2 + "[key]==='object'&&" +
                    match2 + "[key]&&" +
                    match2 + "[key]===global[key]" +
                    "?'global'" +
                    ":typeof " + match2 + "[key]" +
                    ")+' '+key;" +
                    "}).sort().join('\\n'))\n"
                );
                break;
            // syntax-sugar - print String(val)
            case "print":
                script = "console.error(String(" + match2 + "))\n";
                break;
            }
        });
        // eval script
        that.evalDefault(script, context, file, onError);
    };
};

local.requireReadme = function () {
/*
 * this function will require and export example.js embedded in README.md
 */
    let Module;
    let code;
    let exports;
    let file;
    let {
        assetsDict,
        fsReadFileOrDefaultSync,
        objectAssignDefault,
        replStart,
        templateRenderMyApp
    } = local;
    // if library-mode, then return local
    if (npm_config_mode_lib) {
        local.testRunDefault = noop;
        return local;
    }
    // if file modified, then restart process
    if (npm_config_mode_auto_restart) {
        require("fs").readdir(".", function (ignore, fileList) {
            fileList.concat(__filename).forEach(async function (file) {
                let stats;
                if (file[0] === ".") {
                    return;
                }
                stats = await require("fs").promises.stat(file);
                if (!stats.isFile()) {
                    return;
                }
                require("fs").watchFile(file, {
                    interval: 1000,
                    persistent: false
                }, function () {
                    console.error("watchFile - modified - " + file);
                    setTimeout(process.exit.bind(undefined, 77), 1000);
                });
            });
        });
    }
    // if browser-env, then return local
    if (!isEnvNode) {
        return objectAssignDefault(
            globalThis.utility2_rollup || globalThis.local,
            local
        );
    }
    // start repl-debugger
    replStart();
    // jslint $PWD
    require("child_process").spawn("node", [
        "-e", (
            "require(" + JSON.stringify(__filename) +
            ").jslintAndPrintDir(" + JSON.stringify(process.cwd()) +
            ", {modeAutofix:" + !npm_config_mode_test +
            ",modeConditional:true});"
        )
    ], {
        env: Object.assign({}, process.env, {
            npm_config_mode_lib: "1"
        }),
        stdio: [
            "ignore", 1, 2
        ]
    });
    // if rollup, then return local
    if (globalThis.utility2_rollup || npm_config_mode_start) {
        assetsDict["/assets.app.js"] = require("fs").readFileSync(
            __filename,
            "utf8"
        ).replace((
            /^#!\//
        ), "// ");
        // init exports
        local[npm_package_nameLib] = local;
        return local;
    }
    // init utility2_moduleExports from $npm_package_main
    globalThis.utility2_moduleExports = require(
        require("path").resolve(npm_package_main)
    );
    // read example.js from README.md
    code = assetsDict["/assets.example.template.js"];
    fsReadFileOrDefaultSync("README.md", "utf8", "").replace((
        /\n```javascript(\n\/\*\nexample\.js\n[\S\s]*?\n)```\n/
    ), function (ignore, match1, ii, input) {
        // preserve lineno
        code = input.slice(0, ii).replace((
            /.+/g
        ), "") + "\n" + match1;
        return "";
    });
    // alias require($npm_package_name) to utility2_moduleExports;
    code = code.replace(
        new RegExp("require\\(." + npm_package_name + ".\\)"),
        "globalThis.utility2_moduleExports"
    ).replace(
        new RegExp("require\\(." + npm_package_nameOriginal + ".\\)"),
        "globalThis.utility2_moduleExports"
    );
    // jslint example.js
    file = require("path").resolve("example.js");
    jslintAndPrint(code, file);
    // instrument example.js
    code = instrumentInPackage(code, file);
    // eval example.js
    Module = require("module");
    exports = new Module(file);
    require.cache[file] = exports;
    exports._compile(code, file);
    // export example.js
    exports = exports.exports;
    exports.utility2 = local;
    exports[npm_package_nameLib] = globalThis.utility2_moduleExports;
    // cleanup utility2_moduleExports
    delete globalThis.utility2_moduleExports;
    // init assets lib.xxx.js
    [
        ".css", ".js"
    ].forEach(function (extname) {
        assetsDict[
            "/assets." + npm_package_nameLib + extname
        ] = fsReadFileOrDefaultSync(
            require("path").resolve(npm_package_main).replace((
                /\.\w+?$/
            ), extname),
            "utf8",
            ""
        ).replace((
            /^#!\//
        ), "// ");
    });
    Object.assign(assetsDict, exports.assetsDict);
    // instrument assets lib.xxx.js
    assetsDict["/assets." + npm_package_nameLib + ".js"] = (
        instrumentInPackage(
            assetsDict["/assets." + npm_package_nameLib + ".js"],
            npm_package_main
        )
    );
    exports.assetsDict = assetsDict;
    assetsDict["/assets.example.js"] = code;
    assetsDict["/assets.test.js"] = instrumentInPackage(
        require("fs").readFileSync("test.js", "utf8"),
        "test.js"
    );
    // init assets index.html
    file = assetsDict["/"];
    // uncomment utility2-comment
    file = file.replace((
        /\n<!--\u0020utility2-comment\n|\nutility2-comment\u0020-->\n/g
    ), "\n\n");
    // interpolate {{...}}
    file = templateRenderMyApp(file);
    assetsDict["/"] = file;
    assetsDict["/index.html"] = file;
    // init assets.app.js
    assetsDict["/assets.app.js"] = [
        "header",
        "/assets.utility2.rollup.js",
        "/assets.utility2.rollup.start.js",
        "/assets.my_app.css",
        "/assets.my_app.js",
        "/assets.example.js",
        "/assets.test.js",
        "/assets.utility2.rollup.end.js"
    ].map(function (key) {
        switch (key) {
        case "/assets.my_app.css":
            file = "/assets." + npm_package_nameLib + ".css";
            // disable $-escape in replacement-string
            code = assetsDict[
                "/assets.utility2.rollup.content.js"
            ].replace("/* utility2.rollup.js content */", function () {
                return (
                    "local.assetsDict[\"" + file + "\"] = (\n" +
                    JSON.stringify(assetsDict[file]).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") +
                    ");\n"
                );
            });
            break;
        case "/assets.my_app.js":
            file = "/assets." + npm_package_nameLib + ".js";
            // disable $-escape in replacement-string
            code = assetsDict[
                "/assets.utility2.rollup.content.js"
            ].replace("/* utility2.rollup.js content */", function () {
                return (
                    "local.assetsDict[\"" + file + "\"] = (\n" +
                    JSON.stringify(assetsDict[file]).replace((
                        /\\\\/g
                    ), "\u0000").replace((
                        /\\n/g
                    ), "\\n\\\n").replace((
                        /\u0000/g
                    ), "\\\\") +
                    ");\n" +
                    assetsDict[file]
                );
            });
            break;
        case "header":
            return (
                "/* this rollup was created with utility2\n" +
                " * https://github.com/kaizhu256/node-utility2\n" +
                " */\n" +
                "\n" +
                "\n" +
                "/*\n" +
                "assets.app.js\n" +
                "\n" +
                npm_package_description + "\n" +
                "\n" +
                "instruction\n" +
                "    1. save this script as assets.app.js\n" +
                "    2. run shell-cmd:\n" +
                "        $ PORT=8081 node assets.app.js\n" +
                "    3. open browser to http://127.0.0.1:8081 " +
                "and play with web-demo\n" +
                "    4. edit this script to suit your needs\n" +
                "*/\n" +
                assetsDict["/assets.utility2.rollup.start.js"].replace((
                    /utility2_rollup/g
                ), "utility2_app")
            );
        default:
            code = assetsDict[key];
        }
        return (
            "/* script-begin " + key + " */\n" +
            code.trim() +
            "\n/* script-end " + key + " */\n"
        );
    }).join("\n\n\n");
    objectAssignDefault(exports, local);
    // init testCase_buildXxx
    Object.keys(local).forEach(function (key) {
        if (
            key.indexOf("_testCase_build") === 0 ||
            key === "_testCase_webpage_default"
        ) {
            exports[key.slice(1)] = exports[key.slice(1)] || local[key];
        }
    });
    return exports;
};

local.serverRequestListener = function (req, res) {
/*
 * this function will handle server-<req> and server-<res> using
 * express-like middleware-chaining
 */
    let isDone;
    let list;
    let timeStart;
    let timeout;
    let timerTimeout;
    let urlParsed;
    let {
        assetsDict,
        middlewareList
    } = local;
    function onClose() {
    /*
     * this function will hand "close" evt
     */
        console.error("serverLog - " + JSON.stringify({
            time: new Date(timeStart).toISOString(),
            type: "serverResponse",
            method: req.method,
            url: urlParsed.pathname,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - timeStart
        }) + "\n");
        isDone = true;
        clearTimeout(timerTimeout);
        req.destroy();
        res.destroy();
    }
    function onError(err) {
    /*
     * this function will end server-request
     */
        if (!isDone && !err) {
            isDone = true;
            res.statusCode = 404;
            res.end("404 Not Found");
            return;
        }
        console.error(err || new Error("onError called more than once"));
        if (isDone) {
            req.destroy();
            res.destroy();
            return;
        }
        isDone = true;
        res.statusCode = 500;
        res.end("500 Internal Server Error");
    }
    function onTimeout() {
        isDone = true;
        onError(new Error("timeout - " + timeout + " ms"));
    }
    async function middlewareInit(req, ignore, next) {
        let contentType;
        // init timeStart
        timeStart = Date.now();
        // init timerTimeout
        timeout = timeout || npm_config_timeout;
        timerTimeout = setTimeout(onTimeout, timeout);
        // init urlParsed
        urlParsed = new URL("http://127.0.0.1:" + PORT + req.url);
        // init evt-handling
        req.on("abort", onError);
        req.on("close", onClose);
        req.on("error", onError);
        res.on("error", onError);
        res.on("close", onClose);
        // set reponse-header "content-type"
        contentType = {
            // application
            ".js": "application/javascript; charset=utf-8",
            ".json": "application/json; charset=utf-8",
            ".mjs": "application/javascript; charset=utf-8",
            ".pdf": "application/pdf",
            ".wasm": "application/wasm",
            ".xml": "application/xml; charset=utf-8",
            // image
            ".bmp": "image/bmp",
            ".gif": "image/gif",
            ".jpe": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".jpg": "image/jpeg",
            ".png": "image/png",
            ".svg": "image/svg+xml; charset=utf-8",
            // text
            ".css": "text/css; charset=utf-8",
            ".htm": "text/html; charset=utf-8",
            ".html": "text/html; charset=utf-8",
            ".md": "text/markdown; charset=utf-8",
            ".txt": "text/plain; charset=utf-8",
            "/": "text/html; charset=utf-8"
        };
        contentType = contentType[(
            /^\/$|\.[^.]*?$|$/m
        ).exec(urlParsed.pathname)[0]];
        if (contentType) {
            res.setHeader("content-type", contentType);
        }
        await next();
    }
    async function middlewareServeAsset(ignore, res, next) {
    /*
     * this function will serve assets from <assetsDict>
     */
        if (!assetsDict.hasOwnProperty(urlParsed.pathname)) {
            await next();
            return;
        }
        res.statusCode = 200;
        res.end(assetsDict[urlParsed.pathname]);
    }
    async function middlewareServeFile(req, res, next) {
    /*
     * this function will serve <file> from fs
     */
        let file;
        if (req.method !== "GET") {
            await next();
            return;
        }
        file = urlParsed.pathname.slice(1);
        // replace trailing "/" with "/index.html"
        file = file.replace((
            /\/$/
        ), "/index.html");
        // resolve file
        file = require("path").resolve(file);
        if (
            // security - disable parent-directory lookup
            file.indexOf(process.cwd() + require("path").sep) !== 0 ||
            // security - ignore file with non-alphanumeric-first-character
            !(
                /[0-9A-Za-z]/
            ).test(require("path").basename(file)[0])
        ) {
            await next();
            return;
        }
        try {
            file = await require("fs").promises.readFile(file);
        } catch (ignore) {
            await next();
            return;
        }
        res.end(file);
    }
    async function next() {
        let middleware;
        try {
            middleware = list.shift();
            if (isDone || !middleware) {
                onError();
                return;
            }
            // recurse
            await middleware(req, res, next);
        } catch (errCaught) {
            onError(errCaught);
        }
    }
    // init list
    list = [].concat(
        middlewareInit,
        middlewareList,
        middlewareServeAsset,
        middlewareServeFile
    );
    next();
};

local.serverRespondEcho = function (req, res) {
/*
 * this function will respond with debug info
 */
    res.write(
        req.method + " " + req.url +
        " HTTP/" + req.httpVersion + "\r\n" +
        Object.keys(req.headers).map(function (key) {
            return key + ": " + req.headers[key] + "\r\n";
        }).join("") + "\r\n"
    );
    req.pipe(res);
};

local.setTimeoutOnError = function (onError, timeout, err, data) {
/*
 * this function will after timeout has passed,
 * then call <onError>(<err>, <data>)
 */
    if (typeof onError === "function") {
        setTimeout(function () {
            onError(err, data);
        }, timeout);
    }
    return data;
};

local.stringHtmlSafe = function (str) {
/*
 * this function will make <str> html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
    return str.replace((
        /&/gu
    ), "&amp;").replace((
        /"/gu
    ), "&quot;").replace((
        /'/gu
    ), "&apos;").replace((
        /</gu
    ), "&lt;").replace((
        />/gu
    ), "&gt;").replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
    ), "&$1");
};

local.stringRegexpEscape = function (str) {
/*
 * this function will regexp-escape <str>
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
 */
    return str.replace((
        /[\-\/\\\^$*+?.()|\[\]{}]/g
    ), "\\$&");
};

local.svgBadgeCreate = function ({
    fill,
    str1,
    str2
}) {
/*
 * this function will create svg-badge
 */
    let xx1;
    let xx2;
    str1 = String(str1);
    str2 = String(str2);
    xx1 = 6 * str1.length + 20;
    xx2 = 6 * str2.length + 20;
    return (
        "<svg height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\" xmlns=\"http://www.w3.org/2000/svg\">\n" +
        "<rect fill=\"#555\" height=\"20\" width=\"" +
        (xx1 + xx2) +
        "\"/>\n" +
        "<rect fill=\"" + fill + "\" height=\"20\" width=\"" +
        xx2 + "\" x=\"" + xx1 + "\"/>\n" +
        "<g\n" +
        "fill=\"#fff\"\n" +
        "font-family=\"DejaVu Sans,Verdana,Geneva,sans-serif\"\n" +
        "font-size=\"11\"\n" +
        "text-anchor=\"middle\"\n" +
        ">\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        0.5 * xx1 + "\" y=\"15\">" + str1 + "</text>\n" +
        "<text x=\"" + 0.5 * xx1 + "\" y=\"14\">" + str1 + "</text>\n" +
        "<text fill-opacity=\".5\" fill=\"#777\" x=\"" +
        (xx1 + 0.5 * xx2) + "\" y=\"15\">" + str2 + "</text>\n" +
        "<text x=\"" + (xx1 + 0.5 * xx2) + "\" y=\"14\">" + str2 + "</text>\n" +
        "</g>\n" +
        "</svg>\n"
    );
};

local.templateRenderMyApp = function (template) {
/*
 * this function will render my-app template
 */
    template = template.replace((
        /kaizhu256(\.github\.io\/|%252F|\/)/g
    ), GITHUB_OWNER + "$1");
    template = template.replace((
        /node-my-app/g
    ), GITHUB_REPO);
    template = template.replace((
        /\bh1-my-app\b/g
    ), (
        npm_package_nameHeroku ||
        ("h1-" + npm_package_nameLib.replace((
            /_/g
        ), "-"))
    ));
    template = template.replace((
        /\bmy-app\b/g
    ), npm_package_name);
    template = template.replace((
        /my_app/g
    ), npm_package_nameLib);
    template = template.replace((
        /\{\{(\w+)(\u0020jsonStringify)?\}\}/g
    ), function (ignore, key, jsonStringify) {
        return String(
            jsonStringify
            ? JSON.stringify(local[key])
            : String(local[key])
        ).replace((
            /<\//g
        ), "<\\/");
    });
    return template;
};

local.testCase_noop_default = function (opt, onError) {
/*
 * this function will test noop's default handling-behavior
 */
    noop();
    onError(undefined, opt);
};

local.testMock = function (mockList, onTestCase, onError) {
/*
 * this function will mock objects in <mockList> when running <onTestCase>
 */
    let onError2;
    onError2 = function (err) {
        // restore mock[0] from mock[2]
        mockList.reverse().forEach(function (mock) {
            Object.keys(mock[2]).forEach(function (key) {
                try {
                    mock[0][key] = mock[2][key];
                } catch (errCaught) {
                    console.error(errCaught);
                }
            });
        });
        onError(err);
    };
    // suppress console.error and console.log
    mockList.unshift([
        console, {}
    ]);
    local.objectAssignDefault(mockList[0][1], {
        error: noop,
        log: noop
    });
    // mock mock[0]
    mockList.forEach(function (mock) {
        mock[2] = {};
        // backup mock[0] into mock[2]
        Object.keys(mock[1]).forEach(function (key) {
            mock[2][key] = mock[0][key];
        });
        // override mock[0] with mock[1]
        Object.keys(mock[1]).forEach(function (key) {
            try {
                mock[0][key] = mock[1][key];
            } catch (errCaught) {
                console.error(errCaught);
            }
        });
    });
    // try to run onTestCase with mock[0]
    try {
        // run onTestCase
        onTestCase(onError2);
    } catch (errCaught) {
        onError2(errCaught);
    }
};

local.testReportMerge = function (
    testReport = {},
    testReport2 = {},
    mode = undefined
) {
/*
 * this function will
 * 1. merge <testReport2> into <testReport>
 * 2. render <testReport>.html
 * 3. write <testReport> to fs
 */
    let html;
    let testCaseNumber;
    let testPlatformDict;
    let testPlatformList;
    function fileWrite(file, data) {
    /*
     * this function will write <data> to <file>
     */
        file = require("path").resolve(UTILITY2_DIR_BUILD + "/" + file);
        require("fs").writeFileSync(file, data);
        console.error("test-report - wrote - " + file);
    }
    // 1. merge <testReport2> into <testReport>
    testReport = local.objectAssignDefault(testReport, {
        coverage: globalThis.__coverage__,
        date: new Date().toISOString(),
        testPlatformList: [
            {}
        ]
    });
    testPlatformDict = {};
    // deduplicate testPlatform with same name
    testPlatformList = [].concat(
        testReport.testPlatformList,
        testReport2.testPlatformList || []
    ).reverse().map(function (testPlatform) {
        local.objectAssignDefault(testPlatform, {
            date: new Date().toISOString(),
            modeBuild: MODE_CI,
            nameBase: (
                isEnvNode
                ? "node - " + process.platform + " - " + process.version
                : "browser - " + location.pathname + " - " + navigator.userAgent
            ),
            status: "pending",
            testCaseList: [],
            testsFailed: 0,
            testsPassed: 0,
            testsPending: 0,
            timeElapsed: 0,
            timeOnload: (
                globalThis.domOnEventWindowOnloadTimeElapsed < 0x10000000000 &&
                globalThis.domOnEventWindowOnloadTimeElapsed | 0
            ),
            timeStart: 0
        });
        testPlatform.name = (
            testPlatform.modeBuild + " - " + testPlatform.nameBase
        );
        testPlatformDict[testPlatform.name] = testPlatform;
        return testPlatform;
    }).slice(-1);
    delete testPlatformDict[testPlatformList[0].name];
    testPlatformList = [
        testPlatformList[0]
    ].concat(Object.values(testPlatformDict).sort(function (aa, bb) {
        return (
            aa.date < bb.date
            ? 1
            : -1
        );
    }));
    Object.assign(testReport, {
        testsFailed: 0,
        testsPassed: 0,
        testsPending: 0
    });
    testPlatformList.forEach(function (testPlatform) {
        Object.assign(testPlatform, {
            testsFailed: 0,
            testsPassed: 0,
            testsPending: 0
        });
        testPlatform.testCaseList.forEach(function ({
            status
        }) {
            switch (status) {
            // update failed tests
            case "failed":
                testPlatform.testsFailed += 1;
                testReport.testsFailed += 1;
                break;
            // update passed tests
            case "passed":
                testPlatform.testsPassed += 1;
                testReport.testsPassed += 1;
                break;
            // update pending tests
            default:
                testPlatform.testsPending += 1;
                testReport.testsPending += 1;
            }
        });
        // update testPlatform.status
        testPlatform.status = (
            testPlatform.testsFailed
            ? "failed"
            : testPlatform.testsPending
            ? "pending"
            : "passed"
        );
        // sort testCaseList by status and name
        testPlatform.testCaseList.sort(function (aa, bb) {
            return (
                (aa.status.replace("passed", "z") + aa.name) >
                (bb.status.replace("passed", "z") + bb.name)
                ? 1
                : -1
            );
        });
    });
    // 2. render <testReport>.html
    testCaseNumber = 0;
    html = local.assetsDict["/assets.utility2.template.html"];
    html = html.replace("assets.utility2.template.html", "");
    html = html.replace((
        /<title>.*?<\/title>/
    ), "<title>test-report</title>");
    // init html - style
    html = html.replace((
        "\n</style>\n"
    ), (
        "\n" +
        "</style>\n" +
        "<style>\n" +
        "/* jslint utility2:true */\n" +
        ".test-report-div img {\n" +
        "    border: 1px solid #999;\n" +
        "    margin: 5px 0 5px 0;\n" +
        "    max-height: 256px;\n" +
        "    max-width: 512px;\n" +
        "}\n" +
        ".test-report-div pre {\n" +
        "    background: #fdd;\n" +
        "    border-top: 1px solid #999;\n" +
        "    margin-bottom: 0;\n" +
        "    padding: 10px;\n" +
        "}\n" +
        ".test-report-div span {\n" +
        "    display: inline-block;\n" +
        "    width: 120px;\n" +
        "}\n" +
        ".test-report-div table {\n" +
        "    border-top: 1px solid #999;\n" +
        "    text-align: left;\n" +
        "    width: 100%;\n" +
        "}\n" +
        ".test-report-div table > tbody > tr:nth-child(odd) {\n" +
        "    background: #bfb;\n" +
        "}\n" +
        ".test-report-div .footer {\n" +
        "    text-align: center;\n" +
        "}\n" +
        ".test-report-div .platform {\n" +
        "    background: #fff;\n" +
        "    border: 1px solid #999;\n" +
        "    margin-bottom: 20px;\n" +
        "    padding: 0 10px 10px 10px;\n" +
        "    text-align: left;\n" +
        "}\n" +
        ".test-report-div .summary {\n" +
        "    background: #bfb;\n" +
        "}\n" +
        ".test-report-div .test-failed {\n" +
        "    background: #f99;\n" +
        "}\n" +
        ".test-report-div .test-pending {\n" +
        "    background: #99f;\n" +
        "}\n" +
        "</style>\n"
    ));
    // init html - body
    html = html.replace((
        /\n<\/script>[\S\s]*?<\/body>\n/
    ), function () {
        return (
            "\n" +
            "</script>\n" +
            "<div class=\"test-report-div\">\n" +
            // init html - header
            "<h1>test-report for\n" +
            "    <a href=\"" + (npm_package_homepage || "#") + "\">\n" +
            "    " + npm_package_name + " (" + npm_package_version + ")\n" +
            "    </a>\n" +
            "</h1>\n" +
            "\n" +
            // init html - summary
            "<div class=\"platform summary\">\n" +
            "<h2>summary</h2>\n" +
            "<h4>\n" +
            "    <span>version</span>- " + npm_package_version + "<br>\n" +
            "    <span>test-date</span>- " + testReport.date + "<br>\n" +
            "    <span>commit-info</span>- " +
            CI_COMMIT_ID + " - " + CI_COMMIT_MESSAGE + "<br>\n" +
            "</h4>\n" +
            "<table>\n" +
            "<thead>\n" +
            "    <tr>\n" +
            "    <th>total tests-failed</th>\n" +
            "    <th>total tests-passed</th>\n" +
            "    <th>total tests-pending</th>\n" +
            "    </tr>\n" +
            "</thead>\n" +
            "<tbody>\n" +
            "    <tr>\n" +
            "    <td class=\"" + (
                testReport.testsFailed
                ? "testFailed"
                : "testPassed"
            ) + "\">" + testReport.testsFailed + "</td>\n" +
            "    <td>" + testReport.testsPassed + "</td>\n" +
            "    <td>" + testReport.testsPending + "</td>\n" +
            "    </tr>\n" +
            "</tbody>\n" +
            "</table>\n" +
            "</div>\n" +
            "\n" +
            // init html - testPlatformList
            testPlatformList.map(function ({
                date,
                name,
                screenshot,
                testCaseList,
                testsFailed,
                testsPassed,
                testsPending,
                timeElapsed,
                timeOnload
            }, ii) {
                let errStackList;
                errStackList = [];
                screenshot = screenshot && encodeURIComponent(screenshot);
                return (
                    "<div class=\"platform\">\n" +
                    "<h4>\n" +
                    (ii + 1) + ". " + name + "<br>\n" + (
                        screenshot
                        ? "<a href=\"" + screenshot + "\">\n" +
                        "<img\n" +
                        "alt=\"" + screenshot + "\"\n" +
                        "src=\"" + screenshot + "\"\n" +
                        ">\n" +
                        "</a>\n" +
                        "<br>\n"
                        : ""
                    ) + (
                        timeOnload
                        ? "<span>onload-time</span>- " +
                        timeOnload +
                        " ms<br>\n"
                        : ""
                    ) +
                    "<span>test-date</span>- " + date + "<br>\n" +
                    "<span>time-elapsed</span>- " + timeElapsed + " ms<br>\n" +
                    "<span>tests-failed</span>- " + testsFailed + "<br>\n" +
                    "<span>tests-passed</span>- " + testsPassed + "<br>\n" +
                    "<span>tests-pending</span>- " + testsPending + "<br>\n" +
                    "</h4>\n" +
                    "\n" +
                    // init html - testCaseList
                    "<table>\n" +
                    "<thead><tr>\n" +
                    "<th>#</th>\n" +
                    "<th>time-elapsed</th>\n" +
                    "<th>status</th>\n" +
                    "<th>test-case</th>\n" +
                    "</tr></thead>\n" +
                    "<tbody>\n" +
                    testCaseList.map(function ({
                        errStack,
                        name,
                        status,
                        timeElapsed
                    }) {
                        testCaseNumber += 1;
                        if (errStack) {
                            errStackList.push(
                                testCaseNumber + ". " + name + "\n" +
                                errStack
                            );
                        }
                        return (
                            "<tr>\n" +
                            "<td>" + testCaseNumber + "</td>\n" +
                            "<td>" + timeElapsed + " ms</td>\n" +
                            "<td class=\"test-" + status + "\">" +
                            status + "</td>\n" +
                            "<td>" + name + "</td>\n" +
                            "</tr>\n"
                        );
                    }).join("") +
                    "</tbody>\n" +
                    "</table>\n" +
                    "\n" + (
                        errStackList.length
                        ? "<pre tabIndex=\"0\">\n" +
                        errStackList.join("\n") + "\n" +
                        "</pre>\n"
                        : ""
                    ) +
                    "</div>\n"
                );
            }).join("") +
            "\n" +
            // init html - footer
            "<div class=\"footer\">\n" +
            "[ this document was created with <a\n" +
            "    href=\"https://github.com/kaizhu256/node-utility2\"\n" +
            "    target=\"_blank\"\n" +
            ">utility2</a> ]\n" +
            "</div>\n" +
            "\n" +
            "</div>\n" +
            "</body>\n"
        );
    });
    testReport = Object.assign(testReport, {
        html,
        testPlatformList
    });
    // 3. write <testReport> to fs
    if (mode !== "modeWrite") {
        return testReport;
    }
    delete testReport.coverage;
    delete testReport.html;
    // print test-report summary
    console.error(
        "\n" + new Array(56).join("-") + "\n" +
        testPlatformList.filter(function (testPlatform) {
            // if testPlatform has no tests, then filter it out
            return testPlatform.testCaseList.length;
        }).map(function (testPlatform) {
            return (
                "| test-report - " + testPlatform.name + "\n|" +
                String(
                    testPlatform.timeElapsed + " ms     "
                ).padStart(16, " ") +
                String(
                    testPlatform.testsFailed + " failed "
                ).padStart(16, " ") +
                String(
                    testPlatform.testsPassed + " passed "
                ).padStart(16, " ") +
                "     |\n" + new Array(56).join("-") + "\n"
            );
        }).join("")
    );
    // print failed testCase
    testPlatformList.forEach(function (testPlatform) {
        testPlatform.testCaseList.forEach(function (testCase) {
            if (testCase.status !== "passed") {
                console.error(JSON.stringify(testCase, undefined, 4));
            }
        });
    });
    // jslint html
    jslintAndPrint(html, "test-report.html");
    // create test-report.html
    fileWrite("test-report.html", html);
    // create commit.badge.svg
    fileWrite("commit.badge.svg", local.svgBadgeCreate({
        fill: "#07f",
        str1: "last build",
        str2: (
            new Date().toISOString().slice(0, 19).replace("T", " ") +
            " - " + CI_BRANCH + " - " + CI_COMMIT_ID
        )
    }));
    // create test-report.badge.svg
    fileWrite("test-report.badge.svg", local.svgBadgeCreate({
        fill: (
            testPlatformList[0].testsFailed
            ? "#d00"
            : "#0d0"
        ),
        str1: "tests failed",
        str2: testPlatformList[0].testsFailed
    }));
    // if tests failed, then exit with non-zero exitCode
    process.exit(testReport.testsFailed !== 0);
};

local.testRunDefault = async function (testCaseDict = {}) {
/*
 * this function will run tests in <testCaseDict>
 */
    let consoleError;
    let isCoverage;
    let processExit;
    let testPlatform;
    let testReport;
    let timerInterval;
    function timeElapsedPoll(opt) {
    /*
     * this function will poll "Date.now() - <opt>.timeStart"
     */
        opt.timeStart = opt.timeStart || Date.now();
        opt.timeElapsed = Date.now() - opt.timeStart;
    }
    async function testCaseRun(testCase) {
        let testCasePromise;
        let testCaseResolve;
        testCasePromise = new Promise(function (resolve) {
            testCaseResolve = resolve;
        });
        function onError(err) {
            // update testPlatform.timeElapsed
            timeElapsedPoll(testPlatform);
            // if testCase isDone, then fail testCase
            if (testCase.isDone) {
                err = err || new Error(
                    "callback in testCase " +
                    testCase.name +
                    " called multiple times"
                );
            }
            // if err occurred, then fail testCase
            if (err) {
                // restore console.log
                console.error = consoleError;
                testCase.status = "failed";
                consoleError(
                    "\ntestRunDefault - " +
                    testPlatform.timeElapsed + " ms - testCase failed - " +
                    testCase.name + "\n" + err.message + "\n" + err.stack
                );
                testCase.errStack = (
                    testCase.errStack || err.message + "\n" + err.stack
                );
                // validate errStack is non-empty
                assertOrThrow(
                    testCase.errStack,
                    "invalid errStack " + testCase.errStack
                );
            }
            // if tests isDone, then do nothing
            if (testCase.isDone) {
                return;
            }
            testCase.isDone = true;
            if (testCase.status === "pending") {
                testCase.status = "passed";
            }
            // stop testCase timer
            timeElapsedPoll(testCase);
            consoleError(
                "testRunDefault - " +
                testPlatform.timeElapsed + " ms - [" + (
                    isEnvNode
                    ? "node"
                    : "browser"
                ) + " test-case " +
                testPlatform.testCaseList.filter(function (testCase) {
                    return testCase.isDone;
                }).length + " of " + testPlatform.testCaseList.length
                + " " + testCase.status + "] - " + testCase.name
            );
            testCaseResolve();
        }
        try {
            timeElapsedPoll(testCase);
            testCase.onTestCase({}, onError);
            noop(await testCasePromise);
        } catch (errCaught) {
            onError(errCaught);
        }
    }
    if (npm_config_mode_lib) {
        return;
    }
    // init middlewareList
    local.middlewareList = local.middlewareList || [];
    // init http-server on $PORT
    if (isEnvNode && !globalThis.utility2_serverHttp1) {
        globalThis.utility2_serverHttp1 = require("http").createServer(
            local.serverRequestListener
        );
        console.error("http-server listening on port " + PORT);
        local.onReadyIncrement();
        globalThis.utility2_serverHttp1.listen(PORT, local.onReadyDecrement);
    }
    globalThis.utility2_modeTest = (
        globalThis.utility2_modeTest ||
        testCaseDict.modeTest ||
        npm_config_mode_test
    ) | 0;
    if (
        globalThis.utility2_modeTest !== 1 ||
        Object.keys(testCaseDict).length === 0
    ) {
        return;
    }
    if (localOnReadyCnt !== 0) {
        local.eventListenerAdd("utility2.onReady", {
            once: true
        }, local.testRunDefault.bind(undefined, testCaseDict));
        return;
    }
    globalThis.utility2_modeTest += 1;
    // visual notification - testRun
    // mock console.error
    consoleError = console.error;
    isCoverage = (
        typeof globalThis.__coverage__ === "object" &&
        globalThis.__coverage__ &&
        Object.keys(globalThis.__coverage__).length
    );
    console.error = function (...argList) {
    /*
     * this function will ignore serverLog-msg during test-run
     */
        if (!isCoverage && !(
            /^serverLog\u0020-\u0020\{/
        ).test(argList[0])) {
            consoleError(...argList);
        }
    };
    // mock proces.exit
    if (isEnvNode) {
        processExit = process.exit;
        process.exit = function (exitCode) {
            local.eventListenerEmit(
                "utility2.testRunMock.process.exit",
                exitCode | 0
            );
        };
    }
    // init testReport
    testReport = globalThis.utility2_testReport;
    // init testPlatform
    testPlatform = testReport.testPlatformList[0];
    // init testPlatform timer
    timeElapsedPoll(testPlatform);
    // reset testPlatform.testCaseList
    testPlatform.testCaseList.length = 0;
    // add tests into testPlatform.testCaseList
    Object.entries(testCaseDict).forEach(function ([
        key, val
    ]) {
        // add testCase testCaseDict[key] to testPlatform.testCaseList
        if (
            key && typeof val === "function" && (
                npm_config_mode_test_case
                ? npm_config_mode_test_case.split(",").indexOf(key) >= 0
                : key.indexOf("testCase_") === 0
            )
        ) {
            testPlatform.testCaseList.push({
                name: key,
                status: "pending",
                onTestCase: val
            });
        }
    });
    local.testReportMerge(testReport);
    local.eventListenerEmit("utility2.testRunStart", testReport);
    // testRunUpdate every 2000 ms until isDone
    timerInterval = setInterval(function () {
        // update testPlatform.timeElapsed
        timeElapsedPoll(testPlatform);
        local.testReportMerge(testReport);
        local.eventListenerEmit("utility2.testRunUpdate", testReport);
        // cleanup timerInterval
        if (!testReport.testsPending) {
            clearInterval(timerInterval);
        }
        // list pending testCase every 5000 ms
        if (testPlatform.timeElapsed % 5000 < 3000) {
            consoleError(
                "testRunDefault - " +
                testPlatform.timeElapsed + " ms - testCase pending - " +
                testPlatform.testCaseList.filter(function (testCase) {
                    return testCase.status === "pending";
                }).slice(0, 4).map(function (testCase) {
                    return testCase.name;
                }).join(", ") + " ..."
            );
        }
    }, 2000);
    // run testCaseList
    await Promise.all(testPlatform.testCaseList.map(testCaseRun));
    clearInterval(timerInterval);
    // update timeElapsed
    timeElapsedPoll(testPlatform);
    // finalize testReport
    local.testReportMerge(testReport);
    // restore console.log
    console.error = consoleError;
    // restore process.exit
    if (processExit) {
        process.exit = processExit;
    }
    // create test-report.json
    delete testReport.coverage;
    local.fsWriteFileWithMkdirpSync(
        UTILITY2_DIR_BUILD + "/test-report.json",
        JSON.stringify(testReport, undefined, 4)
    );
    // reset utility2_modeTest
    globalThis.utility2_modeTest = 0;
    // save testReport and coverage
    testReport.coverage = globalThis.__coverage__;
    console.timeStamp(globalThis.utility2_testId);
    local.eventListenerEmit("utility2.testRunEnd", testReport);
    // exit with number of tests failed
    if (processExit) {
        process.exit(testReport.testsFailed, testReport);
    }
};

local.tryCatchOnError = function (fnc, onError) {
/*
 * this function will run <fnc> in tryCatch block,
 * else call onError with errCaught
 */
    let result;
    // validate onError
    local.assertOrThrow(typeof onError === "function", typeof onError);
    try {
        // reset errCaught
        delete local._debugTryCatchError;
        result = fnc();
        delete local._debugTryCatchError;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
};

local.uiAnimateSlideAccordian = function (elem, elemList, onError) {
/*
 * this function will slideDown <elem>, but slideUp elements in <elemList>
 */
    elemList.forEach(function (elem2) {
        if (elem2 !== elem) {
            local.uiAnimateSlideUp(elem2);
        }
    });
    setTimeout(function () {
        local.uiAnimateSlideDown(elem, onError);
    }, 250);
};

local.uiAnimateSlideDown = function (elem, onError) {
/*
 * this function will slideDown dom-<elem>
 */
    onError = onError || noop;
    if (!(
        elem &&
        elem.style && elem.style.maxHeight !== "100%" &&
        elem.classList && elem.classList.contains("uiAnimateSlide")
    )) {
        onError();
        return;
    }
    elem.style.borderBottom = "";
    elem.style.borderTop = "";
    elem.style.marginBottom = "";
    elem.style.marginTop = "";
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + "px";
    elem.style.paddingBottom = "";
    elem.style.paddingTop = "";
    setTimeout(function () {
        elem.style.maxHeight = "100%";
        onError();
    }, 250);
};

local.uiAnimateSlideUp = function (elem, onError) {
/*
 * this function will slideUp dom-<elem>
 */
    if (!(
        elem &&
        elem.style && elem.style.maxHeight !== "0px" &&
        elem.classList && elem.classList.contains("uiAnimateSlide")
    )) {
        local.setTimeoutOnError(onError);
        return;
    }
    elem.style.borderBottom = "0";
    elem.style.borderTop = "0";
    elem.style.marginBottom = "0";
    elem.style.marginTop = "0";
    elem.style.maxHeight = "0";
    elem.style.paddingBottom = "0";
    elem.style.paddingTop = "0";
    local.setTimeoutOnError(onError, 250);
};

local.urlJoin = function (aa, bb) {
/*
 * this function will if bb is relative, url-join aa with bb
 */
    // bb is absolute-url
    if ((
        /^\w+?:\/\//
    ).test(bb)) {
        return bb;
    }
    // bb is absolute-url without protocol
    if (bb.slice(0, 2) === "//") {
        return aa.split("/")[0] + bb;
    }
    // bb is absolute-url without host
    if (bb[0] === "/") {
        return aa.split("/").slice(0, 3).join("/") + bb;
    }
    // bb is relative-url
    if (aa.split("/").length < 4) {
        aa += "/";
    }
    return aa.replace((
        /[?#].*?$/
    ), "").replace((
        /[^\/]*?$/
    ), "") + bb;
};

local.uuid4Create = function () {
/*
 * this function will create random uuid with format
 * "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
 */
    // code derived from http://jsperf.com/uuid4
    let id;
    let ii;
    id = "";
    ii = 0;
    while (ii < 32) {
        switch (ii) {
        case 8:
        case 20:
            id += "-";
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
            break;
        case 12:
            id += "-";
            id += "4";
            break;
        case 16:
            id += "-";
            id += local.identity((Math.random() * 4) | 8).toString(16);
            break;
        default:
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
        }
        ii += 1;
    }
    return id;
};

/* validateLineSortedReset */
// run shared js-env code - init-after
// init utility2_testReport
globalThis.utility2_testReport = local.testReportMerge(
    globalThis.utility2_testReport
);
local.regexpCharsetEncodeUri = (
    /!#\$%&'\(\)\*\+,-\.\/0123456789:;=\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/
);
local.regexpCharsetEncodeUriComponent = (
    /!%'\(\)\*-\.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~/
);
// https://www.w3.org/TR/html5/sec-forms.html#email-state-typeemail
local.regexpValidateEmail = (
    /^[a-zA-Z0-9.!#$%&'*+\/=?\^_`{|}~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/
);
// https://en.wikipedia.org/wiki/E.164
local.regexpValidatePhone = (
    /^(?:\+\d{1,3}[\u0020\-]?)?(?:\(\d{1,4}\)[\u0020\-]?)?\d[\d\u0020\-]{7,17}$/
);
local.regexpValidateUuid = (
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
);
local.stringCharsetAscii = (
    "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" +
    "\b\t\n\u000b\f\r\u000e\u000f" +
    "\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017" +
    "\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f" +
    " !\"#$%&'()*+,-./0123456789:;<=>?" +
    "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_" +
    "`abcdefghijklmnopqrstuvwxyz{|}~\u007f"
);
assertJsonEqual(
    local.stringCharsetAscii,
    Array.from(new Array(128), function (ignore, ii) {
        return String.fromCharCode(ii);
    }).join("")
);
local.stringCharsetEncodeUri = (
    "!#$%&'()*+,-./" +
    "0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
);
local.stringCharsetEncodeUriComponent = (
    "!%'()*-." +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
);
local.stringHelloEmoji = "hello \ud83d\ude01\n";


/* istanbul ignore next */
// run node js-env code - init-after
(function () {
if (!isEnvNode) {
    return;
}
// exit after $npm_config_timeout_exit
if (!npm_config_mode_lib && npm_config_timeout_exit) {
    setTimeout(process.exit.bind(undefined, 15), npm_config_timeout_exit);
}
// merge previous test-report
if (!npm_config_mode_lib && npm_config_mode_test_report_merge) {
    local.testReportMerge(
        globalThis.utility2_testReport,
        local.fsReadFileOrDefaultSync(
            UTILITY2_DIR_BUILD + "/test-report.json",
            "json",
            {}
        )
    );
    if (process.argv[2] !== "--help") {
        console.error(
            "\n" + MODE_CI + " - merged test-report from file " +
            UTILITY2_DIR_BUILD + "/test-report.json"
        );
    }
}
// init cli
local.cliDict = {};
local.cliDict["utility2.browserTest"] = async function () {
/*
 * <urlList> <mode>
 * will browser-test in parallel, comma-separated <urlList> with given <mode>
 */
    local.browserTest({
        url: process.argv[3]
    });
};

local.cliDict["utility2.testReportCreate"] = function () {
/*
 *
 * will create test-report
 */
    let testReport;
    try {
        testReport = JSON.parse(require("fs").readFileSync(
            UTILITY2_DIR_BUILD + "/test-report.json",
            "utf8"
        ));
    } catch (ignore) {}
    local.testReportMerge(testReport, {}, "modeWrite");
};

if (module === require.main && (!globalThis.utility2_rollup || (
    process.argv[2] &&
    local.cliDict[process.argv[2]] &&
    process.argv[2].indexOf("utility2.") === 0
))) {
    local.cliRun({});
    if (local.cliDict[process.argv[2]]) {
        switch (process.argv[2]) {
        case "--interactive":
        case "-i":
        case "utility2.start":
            break;
        default:
            return;
        }
    }
}
// override assets
if (globalThis.utility2_rollup) {
    local.assetsDict["/assets.utility2.rollup.js"] = (
        require("fs").readFileSync(
            __filename,
            "utf8"
        ).split("\n/* script-end /assets.utility2.rollup.end.js */")[0] +
        "\n/* script-end /assets.utility2.rollup.end.js */\n"
    );
    return;
}
// init assets
[
    "/assets.utility2.example.js",
    "/assets.utility2.html",
    "/assets.utility2.test.js",
    "lib.apidoc.js",
    "lib.istanbul.js",
    "lib.jslint.js",
    "lib.marked.js",
    "lib.utility2.js",
    "test.js"
].forEach(function (key) {
    switch (key) {
    case "/assets.utility2.example.js":
        local.assetsDict[key] = "";
        local.fsReadFileOrDefaultSync(
            __dirname + "/README.md",
            "utf8",
            ""
        ).replace((
            /```javascript([\S\s]*?)```/
        ), function (ignore, match1) {
            local.assetsDict[key] = match1.trim() + "\n";
            return "";
        });
        break;
    case "/assets.utility2.html":
        local.assetsDict[key] = "";
        local.fsReadFileOrDefaultSync(
            __dirname + "/README.md",
            "utf8",
            ""
        ).replace((
            /<!doctype\u0020html>[\S\s]*?<\/html>\\n\\\n/
        ), function (match0) {
            match0 = match0.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || "";
            });
            match0 = match0.replace(
                "<script src=\"assets.app.js\"></script>\n",
                (
                    "<script " +
                    "src=\"assets.utility2.rollup.js\"></script>\n" +
                    "<script " +
                    "src=\"assets.utility2.example.js\"></script>\n" +
                    "<script " +
                    "src=\"assets.utility2.test.js\"></script>\n"
                )
            );
            match0 = match0.replace(
                "assets.example.js",
                "assets.utility2.example.js"
            );
            match0 = match0.replace(
                "assets.test.js",
                "assets.utility2.test.js"
            );
            match0 = match0.replace((
                /npm_package_/g
            ), "");
            match0 = match0.replace((
                /<!--\u0020utility2-comment\b([\S\s]*?)\butility2-comment\u0020-->/g
            ), "$1");
            return "";
        });
        break;
    case "/assets.utility2.test.js":
        local.assetsDict[key] = local.fsReadFileOrDefaultSync(
            __dirname + "/test.js",
            "utf8",
            ""
        );
        break;
    case "lib.utility2.js":
        key = key.replace("lib.", "");
        local.assetsDict["/assets." + key] = local.fsReadFileOrDefaultSync(
            __dirname + "/lib." + key,
            "utf8",
            ""
        ).replace((
            /^#!\//
        ), "// ");
        break;
    default:
        local.assetsDict["/assets.utility2." + key] = (
            local.fsReadFileOrDefaultSync(
                __dirname + "/" + key,
                "utf8",
                ""
            ).replace((
                /^#!\//
            ), "// ")
        );
    }
});
/* validateLineSortedReset */
local.assetsDict["/assets.utility2.rollup.js"] = [
    "header",
    "/assets.utility2.rollup.start.js",
    "lib.apidoc.js",
    "lib.istanbul.js",
    "lib.jslint.js",
    "lib.marked.js",
    "lib.utility2.js",
    "/assets.utility2.example.js",
    "/assets.utility2.html",
    "/assets.utility2.lib.jslint.js",
    "/assets.utility2.test.js",
    "/assets.utility2.rollup.end.js"
].map(function (key) {
    let code;
    switch (key) {
    case "/assets.utility2.example.js":
    case "/assets.utility2.html":
    case "/assets.utility2.lib.jslint.js":
    case "/assets.utility2.test.js":
        // disable $-escape in replacement-string
        code = local.assetsDict[
            "/assets.utility2.rollup.content.js"
        ].replace("/* utility2.rollup.js content */", function () {
            return (
                "local.assetsDict[\"" + key + "\"] = (\n" +
                JSON.stringify(local.assetsDict[key]).replace((
                    /\\\\/g
                ), "\u0000").replace((
                    /\\n/g
                ), "\\n\\\n").replace((
                    /\u0000/g
                ), "\\\\") +
                ");\n"
            );
        });
        break;
    case "/assets.utility2.rollup.start.js":
    case "/assets.utility2.rollup.end.js":
        code = local.assetsDict[key];
        break;
    case "header":
        return (
            "/* this rollup was created with utility2\n" +
            " * https://github.com/kaizhu256/node-utility2\n" +
            " */\n"
        );
    case "lib.utility2.js":
        key = "/assets." + key.replace("lib.", "");
        code = local.assetsDict[key];
        break;
    default:
        key = "/assets.utility2." + key;
        code = local.assetsDict[key];
    }
    return (
        "/* script-begin " + key + " */\n" +
        code.trim() +
        "\n/* script-end " + key + " */\n"
    );
}).join("\n\n\n");
}());
}());
}());

/* jslint ignore:end */
    return local;
}(globalThis.utility2_rollup));
/* script-end /assets.my_app.js */



/* script-begin /assets.example.js */
/*
example.js

this script will demo automated browser-tests with coverage
(via puppeteer and istanbul)

instruction
    1. save this script as example.js
    2. run the shell-command:
        $ npm install utility2 && \
            PATH="$(pwd)/node_modules/.bin:$PATH" \
            PORT=8081 \
            UTILITY2_DIR_BUILD=.tmp/build \
            npm_config_mode_coverage=utility2 \
            node_modules/.bin/utility2 test example.js
    3. view test-report in .tmp/build/test-report.html
    4. view coverage in .tmp/build/coverage/index.html
*/


/* istanbul instrument in package utility2 */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


/* jslint utility2:true */
(function (local) {
"use strict";


// run shared js-env code - init-before
(function () {
// init local
local = (
    globalThis.utility2_rollup ||
    globalThis.utility2_utility2 ||
    globalThis.utility2_moduleExports
);
// init exports
globalThis.local = local;
}());


// run shared js-env code - function
(function () {
// init assets
local.assetsDict["/assets.hello.txt"] = "hello \ud83d\ude01\n";
local.assetsDict["/assets.index.template.html"] = "";

local.testCase_httpFetch_200 = async function (opt, onError) {
/*
 * this function will test httpFetch's "200 ok" handling-behavior
 */
    // test httpFetch-path "assets.hello.txt"
    opt = await local.httpFetch("assets.hello.txt");
    // validate status is 200
    local.assertJsonEqual(opt.status, 200);
    // validate responseText
    local.assertJsonEqual(await opt.text(), "hello \ud83d\ude01\n");
    onError(undefined, opt);
};

local.testCase_httpFetch_404 = async function (opt, onError) {
/*
 * this function will test httpFetch's "404 not found" handling-behavior
 */
    // test httpFetch-path "undefined"
    opt = await local.httpFetch("assets.hello.txt");
    // validate status is 200 - should fail
    local.assertJsonEqual(opt.status, 200);
    onError();
};

local.testCase_webpage_default = async function (opt, onError) {
/*
 * this function will test webpage's default handling-behavior
 */
    if (!local.isEnvNode) {
        onError(undefined, opt);
        return;
    }
    await local.browserTest({
        url: "http://127.0.0.1:" + process.env.PORT + "/?npm_config_mode_test=1"
    });
    onError(undefined, opt);
};

// run tests
if (local.isEnvNode && process.env.npm_config_mode_test) {
    local.testRunDefault(local);
}
}());


/* istanbul ignore next */
// run browser js-env code - init-test
(function () {
if (local.isEnvNode) {
    return;
}
// log stderr and stdout to #outputStdout1
["error", "log"].forEach(function (key) {
    let elem;
    let fnc;
    elem = document.querySelector("#outputStdout1");
    if (!elem) {
        return;
    }
    fnc = console[key];
    console[key] = function (...argList) {
        fnc(...argList);
        // append text to #outputStdout1
        elem.textContent += argList.map(function (arg) {
            return (
                typeof arg === "string"
                ? arg
                : JSON.stringify(arg, undefined, 4)
            );
        }).join(" ").replace((
            /\u001b\[\d+?m/g
        ), "") + "\n";
        // scroll textarea to bottom
        elem.scrollTop = elem.scrollHeight;
    };
});
}());


/* istanbul ignore next */
// run node js-env code - init-test
(function () {
if (!local.isEnvNode) {
    return;
}
// init exports
module.exports = local;
// init assetsDict
local.assetsDict = local.assetsDict || {};
local.assetsDict["/assets.utility2.js"] = (
    local.assetsDict["/assets.utility2.js"] ||
    require("fs").readFileSync(
        require("path").resolve(local.__dirname + "/lib.utility2.js"),
        "utf8"
    ).replace((
        /^#!\//
    ), "// ")
);
/* validateLineSortedReset */
/* jslint ignore:start */
local.assetsDict["/"] = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta
    content="width=device-width, initial-scale=1"
    name="viewport"
>
<!-- "assets.utility2.template.html" -->
<title>utility2 (2020.12.3)</title>
<style>
/* jslint utility2:true */
/*csslint
*/
/* csslint ignore:start */
*,
*:after,
*:before {
    box-sizing: border-box;
}
.uiAnimateSlide {
    overflow-y: hidden;
    transition:
        max-height ease-in 250ms,
        min-height ease-in 250ms,
        padding-bottom ease-in 250ms,
        padding-top ease-in 250ms;
}
/* csslint ignore:end */
@keyframes uiAnimateSpin {
0% {
    transform: rotate(0deg);
}
100% {
    transform: rotate(360deg);
}
}
a {
    overflow-wrap: break-word;
}
body {
    background: #f7f7f7;
    font-family: Arial, Helvetica, sans-serif;
    font-size: small;
    margin: 0 40px;
}
body > div,
body > input,
body > pre,
body > .button,
body > .textarea {
    margin-bottom: 20px;
    margin-top: 0;
}
body > input,
body > .button {
    width: 20rem;
}
body > .readonly {
    background: #ddd;
}
body > .textarea {
    height: 10rem;
    resize: vertical;
    width: 100%;
}
code,
pre,
.textarea {
    font-family: Consolas, Menlo, monospace;
    font-size: smaller;
}
pre {
    overflow-wrap: break-word;
    white-space: pre-wrap;
}
.button {
    background: #ddd;
    border: 1px solid #999;
    color: #000;
    cursor: pointer;
    display: inline-block;
    padding: 2px 5px;
    text-align: center;
    text-decoration: none;
}
.button:hover {
    background: #bbb;
}
.colorError {
    color: #d00;
}
.textarea {
    background: #fff;
    border: 1px solid #999;
    border-radius: 0;
    cursor: auto;
    overflow: auto;
    padding: 2px;
}
.zeroPixel {
    border: 0;
    height: 0;
    margin: 0;
    padding: 0;
    width: 0;
}
</style>
</head>
<body>
<div class="uiAnimateSpin" style="
    animation: uiAnimateSpin 2s linear infinite;
    border-radius: 50%;
    border-top: 5px solid #7d7;
    border: 5px solid #999;
    display: none;
    height: 25px;
    vertical-align: middle;
    width: 25px;
"></div>
<script>
/* jslint utility2:true */
(function () {
    "use strict";
    // polyfill globalThis
    window.globalThis = window;
    // measure-and-print time-elapsed for window.onload
    if (!window.domOnEventWindowOnloadTimeElapsed) {
        window.domOnEventWindowOnloadTimeElapsed = Date.now() + 100;
        window.addEventListener("load", function () {
            setTimeout(function () {
                window.domOnEventWindowOnloadTimeElapsed = (
                    Date.now() -
                    window.domOnEventWindowOnloadTimeElapsed
                );
                console.error(
                    "domOnEventWindowOnloadTimeElapsed = " +
                    window.domOnEventWindowOnloadTimeElapsed
                );
            }, 100);
        });
    }
    // limit select-all within <pre tabIndex="0"> elem
    if (!window.domOnEventSelectAllWithinPre) {
        window.domOnEventSelectAllWithinPre = function (evt) {
            let range;
            let selection;
            if (
                (evt.ctrlKey || evt.metaKey) &&
                evt.key === "a" &&
                evt.target.closest("pre")
            ) {
                range = document.createRange();
                range.selectNodeContents(evt.target.closest("pre"));
                selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                evt.preventDefault();
            }
        };
        // handle evt
        document.addEventListener(
            "keydown",
            window.domOnEventSelectAllWithinPre
        );
    }
}());
</script>
<h1>
<a href="https://github.com/kaizhu256/node-utility2" target="_blank">
    utility2 (2020.12.3)
</a>
</h1>
<h3>this zero-dependency package will provide high-level functions to to build, test, and deploy webapps</h3>
<a
    class="button" download href="assets.app.js"
>download standalone app</a><br>
<button
    class="button"
    id="buttonTestRun1"
>run browser-tests</button><br>
<div class="uiAnimateSlide" id="htmlTestReport1" style="
    border-bottom: 0;
    border-top: 0;
    margin-bottom: 0;
    margin-top: 0;
    max-height: 0;
    padding-bottom: 0;
    padding-top: 0;
"></div>


<!-- custom-html-start -->
<label>edit or paste script below to cover and test</label>
<textarea
    class="textarea"
    id="inputTextarea1">
// remove comment below to disable jslint
/*jslint browser, devel*/
/*global window*/
(function () {
    "use strict";
    let local = window.utility2;
    let testCaseDict = {
        modeTest: 1
    };

    // comment this testCase to disable failed error demo
    testCaseDict.testCase_failed_error_demo = function (opt, onError) {
    /*
     * this function will run a failed error demo
     */
        onError(new Error("this is a failed error demo"), opt);
    };

    testCaseDict.testCase_passed_http_fetch_demo = function (opt, onError) {
    /*
     * this function will demo a passed http-fetch test
     */
        // fetch main-page "/"
        window.fetch("/").then(function (res) {
            // validate "200 ok" status
            local.assertOrThrow(res.status === 200, res.status);
            return res.text();
        }).then(function (data) {
            // validate non-empty data
            local.assertOrThrow(data && data.length > 0, data);
            onError(undefined, opt);
        // handle err
        }).catch(onError);
    };

    // create coverage-report
    local.eventListenerAdd("utility2.testRunEnd", {}, function () {
        document.querySelector(
            "#htmlCoverageReport1"
        ).innerHTML = local.coverageReportCreate({});
    });

    // run tests
    if (!(
        /\bnpm_config_mode_test=1\b/
    ).test(location.search)) {
        local.testRunDefault(testCaseDict);
    }
}());
</textarea>
<button
    class="button"
    id="buttonJslintAutofix1"
>jslint autofix</button><br>
<pre class= "colorError" id="outputJslintPre1" tabindex="0"></pre>
<label>instrumented-code</label>
<textarea
    class="readonly textarea"
    id="outputTextarea1"
    readonly
    tabindex="0"
></textarea>
<label>stderr and stdout</label>
<textarea
    class="onevent-output-reset readonly textarea"
    id="outputStdout1"
    readonly
></textarea>
<div id="htmlCoverageReport1"></div>
<script>
/* jslint utility2:true */
/*jslint eval*/
window.addEventListener("load", function () {
    "use strict";
    let local;
    function testRun(evt) {
        // jslint #inputTextarea1
        local.jslintAndPrint(document.querySelector(
            "#inputTextarea1"
        ).value, "inputTextarea1.js", {
            modeAutofix: evt.target.id === "buttonJslintAutofix1",
            modeConditional: evt.target.id !== "buttonJslintAutofix1"
        });
        document.querySelector(
            "#outputJslintPre1"
        ).textContent = local.jslint.jslintResult.errMsg.replace((
            /\\u001b\\[\\d*m/g
        ), "").trim();
        // jslint-autofix #inputTextarea1
        if (local.jslint.jslintResult.autofix) {
            document.querySelector(
                "#inputTextarea1"
            ).value = local.jslint.jslintResult.code;
        }
        // try to cleanup __coverage__
        try {
            delete globalThis.__coverage__["/inputTextarea1.js"];
        } catch (ignore) {}
        // try to cover and eval #inputTextarea1
        try {
            document.querySelector(
                "#outputTextarea1"
            ).value = local.istanbul.instrumentSync(
                document.querySelector("#inputTextarea1").value,
                "/inputTextarea1.js"
            );
            eval(
                document.querySelector("#outputTextarea1").value
            );
        } catch (errCaught) {
            console.error(errCaught);
        }
    }
    // init local
    local = window.utility2;
    // init evt-handling
    document.querySelector(
        "#buttonJslintAutofix1"
    ).addEventListener("click", testRun);
    document.querySelector(
        "#inputTextarea1"
    ).addEventListener("keyup", testRun);
    // testRun
    testRun({
        target: {}
    });
});
</script>
<!-- custom-html-end -->


<script>
window.utility2_state = {
npm_config_mode_backend: undefined,
npm_package_description: "this zero-dependency package will provide high-level functions to to build, test, and deploy webapps",
npm_package_homepage: "https://github.com/kaizhu256/node-utility2",
npm_package_name: "utility2",
npm_package_nameLib: "utility2",
npm_package_version: "2020.12.3"
}
</script>
<script src="assets.utility2.lib.istanbul.js"></script>
<script src="assets.utility2.lib.jslint.js"></script>
<script src="assets.utility2.lib.marked.js"></script>
<script src="assets.utility2.js"></script>
<script>
/* jslint utility2:true */
window.utility2.onReadyIncrement();
window.addEventListener("load", function () {
    "use strict";
    let local;
    function onTestRun({
        msg,
        target,
        type
    }) {
        switch ((target && target.id) || type) {
        case "buttonTestRun1":
            window.utility2_modeTest = 1;
            local.testRunDefault(window.local);
            return;
        case "utility2.testRunEnd":
            document.querySelectorAll(
                "#buttonTestRun1"
            ).forEach(function (elem) {
                elem.textContent = "run tests";
            });
            document.querySelectorAll(
                "#htmlTestReport1"
            ).forEach(function (elem) {
                elem.innerHTML = msg.html;
            });
            return;
        case "utility2.testRunStart":
            document.querySelectorAll(
                ".onevent-output-reset"
            ).forEach(function (elem) {
                elem.textContent = "";
            });
            document.querySelectorAll(
                "#buttonTestRun1"
            ).forEach(function (elem) {
                elem.textContent = "running tests";
            });
            document.querySelectorAll(
                "#htmlTestReport1"
            ).forEach(function (elem) {
                local.uiAnimateSlideDown(elem);
                elem.innerHTML = msg.html;
            });
            return;
        case "utility2.testRunUpdate":
            document.querySelectorAll(
                "#htmlTestReport1"
            ).forEach(function (elem) {
                local.uiAnimateSlideDown(elem);
                elem.innerHTML = msg.html;
            });
            return;
        }
    }
    local = window.utility2;
    document.querySelectorAll(
        "#buttonTestRun1"
    ).forEach(function (elem) {
        elem.addEventListener("click", onTestRun);
    });
    local.eventListenerAdd("utility2.testRunEnd", {}, onTestRun);
    local.eventListenerAdd("utility2.testRunUpdate", {}, onTestRun);
    local.eventListenerAdd("utility2.testRunStart", {}, onTestRun);
    local.onReadyDecrement();
});
</script>

<script src="assets.example.js"></script>
<script src="assets.test.js"></script>
<div style="text-align: center;">
    [
    this app was created with
    <a
        href="https://github.com/kaizhu256/node-utility2"
        target="_blank"
    >utility2</a>
    ]
</div>
</body>
</html>
`;
/* jslint ignore:end */
local.assetsDict["/assets.example.html"] = local.assetsDict["/"];
// init cli
if (module !== require.main || globalThis.utility2_rollup) {
    return;
}
local.assetsDict["/assets.example.js"] = (
    local.assetsDict["/assets.example.js"] ||
    require("fs").readFileSync(__filename, "utf8")
);
local.assetsDict["/favicon.ico"] = local.assetsDict["/favicon.ico"] || "";
local.assetsDict["/index.html"] = local.assetsDict["/"];
// if $npm_config_timeout_exit exists,
// then exit this process after $npm_config_timeout_exit ms
if (process.env.npm_config_timeout_exit) {
    setTimeout(
        process.exit.bind(undefined, 15),
        process.env.npm_config_timeout_exit | 0
    ).unref();
}
// start server
if (globalThis.utility2_serverHttp1) {
    return;
}
process.env.PORT = process.env.PORT || "8081";
console.error("http-server listening on port " + process.env.PORT);
require("http").createServer(function (req, res) {
    let data;
    data = local.assetsDict[require("url").parse(req.url).pathname];
    if (data !== undefined) {
        res.end(data);
        return;
    }
    res.statusCode = 404;
    res.end();
}).listen(process.env.PORT);
}());
}());
/* script-end /assets.example.js */



/* script-begin /assets.test.js */
/* istanbul instrument in package utility2 */
// assets.utility2.header.js - start
/* jslint utility2:true */
/* istanbul ignore next */
// run shared js-env code - init-local
(function () {
    "use strict";
    let isEnvNode;
    let local;
    // init debugInline
    if (!globalThis.debugInline) {
        let consoleError;
        consoleError = console.error;
        globalThis.debugInline = function (...argList) {
        /*
         * this function will both print <argList> to stderr and
         * return <argList>[0]
         */
            consoleError("\n\ndebugInline");
            consoleError(...argList);
            consoleError("\n");
            return argList[0];
        };
    }
    // init isEnvNode
    isEnvNode = (
        typeof process === "object" && process &&
        process.versions && typeof process.versions.node === "string"
    );
    // init function
    function objectDeepCopyWithKeysSorted(obj) {
    /*
     * this function will recursively deep-copy <obj> with keys sorted
     */
        let sorted;
        if (typeof obj !== "object" || !obj) {
            return obj;
        }
        // recursively deep-copy list with child-keys sorted
        if (Array.isArray(obj)) {
            return obj.map(objectDeepCopyWithKeysSorted);
        }
        // recursively deep-copy obj with keys sorted
        sorted = {};
        Object.keys(obj).sort().forEach(function (key) {
            sorted[key] = objectDeepCopyWithKeysSorted(obj[key]);
        });
        return sorted;
    }
    function assertJsonEqual(aa, bb) {
    /*
     * this function will assert JSON.stringify(<aa>) === JSON.stringify(<bb>)
     */
        aa = JSON.stringify(objectDeepCopyWithKeysSorted(aa));
        bb = JSON.stringify(objectDeepCopyWithKeysSorted(bb));
        if (aa !== bb) {
            throw new Error(JSON.stringify(aa) + " !== " + JSON.stringify(bb));
        }
    }
    function assertOrThrow(passed, msg) {
    /*
     * this function will throw <msg> if <passed> is falsy
     */
        if (passed) {
            return;
        }
        throw (
            (
                msg &&
                typeof msg.message === "string" &&
                typeof msg.stack === "string"
            )
            // if msg is err, then leave as is
            ? msg
            : new Error(
                typeof msg === "string"
                // if msg is string, then leave as is
                ? msg
                // else JSON.stringify(msg)
                : JSON.stringify(msg, undefined, 4)
            )
        );
    }
    function documentQuerySelectorAll(selector) {
    /*
     * this function will return document.querySelectorAll(<selector>) or
     * empty list if function is not available
     */
        return Array.from(
            (
                typeof document === "object" && document &&
                typeof document.querySelectorAll === "function"
            )
            ? document.querySelectorAll(selector)
            : []
        );
    }
    function identity(val) {
    /*
     * this function will return <val>
     */
        return val;
    }
    function noop() {
    /*
     * this function will do nothing
     */
        return;
    }
    function objectAssignDefault(tgt = {}, src = {}, depth = 0) {
    /*
     * this function will if items from <tgt> are null, undefined, or
     * "", then overwrite them with items from <src>
     */
        function recurse(tgt, src, depth) {
            Object.entries(src).forEach(function ([
                key, bb
            ]) {
                let aa;
                aa = tgt[key];
                if (aa === undefined || aa === null || aa === "") {
                    tgt[key] = bb;
                    return;
                }
                if (
                    depth !== 0 &&
                    typeof aa === "object" && aa && !Array.isArray(aa) &&
                    typeof bb === "object" && bb && !Array.isArray(bb)
                ) {
                    recurse(aa, bb, depth - 1);
                }
            });
        }
        recurse(tgt, src, depth | 0);
        return tgt;
    }
    function onErrorThrow(err) {
    /*
     * this function will throw <err> if exists
     */
        if (err) {
            throw err;
        }
    }
    // init local
    local = {
        assertJsonEqual,
        assertOrThrow,
        documentQuerySelectorAll,
        identity,
        isEnvNode,
        local,
        noop,
        objectAssignDefault,
        objectDeepCopyWithKeysSorted,
        onErrorThrow
    };
    globalThis.globalLocal = local;
}());
// assets.utility2.header.js - end


/* jslint utility2:true */
(function (local) {
"use strict";


/* istanbul ignore next */
// run shared js-env code - init-before
(function () {
// init local
local = globalThis.utility2 || require("./lib.utility2.js");
local = local.requireReadme();
globalThis.local = local;
// init test
local.testRunDefault(local);
}());


// run shared js-env code - function
(function () {
let {
    assertJsonEqual,
    assertOrThrow,
    isEnvNode,
    noop,
    onErrorThrow,
    tryCatchOnError
} = local;

local.testCase_assertXxx_default = function (opt, onError) {
/*
 * this function will test assertXxx's default handling-behavior
 */
    // test assertion passed
    assertOrThrow(true, true);
    // test assertion failed with undefined message
    tryCatchOnError(function () {
        assertOrThrow(undefined);
    }, function (err) {
        // validate err
        assertJsonEqual(err.message, "");
    });
    // test assertion failed with string message
    tryCatchOnError(function () {
        assertOrThrow(undefined, "aa");
    }, function (err) {
        // validate err
        assertJsonEqual(err.message, "aa");
    });
    // test assertion failed with errObj
    tryCatchOnError(function () {
        assertOrThrow(undefined, new Error("aa"));
    }, function (err) {
        // validate err
        assertJsonEqual(err.message, "aa");
    });
    // test assertion failed with json object
    tryCatchOnError(function () {
        assertOrThrow(undefined, {
            aa: 1
        });
    }, function (err) {
        // validate err
        assertJsonEqual(err.message, "{\n    \"aa\": 1\n}");
    });
    onError(undefined, opt);
};

local.testCase_buildApidoc_default = function (opt, onError) {
/*
 * this function will test buildApidoc's default handling-behavior
 */
    local._testCase_buildApidoc_default({
        blacklistDict: {}
    }, onError, opt);
};

local.testCase_buildApp_default = function (opt, onError) {
/*
 * this function will test buildApp's default handling-behavior
 */
    local._testCase_buildApp_default({
        customizeAssetsList: [
            {
                file: "/assets.hello.txt",
                url: "/assets.hello.txt"
            }, {
                file: "/assets.script_only.html",
                url: "/assets.script_only.html"
            }, {
                file: "/assets.utility2.lib.istanbul.js",
                url: "/assets.utility2.lib.istanbul.js"
            }, {
                file: "/assets.utility2.lib.jslint.js",
                url: "/assets.utility2.lib.jslint.js"
            }, {
                file: "/assets.utility2.lib.marked.js",
                url: "/assets.utility2.lib.marked.js"
            }, {
                file: "/assets.utility2.rollup.js",
                url: "/assets.utility2.rollup.js"
            }
        ],
        customizeReadmeList: [
            // customize quickstart-example-js-instruction
            {
                merge: (
                    /\n#\u0020quickstart\u0020example.js\n[\S\s]*?\n\n\n/
                )
            // customize quickstart-example-js-comment
            }, {
                aa: "\n<!-- utility2-comment\n",
                bb: "\n"
            // customize quickstart-example-js-comment
            }, {
                aa: "\nutility2-comment -->\n",
                bb: "\n"
            // customize quickstart-example-js-comment
            }, {
                aa: "\n<!-- utility2-comment\n",
                bb: "\n"
            // customize quickstart-example-js-script-1
            }, {
                aa: "<script src=\"assets.utility2.js\"></script>\n",
                bb: "\n"
            // customize quickstart-example-js-script-2
            }, {
                aa: "<script src=\"assets.utility2.rollup.js\"></script>\n",
                bb: (
                    "<script src=\"assets.utility2.lib.istanbul.js\">" +
                    "</script>\n" +
                    "<script src=\"assets.utility2.lib.jslint.js\">" +
                    "</script>\n" +
                    "<script src=\"assets.utility2.lib.marked.js\">" +
                    "</script>\n" +
                    "<script src=\"assets.utility2.js\"></script>\n"
                )
            // customize quickstart-example-js-comment
            }, {
                aa: "\nutility2-comment -->\n",
                bb: "\n"
            // customize quickstart-example-js-screenshot
            }, {
                merge: (
                    /\n```[^`]*?\n#\u0020extra\u0020screenshots\n/
                )
            // customize build-script
            }, {
                merge: (
                    /\n#\u0020internal\u0020build\u0020script\n[\S\s]*?\nshCiMain\n/
                )
            }
        ]
    }, onError, opt);
};

local.testCase_chromeDevtoolsClient_coverage = async function (opt, onError) {
/*
 * this function will test chromeDevtoolsClient's coverage handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    await local.chromeDevtoolsClientCreate({
        modeCoverageHack: 1
    });
    onError(undefined, opt);
};

local.testCase_cliRun_default = function (opt, onError) {
/*
 * this function will test cliRun's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    local.testMock([
        [
            local, {
                replStart: noop
            }
        ], [
            local.cliDict, {}
        ], [
            process, {
                argv: []
            }
        ], [
            require("repl"), {
                start: noop
            }
        ], [
            require("vm"), {
                runInThisContext: noop
            }
        ]
    ], function (onError) {
        // test default handling-behavior
        local.cliDict = {
            _default: noop
        };
        local.cliRun({
            rgxComment: (
                /^/
            )
        });
        // test builtin handling-behavior
        [
            "--eval",
            "--help",
            "--interactive",
            "--version",
            "undefined"
        ].forEach(function (key) {
            process.argv[2] = key;
            local.cliDict = {};
            local.cliRun({
                rgxComment: (
                    /^/
                )
            });
        });
        // test err handling-behavior
        local.cliDict = {};
        tryCatchOnError(local.cliRun.bind(undefined, {}), assertOrThrow);
        onError(undefined, opt);
    }, onError);
};

local.testCase_eventListenerXxx_default = function (opt, onError) {
/*
 * this function will test eventListenerXxx's default handling-behavior
 */
    let listener;
    listener = function ({
        msg,
        type
    }) {
        assertJsonEqual(msg, "bb");
        assertJsonEqual(type, "aa");
    };
    local.eventListenerAdd("aa", {}, listener);
    local.eventListenerAdd("aa", {
        once: true
    }, listener);
    local.eventListenerEmit("aa", "bb");
    local.eventListenerEmit("aa", "bb");
    local.eventListenerRemove(listener);
    onError(undefined, opt);
};

local.testCase_libUtility2Js_standalone = function (opt, onError) {
/*
 * this function will test lib.utility2.js's standalone handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    require("fs").readFile("lib.utility2.js", "utf8", function (err, data) {
        onErrorThrow(err);
        require("fs").writeFile(".tmp/lib.utility2.js", data.replace(
            "/* istanbul instrument in package utility2 */",
            ""
        ), function (err) {
            onErrorThrow(err);
            require("./.tmp/lib.utility2.js");
        });
        onError(undefined, opt);
    });
};

local.testCase_listShuffle_default = function (opt, onError) {
/*
 * this function will test listShuffle's default handling-behavior
 */
    opt = {};
    // init list
    opt.list = "[0,1]";
    // shuffle list 100 times
    opt.ii = 0;
    while (opt.ii < 100) {
        opt.listShuffled = JSON.stringify(
            local.listShuffle(JSON.parse(opt.list))
        );
        // validate shuffled list
        assertJsonEqual(opt.listShuffled.length, opt.list.length);
        opt.changed = opt.changed || opt.listShuffled !== opt.list;
        opt.ii += 1;
    }
    // validate list changed at least once during shuffle
    assertOrThrow(opt.changed, opt);
    onError(undefined, opt);
};

local.testCase_replStart_default = function (opt, onError) {
/*
 * this function will test replStart's default handling-behavior
 */
    if (!isEnvNode) {
        onError(undefined, opt);
        return;
    }
    local.replStart();
    // coverage-hack - test replStart's muliple-call handling-behavior
    local.replStart();
    local.testMock([
        [
            require("child_process"), {
                spawn: function () {
                    return {
                        on: function (evt, callback) {
                            callback(undefined, evt);
                        }
                    };
                }
            }
        ],
        // suppress process.stdout
        [
            process.stdout, {
                write: noop
            }
        ]
    ], function (onError) {
        [
            // test null-case handling-behavior
            "",
            // test shell handling-behavior
            "$ :\n",
            // test git diff handling-behavior
            "$ git diff\n",
            // test git log handling-behavior
            "$ git log\n",
            // test ll handling-behavior
            "$ ll\n",
            // test charCode handling-behavior
            "charCode abcd\n",
            // test charSort handling-behavior
            "charSort abcd\n",
            // test keys handling-behavior
            "keys {}\n",
            // test print handling-behavior
            "print abcd\n",
            // test err handling-behavior
            "undefined()\n"
        ].forEach(function (script) {
            globalThis.utility2_repl1.eval(script, null, "repl", noop);
        });
        onError(undefined, opt);
    }, onError);
};

local.testCase_setTimeoutOnError_default = function (opt, onError) {
/*
 * this function will test setTimeoutOnError's default handling-behavior
 */
    // test null-case handling-behavior
    assertJsonEqual(local.setTimeoutOnError(), undefined);
    // test onError handling-behavior
    assertJsonEqual(
        local.setTimeoutOnError(onError, 0, null, {}, opt),
        {}
    );
};

local.testCase_stringHtmlSafe_default = function (opt, onError) {
/*
 * this function will test stringHtmlSafe's default handling-behavior
 */
    assertJsonEqual(
        local.stringHtmlSafe(
            local.stringHtmlSafe(local.stringCharsetAscii).slice(32, -1)
        ),
        (
            " !&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@" +
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        )
    );
    onError(undefined, opt);
};

local.testCase_stringXxx_default = function (opt, onError) {
/*
 * this function will test stringXxx's default handling-behavior
 */
    assertJsonEqual(
        local.regexpCharsetEncodeUri.source,
        local.stringRegexpEscape(
            local.stringCharsetEncodeUri
        ).replace("\\-", "-")
    );
    assertJsonEqual(
        local.regexpCharsetEncodeUriComponent.source,
        local.stringRegexpEscape(
            local.stringCharsetEncodeUriComponent
        ).replace("\\-", "-")
    );
    assertJsonEqual(
        local.stringCharsetEncodeUri,
        Array.from(
            new Set(encodeURI(local.stringCharsetAscii).split(""))
        ).sort().join("")
    );
    assertJsonEqual(
        local.stringCharsetEncodeUriComponent,
        Array.from(
            new Set(encodeURIComponent(local.stringCharsetAscii).split(""))
        ).sort().join("")
    );
    assertJsonEqual(
        local.stringRegexpEscape(local.stringCharsetAscii),
        (
            "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" +
            "\b\t\n\u000b\f\r\u000e\u000f" +
            "\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017" +
            "\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f" +
            " !\"#\\$%&'\\(\\)\\*\\+,\\-\\.\\/0123456789:;<=>\\?@" +
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]\\^_`" +
            "abcdefghijklmnopqrstuvwxyz\\{\\|\\}~" +
            "\u007f"
        )
    );
    onError(undefined, opt);
};

local.testCase_testMock_err = function (opt, onError) {
/*
 * this function will test testMock's err handling-behavior
 */
    try {
        local.testMock([], function () {
            throw new Error();
        });
    } catch (errCaught) {
        // handle err
        assertOrThrow(errCaught, errCaught);
        onError(undefined, opt);
    }
};

local.testCase_uiAnimateXxx_default = function (opt, onError) {
/*
 * this function will test uiAnimateXxx's default handling-behavior
 */
    if (isEnvNode) {
        onError(undefined, opt);
        return;
    }
    opt = document.createElement("div");
    // test uiAnimateSlideXxx handling-behavior
    local.uiAnimateSlideDown();
    local.uiAnimateSlideUp();
    opt.classList.add("uiAnimateSlide");
    local.uiAnimateSlideDown(opt);
    assertOrThrow(
        opt.style.maxHeight.indexOf("px") >= 0,
        opt.style.maxHeight
    );
    local.uiAnimateSlideUp(opt);
    assertJsonEqual(opt.style.maxHeight, "0px");
    // test uiAnimateSlideAccordian handling-behavior
    local.uiAnimateSlideAccordian(
        opt,
        [
            opt, document.createElement("div")
        ]
    );
    onError(undefined, opt);
};

local.testCase_urlJoin_default = function (opt, onError) {
/*
 * this function will test urlJoin's default handling-behavior
 */
    assertJsonEqual(local.urlJoin("", ""), "/");
    assertJsonEqual(local.urlJoin("http://aa/bb", "zz"), "http://aa/zz");
    assertJsonEqual(
        local.urlJoin("http://aa/bb/", "zz"),
        "http://aa/bb/zz"
    );
    assertJsonEqual(
        local.urlJoin("http://aa/bb/", "/zz"),
        "http://aa/zz"
    );
    assertJsonEqual(local.urlJoin("http://aa/bb/", "//zz"), "http://zz");
    assertJsonEqual(
        local.urlJoin("http://aa/bb/", "http://zz"),
        "http://zz"
    );
    onError(undefined, opt);
};

local.testCase_uuid4Create_default = function (opt, onError) {
/*
 * this function will test uuid4Create's default handling-behavior
 */
    assertOrThrow(
        local.regexpValidateUuid.test(local.uuid4Create()),
        local.uuid4Create()
    );
    onError(undefined, opt);
};

local.testCase_webpage_default = async function (opt, onError) {
/*
 * this function will test webpage's default handling-behavior
 */
    local._testCase_webpage_default(opt, onError);
};

local.testCase_webpage_err = async function (opt, onError) {
/*
 * this function will test webpage's err handling-behavior
 */
    if (isEnvNode) {
        await local.browserTest({
            modeSilent: true,
            url: (
                "http://127.0.0.1:" + process.env.PORT +
                "/?npm_config_mode_test=1" +
                "&npm_config_mode_test_case=testCase_webpage_err"
            )
        });
        onError(undefined, opt);
        return;
    }
    if (local.npm_config_mode_test_case !== "testCase_webpage_err") {
        onError(undefined, opt);
        return;
    }
    // ignore err in coverage-case
    globalThis.utility2_testReport.testPlatformList[0].testCaseList = [];
    globalThis.utility2_testReport.testsPending = 0;
    setTimeout(function () {
        // test err from callback handling-behavior
        onError(new Error(), opt);
        // test err from multiple-callback handling-behavior
        onError(undefined, opt);
    }, 2000);
    // test uncaught-err handling-behavior
    setTimeout(assertOrThrow.bind(undefined, undefined));
};


// run node js-env code - init-after
/* istanbul ignore next */
(function () {
if (!isEnvNode) {
    return;
}
// init cli
if (module !== require.main || globalThis.utility2_rollup) {
    return;
}
local.assetsDict["/assets.script_only.html"] = (
    "<h1>script_only_test</h1>\n" +
    "<script src=\"assets.utility2.js\"></script>\n" +
    "<script>\n" +
    "window.utility2.onReadyIncrement();\n" +
    "window.addEventListener(\"load\", window.utility2.onReadyDecrement);\n" +
    "</script>\n" +
    "<script src=\"assets.example.js\"></script>\n" +
    "<script src=\"assets.test.js\"></script>\n"
);
if (process.argv[2]) {
    // start with coverage
    if (process.env.npm_config_mode_coverage) {
        process.argv.splice(1, 1, __dirname + "/lib.istanbul.js", "cover");
        local.istanbul.cliDict[process.argv[2]]();
        return;
    }
    // start
    process.argv.splice(1, 1);
    process.argv[1] = require("path").resolve(process.argv[1]);
    require("module").runMain();
}
// runme
if (process.env.npm_config_runme) {
    require(require("path").resolve(process.env.npm_config_runme));
}
}());
}());
}());
/* script-end /assets.test.js */



/* script-begin /assets.utility2.rollup.end.js */
(function () {
    "use strict";
    globalThis.utility2_rollup_old = globalThis.utility2_rollup;
    globalThis.utility2_rollup = null;
}());
/* utility2.rollup.js end */
/* script-end /assets.utility2.rollup.end.js */
